using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Collections.Generic;
using UnityEngine.Rendering;
using UnityEngine.UI;

/// <summary>
/// www.mezanix.com
/// </summary>
namespace Mezanix.Diamond
{
	/// <summary>
	/// LogicNode.
	/// The building block of the Diamond Graph, here we have the logic executed.
	/// However, Other classes like Node, NodeState, and Logic, manage
	/// which logic and when this logic will be executed.
	/// 
	/// In the Logic Node things are executed,
	/// 	For workflow speed, the Logic Node is adaptive,
	/// 	no need to search in big lists of nodes, you create your Logic Node and you adapt it to your need.
	/// 	to do that, the Logic Node show you 3 enum buttons: Logic Type, Variable Type, and Compute Type.
	/// 	In Logic Type you choose what you want to do (define an input, compute or operation, time operation).
	/// 	In Variable Type you choose on which variabale you want to apply your Logic Type (bool, float, game object,
	/// 	transform, camera, rigidbody etc..).
	/// 	In Compute Type: according to your earlier choices (Logic Type and Variable Type), the Logic Node adapte the
	/// 	Compute Type enum and offer to you a list of operations corresponding to your choice.
	/// 	To explaine the Logic Node adaptivity, lets see some examples: 
	/// 	Example 1: In the Logic Type, choose "Compute Or Operation". In the Variable Type, choose "Camera".
	/// 	click on the Compute Type enum button and you will see a list of operations related to the camera
	/// 	like "Screen Point To Ray", .., "Get Far Clip Plan", .. "Set Field Of View" etc..
	/// 	Example 2: In the Logic Type, choose "Compute Or Operation". In the Variable Type, choose 
	/// 	"Component Transform".
	/// 	click on the Compute Type enum button and you will see a list of operations related to the transform
	/// 	like "Get Position", .. "Get Child Count", .. "Translate" etc..
	/// 	Example 3: In the Logic Type, choose "Time Operation". Click on the Time Type enum button and you will 
	/// 	see a list of variables or operations related to the time or the frames like "Delta Time", .. "TicTac One Frames", 
	/// 	.. "Tictac On Time", .. "Time Since Level Load" etc.. 
	/// 	Example 4: In the Logic Type, choose "Unity Input Class And Cross Platform". In the Compute Type choose
	/// 	"Get Axis". The Logic Node will invite you to enter your axis name and to choose if you want to use 
	/// 	cross platform inputs or not. If you have spelling errors in the axe name, the Logic Node will tell you
	/// 	that this axis is not defined in the Unity Input Manager. 
	/// 	P.S. To acess the Unity Input Manager, in th Unity editor go to top menu: Edit->Project Settings->Input
	/// 	P.S. Cross platform inputs runs only on generated scripts (no run in editor), in order to use the 
	/// 	cross platform inputs, import the Unity cross platform inputs standard asset.
	/// 	P.S In the Logic Type, instead of "Unity Input Class And Cross Platform", you can choose "Input", it's
	/// 	a simpler case of the first one. In it, you will choose essentially desktop inputs (keyboard and mouse).
	/// 	P.S In the Logic Type, you can use also "Mouse Input", the features of "Mouse Input" exists already in
	/// 	"Unity Input Class And Cross Platform", but you choose it if you want to have the mouse position 
	/// 	after freeing the cursor. Some First Person cameras may lock the cursor at the screen center,
	/// 	so sometimes you need to free it if you want to use the mouse position.
	/// </summary>
	[Serializable]
	public partial class LogicNode : ScriptableObject 
	{
		/// <summary>
		/// General global variables.
		/// For the LogicNode basic functionalities.
		/// </summary>
		#region global variables general
		public Logic logic;

		//[HideInInspector]
		public string uniqueID = "";

		public int id;
		
		public SelectionState selectionState;
		

		public string nodeName;

		public Rect rect = new Rect ();


		public Vector2 fieldNormalizedSizeMin;

		public Vector2 fieldNormalizedSizeMid;

		public Vector2 fieldNormalizedSizeMax;

		public float lastVerticalNormalized;

		public float lastHorizontalNormalized;


		bool minimizeUpLeftMessageBox = true;

		bool minimizeDocumentationBoxUpRight = true;

		bool DrawObjectFieldFillingMessage_ThereIsAdditional = false;

		bool cameraDirectionalLightMessageWritten = false;


		Vector2 documentationCharSize = new Vector2 (5.3f, 17f);

		string [] DrawObjectFieldFillingMessage_Additional = new string[1];

		enum ObjectResultDrawChoice
		{
			itself,

			itsName
		}

		public TouchScreenKeyboardType touchScreenKeyboardType;


		int downTimeCounterInt;
		bool startCounting = false;


		public LogicType logicType;
		public int logicType_length = 0;
		public string logicType_last;

		public VariableType variableType;
		public int variableType_Length = 0;
		public string variableType_last;


		public ComputeFloatType computeFloatType;

		public ComputeIntType computeIntType;



		public ComputeStringType computeStringType;
		public int computeStringType_length = 0;
		public string computeStringType_last;


		public ComputeBoolType computeBoolType;
		public int computeBoolType_length = 0;
		public string computeBoolType_last;


		public ComputeVector3Type computeVector3Type;
		public int computeVector3Type_length = 0;
		public string computeVector3Type_last;


		public ComputeVector2Type computeVector2Type;


		public ComputeColorType computeColorType;
		public int computeColorType_length = 0;
		public string computeColorType_last;

		public ComputeGameObjectType computeGameObjectType;


		public ComputeColliderType computeColliderType;

		public ComputeCollider2DType computeCollider2DType;


		public ComputeRendererType computeRendererType;

		public ComputeRigidBodyType computeRigidBodyType;



		public ComputeTransformType computeTransformType;
		public int computeTransformType_length = 0;
		public string computeTransformType_last;

		public ComputeMaterialType computeMaterialType;
		public int computeMaterialType_length = 0;
		public string computeMaterialType_last;

		public ComputeTexture2DType computeTexture2DType;
		public int computeTexture2DType_length = 0;
		public string computeTexture2DType_last;

		public ComputeShaderType computeShaderType;
		public int computeShaderType_length = 0;
		public string computeShaderType_last;


		public ComputeMatrix44Type computeMatrix44Type;
		public int computeMatrix44Type_length = 0;
		public string computeMatrix44Type_last;


		public ComputeColorListType computeColorListType;

		public ComputeShaderListType computeShaderListType;

		public ComputeTexture2DListType computeTexture2DListType;

		public ComputeMaterialListType computeMaterialListType;

		public ComputeRectListType computeRectListType;

		public ComputeVector4ListType computeVector4ListType;

		public ComputeVector3ListType computeVector3ListType;

		public ComputeVector2ListType computeVector2ListType;

		public ComputeStringsListType computeStringsListType;

		public ComputeIntsListType computeIntListType;

		public ComputeFloatsListType computeFloatsListType;

		public ComputeBoolListType computeBoolListType;

		public ComputeAudioSourceType computeAudioSourceType;

		public ComputeSpriteRendererType computeSpriteRendererType;

		public ComputeLineRendererType computeLineRendererType;


		public ComputeUnityTextType computeUnityTextType;
		public int computeUnityTextType_length = 0;
		public string computeUnityTextType_last;


		public ComputeUiButtonType computeUiButtonType;
		public int computeUiButtonType_length= 0;
		public string computeUiButtonType_last;



		enum VariableStruct
		{
			singleOrArray,

			list,
		}

		public ComputeRayType computeRayType;

		public ComputeRay2DType computeRay2DType;
		public int computeRay2DType_length = 0;
		public string computeRay2DType_last;



		public ComputeBoxCollider2DType computeBoxCollider2DType;

		public ComputeCircleCollider2DType computeCircleCollider2DType;


		public ComputeGameObjectListType computeGameObjectListType;

		public ComputeMouseInputType computeMouseInputType;


		public ComputeRectType computeRectType;
		public int computeRectType_length = 0;
		public string computeRectType_last;


		public ComputeVector4Type computeVector4Type;
		public int computeVector4Type_length = 0;
		public string computeVector4Type_last;



		public enum InventoryListAction
		{
			Add,

			Remove,

			makeObjectOfFollowingIndexReady,

			nameEntireList,

			RemoveAtThisIndex,
		}
		public InventoryListAction inventoryListAction;

		public ComputeUnityInputClassAndCrossPlatformType computeUnityInputClassAndCrossPlatformType;


		public ComputeBoxColliderType computeBoxColliderType;

		public ComputeSphereColliderType computeSphereColliderType;

		public ComputeCapsuleColliderType computeCapsuleColliderType;

		public ComputeMeshColliderType computeMeshColliderType;

		Collider collider = null;
		BoxCollider boxCollider = null;
		CapsuleCollider capsuleCollider = null;
		MeshCollider meshCollider = null;
		SphereCollider sphereCollider = null;


		Collider2D collider2D = null;
		BoxCollider2D boxCollider2D = null;
		CircleCollider2D circleCollider2D = null;
		Collider2D collider2D_1 = null;

		Transform transform_ = null;

		public PhysicMaterialCombine physicMaterialCombine;

		public CollisionDetectionMode collisionDetectionMode;

		public QueryTriggerInteraction queryTriggerInteraction;


		public MaterialGlobalIlluminationFlags materialGlobalIlluminationFlags;


		public ForceMode forceMode;

		public ColorBlendMode colorBlendMode;

		public FilterMode filterMode;

		public SpriteDrawMode spriteDrawMode;

		public SpriteTileMode spriteTileMode;


		public ComputeRigidBody2DType computeRigidBody2DType;

		Rigidbody2D rigidBody2D = null;

		public ForceMode2D forceMode2D;

		Rigidbody rigidBody = null;


		Renderer renderer = null;
		LineRenderer lineRenderer = null;

		SpriteRenderer spriteRenderer = null;


		ParticleSystem particleSystem = null;

		public ParticleSystemSimulationSpace particleSystemSimulationSpace;

		public ParticleSystemScalingMode particleSystemScalingMode;

		ParticleSystem.MainModule psMain;

		public ComputeParticleSystemType computeParticleSystemType;
		public int computeParticleSystemType_length = 0;
		public string computeParticleSystemType_last;


		public WriteTextureFormat writeTextureFormat;

		public TextureWrapMode textureWrapMode;

		enum PrepareTexture2DForWhat
		{
			blend,

			write,
		}

		public TextureFormat textureFormat;

		public TextureEncodeType textureEncodeType;

		public enum CompeleOrPartOfTexture 
		{
			theCompleteTexture,

			aBlockOfTheTexture,
		}

		public CompeleOrPartOfTexture compeleOrPartOfTexture;

		public TextureComputer.ComputeOn channel;

		public TextureComputer.ComputeOn [] channels;

		public TextureComputer.ExtractResultType extractResultType;

		public TextureComputer.SwitchColorsType switchColorsType;

		public TextureComputer.MirrorTexture2D_Direction mirrorTexture2D_Direction;

		enum ChannelEnumForWhat 
		{
			ComputeNormal,

			Extract,

			Set,
		}

		public enum NormalMapComputeIntensity 
		{
			_1, _2, _3, _4, _5, _6, _7, _8, _9, _10,
		}

		public NormalMapComputeIntensity normalMapComputeIntensity;


		public enum ShadersGetGlobalPropertieMode
		{
			byName,

			byNameID,
		}

		public ShadersGetGlobalPropertieMode shadersGetGlobalPropertieMode;


		bool doNotCheckShader_0 = true;

		bool doNotCheckTexture2D_0 = true;

	

		public TimeType timeType;



		Camera cam;
		Camera cam_1;
		public Camera.StereoscopicEye camera_StereoscopicEye;

		public TransparencySortMode transparencySortMode;
		public RenderingPath renderingPath;
		public OpaqueSortMode opaqueSortMode;
		public DepthTextureMode depthTextureMode;
		public ComputeCameraType computeCameraType;


		RaycastHit hit;

		RaycastHit [] hits;

		RaycastHit raycastHit;

		RaycastHit2D hit2D;

		public GameObject hit2D_gameObject;

		public Vector2 hit2D_centroid;

		public float hit2D_distance;

		public float hit2D_fraction;

		public Vector2 hit2D_normal;

		public Vector2 hit2D_point;


		public ComputeNavMeshAgentType computeNavMeshAgentType;
		public int computeNavMeshAgentType_length = 0;
		public string computeNavMeshAgentType_last;

		public UnityEngine.AI.ObstacleAvoidanceType obstacleAvoidanceType;


		UnityEngine.AI.NavMeshAgent navMeshAgent = null;
		UnityEngine.AI.NavMeshHit navMeshHit;
		public float NavMeshHit_distance;
		public bool NavMeshHit_hit;
		public int NavMeshHit_mask;
		public Vector3 NavMeshHit_normal;
		public Vector3 NavMeshHit_position;
		public bool OffMeshLinkData_activated;
		public Vector3 OffMeshLinkData_startPosition;
		public Vector3 OffMeshLinkData_endPosition;
		public UnityEngine.AI.OffMeshLinkType OffMeshLinkData_Type;
		public bool OffMeshLinkData_valid;


		float downCounterForBoolImpulse;


		public AudioClip audioClipValue_Local = null;

		AudioSource audioSource_ = null;


		UnityEngine.UI.Button.ButtonClickedEvent uiButtonClickedEvent;

		UnityEngine.UI.Button uiButton = null;

		public UnityEngine.UI.Image.FillMethod fillMethod;

		UnityEngine.UI.Image uiImage = null;

		public ComputeUiImageType computeUiImageType;
		public int computeUiImageType_length = 0;
		public string computeUiImageType_last;

		public TextAnchor textAnchor;

		UnityEngine.UI.Text unityText = null;


		const float gapPermissionLinkDraw = 0.25f;

		Event eGlobal;

		int inputHotKeyIndex = -1;

		public bool alwaysDoIt = false;



		public float touch_altitudeAngle;

		public float touch_azimuthAngle;

		public Vector2 touch_deltaPosition;

		public float touch_deltaTime;


		public int touch_fingerId;

		public float touch_maximumPossiblePressure;

		public string touch_phase = "";

		public Vector2 touch_position;

		public float touch_pressure;


		public float touch_radius;

		public float touch_radiusVariance ;

		public Vector2 touch_rawPosition ;

		public int touch_tapCount;

		public string touch_type = "";


		public IMECompositionMode iMECompositionMode;

		AccelerationEvent [] accelerationEvents;

		public UnityEngine.SceneManagement.LoadSceneMode loadSceneMode;


		public ComputeUiToggleType computeUiToggleType;

		UnityEngine.UI.Toggle uiToggle = null;


		public ComputeUiInputFieldType computeUiInputFieldType;

		UnityEngine.UI.InputField uiInputField = null;


		public ComputeLightType computeLightType;

		Light lightComp = null;


		public ComputeAdsType computeAdsType;

		float keplerRadius = 1f;


		public AnimationCurve animationCurve_ = new AnimationCurve ();
		#endregion global variables general


		/// <summary>
		/// Global variables for values.
		/// The logicNode values are tha variables holding the values
		/// the user manipulates in his graph.
		/// These values will be held and 
		/// manipulated in the same way by the generated scripts. 
		/// </summary>
		#region global variables values
		public Rect rectValue;

		public Rect [] rectValues;

		public List <Rect> rectListValue = new List<Rect> ();

		public List <Rect> [] rectListValues = new List<Rect>[2];


		public bool boolValue;

		public bool[] boolValues;

		public List <bool> boolsListValue = new List<bool> ();

		public List <bool>[] boolsListValues = new List<bool>[2];


		public bool doIT;


		public Color colorValue;

		public Color[] colorValues;

		public List <Color> colorsListValue = new List<Color> ();

		public List <Color> [] colorsListValues = new List<Color>[2];




		public int intValue;

		public int [] intValues;


		public List <int> intsListValue = new List<int> ();

		public List <int> [] intsListValues = new List<int>[2];



		public float floatValue;

		public float[] floatValues;


		public List <float> floatsListValue = new List<float> ();

		public List <float> [] floatsListValues = new List<float>[2];






		public Vector2 vector2Value;

		public Vector2 [] vector2Values;


		public List <Vector2> vector2ListValue = new List<Vector2>();

		public List <Vector2>[] vector2ListValues = new List<Vector2>[2];




		public Vector3 vector3Value;

		public Vector3[] vector3Values;


		public List <Vector3> vector3ListValue = new List<Vector3> ();

		public List <Vector3>[] vector3ListValues = new List<Vector3>[2];



		public Ray rayValue;

		public Vector3 rayValueOrigin;

		public Vector3 rayDirectionValueNotNormalized;


		public Ray2D ray2DValue;

		public Vector2 ray2DValueOrigin;

		public Vector2 ray2DDirectionValueNotNormalized;



		public string stringValue;

		public string[] stringValues = new string[2];


		public List <string> stringsListValue = new List<string>();

		public List <string>[] stringsListValues = new List<string>[2];





		public GameObject gameObjectValue;

		public string gameObjectValueUI;

		GameObject gameObjectValueOld = null;



		public GameObject[] gameObjectValues;

		public string [] gameObjectValuesUIs;

		GameObject [] gameObjectValuesOld = new GameObject[2];


		public List <GameObject> gameObjectsListValue = new List<GameObject> ();

		public List <GameObject> [] gameObjectsListValues = new List<GameObject>[2];


		public Vector3 boundsCenterValue = new Vector3 ();

		public Vector3 boundsExtentsValue = new Vector3 ();

		public Vector3 boundsMaxValue = new Vector3 ();

		public Vector3 boundsMinValue = new Vector3 ();

		public Vector3 boundsSizeValue = new Vector3 ();


		public Vector3 raycastHitBarycentricCoordinate;

		public int raycastHitTriangleIndex;


		public Vector3 raycastHitPoint;

		public Vector3 raycastHitNormal;

		public float raycastHitDistance;


		public GameObject raycastHitGameObject;


		public Vector2 raycastHitLightmapCoord;

		public Vector2 raycastHittextureCoord;

		public Vector2 raycastHittextureCoord2;


		public Matrix4x4 m44Value_entier;

		public Matrix4x4 [] m44Value_Input_entier;

		public float [] m44Value;

		public float m44ValueDeterminant;

		public bool m44ValueIsIdentity;

		public bool m44ValueInvertible;


		public Vector4 [] vector4Values;

		public Vector4 vector4Value;


		public List <Vector4> vector4ListValue = new List<Vector4>();

		public List <Vector4> [] vector4ListValues = new List<Vector4>[2];


		public Material materialValue;

		public Material [] materialValues;

		public Material [] materialValuesOld;

		public string [] materialValuesAssetsID;


		public List <Material> materialsListValue = new List<Material>();

		public List <Material>[] materialsListValues = new List<Material>[2];


		public Texture2D texture2DValue;

		public Texture2D [] texture2DValues;


		public Texture2D [] texture2DValuesOld;

		public string [] texture2DValuesAssetsID;


		public List <Texture2D> texture2DListValue = new List<Texture2D>();

		public List <Texture2D>[] texture2DListValues = new List<Texture2D>[2];


		public Shader shaderValue;

		public Shader shaderValueOld;

		public string shaderValueAssetsID;


		public Shader [] shaderValues;

		public Shader [] shaderValuesOld;

		public string [] shaderValuesAssetsID;


		public List <Shader> shaderListValue = new List<Shader>();

		public List <Shader>[] shaderListValues = new List<Shader>[2];


		public Mesh meshValue;

		public Mesh [] meshValues;
	

		public double doubleValue = 0.0;


		#endregion values


		/// <summary>
		/// Global variables for links.
		/// Links are the connections between logicNodes inputs and outputs.
		/// The global variables of this section help managing links.
		/// P.S. the expression "logicNode inputs" means the inputs for the 
		/// logicNode variables, it doesn't mean devices inputs like mouse and keyboard. 
		/// </summary>
		#region global variables links
		public CurrentStatesNames currentStateNames;

		public CurrentStatesNames oldStateDestination;
			
		public string [] outputsIDs;

		public VariableType [] outputsTypes;

		public Rect [] outputsRects;

		public bool [] activeOutputs;

		public int [] outputLinkedIndexToDestination;

		public int [] outputListCounts;

		public Rect [] firstRectOfListsOutput;


		public string [] inputsIDs;

		public VariableType [] inputsTypes;

		public string [] inputsSources;

		public string [] inputsSources_forPermition;

		public Rect [] inputsRects;

		public bool [] activeInputs;

		public bool [] publicInputs;

		public bool [] permittedInputs;

		public bool [] dataFlowControlEnabled = new bool[1];

		public bool [] attachedToGameObject;

		public bool [] activeInputsFields;


		public const char inOutAdressSeparator = '.';

		public const string inAdressSignature  = "in";

		public const string outAdressSignature  = "out";
	

		bool linkedOrAttachedTo = true;


		int listIndexFinal = -1;

		int outIndexForHotKeyLinking = -1;
		int outListIndexForHotKeyLinking = 0;
		int onDragInOutListIndex = -1;
		int inputIndexForHotKeyLinking = -1;
		string variableFieldIDToMakePublicPrivate = "";

		float tanLength = 1f;

		float linkWidth = 5f;

		const float notPermittedInputAlphaColor = 0.3f;

		float nearLinkExtremity = 40f;

		float linkExtemityMoveSmother = 0.2f;
		#endregion global variables links


		/// <summary>
		/// Global variables for some basic device inputs
		/// </summary>
		#region global variables input
		public KeyCode keyCode;

		public AxeName axeName;

		Vector3 mousePosition;


		public KeyCodeTriggerWhen keyCodeTriggerWhen;

		public MouseInputTriggerWhen mouseInputTriggerWhen;

		bool axisNameIsSetup;
		#endregion global variables input


		/// <summary>
		/// Global variables for the LogicNode drawing in the Unity Editor
		/// inside the Diamond window.
		/// </summary>
		#region global variables drawing
		public bool maximized;

		bool renameCalled;


		float optionsButtonWidth;

		float [] fieldIDGlobal;


		enum FieldDrawType
		{
			nodeName,

			optionsButton,

			label,

			variable
		}

		Vector2 nodeNameFieldContentRatio;

		Vector2 nodeNameFieldAlignmentRatio;


		Vector2 optionsButtonFieldContentRatio; 

		Vector2 optionsButtonFieldAlignmentRatio; 


		//Vector2 labelFieldContentRatio; 

		//Vector2 labelFieldAlignmentRatio; 


		Vector2 variableFieldContentRatio; 

		Vector2 variableFieldAlignmentRatio; 


		float rectWidthFactor;

		float rectWidthFactorDefault;

		float rectWidthFactorMin;

		float rectWidthFactorMid;


		const string doItbuttonLabel = "Do It";


		public static Color linkColor = ColorsArithmetic.RGB_255_To_Normalized (0f, 255f, 124f, 1f);


		public float zoom = 1f;

		float zoomMin = 0.6f;

		float zoomIncr = 0.05f;



		float[] fieldsCountGlobal;

		//int columns = 1;
		//int columnID = 0;

		#endregion global variables drawing



		/// <summary>
		/// Global variables for strings holding messages as information and
		/// warnings the user need to know when using the LogicNode.
		/// The messages appear along side the LogicNode fields or in message boxes
		/// at the logicNode sides.
		/// </summary>
		#region global variables string messages
		const string sameNodeNameMessage = "A Logic Node with the same name already exist in this Logic, \n" +
			"please choose an another name.";

		const string deleteHotkeyMessage = "alt / option + X for Delete";

		const string noResultForThisCase = "No result for this case";

		const string goToTheUnityDocumentation = "Go to documentation     ";

		const string thisAxisNameIsNotSetup = "This Axis Name is not setup";

		const string workOnlyOnGeneratedScripts = "Works Only On Generated Scripts";

		const string alwaysDoItOrder = "Always Do It";
		const string alwaysDoItExpression = "Always Doing It";
		const string dontDoItAllTheTimeExpression = "Don't Do It all the time";

		const string noRunInEditorWithAttachedToOrLinked = "No Editor run: 'Attached To'/linked null";

		const string actionOnHowManyFrames = "Action on how many frames?";

		const string textureNoSameWidthInfo = "Textures don't have same width";

		const string textureNoSameHeightInfo = "Textures don't have same height";

		const string dontOfenRunTimeInfo = "Don't do it often with big textures";

		const string textureReadableInNode = "Enable textures read/write in inspector";

		const string m44enierLabel = "The Whole Matrix";
		const string m44enierValueLabel = "Matrix 4x4";

		const string gameObject_0_isNullInfo = "Fill in GameObject Field";

		const string gameObject_0_ParticleSystemisNullInfo = "Add ParticleSystem To GameObject";

		const string blockThisInput = "Block this input";

		const string allowThisInput = "Allow this input";

		const string sliderInfo = "For Slider, Hold 'Shift' and point the mouse, no need for click\n";

		const string entireListLabel = "The entire List";

		const string breackTheLink = "Break the link";


		const string crossPlatformRunOnlyInRunTime = "Cross Platform Run Only In Runtime";

		const string makeSureCrossPlatformImported = "Make sure Cross Platform asset is imported";


		string [] noTransferredDataFound = new string []
		{
			"No transferred data found",
			"Use send transferred data nodes",
			"to send a transferred data",
		};

		string [] noEventFound = new string []
		{
			"No event found",
			"Use send event node",
			"to send an event",
		};
		#endregion global variables string messages

		public string specialNodeType = "";

		/// <summary>
		/// LogicNodeInit.
		/// Initialization of the logicNode object.
		/// Executed once at a new LogicNode creation in the graph. 
		/// </summary>
		/// <param name="setLogic">Set logic.</param>
		/// <param name="setInitialPosition">Set initial position.</param>
		public void LogicNodeInit (Logic setLogic, Vector2 setInitialPosition, string setSpecialNodeType,
			bool reset)
		{
			if ( ! reset)
			{
				uniqueID = DatesTimesAndFrequences.DateTimeNow ();
			}

			logic = setLogic;

			selectionState = SelectionState.selected;

			name = "Scriptable Logic Node";

			maximized = true;

			rect = RectOnMaxMin (new Rect (
				setInitialPosition.x, setInitialPosition.y, 
				Skins.logicNodeRect.width, Skins.logicNodeRect.height));

			SetNormalizedPosition ();

			if ( ! reset)
			{
				logic.nodes.Add (this);

				id = logic.nodes.Count - 1;
			}



			renameCalled = false;

			if ( ! reset)
			{
				nodeName = DatesTimesAndFrequences.DateTimeNow ();

				CheckNamesConflict ();
			}


			shaderValuesAssetsID = new string[2];

			shaderValuesOld = new Shader[2];


			materialValuesAssetsID = new string[2];

			materialValuesOld = new Material[2];


			texture2DValuesAssetsID = new string[2];

			texture2DValuesOld = new Texture2D[2];



			boolValues = new bool[2]; boolValues [0] = boolValues [1] = false;

			doIT = false;


			meshValues = new Mesh[2]; meshValues [0] = meshValues [1] = null;


			rectValues = new Rect[2]; rectValues [0] = rectValues [1] = new Rect ();



			boolsListValue = new List<bool> ();

			boolsListValues = new List<bool>[2]; boolsListValues [0] = boolsListValues [1] = new List<bool> ();




			colorValues = new Color[2]; colorValues [0] = colorValues [1] = Color.white;


			colorsListValue = new List<Color> ();

			colorsListValues = new List<Color>[2]; colorsListValues [0] = colorsListValues [1] = new List<Color>();


			floatsListValue = new List<float> ();

			floatsListValues = new List<float>[2]; floatsListValues [0] = floatsListValues [1] = new List<float> ();


			floatValues = new float[3]; floatValues [0] = floatValues [1] = floatValues [2] = 1f;




			intsListValue = new List<int> ();

			intsListValues = new List<int>[2]; intsListValues [0] = intsListValues [1] = new List<int> ();


			intValues = new int[3]; intValues [0] = intValues [1] = intValues [2] = 0;





			stringsListValue = new List<string> ();

			stringsListValues = new List<string>[2]; stringsListValues [0] = stringsListValues [1] = new List<string> ();

			stringValues = new string[2]; stringValues [0] = stringValues [1] = "";




			vector2ListValue = new List<Vector2> ();

			vector2ListValues = new List<Vector2>[2]; vector2ListValues [0] = vector2ListValues [1] = new List<Vector2> ();

			vector2Values = new Vector2[2]; vector2Values [0] = vector2Values [1] = Vector2.zero;



			vector3ListValue = new List<Vector3> ();

			vector3ListValues = new List<Vector3>[2]; vector3ListValues [0] = vector3ListValues [1] = new List<Vector3> ();


			vector3Values = new Vector3[2]; vector3Values [0] = vector3Values [1] = Vector3.zero;




			vector4ListValue = new List<Vector4> ();

			vector4ListValues = new List<Vector4>[2]; vector4ListValues [0] = vector4ListValues [1] = new List<Vector4> ();

			vector4Values = new Vector4[2]; vector4Values [0] = vector4Values [1] = Vector4.zero;







			m44Value_Input_entier = new Matrix4x4 [2]; m44Value_Input_entier [0] = m44Value_Input_entier [1] = new Matrix4x4 ();


			gameObjectValues = new GameObject[2]; gameObjectValues [0] = gameObjectValues [1] = null;

			gameObjectValuesUIs = new string[2]; gameObjectValuesUIs [0] = ""; gameObjectValuesUIs [1] = "";


			gameObjectsListValue = new List<GameObject> ();

			gameObjectsListValues = new List<GameObject>[2]; gameObjectsListValues [0] = gameObjectsListValues [1] = new List<GameObject>();



			materialsListValue = new List<Material> ();

			materialsListValues = new List<Material>[2]; materialsListValues [0] = materialsListValues [1] = new List<Material> ();


			materialValues = new Material[2]; materialValues [0] = materialValues [1] = null;



			texture2DListValue = new List<Texture2D> ();

			texture2DListValues = new List<Texture2D>[2]; texture2DListValues [0] = texture2DListValues [1] = new List<Texture2D> ();


			texture2DValues = new Texture2D[2]; texture2DValues [0] = texture2DValues [1] = null;

			//renderTextureValues = new RenderTexture[2]; renderTextureValues [0] = renderTextureValues [1] = null;



			shaderListValue = new List<Shader> ();

			shaderListValues = new List<Shader>[2]; shaderListValues [0] = shaderListValues [1] = new List<Shader> ();

			shaderValues = new Shader[2]; shaderValues [0] = shaderValues [1] = null;


			rectListValue = new List<Rect> ();

			rectListValues = new List<Rect>[2]; rectListValues [0] = rectListValues [1] = new List<Rect> ();




			channels = new TextureComputer.ComputeOn[2];


			boundsCenterValue	= new Vector3 ();

         	boundsExtentsValue	= new Vector3 ();

         	boundsMaxValue		= new Vector3 ();

         	boundsMinValue		= new Vector3 ();

         	boundsSizeValue		= new Vector3 ();


			m44Value = new float[16];



			mousePosition = new Vector3 ();



			fieldIDGlobal = new float[] {0f, 0f};

			fieldsCountGlobal = new float[] {1f, 1f};

			SetFieldsContentsAndAlignmentsRatios ();


			InitInputsOutputs ();


			InitInOutRects ();

			InitInputSources ();

			InitPublicInputs ();

			InitPermittedInputs ();

			InitDataFlowControlEnabled ();
		
			InitLinkedIndexToDestination ();


			Nv_Init ();


			for (int i = 0; i < activeOutputs.Length; i++)
			{
				activeOutputs [i] = false;
			}


			//inOutAdressSeparator = '.';

			//inAdressSignature = "in";

			//outAdressSignature = "out";


			//linkColor = ColorsArithmetic.RGB_255_To_Normalized (0f, 66f, 85f, 1f);

			//isGameObjectVariableTheMainOne = false;

			//callGetWriteScriptName = false;

			//writeScriptName = "";

			gameObjectsListValue = new List<GameObject> ();

			//gameObjectsListValueOld = new List<GameObject> ();
            //
			//gameObjectsListValueUIs = new List<string> ();

			if ( ! reset)
			{
				AssetDatabase.AddObjectToAsset (this, logic);
			}

			ScriptsCreatedByDiamond.IdentifiedObjectsActions.CreateGameObjectHolder_CreateIdentifiedObjects ();

			ScriptsCreatedByDiamond.MezanixDiamondEvents.CreateGameObjectHolder ();
			mdeGameObjectHolder = GameObject.Find (ScriptsCreatedByDiamond.MezanixDiamondEvents.gameObjectHolderName);

			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer.CreateGameObjectHolder ();
			mddtGameObjectHolder = GameObject.Find (ScriptsCreatedByDiamond.MezanixDiamondDataTransfer.gameObjectHolderName);
		
			specialNodeType = setSpecialNodeType;
		}


		/// <summary>
		/// InOutID_inOutType.
		/// Class for holding the inputs and outputs IDs alongside with their
		/// corresponding variable type
		/// </summary>
		class InOutID_inOutType
		{
			public string id;

			public VariableType type;

			public InOutID_inOutType (string setId, VariableType setType)
			{
				id = setId;

				type = setType;
			}
		}

		InOutID_inOutType [] inOutID_inOutType;

		/// <summary>
		/// Initialization of the inputs and outputs IDs and their types.
		/// </summary>
		void InitInputsOutputs ()
		{
			inOutID_inOutType = new InOutID_inOutType[]
			{
				new InOutID_inOutType (Enums.boolValue_ID, VariableType.Bool),

				new InOutID_inOutType (Enums.boolValues_0_ID, VariableType.Bool),

				new InOutID_inOutType (Enums.boolValues_1_ID, VariableType.Bool),


				new InOutID_inOutType (Enums.boolsList_ID, VariableType.boolsList),

				new InOutID_inOutType (Enums.boolsListEntire_ID, VariableType.boolsList),

				new InOutID_inOutType (Enums.boolsListEntire0_ID, VariableType.boolsList),

				new InOutID_inOutType (Enums.boolsListEntire1_ID, VariableType.boolsList),




				new InOutID_inOutType (Enums.colorValue_ID, VariableType.Color),

				new InOutID_inOutType (Enums.colorValues_0_ID, VariableType.Color),

				new InOutID_inOutType (Enums.colorValues_1_ID, VariableType.Color),


				new InOutID_inOutType (Enums.colorsList_ID, VariableType.colorsList),

				new InOutID_inOutType (Enums.colorsListEntire_ID, VariableType.colorsList),

				new InOutID_inOutType (Enums.colorsListEntire0_ID, VariableType.colorsList),

				new InOutID_inOutType (Enums.colorsListEntire1_ID, VariableType.colorsList),





				new InOutID_inOutType (Enums.texture2DValue_ID, VariableType.Texture2D),

				new InOutID_inOutType (Enums.texture2DValues_0_ID, VariableType.Texture2D),

				new InOutID_inOutType (Enums.texture2DValues_1_ID, VariableType.Texture2D),


				new InOutID_inOutType (Enums.texture2DList_ID, VariableType.texture2DList),

				new InOutID_inOutType (Enums.texture2DListEntire_ID, VariableType.texture2DList),

				new InOutID_inOutType (Enums.texture2DListEntire0_ID, VariableType.texture2DList),

				new InOutID_inOutType (Enums.texture2DListEntire1_ID, VariableType.texture2DList),




				new InOutID_inOutType (Enums.intValue_ID, VariableType.Int),

				new InOutID_inOutType (Enums.intValues_0_ID, VariableType.Int),

				new InOutID_inOutType (Enums.intValues_1_ID, VariableType.Int),


				new InOutID_inOutType (Enums.intsList_ID, VariableType.intsList),

				new InOutID_inOutType (Enums.intsListEntire_ID, VariableType.intsList),

				new InOutID_inOutType (Enums.intsListEntire0_ID, VariableType.intsList),

				new InOutID_inOutType (Enums.intsListEntire1_ID, VariableType.intsList),




				new InOutID_inOutType (Enums.floatValue_ID, VariableType.Float),

				new InOutID_inOutType (Enums.floatValues_0_ID, VariableType.Float),

				new InOutID_inOutType (Enums.floatValues_1_ID, VariableType.Float),


				new InOutID_inOutType (Enums.floatsList_ID, VariableType.floatsList),

				new InOutID_inOutType (Enums.floatsListEntire_ID, VariableType.floatsList),

				new InOutID_inOutType (Enums.floatsListEntire0_ID, VariableType.floatsList),

				new InOutID_inOutType (Enums.floatsListEntire1_ID, VariableType.floatsList),




				new InOutID_inOutType (Enums.vector2Value_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.vector2Values_0_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.vector2Values_1_ID, VariableType.Vector2),


				new InOutID_inOutType (Enums.vector2List_ID, VariableType.vector2List),

				new InOutID_inOutType (Enums.vector2ListEntire_ID, VariableType.vector2List),

				new InOutID_inOutType (Enums.vector2ListEntire0_ID, VariableType.vector2List),

				new InOutID_inOutType (Enums.vector2ListEntire1_ID, VariableType.vector2List),




				new InOutID_inOutType (Enums.vector3Value_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.vector3Values_0_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.vector3Values_1_ID, VariableType.Vector3),


				new InOutID_inOutType (Enums.vector3List_ID, VariableType.vector3List),

				new InOutID_inOutType (Enums.vector3ListEntire_ID, VariableType.vector3List),

				new InOutID_inOutType (Enums.vector3ListEntire0_ID, VariableType.vector3List),

				new InOutID_inOutType (Enums.vector3ListEntire1_ID, VariableType.vector3List),



				new InOutID_inOutType (Enums.rayOrigin_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.rayDirection_ID, VariableType.Vector3),


				new InOutID_inOutType (Enums.ray2DOrigin_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.ray2DDirection_ID, VariableType.Vector2),



				new InOutID_inOutType (Enums.stringValue_ID, VariableType.String),

				new InOutID_inOutType (Enums.stringValues_0_ID, VariableType.String),

				new InOutID_inOutType (Enums.stringValues_1_ID, VariableType.String),


				new InOutID_inOutType (Enums.stringsList_ID, VariableType.stringsList),

				new InOutID_inOutType (Enums.stringsListEntire_ID, VariableType.stringsList),

				new InOutID_inOutType (Enums.stringsListEntire0_ID, VariableType.stringsList),

				new InOutID_inOutType (Enums.stringsListEntire1_ID, VariableType.stringsList),



				new InOutID_inOutType (Enums.gameObjectValue_ID, VariableType.GameObject),

				new InOutID_inOutType (Enums.gameObjectValues_0_ID, VariableType.GameObject),

				new InOutID_inOutType (Enums.gameObjectValues_1_ID, VariableType.GameObject),


				new InOutID_inOutType (Enums.gameObjectsList_ID, VariableType.GameObjectList),


				new InOutID_inOutType (Enums.gameObjectsListEntire_ID, VariableType.GameObjectList),

				new InOutID_inOutType (Enums.gameObjectsListEntire0_ID, VariableType.GameObjectList),

				new InOutID_inOutType (Enums.gameObjectsListEntire1_ID, VariableType.GameObjectList),




				new InOutID_inOutType (Enums.boundsCenterValue_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.boundsExtentsValue_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.boundsMaxValue_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.boundsMinValue_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.boundsSizeValue_ID, VariableType.Vector3),





				new InOutID_inOutType (Enums.raycastHitBarycentricCoordinate_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.raycastHitTriangleIndex_ID, VariableType.Int),


				new InOutID_inOutType (Enums.raycastHitPoint_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.raycastHitNormal_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.raycastHitDistance_ID, VariableType.Float),


				new InOutID_inOutType (Enums.raycastHitGameObject_ID, VariableType.GameObject),


				new InOutID_inOutType (Enums.raycastHitLightmapCoord_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.raycastHitTextureCoord_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.raycastHitTextureCoord2_ID, VariableType.Vector2),



				new InOutID_inOutType (Enums.hit2D_centroid_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.hit2D_distance_ID, VariableType.Float),

				new InOutID_inOutType (Enums.hit2D_fraction_ID, VariableType.Float),

				new InOutID_inOutType (Enums.hit2D_gameObject_ID, VariableType.GameObject),

				new InOutID_inOutType (Enums.hit2D_normal_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.hit2D_point_ID, VariableType.Vector2),



				new InOutID_inOutType (Enums.vector4Values_0_ID, VariableType.Vector4),

				new InOutID_inOutType (Enums.vector4Values_1_ID, VariableType.Vector4),

				new InOutID_inOutType (Enums.vector4Value_ID, VariableType.Vector4),


				new InOutID_inOutType (Enums.vector4List_ID, VariableType.vector4List),

				new InOutID_inOutType (Enums.vector4ListEntire_ID, VariableType.vector4List),

				new InOutID_inOutType (Enums.vector4ListEntire0_ID, VariableType.vector4List),

				new InOutID_inOutType (Enums.vector4ListEntire1_ID, VariableType.vector4List),



				new InOutID_inOutType (Enums.materialValue_ID, VariableType.Material),

				new InOutID_inOutType (Enums.materialValues_0_ID, VariableType.Material),

				new InOutID_inOutType (Enums.materialValues_1_ID, VariableType.Material),


				new InOutID_inOutType (Enums.materialList_ID, VariableType.materialsList),

				new InOutID_inOutType (Enums.materialListEntire_ID, VariableType.materialsList),

				new InOutID_inOutType (Enums.materialListEntire0_ID, VariableType.materialsList),

				new InOutID_inOutType (Enums.materialListEntire1_ID, VariableType.materialsList),










				//new InOutID_inOutType (Enums.renderTextureValue_ID, VariableType.RenderTexture),
				//
				//new InOutID_inOutType (Enums.renderTextureValues_0_ID, VariableType.RenderTexture),
				//
				//new InOutID_inOutType (Enums.renderTextureValues_1_ID, VariableType.RenderTexture),


				new InOutID_inOutType (Enums.shaderValue_ID, VariableType.Shader),

				new InOutID_inOutType (Enums.shaderValues_0_ID, VariableType.Shader),

				new InOutID_inOutType (Enums.shaderValues_1_ID, VariableType.Shader),


				new InOutID_inOutType (Enums.shaderList_ID, VariableType.shadersList),

				new InOutID_inOutType (Enums.shaderListEntire_ID, VariableType.shadersList),

				new InOutID_inOutType (Enums.shaderListEntire0_ID, VariableType.shadersList),

				new InOutID_inOutType (Enums.shaderListEntire1_ID, VariableType.shadersList),



				new InOutID_inOutType (Enums.OffMeshLinkData_activated_ID, VariableType.Bool),

				new InOutID_inOutType (Enums.OffMeshLinkData_startPosition_ID, VariableType.Vector3),
				new InOutID_inOutType (Enums.OffMeshLinkData_endPosition_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.OffMeshLinkData_valid_ID, VariableType.Bool),




				new InOutID_inOutType (Enums.NavMeshHit_distance_ID, VariableType.Float),

				new InOutID_inOutType (Enums.NavMeshHit_hit_ID, VariableType.Bool),

				new InOutID_inOutType (Enums.NavMeshHit_mask_ID, VariableType.Int),

				new InOutID_inOutType (Enums.NavMeshHit_normal_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.NavMeshHit_position_ID, VariableType.Vector3),



				//new InOutID_inOutType (Enums.meshValue_ID, VariableType.meshOnGameObject),
				//
				//new InOutID_inOutType (Enums.meshValues_0_ID, VariableType.meshOnGameObject),
				//
				//new InOutID_inOutType (Enums.meshValues_1_ID, VariableType.meshOnGameObject),




				new InOutID_inOutType (Enums.m44ValueDeterminant_ID, VariableType.Float),

				new InOutID_inOutType (Enums.m44ValueIsIdentity_ID, VariableType.Bool),

				new InOutID_inOutType (Enums.m44ValueInvertible_ID, VariableType.Bool),



				new InOutID_inOutType (Enums.m44Value_entier_ID, VariableType.Matrix4x4),

				new InOutID_inOutType (Enums.m44Value_Input_0_entier_ID, VariableType.Matrix4x4),

				new InOutID_inOutType (Enums.m44Value_Input_1_entier_ID, VariableType.Matrix4x4),



				new InOutID_inOutType (Enums.rectValue_ID, VariableType.rect),

				new InOutID_inOutType (Enums.rectValues_0_ID, VariableType.rect),

				new InOutID_inOutType (Enums.rectValues_1_ID, VariableType.rect),


				new InOutID_inOutType (Enums.rectList_ID, VariableType.rectsList),

				new InOutID_inOutType (Enums.rectListEntire_ID, VariableType.rectsList),

				new InOutID_inOutType (Enums.rectListEntire0_ID, VariableType.rectsList),

				new InOutID_inOutType (Enums.rectListEntire1_ID, VariableType.rectsList),




				new InOutID_inOutType (Enums.touch_altitudeAngle_ID, VariableType.Float), 

				new InOutID_inOutType (Enums.touch_azimuthAngle_ID, VariableType.Float),

				new InOutID_inOutType (Enums.touch_deltaPosition_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.touch_deltaTime_ID, VariableType.Float),



				new InOutID_inOutType (Enums.touch_fingerId_ID, VariableType.Int),

				new InOutID_inOutType (Enums.touch_maximumPossiblePressure_ID, VariableType.Float),

				new InOutID_inOutType (Enums.touch_phase_ID, VariableType.String),

				new InOutID_inOutType (Enums.touch_position_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.touch_pressure_ID, VariableType.Float),



				new InOutID_inOutType (Enums.touch_radius_ID, VariableType.Float),

				new InOutID_inOutType (Enums.touch_radiusVariance_ID, VariableType.Float),

				new InOutID_inOutType (Enums.touch_rawPosition_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.touch_tapCount_ID, VariableType.Int),

				new InOutID_inOutType (Enums.touch_type_ID, VariableType.String),

			};

			InOutID_inOutType [] ioidiotypeOfM44Outs = new InOutID_inOutType[16];

			for (int i = 0; i < 16; i++)
			{
				string ioid = "m44Value_" + i.ToString ();

				ioidiotypeOfM44Outs [i] = new InOutID_inOutType (ioid, VariableType.Float);
			}

			List<InOutID_inOutType> inOutID_inOutType_lst = new List<InOutID_inOutType> ();

			for (int i = 0; i < inOutID_inOutType.Length; i++)
				inOutID_inOutType_lst.Add (inOutID_inOutType [i]);

			for (int i = 0; i < ioidiotypeOfM44Outs.Length; i++)
				inOutID_inOutType_lst.Add (ioidiotypeOfM44Outs [i]);



			inOutID_inOutType = inOutID_inOutType_lst.ToArray ();

			inOutID_inOutType_lst.Clear ();



			outputsIDs = new string[inOutID_inOutType.Length];

			outputsTypes = new VariableType[inOutID_inOutType.Length];

			for (int i = 0; i < inOutID_inOutType.Length; i++)
			{
				outputsIDs [i] = inOutID_inOutType [i].id;

				outputsTypes [i] = inOutID_inOutType [i].type;
			}









			inOutID_inOutType = new InOutID_inOutType[]
			{
				new InOutID_inOutType (Enums.boolValues_0_ID, VariableType.Bool),

				new InOutID_inOutType (Enums.boolValues_1_ID, VariableType.Bool),


				new InOutID_inOutType (Enums.boolsListEntire0_ID, VariableType.boolsList),

				new InOutID_inOutType (Enums.boolsListEntire1_ID, VariableType.boolsList),




				new InOutID_inOutType (Enums.colorValues_0_ID, VariableType.Color),

				new InOutID_inOutType (Enums.colorValues_1_ID, VariableType.Color),


				new InOutID_inOutType (Enums.colorsListEntire0_ID, VariableType.colorsList),

				new InOutID_inOutType (Enums.colorsListEntire1_ID, VariableType.colorsList),




				new InOutID_inOutType (Enums.intValues_0_ID, VariableType.Int),

				new InOutID_inOutType (Enums.intValues_1_ID, VariableType.Int),

				new InOutID_inOutType (Enums.intValues_2_ID, VariableType.Int),


				new InOutID_inOutType (Enums.intsListEntire0_ID, VariableType.intsList),

				new InOutID_inOutType (Enums.intsListEntire1_ID, VariableType.intsList),






				new InOutID_inOutType (Enums.floatValues_0_ID, VariableType.Float),

				new InOutID_inOutType (Enums.floatValues_1_ID, VariableType.Float),

				new InOutID_inOutType (Enums.floatValues_2_ID, VariableType.Float),


				new InOutID_inOutType (Enums.floatsListEntire0_ID, VariableType.floatsList),

				new InOutID_inOutType (Enums.floatsListEntire1_ID, VariableType.floatsList),







				new InOutID_inOutType (Enums.vector2Values_0_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.vector2Values_1_ID, VariableType.Vector2),


				new InOutID_inOutType (Enums.vector2ListEntire0_ID, VariableType.vector2List),

				new InOutID_inOutType (Enums.vector2ListEntire1_ID, VariableType.vector2List),






				new InOutID_inOutType (Enums.vector3Values_0_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.vector3Values_1_ID, VariableType.Vector3),


				new InOutID_inOutType (Enums.vector3ListEntire0_ID, VariableType.vector3List),

				new InOutID_inOutType (Enums.vector3ListEntire1_ID, VariableType.vector3List),




				new InOutID_inOutType (Enums.rayOrigin_ID, VariableType.Vector3),

				new InOutID_inOutType (Enums.rayDirection_ID, VariableType.Vector3),


				new InOutID_inOutType (Enums.ray2DOrigin_ID, VariableType.Vector2),

				new InOutID_inOutType (Enums.ray2DDirection_ID, VariableType.Vector2),







				new InOutID_inOutType (Enums.vector4Values_0_ID, VariableType.Vector4),

				new InOutID_inOutType (Enums.vector4Values_1_ID, VariableType.Vector4),


				new InOutID_inOutType (Enums.vector4ListEntire0_ID, VariableType.vector4List),

				new InOutID_inOutType (Enums.vector4ListEntire1_ID, VariableType.vector4List),



				new InOutID_inOutType (Enums.stringValues_0_ID, VariableType.String),

				new InOutID_inOutType (Enums.stringValues_1_ID, VariableType.String),


				new InOutID_inOutType (Enums.stringsListEntire0_ID, VariableType.stringsList),

				new InOutID_inOutType (Enums.stringsListEntire1_ID, VariableType.stringsList),




				new InOutID_inOutType (Enums.gameObjectValues_0_ID, VariableType.GameObject),

				new InOutID_inOutType (Enums.gameObjectValues_1_ID, VariableType.GameObject),


				new InOutID_inOutType (Enums.gameObjectsListEntire0_ID, VariableType.GameObjectList),

				new InOutID_inOutType (Enums.gameObjectsListEntire1_ID, VariableType.GameObjectList),




				new InOutID_inOutType (Enums.doIt_ID, VariableType.Bool),



				new InOutID_inOutType (Enums.materialValues_0_ID, VariableType.Material),

				new InOutID_inOutType (Enums.materialValues_1_ID, VariableType.Material),


				new InOutID_inOutType (Enums.materialListEntire0_ID, VariableType.materialsList),

				new InOutID_inOutType (Enums.materialListEntire1_ID, VariableType.materialsList),




				new InOutID_inOutType (Enums.texture2DValues_0_ID, VariableType.Texture2D),

				new InOutID_inOutType (Enums.texture2DValues_1_ID, VariableType.Texture2D),


				new InOutID_inOutType (Enums.texture2DListEntire0_ID, VariableType.texture2DList),

				new InOutID_inOutType (Enums.texture2DListEntire1_ID, VariableType.texture2DList),


				//new InOutID_inOutType (Enums.renderTextureValues_0_ID, VariableType.RenderTexture),
				//
				//new InOutID_inOutType (Enums.renderTextureValues_1_ID, VariableType.RenderTexture),

				new InOutID_inOutType (Enums.shaderValues_0_ID, VariableType.Shader),

				new InOutID_inOutType (Enums.shaderValues_1_ID, VariableType.Shader),


				new InOutID_inOutType (Enums.shaderListEntire0_ID, VariableType.shadersList),

				new InOutID_inOutType (Enums.shaderListEntire1_ID, VariableType.shadersList),



				//new InOutID_inOutType (Enums.meshValues_0_ID, VariableType.meshOnGameObject),
				//
				//new InOutID_inOutType (Enums.meshValues_1_ID, VariableType.meshOnGameObject),




				new InOutID_inOutType (Enums.m44Value_Input_0_entier_ID, VariableType.Matrix4x4),

				new InOutID_inOutType (Enums.m44Value_Input_1_entier_ID, VariableType.Matrix4x4),




				new InOutID_inOutType (Enums.rectValues_0_ID, VariableType.rect),

				new InOutID_inOutType (Enums.rectValues_1_ID, VariableType.rect),


				new InOutID_inOutType (Enums.rectListEntire0_ID, VariableType.rectsList),

				new InOutID_inOutType (Enums.rectListEntire1_ID, VariableType.rectsList),
			};

			inputsIDs = new string[inOutID_inOutType.Length];

			inputsTypes = new VariableType[inOutID_inOutType.Length];

			for (int i = 0; i < inOutID_inOutType.Length; i++)
			{
				inputsIDs [i] = inOutID_inOutType [i].id;

				inputsTypes [i] = inOutID_inOutType [i].type;
			}



			DisactivateAllInputsAllOutputs ();

			//InitInOutRects ();
		}




		/// <summary>
		/// Methods called for drawing and managing the visual aspect of the logicNode zooming
		/// and adaptation
		/// </summary>
		#region Draw methods
		void SetContentsRatioAndAlignment (FieldDrawType fieldDrawType, 
			ref Vector2 contentRatio, ref Vector2 alignmentRatio)
		{
			switch (fieldDrawType)
			{
			case FieldDrawType.label:
				//contentRatio = labelFieldContentRatio;				
				//alignmentRatio = labelFieldAlignmentRatio;

				contentRatio = nodeNameFieldContentRatio;
				alignmentRatio = nodeNameFieldAlignmentRatio;
				break;

			case FieldDrawType.nodeName:
				contentRatio = nodeNameFieldContentRatio;
				alignmentRatio = nodeNameFieldAlignmentRatio;
				break;

			case FieldDrawType.optionsButton:
				contentRatio = optionsButtonFieldContentRatio;
				alignmentRatio = optionsButtonFieldAlignmentRatio;
				break;

			case FieldDrawType.variable:
				//contentRatio = variableFieldContentRatio;				
				//alignmentRatio = variableFieldAlignmentRatio;

				contentRatio = nodeNameFieldContentRatio;
				alignmentRatio = nodeNameFieldAlignmentRatio;
				break;
			}
		}


		void SetFieldsContentsAndAlignmentsRatios ()
		{
			optionsButtonWidth = 7f;

			rectWidthFactorDefault = 1.6f * rectWidthFactorDefaultFactor;

			rectWidthFactorMin = 0.4f*rectWidthFactorDefault;

			rectWidthFactorMid = 0.55f*rectWidthFactorDefault;


			float contentRatioWidth = 0.75f;

			float contentRatioHeight = 0.8f;

			nodeNameFieldContentRatio = new Vector2 (contentRatioWidth, contentRatioHeight);

			nodeNameFieldAlignmentRatio = new Vector2 (0.5f, 0.3f);


			optionsButtonFieldContentRatio = new Vector2 (1f, 1f); 

			optionsButtonFieldAlignmentRatio = new Vector2 (0.5f, 1f); 


			//labelFieldContentRatio = new Vector2 (contentRatioWidth, contentRatioHeight); 

			//labelFieldAlignmentRatio = new Vector2 (0.5f, 1f); 


			variableFieldContentRatio = new Vector2 (contentRatioWidth, contentRatioHeight); 

			variableFieldAlignmentRatio = new Vector2 (0.5f, 0f); 
		}


		Rect GetSuitableRect (FieldDrawType fieldDrawType)
		{
			return GetSuitableRect (fieldDrawType, 
				new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));
		}
		Rect GetSuitableRect_NoAlignementGapX (FieldDrawType fieldDrawType, Vector2 fieldID, Vector2 fieldsCount)
		{
			Vector2 contentRatio = variableFieldContentRatio;

			Vector2 alignmentRatio = variableFieldAlignmentRatio;



			rectWidthFactor = rectWidthFactorMid;

			//SetFieldsCount (ref fieldsCount);

			fieldsCount = new Vector2 (fieldsCount.x, fieldsCount.y++);


			SetContentsRatioAndAlignment (fieldDrawType, ref contentRatio, ref alignmentRatio);



			//if (zoom >= 1f)
			//	rectPosIni = rect.position;
			//
			//Vector2 rectPos = rectPosIni + new Vector2 ((-(zoom-1f)/(1f-zoomMin))*rect.width*0.5f, 
			//	(-(zoom-1f)/(1f-zoomMin))*rect.height*0.5f);
			//
			//rect = new Rect(rectPos, rect.size);		


			rect = RectOnMaxMin (new Rect (
				new Vector2 (rect.x, rect.y), 
				zoom * new Vector2 (
					fieldsCount.x * Skins.logicNodeRectStep.x * rectWidthFactor,
					fieldsCount.y * Skins.logicNodeRectStep.y)));



			Vector2 zoneSize = new Vector2 (rect.width / fieldsCount.x, rect.height / fieldsCount.y); 

			Rect zone = new Rect (rect.x + zoneSize.x*fieldID.x, rect.y + zoneSize.y*fieldID.y, zoneSize.x, zoneSize.y);


			Vector2 contentSize = new Vector2 (contentRatio.x * zoneSize.x, contentRatio.y * zoneSize.y);

			Vector2 gapSize = new Vector2 (zoneSize.x - contentSize.x, zoneSize.y - contentSize.y);

			return new Rect (zone.x, zone.y + alignmentRatio.y * gapSize.y, contentSize.x, contentSize.y);
		}
		Rect GetSuitableRect (FieldDrawType fieldDrawType, Vector2 fieldID, Vector2 fieldsCount)
		{
			Vector2 contentRatio = variableFieldContentRatio;

			Vector2 alignmentRatio = variableFieldAlignmentRatio;



			rectWidthFactor = rectWidthFactorMid;

			//SetFieldsCount (ref fieldsCount);

			fieldsCount = new Vector2 (fieldsCount.x, fieldsCount.y++);


			SetContentsRatioAndAlignment (fieldDrawType, ref contentRatio, ref alignmentRatio);



			//if (zoom >= 1f)
			//	rectPosIni = rect.position;
			//
			//Vector2 rectPos = rectPosIni + new Vector2 ((-(zoom-1f)/(1f-zoomMin))*rect.width*0.5f, 
			//	(-(zoom-1f)/(1f-zoomMin))*rect.height*0.5f);
			//
			//rect = new Rect(rectPos, rect.size);		

			rect = RectOnMaxMin (new Rect (
				new Vector2 (rect.x, rect.y), 
				zoom * new Vector2 (
					fieldsCount.x * Skins.logicNodeRectStep.x * rectWidthFactor,
					fieldsCount.y * Skins.logicNodeRectStep.y)));

		



			Vector2 zoneSize = new Vector2 (rect.width / fieldsCount.x, rect.height / fieldsCount.y); 

			Rect zone = new Rect (rect.x + zoneSize.x*fieldID.x, rect.y + zoneSize.y*fieldID.y, zoneSize.x, zoneSize.y);


			Vector2 contentSize = new Vector2 (contentRatio.x * zoneSize.x, contentRatio.y * zoneSize.y);

			Vector2 gapSize = new Vector2 (zoneSize.x - contentSize.x, zoneSize.y - contentSize.y);

			return new Rect (zone.x + alignmentRatio.x * gapSize.x, zone.y + alignmentRatio.y * gapSize.y, contentSize.x, contentSize.y);
		}
		Rect GetSuitableRect (FieldDrawType fieldDrawType, Vector2 fieldsCountLocal, Vector2 fieldID, bool h)
		{
			Vector2 fieldsCount = new Vector2 (1f, 3f);

			Vector2 contentRatio = variableFieldContentRatio;

			Vector2 alignmentRatio = variableFieldAlignmentRatio;



			rectWidthFactor = rectWidthFactorMid;

			SetContentsRatioAndAlignment (fieldDrawType, ref contentRatio, ref alignmentRatio);


			rect = RectOnMaxMin (new Rect (rect.x, rect.y, 
				fieldsCount.x * Skins.logicNodeRectStep.x * rectWidthFactor,
				fieldsCount.y * Skins.logicNodeRectStep.y));

			Vector2 zoneSize = new Vector2 (rect.width / fieldsCountLocal.x, rect.height / fieldsCountLocal.y); 

			Rect zone = new Rect (rect.x + zoneSize.x*fieldID.x, rect.y + zoneSize.y*fieldID.y, zoneSize.x, zoneSize.y);


			Vector2 contentSize = new Vector2 (contentRatio.x * zoneSize.x, contentRatio.y * zoneSize.y);

			Vector2 gapSize = new Vector2 (zoneSize.x - contentSize.x, zoneSize.y - contentSize.y);

			return new Rect (zone.x + alignmentRatio.x * gapSize.x, zone.y + alignmentRatio.y * gapSize.y, contentSize.x, contentSize.y);
		}
		Rect GetSuitableRect (FieldDrawType fieldDrawType, float column, float totalColumns, bool incrementHeight)
		{
			Rect r = new Rect ();

			Rect suitRect = new Rect ();

			if (incrementHeight)
			{
				suitRect = GetSuitableRect (fieldDrawType, 
					new Vector2 (0f, fieldIDGlobal [1]++),
					new Vector2 (1f, fieldsCountGlobal [1]++));

			}
			else if ( ! incrementHeight)
			{
				suitRect = GetSuitableRect (fieldDrawType, 
					new Vector2 (0f, fieldIDGlobal [1]),
					new Vector2 (1f, fieldsCountGlobal [1]));
			}

			float finalWidth = suitRect.width / totalColumns;

			r = new Rect (suitRect.position + new Vector2 (column*finalWidth, 0f),
				new Vector2 (finalWidth, suitRect.height));

			return r;
		}
		Rect GetSuitableRect (FieldDrawType fieldDrawType, float column, float totalColumns)
		{
			Rect r = GetSuitableRect (fieldDrawType, column, totalColumns, column > totalColumns -2);
			//IncrementColumnID ();
			return r;
		}
		Rect [] GetSuitableLineRects (FieldDrawType fieldDrawType, int nb)
		{
			Rect [] r = new Rect [nb];

			for (int i = 0; i < nb-1; i++)
			{
				r [i] = GetSuitableRect (fieldDrawType, (float)i, (float)nb, false);
			}
			r [nb-1] = GetSuitableRect (fieldDrawType, (float)(nb-1), (float)nb, true);

			return r;
		}





		void changeExecutionOrder (object iObj)
		{
			int i = int.Parse (iObj.ToString ());

			if (i == logic.nodes.IndexOf (this))
				return;

			ListOperations.Permute (ref logic.nodes, logic.nodes.IndexOf (this), i);
		}

		void DrawExecutionOrder ()
		{
			Rect executionOrderRect = new Rect (rect.position + new Vector2 (-20f, 0), new Vector2 (20f, 22f));

			if (GUI.Button (executionOrderRect,
				logic.nodes.IndexOf (this).ToString (), GetGuiStyle (Skins.button))
				&& eGlobal.button == 0)
			{
				
				GenericMenu menu = new GenericMenu ();

				for (int i = 0; i < logic.nodes.Count; i++)
				{
					menu.AddItem (new GUIContent (i.ToString ()), 
						(i == logic.nodes.IndexOf (this))? true: false,
						changeExecutionOrder, i.ToString ());
				}

				menu.ShowAsContext ();
			}

			if (executionOrderRect.Contains (eGlobal.mousePosition))
			{
				DrawFloatingMessage (eGlobal.mousePosition, "Change execution order");
			}
		}


		void DrawOptionButton ()
		{				
			if (GUI.Button (
				GetSuitableRect (FieldDrawType.optionsButton, 
					new Vector2 (rect.width / (optionsButtonWidth*zoom), 2.5f),
					new Vector2 ((rect.width / (optionsButtonWidth))-1.7f, 0.5f), 
					true), 
				"", Skins.guiSkin.GetStyle (Skins.dotesOptions)) && eGlobal.button == 0)
			{

				OpenOptionsMenu ();
			}
		}

		public void OpenOptionsMenu ()
		{
			eGlobal.mousePosition = new Vector2 (rect.x + rect.width*zoom, rect.y);

			GenericMenu menu = new GenericMenu ();

			menu.AddItem (new GUIContent ("Rename"), false, OptionsRename);

			menu.AddItem (new GUIContent ("Reset"), false, Reset);

			menu.AddItem (new GUIContent ("Delete"), false, RemoveNodeFromOptionsMenu);

			menu.ShowAsContext ();			
		}


		public static void DrawFloatingMessage (Vector2 posFm, string message)
		{
			Vector2 stringToRect = new Vector2 (7f, 15f);

			Vector2 messageRectSize = new Vector2 (stringToRect.x*message.Length, stringToRect.y);

			Rect messageRect = new Rect (posFm + new Vector2 (-messageRectSize.x*0.5f, stringToRect.y*3f),
				messageRectSize);

			GUI.Box (messageRect, message, GetGuiStyle (Skins.floatMessage));
		}
		public static void DrawFloatingMessage (Rect drawingRect, string message)
		{
			Vector2 stringToRect = new Vector2 (7f, 15f);

			Vector2 messageRectSize = new Vector2 (stringToRect.x*message.Length, stringToRect.y);

			Rect messageRect = new Rect (drawingRect.position, messageRectSize);

			GUI.Box (messageRect, message, GetGuiStyle (Skins.floatMessage));
		}


		float ZoomShowLimit (float limit)
		{
			float r = zoomMin + (1f - zoomMin)*limit;

			//Debug.Log ("ZoomLabelShowLimit: " + r);

			//Debug.Log ("Zoom: " + zoom);

			return r;
		}


		void DrawLogicNodeLabel (string s)
		{
			if (zoom < ZoomShowLimit (0.7f))
				return;

			Rect suitRect = GetSuitableRect (FieldDrawType.label);
			//	new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//	new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			//Rect suitRect = GetSuitableRect (FieldDrawType.label, 0, 2);

			EditorGUI.LabelField (suitRect, s, Skins.guiSkin.GetStyle (Skins.logicNodeLabel));
		}
		void DrawLogicNodeLabel (string s, int column, int totalColumns)
		{
			//if (zoom < ZoomShowLimit (0.7f))
			//	return;

			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			EditorGUI.LabelField (suitRect, s, Skins.guiSkin.GetStyle (Skins.logicNodeLabel));
		}
		void DrawLogicNodeLabel (string [] s)
		{
			//if (zoom < ZoomShowLimit (0.7f))
			//	return;

			for (int i = 0; i < s.Length; i++)
			{
				DrawLogicNodeLabel (s [i], i, s.Length);
			}
		}




		delegate void DoItMethod ();

		DoItMethod doItMethod;

		void DrawDoItButton ()
		{
			noAlwaysDoItOption = false;

			Rect suitRect = DrawDoItInputField ();

			if (maximized)
			if ( ! alwaysDoIt)
			if (GUI.Button (suitRect, doItbuttonLabel) && eGlobal.button == 0)
			{

				doIT = true;
			}
			if (alwaysDoIt)
				EditorGUI.LabelField (suitRect, alwaysDoItExpression, GetGuiStyle (Skins.alwaysDoItExpression));

			int varIndex = IndexOfInID (Enums.doIt_ID);

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
		void DrawDoItButton (DoItMethod dim)
		{
			Rect suitRect = DrawDoItInputField ();

			if (maximized)
			if ((GUI.Button (suitRect, doItbuttonLabel) && eGlobal.button == 0) || doIT)
			{

				dim ();
			}

			int varIndex = IndexOfInID (Enums.doIt_ID);

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void WriteToTheDiscBlendedTextureButton (DoItMethod dim)
		{
			//Rect suitRect = DrawDoItInputField ();

			if (maximized)
			{


				if (GUI.Button (GetSuitableRect (FieldDrawType.variable), "Save new Texture to Disc") && eGlobal.button == 0)
				{
					dim ();
				}
			}

			//int varIndex = IndexOfInID (Enums.doIt_ID);

			//if (varIndex > -1 && varIndex < activeInputsFields.Length)
			//	activeInputsFields [varIndex] = true;
		}


		int GetMaxPhrasesLength (string [] message)
		{
			int [] phrasesLengths = new int[message.Length];

			for (int i = 0; i < message.Length; i++)
				phrasesLengths [i] = message [i].Length;

			return Mathf.Max (phrasesLengths);
		}

		Rect GetMessageBoxRectLeftUp (string [] message, Vector2 charWh)
		{
			Vector2 wH = new Vector2 (
				charWh.x*(float)GetMaxPhrasesLength (message), 
				charWh.y*(float)message.Length);

			return new Rect (rect.x, rect.y - wH.y, wH.x, wH.y);
		}

		Rect GetMessageBoxRectLeftUp (string [] message, Vector2 charWh, float linesPlus)
		{
			Vector2 wH = new Vector2 (
				charWh.x*(float)GetMaxPhrasesLength (message), 
				charWh.y*(float)(message.Length));

			return new Rect (rect.x, rect.y - wH.y - linesPlus, wH.x, wH.y);
		}

		Rect GetMessageBoxRectLeftDown (string [] message, Vector2 charWh)
		{
			Vector2 wH = new Vector2 (charWh.x*(float)GetMaxPhrasesLength (message), charWh.y*(float)message.Length);

			return new Rect (rect.x, rect.y + rect.height + Skins.separatorThickness, wH.x, wH.y);
		}

		Rect GetMessageBoxRectRighttUp (string [] message, Vector2 charWh)
		{
			Vector2 wH = new Vector2 (
				charWh.x*(float)GetMaxPhrasesLength (message), 
				charWh.y*(float)message.Length);

			return new Rect (rect.x + rect.width, rect.y, wH.x, wH.y);
		}

		Rect RectOnMaxMin (Rect maxRect)
		{
			Rect retVal = new Rect ();

			if ( ! maximized)
			{
				retVal = new Rect (maxRect.x, maxRect.y, 
					Skins.logicNodeRectMini.width*rectWidthFactorMin, Skins.logicNodeRectMini.height);
			}
			else if (maximized)
			{
				retVal = maxRect;
			}

			return retVal;
		}


		void DrawMessageBoxUpLeft (string [] message)
		{
			float buttonToOpenMessage = 20f;

			Rect openMessageRect = new Rect (buttonToOpenMessage + rect.x, rect.y - 20f, 90f, 20f);

			Rect mbr = GetMessageBoxRectLeftUp (message, new Vector2 (5.3f, 17f), openMessageRect.height);

			string messageFinale = StringTreatment.StringArrayToString (message);

			Rect maximizeRect = new Rect (rect.x, openMessageRect.y, openMessageRect.height, 
				openMessageRect.height);


			GUI.Box (maximizeRect, "", Skins.guiSkin.GetStyle (Skins.leftUpMessageInfo));
			if (! minimizeUpLeftMessageBox)
			{
				GUI.Box (mbr, messageFinale, Skins.guiSkin.GetStyle (Skins.leftUpMessageInfo));

				//Rect minimizeRect = new Rect (mbr.x + mbr.width - 30f, mbr.y, 25f, 25f);

				GUI.Box (openMessageRect, "", Skins.guiSkin.GetStyle (Skins.leftUpMessageInfo));
				if (GUI.Button (maximizeRect, "", Skins.guiSkin.GetStyle (Skins.back)) && eGlobal.button == 0)
				{
					minimizeUpLeftMessageBox = true;
				}
			}
			else if (minimizeUpLeftMessageBox)
			{
				GUI.Box (openMessageRect, "Open Message:", Skins.guiSkin.GetStyle (Skins.leftUpMessageInfo));


				if (GUI.Button (maximizeRect, "", Skins.guiSkin.GetStyle (Skins.forward)) && eGlobal.button == 0)
				{
					minimizeUpLeftMessageBox = false;
				}
			}
		}

		void DrawMessageBoxDownLeft (string [] message)
		{
			Rect mbr = GetMessageBoxRectLeftDown (message, new Vector2 (5.3f, 17f));

			string messageFinale = StringTreatment.StringArrayToString (message);

			GUI.Box (mbr, messageFinale, 
				Skins.guiSkin.GetStyle (Skins.leftDownMessageInfo));
		}

		void DrawDocumentationBoxUpRight (string [] message)
		{
			Rect mbr = GetMessageBoxRectRighttUp (message, documentationCharSize);

			string messageFinale = StringTreatment.StringArrayToString (message, true);

			if ( ! minimizeDocumentationBoxUpRight)
			{
				GUI.Box (mbr, messageFinale, 
					Skins.guiSkin.GetStyle (Skins.documentationMessage));

				Rect minimizeRect = new Rect (rect.x + rect.width + 5f,
					rect.y, 20f, 25f);

				if (GUI.Button (minimizeRect, "", 
					Skins.guiSkin.GetStyle (Skins.back)) && eGlobal.button == 0)
				{
					minimizeDocumentationBoxUpRight = true;
				}
			}
			else if (minimizeDocumentationBoxUpRight)
			{
				Rect openMessageRect = new Rect (rect.x + rect.width, rect.y,
					20f, 22f);

				GUI.Box (openMessageRect, "",
					Skins.guiSkin.GetStyle (Skins.leftUpMessageInfo));

				//Rect maximizeRect = new Rect (openMessageRect.x + 85f,
				//	openMessageRect.y, 25f, 25f);

				if (GUI.Button (openMessageRect, "?", 
					Skins.guiSkin.GetStyle (Skins.button)) && eGlobal.button == 0)
				{
					minimizeDocumentationBoxUpRight = false;
				}
			}
		}

		void DrawDocumentationUrlButtons (string [] message, 
			string url_0, string url_1)
		{
			if (minimizeDocumentationBoxUpRight)
			{
				return;
			}

			Rect mbr = GetMessageBoxRectRighttUp (message, documentationCharSize);

			string url = url_0;

			float docUrlHeight = 20f;

			Rect docUrlRect = new Rect (
				mbr.x, mbr.y + mbr.height + 5f, 140f, docUrlHeight);

			if (string.IsNullOrEmpty (url_0))
			{
				if ( ! string.IsNullOrEmpty (url_1))
				{
					url = url_1;

					if (GUI.Button (docUrlRect, "Mezanix Documentation", 
						Skins.guiSkin.GetStyle (Skins.LittleNamedRectsCenterDark)) && eGlobal.button == 0)
					{
						Application.OpenURL (url);
					}
				}
			}
			else if ( ! string.IsNullOrEmpty (url_0))
			{
				url = url_0;

				if (GUI.Button (docUrlRect, "Unity Documentation", 
					Skins.guiSkin.GetStyle (Skins.LittleNamedRectsCenterDark)) && eGlobal.button == 0)
				{
					Application.OpenURL (url);
				}

				if ( ! string.IsNullOrEmpty (url_1))
				{
					url = url_1;

					docUrlRect = new Rect (
						docUrlRect.x, docUrlRect.y + docUrlRect.height,
						docUrlRect.width, docUrlRect.height);

					if (GUI.Button (docUrlRect, "Mezanix Documentation", 
						Skins.guiSkin.GetStyle (Skins.LittleNamedRectsCenterDark)) && eGlobal.button == 0)
					{
						Application.OpenURL (url);
					}
				}
			}
		}




		void DrawLabelFields (string [] labels)
		{
			for (int i = 0; i < labels.Length; i++)
			{
				DrawLabelField (FieldDrawType.label, labels [i], Skins.logicNodeLabel);
			}
		}

		void DrawGameObject_0_isNullInfo ()
		{
			DrawLabelField (FieldDrawType.nodeName, gameObject_0_isNullInfo, 
				Skins.InNodeMessageInfo);			
		}
		void DrawInNodeInfo (string info)
		{
			DrawLabelField (FieldDrawType.nodeName, info, 
				Skins.InNodeMessageInfo);			
		}



		void DrawLogicTypeEnum ()
		{
			if ( ! string.IsNullOrEmpty (specialNodeType))
				return;

			if ( ! maximized)
				return;

			//columns = 2;
			//columnID = 0;

			DrawLogicNodeLabel ("Logic", 0, 2); 
			//columnID = 1;

			logicType = (LogicType)DrawEnum (logicType, ref logicType_length, ref logicType_last, typeof(LogicType),
				FieldDrawType.label, 1, 2);

			//columnID = 0;

			//GUI.Label (
			//	GetSuitableRect 
			//	(FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//		new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), "Logic Type", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));
			//
			//logicType= (LogicType)EditorGUI.EnumPopup (GetSuitableRect 
			//	(FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//		new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), logicType);
		}

		void DrawVariableTypeEnum ()
		{
			if ( ! maximized)
				return;
			
			DrawLogicNodeLabel ("Variable Type", 0, 2);

			variableType = (VariableType)DrawEnum (variableType, ref variableType_Length, ref variableType_last,
				typeof(VariableType),
				FieldDrawType.label, 1, 2);
		}

		void DrawVariableTypeColor (VariableType vt, Rect variableTypeEnumRect)
		{
			Vector2 drawingRectSize = new Vector2 (17f, 17f);

			Rect colorRect = new Rect (
				new Vector2	(
					rect.x + rect.width - drawingRectSize.x, 
					variableTypeEnumRect.y + 1f),
				0.7f*drawingRectSize);

			string variableTypeScriptDeclarationName = CsScriptWriter.VariableTypeToDeclarationString (vt);

			if (colorRect.Contains (eGlobal.mousePosition))
			{
				DrawFloatingMessage (colorRect.center, variableTypeScriptDeclarationName + " type color");
			}

			Diamond.namesToSave.variableTypeColor [GetVariableTypeEnumIndex (vt)] = 
				EditorGUI.ColorField (colorRect, new GUIContent (),
					Diamond.namesToSave.variableTypeColor [GetVariableTypeEnumIndex (vt)],
					false, true, false, new ColorPickerHDRConfig (1f, 1f, 1f, 1f));
		}


		//Enum DrawEnumComputeType (Enum selection)
		//{
		//	DrawLogicNodeLabel ("Compute", 0, 2);
		//
		//	return DrawEnum (selection, FieldDrawType.label, 1, 2);
		//}
		Enum DrawEnumComputeType (Enum selection, ref int selectionLength, 
			ref string selectionLast, Type selectionType)
		{
			DrawLogicNodeLabel ("Compute", 0, 2);

			return DrawEnum (selection, 
				ref selectionLength, ref selectionLast, selectionType, FieldDrawType.label, 1, 2);
		}


		public int timeType_length = 0;
		public string timeType_last;

		void DrawTimeTypeEnum ()
		{
			//Rect suitRect = GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//	new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			DrawLogicNodeLabel ("Time Type", 0, 2); 



			//timeType = (TimeType)DrawEnum (timeType, FieldDrawType.label, 1, 2);
			timeType = (TimeType)DrawEnum (timeType, ref timeType_length, 
				ref timeType_last, typeof(TimeType), FieldDrawType.label, 1, 2);
		}

		void DrawPhysicMaterialCombineEnum ()
		{
			DrawLabelField (FieldDrawType.label, "Physic Material Combine", Skins.logicNodeLabel);

			physicMaterialCombine = (PhysicMaterialCombine)EditorGUI.EnumPopup (
				GetSuitableRect (FieldDrawType.variable, 
					new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
					new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)),
				physicMaterialCombine);
		}

		void DrawForceModeEnum ()
		{
			forceMode = (ForceMode)EditorGUI.EnumPopup (
				GetSuitableRect (FieldDrawType.variable, 
					new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
					new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)),
				forceMode);
		}

		void DrawQueryTriggerInteractionEnum ()
		{
			queryTriggerInteraction = (QueryTriggerInteraction)EditorGUI.EnumPopup (
				GetSuitableRect (FieldDrawType.variable,
					new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
					new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)),
				queryTriggerInteraction);
		}


		void DrawFieldsForSweepTestAll ()
		{
			DrawLabelField (FieldDrawType.label,
				"Direction", Skins.logicNodeLabel);
			DrawVector3InputField (0);

			DrawLabelField (FieldDrawType.label,
				"Distance", Skins.logicNodeLabel);
			DrawFloatInputField (0);

			DrawLabelField (FieldDrawType.label,
				"Query Trigger Interaction", Skins.logicNodeLabel);
			DrawQueryTriggerInteractionEnum ();
		}

		void DrawIntWhichHit ()
		{
			if (hits.Length == 0)
			{
				intValues [0] = -1;

				return;
			}

			DrawLabelField (FieldDrawType.label, hits.Length.ToString () + 
				" Hits found", Skins.logicNodeLabel);

			DrawLabelField (FieldDrawType.label, "Which Hit You Want?", Skins.logicNodeLabel);

			DrawLabelField (FieldDrawType.label, "The Index of the First one is zero", Skins.logicNodeLabel);

			DrawIntInputField (0);

			intValues [0] = Mathf.Clamp (intValues [0], 0, hits.Length-1);
		}

		void DrawFieldsForSweepTest ()
		{
			DrawLabelField (FieldDrawType.label,
				"Direction", Skins.logicNodeLabel);
			DrawVector3InputField (0);

			DrawLabelField (FieldDrawType.label,
				"Distance", Skins.logicNodeLabel);
			DrawFloatInputField (0);

			DrawLabelField (FieldDrawType.label,
				"Query Trigger Interaction", Skins.logicNodeLabel);
			DrawQueryTriggerInteractionEnum ();
		}

		public int materialGlobalIlluminationFlags_length = 0;
		public string materialGlobalIlluminationFlags_last;
		void DrawMaterialGlobalIlluminationFlagsEnum ()
		{
			

			materialGlobalIlluminationFlags = (MaterialGlobalIlluminationFlags)DrawEnum (
				materialGlobalIlluminationFlags,
				ref materialGlobalIlluminationFlags_length,
				ref materialGlobalIlluminationFlags_last, typeof(MaterialGlobalIlluminationFlags),
				"Global Illumination Flag", Skins.logicNodeLabel);

		}


		void DrawWriteTextureFormatEnum ()
		{
			DrawLabelField (FieldDrawType.label, "Texture Format", Skins.logicNodeLabel);

			writeTextureFormat = (WriteTextureFormat)EditorGUI.EnumPopup (GetSuitableRect (FieldDrawType.variable),
				writeTextureFormat);
		}
		public int filterMode_length = 0;
		public string filterMode_last;
		void DrawFilterModeEnum ()
		{
			

			filterMode = (FilterMode)DrawEnum (filterMode,
				ref filterMode_length, ref filterMode_last, typeof(FilterMode),
				"Filter Mode", Skins.logicNodeLabel);
		}
		public int textureWrapMode_length = 0;
		public string textureWrapMode_last;
		void DrawTextureWrapModeEnum ()
		{
			
			textureWrapMode = (TextureWrapMode)DrawEnum (textureWrapMode,
				ref textureWrapMode_length, ref textureWrapMode_last, typeof(TextureWrapMode),
				"Wrap Mode", Skins.logicNodeLabel);
		}

		public int textureEncodeType_length = 0;
		public string textureEncodeType_last;
		void DrawTextureEncodeTypeEnum ()
		{
			
			textureEncodeType = (TextureEncodeType)DrawEnum (textureEncodeType,
				ref textureEncodeType_length, ref textureEncodeType_last, typeof(TextureEncodeType),
				"File Type", Skins.logicNodeLabel);
		}

		void DrawPrepareTexture2DInputs (PrepareTexture2DForWhat forw)
		{
			if (forw == PrepareTexture2DForWhat.blend)
			{
				DrawColorBlendModeEnum ();
			}


			DrawTextureEncodeTypeEnum ();

			DrawLabelField (FieldDrawType.label, "JPG Quality", Skins.logicNodeLabel);

			DrawIntInputField (0);



			DrawLabelField (FieldDrawType.label, "File Name", Skins.logicNodeLabel);
			DrawStringInputField (0, stringInputFieldForWhat.fileName);


			DrawWriteTextureFormatEnum ();

			DrawLabelField (FieldDrawType.label, "With Mipmap?", Skins.logicNodeLabel);
			DrawBoolInputField (0);

			DrawLabelField (FieldDrawType.label, "Is Linear Color Space?", Skins.logicNodeLabel);
			DrawBoolInputField (1);

			if (forw == PrepareTexture2DForWhat.write)
				DrawCompleteOrPArtOfTextureEnum ();

			if (forw == PrepareTexture2DForWhat.write)
			{	
				if (forw == PrepareTexture2DForWhat.write)
				{
					if (compeleOrPartOfTexture == CompeleOrPartOfTexture.aBlockOfTheTexture)
					{
						DrawLabelField (FieldDrawType.label, "Begin At Pixel (%)", Skins.logicNodeLabel);

						DrawVector2InputField (0);

						vector2Values [0] = Vector2.Max (Vector2.zero, vector2Values [0]);

						vector2Values [0] = Vector2.Min (98f*Vector2.one, vector2Values [0]);



						DrawLabelField (FieldDrawType.label, "Block (%)", Skins.logicNodeLabel);

						DrawVector2InputField (1);

						vector2Values [1] = Vector2.Max (2f*Vector2.one, vector2Values [1]);

						vector2Values [1] = Vector2.Min (100f*Vector2.one, vector2Values [1]);
					}
					else if (compeleOrPartOfTexture == CompeleOrPartOfTexture.theCompleteTexture)
					{
						vector2Values [0] = Vector2.zero;

						vector2Values [1] = new Vector2 (100f, 100f);
					}
				}
				else if (forw != PrepareTexture2DForWhat.write)
				{
					DrawLabelField (FieldDrawType.label, "Width and Height", Skins.logicNodeLabel);

					vector2Values [1] = Vector2.Max (vector2Values [1], Vector2.one*(float)TextureComputer.minTextureSize);

					DrawVector2InputField (1);

				}
			}


			DrawInNodeInfo (dontOfenRunTimeInfo);
		}

		void DrawInputsForCaptureGameViewScreenshot ()
		{
			DrawMessageBoxUpLeft (new string[]
				{
					"To do Game View Screenshot\n",
					"1. Click 'do it' button in your logic node.\n",
					"2. Ckick once in the Game View.\n",
					"3. Click an another time the 'do it' button.\n",
					"\n",
					"Double Clicking 'Do IT' button may work also\n",
				});

			DrawLabelField (FieldDrawType.label, "Destination Texture name no Ext", Skins.logicNodeLabel);

			DrawStringInputField (0, stringInputFieldForWhat.fileName);


			DrawLabelFields (
				new string[] 
				{
					"Multiply size by the following",
					"For an exact size shot,",
					"use a Zero or negative value",
				}
			);

			DrawIntInputField (0);

			intValues [0] = Mathf.Max (0, intValues [0]);
		}

		void DrawInputsForSetPixel ()
		{
			DrawColorInputField (0);

			DrawLabelField (FieldDrawType.label, "At x, y", Skins.logicNodeLabel);

			DrawIntInputField (0);

			DrawIntInputField (1);
		}


		float [] Texture2DViewerTargetHeight ()
		{
			float den = 380f;

			float un = rect.height / den;

			float targetH = 120f*un;

			return new float[] {un, targetH};
		}

		void DrawResultTexture2DViewer ()
		{
			float [] viewerHeights = Texture2DViewerTargetHeight ();

			Rect texture2D_viewRect = new Rect (
				rect.x + rect.width*1.05f, 
				rect.y + rect.height - viewerHeights [1] - Skins.logicNodeRectStep.y,
				viewerHeights [1], 
				viewerHeights [1]);

			DrawTexture2DViewer (texture2DValue, texture2D_viewRect);
		}

		void DrawTexture2DViwersForTextureTransform ()
		{
			float [] viewerHeights = Texture2DViewerTargetHeight ();

			Rect texture2D_0_viewRect = new Rect (
				rect.x + rect.width*1.05f, 
				rect.y + rect.height - viewerHeights [1] - Skins.logicNodeRectStep.y,
				viewerHeights [1], 
				viewerHeights [1]);

			DrawTexture2DViewer (texture2DValues [0], texture2D_0_viewRect);


			Rect texture2D_viewRect = new Rect (
				texture2D_0_viewRect.x, 
				texture2D_0_viewRect.y - viewerHeights [0] - viewerHeights [1],
				viewerHeights [1], 
				viewerHeights [1]);

			DrawTexture2DViewer (texture2DValue, texture2D_viewRect);
		}

		void DrawTexture2DViwersForBlend ()
		{
			float [] viewerHeights = Texture2DViewerTargetHeight ();

			Rect texture2D_1_viewRect = new Rect (
				rect.x + rect.width*1.05f, 
				rect.y + rect.height - viewerHeights [1] - Skins.logicNodeRectStep.y,
				viewerHeights [1], 
				viewerHeights [1]);

			DrawTexture2DViewer (texture2DValues [1], texture2D_1_viewRect);




			Rect texture2D_0_viewRect = new Rect (
				texture2D_1_viewRect.x, 
				texture2D_1_viewRect.y - viewerHeights [0] - viewerHeights [1],
				viewerHeights [1], 
				viewerHeights [1]);

			DrawTexture2DViewer (texture2DValues [0], texture2D_0_viewRect);



			Rect texture2D_Res_viewRect = new Rect (
				texture2D_0_viewRect.x, 
				texture2D_0_viewRect.y - viewerHeights [0] - viewerHeights [1],
				viewerHeights [1], 
				viewerHeights [1]);

			DrawTexture2DViewer (texture2DValue, texture2D_Res_viewRect);
		}




		void DrawCompleteOrPArtOfTextureEnum ()
		{
			compeleOrPartOfTexture = (CompeleOrPartOfTexture)EditorGUI.EnumPopup (
				GetSuitableRect (FieldDrawType.nodeName), compeleOrPartOfTexture);
		}

		void DrawChannelsEnum (ChannelEnumForWhat channelEnumForWhat)
		{
			switch (channelEnumForWhat)
			{
			case ChannelEnumForWhat.ComputeNormal:
				DrawLabelField (FieldDrawType.label, "Compute Using Channel", Skins.logicNodeLabel);
				break;

			case ChannelEnumForWhat.Extract:
				DrawLabelField (FieldDrawType.label, "Channel", Skins.logicNodeLabel);
				break;

			case ChannelEnumForWhat.Set:
				DrawLabelField (FieldDrawType.label, "Channel", Skins.logicNodeLabel);
				break;
			}


			channel = (TextureComputer.ComputeOn)EditorGUI.EnumPopup (
				GetSuitableRect(FieldDrawType.variable), channel);
		}

		void DrawChannelsEnum (string label, int valueChannelID)
		{
			DrawLabelField (FieldDrawType.label, label, Skins.logicNodeLabel);


			if (valueChannelID == -1)
			{
				channel = (TextureComputer.ComputeOn)EditorGUI.EnumPopup (
					GetSuitableRect(FieldDrawType.variable), channel);
			}
			else
			{
				channels [valueChannelID] = (TextureComputer.ComputeOn)EditorGUI.EnumPopup (
					GetSuitableRect(FieldDrawType.variable), channels [valueChannelID]);
			}
		}

		public int channel_length = 0;
		public string channel_last;

		void DrawChannelsEnum (string label, int valueChannelID, 
			int lineFractions, int labelInLine, int enumInLine)
		{
			DrawLogicNodeLabel (label, labelInLine, lineFractions);



			if (valueChannelID == -1)
			{
				channel = (TextureComputer.ComputeOn)DrawEnum (channel,
					ref channel_length, ref channel_last, typeof(TextureComputer.ComputeOn), FieldDrawType.label,
					enumInLine, lineFractions);
			}
			else
			{
				channels [valueChannelID] = (TextureComputer.ComputeOn)DrawEnum (channels [valueChannelID], 
					FieldDrawType.label,
					enumInLine, lineFractions);
			}
		}
		public int extractResultType_length = 0;
		public string extractResultType_last;
		void DrawExtractResultTypeEnum ()
		{
			
			extractResultType = (TextureComputer.ExtractResultType)DrawEnum (
				extractResultType,
				ref extractResultType_length,
				ref extractResultType_last, typeof (TextureComputer.ExtractResultType),
				"Extract Result Type", Skins.logicNodeLabel);
		}

		void DrawSwitchColorsTypeEnum ()
		{
			DrawLabelField (FieldDrawType.label, "Switch Colors Type", Skins.logicNodeLabel);

			switchColorsType = (TextureComputer.SwitchColorsType)EditorGUI.EnumPopup (
				GetSuitableRect(FieldDrawType.variable), switchColorsType);
		}

		void DrawInputsFor_ComputeTexture2DType_SwitchColorsType ()
		{
			DrawSwitchColorsTypeEnum ();

			DrawInNodeInfo (dontOfenRunTimeInfo);
		}

		void DrawNormalMapComputeIntensityEnum ()
		{
			DrawLabelField (FieldDrawType.label, "Intensity", Skins.logicNodeLabel);

			normalMapComputeIntensity = (NormalMapComputeIntensity)EditorGUI.EnumPopup (
				GetSuitableRect (FieldDrawType.variable), normalMapComputeIntensity);
		}

		void DrawInputsFor_ComputeTexture2DType_ComputeNormalMap ()
		{
			DrawChannelsEnum (ChannelEnumForWhat.ComputeNormal);

			DrawNormalMapComputeIntensityEnum ();


			DrawLabelField (FieldDrawType.label, "Flip Y", Skins.logicNodeLabel);
			DrawBoolInputField (0);

			DrawInNodeInfo (dontOfenRunTimeInfo);
		}

		float DrawSliderField (FieldDrawType fdt, string guiStyle, float v, float min, float max)
		{
			DrawInNodeInfo ("Hold 'Shift' and point mouse");

			Rect cR = GetSuitableRect (fdt);

			GUI.Box (cR, "", Skins.guiSkin.GetStyle (guiStyle));

			GUI.Box (new Rect (cR.x + cR.width*(v-min)/(max-min) - 4f, cR.y, 8f, cR.height+4f),
				"", Skins.guiSkin.GetStyle (Skins.view));

			if (min > max)
			{
				float tmp = min;

				min = max;

				max = tmp;
			}

			v = Mathf.Clamp (v, min, max);

			if (eGlobal.shift)
			{
				if (cR.Contains (eGlobal.mousePosition))
				{
					float normX = (eGlobal.mousePosition.x - cR.x) / (cR.width==0f?1f:cR.width);

					v = min + normX * (max - min);
				}
			}

			return v;
		}

		void SetWithChannelEnum (TextureComputer.ComputeOn channelToUse, ref string inp, 
			string alpha, 
			string blue,
			string green,
			string hue,
			string red,
			string saturation,
			string value)
		{
			switch (channelToUse)
			{
			case TextureComputer.ComputeOn.alpha:
				inp = alpha;
				break;

			case TextureComputer.ComputeOn.blue:
				inp = blue;
				break;

			case TextureComputer.ComputeOn.green:
				inp = green;
				break;

			case TextureComputer.ComputeOn.hue:
				inp = hue;
				break;

			case TextureComputer.ComputeOn.red:
				inp = red;
				break;

			case TextureComputer.ComputeOn.saturation:
				inp = saturation;
				break;

			case TextureComputer.ComputeOn.value:
				inp = value;
				break;
			}
		}

		void SetWithChannelEnum (ref string inp, 
			string alpha, 
			string blue,
			string green,
			string hue,
			string red,
			string saturation,
			string value)
		{
			switch (channel)
			{
			case TextureComputer.ComputeOn.alpha:
				inp = alpha;
				break;

			case TextureComputer.ComputeOn.blue:
				inp = blue;
				break;

			case TextureComputer.ComputeOn.green:
				inp = green;
				break;

			case TextureComputer.ComputeOn.hue:
				inp = hue;
				break;

			case TextureComputer.ComputeOn.red:
				inp = red;
				break;

			case TextureComputer.ComputeOn.saturation:
				inp = saturation;
				break;

			case TextureComputer.ComputeOn.value:
				inp = value;
				break;
			}
		}
		void SetWithChannelEnumTemplate (ref object inp, 
			object alpha, 
			object blue,
			object green,
			object hue,
			object red,
			object saturation,
			object value)
		{
			switch (channel)
			{
			case TextureComputer.ComputeOn.alpha:
				break;

			case TextureComputer.ComputeOn.blue:
				break;

			case TextureComputer.ComputeOn.green:
				break;

			case TextureComputer.ComputeOn.hue:
				break;

			case TextureComputer.ComputeOn.red:
				break;

			case TextureComputer.ComputeOn.saturation:
				break;

			case TextureComputer.ComputeOn.value:
				break;
			}
		}


		void DrawInputsFor_ComputeTexture2DType_SetChannelsComingFromTexture ()
		{
			DrawChannelsEnum (ChannelEnumForWhat.Set);

			DrawLabelField (FieldDrawType.label, "Coming From This Texture", Skins.logicNodeLabel);
			DrawTexture2DFieldInput (1);

			DrawInNodeInfo (dontOfenRunTimeInfo);
		}

		void DrawInputsFor_ComputeTexture2DType_SetChannels ()
		{
			DrawChannelsEnum (ChannelEnumForWhat.Set);

			DrawIntInputField (0);

			//intValues [0] = Mathf.Clamp (intValues [0], 0, 255);

			string skinToUse = Skins.hueBar;

			SetWithChannelEnum (ref skinToUse, Skins.GrayScaleBar, Skins.BlueBar, Skins.GreenBar, Skins.hueBar,
				Skins.RedBar, Skins.GrayScaleBar, Skins.GrayScaleBar);

			intValues [0] = Mathf.CeilToInt (
				DrawSliderField (FieldDrawType.variable, skinToUse, (float)intValues [0], 0f, 255f));

			DrawInNodeInfo (dontOfenRunTimeInfo);
		}

		void DrawInputsFor_ComputeTexture2DType_SetChannelFromAnother (string label,
			int valueChannelID)
		{
			DrawChannelsEnum (label, valueChannelID);

			DrawIntInputField (valueChannelID);

			string skinToUse = Skins.hueBar;

			SetWithChannelEnum (channels [valueChannelID], ref skinToUse, Skins.GrayScaleBar, Skins.BlueBar, Skins.GreenBar, Skins.hueBar,
				Skins.RedBar, Skins.GrayScaleBar, Skins.GrayScaleBar);

			intValues [valueChannelID] = Mathf.CeilToInt (
				DrawSliderField (FieldDrawType.variable, skinToUse, (float)intValues [valueChannelID], 0f, 255f));
		}

		void DrawInputsFor_ComputeTexture2DType_ExtractChannels ()
		{
			DrawChannelsEnum (ChannelEnumForWhat.Extract);

			DrawExtractResultTypeEnum ();

			DrawInNodeInfo (dontOfenRunTimeInfo);
		}

		void DrawInputsFor_AuthorANewUniColorTexture ()
		{
			DrawColorInputField (0);

			DrawLabelField (FieldDrawType.label, "Width and Height", Skins.logicNodeLabel);

			DrawVector2InputField (0);

			vector2Values [0] = Vector2.Max (Vector2.one*(float)TextureComputer.minTextureSize, vector2Values [0]);
		}
		public int mirrorTexture2D_Direction_length = 0;
		public string mirrorTexture2D_Direction_last;
		void DrawMirrorTexture2D_DirectionEnum ()
		{		
				

			mirrorTexture2D_Direction = (TextureComputer.MirrorTexture2D_Direction)DrawEnum (
				mirrorTexture2D_Direction,
				ref mirrorTexture2D_Direction_length, ref mirrorTexture2D_Direction_last,
				typeof(TextureComputer.MirrorTexture2D_Direction), "Mirror Direction", Skins.logicNodeLabel);

		}

		void DrawMessageBoxUpLeftToPutAdvacedReadableTextures (string [] additionalInfo)
		{
			string [] message = new string[]
			{
				"If input Textures come from an Asset File:\n",
				"1. In The Inspector, put Textures Type To Advanced, \n",
				"2. Turn on the checkbox 'Read/Write Enabled'\n",
				"3. Don't forget to click apply in texture inspector.\n",
			};

			List <string> additional = new List<string> ();

			for (int i = 0; i < message.Length; i++)
				additional.Add (message [i]);

			for (int i = 0; i < additionalInfo.Length; i++)
				additional.Add (additionalInfo [i]);

			DrawMessageBoxUpLeft (additional.ToArray ());
		}

		void DrawMessageBoxUpLeftToPutAdvacedReadableTextures ()
		{
			string [] message = new string[]
			{
				"If input Textures come from an Asset File:\n",
				"1. In The Inspector, put Textures Type To Advanced, \n",
				"2. Turn on the checkbox 'Read/Write Enabled'\n",
				"3. Don't forget to click apply in texture inspector.\n",
			};

			DrawMessageBoxUpLeft (message);
		}

		void DrawInputsForShaderSetMaximumLOD ()
		{
			DrawIntInputField (0);

			intValues[0] = Mathf.Max (intValues [0], -1);
		}


		void DrawShadersGetGlobalPropertieModeEnum ()
		{
			shadersGetGlobalPropertieMode = (ShadersGetGlobalPropertieMode)EditorGUI.EnumPopup
				(GetSuitableRect (FieldDrawType.variable), shadersGetGlobalPropertieMode);

			switch (shadersGetGlobalPropertieMode)
			{
			case ShadersGetGlobalPropertieMode.byName:
				DrawLabelField (FieldDrawType.label, "Property Name", Skins.logicNodeLabel);

				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ShadersGetGlobalPropertieMode.byNameID:
				DrawLabelField (FieldDrawType.label, "Name ID", Skins.logicNodeLabel);

				DrawIntInputField (0);
				break;
			}
		}

		public int colorBlendMode_length = 0;
		public string colorBlendMode_last;
		void DrawColorBlendModeEnum ()
		{
			

			colorBlendMode = (ColorBlendMode)DrawEnum (colorBlendMode,
				ref colorBlendMode_length, ref colorBlendMode_last, typeof(ColorBlendMode),
				"Blend Mode", Skins.logicNodeLabel);
		}

		void DrawComputeColorTypeEnum ()
		{
			

			computeColorType = (ComputeColorType)DrawEnum (computeColorType,
				ref computeColorType_length, ref computeColorType_last, typeof(ComputeColorType),
				"Blend Mode", Skins.logicNodeLabel);
		}

		//void DrawColorField (int valueID)
		//{
		//	switch (computeColorType)
		//	{
		//	case ComputeColorType.randomHsv:
		//		DrawColorInputField (valueID, true, 1f);
		//		break;
		//
		//	case ComputeColorType.add:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.color:
		//		DrawColorInputField (valueID, false, 1f);	
		//		break;
		//
		//	case ComputeColorType.colorBurn:
		//		DrawColorInputField (valueID, false, 1f);	
		//		break;
		//
		//	case ComputeColorType.colorDodge:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.darken:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.difference:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.exclusion:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.hardLight:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.hardMix:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.hue:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.lighten:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.linearBurn:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.linearDodge:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.linearLight:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.luminosity:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.multiply:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.overlay:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.pinLight:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.saturation:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.screen:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.softLight:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.subtract:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//
		//	case ComputeColorType.vividLight:
		//		DrawColorInputField (valueID, false, 1f);
		//		break;
		//	}
		//
		//}


		void DrawParticleSystemSimulationSpaceEnum ()
		{
			DrawLabelField (FieldDrawType.label, "Space", Skins.logicNodeLabel);

			particleSystemSimulationSpace = (ParticleSystemSimulationSpace)EditorGUI.EnumPopup (
				GetSuitableRect (FieldDrawType.variable), particleSystemSimulationSpace);
		}


		Rect DrawDoItInputField ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label);

			DrawInputOutput (true, suitRect.center, Enums.doIt_ID);

			return suitRect;
		}

		void DrawLabelField (FieldDrawType fieldDrawType, string text, string guiSkinStyle)
		{
			if (guiSkinStyle == Skins.logicNodeLabel)
			if (zoom < ZoomShowLimit (0.7f))
				return;

			Rect suitRect = GetSuitableRect (fieldDrawType, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			EditorGUI.LabelField (suitRect, text, Skins.guiSkin.GetStyle (guiSkinStyle));
		}


		void DrawStringResultField (bool isLabel, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				if (isLabel)
				{
					EditorGUI.LabelField (suitRect, stringValue, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					stringValue = EditorGUI.TextField (suitRect, stringValue);
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.stringValue_ID);
		}

		void DrawStringResultField (bool isLabel)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				if (isLabel)
				{
					EditorGUI.LabelField (suitRect, stringValue, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					stringValue = EditorGUI.TextField (suitRect, stringValue);
				}
			}

			DrawInputOutput (false, suitRect.center, Enums.stringValue_ID);
		}

		void DrawStringResultField (string inOutID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, column, totalColumns);

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.touch_phase_ID:
					EditorGUI.LabelField (suitRect, touch_phase.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_type_ID:
					EditorGUI.LabelField (suitRect, touch_type.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), inOutID);
		}

		void DrawStringResultField (string inOutID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.touch_phase_ID:
					EditorGUI.LabelField (suitRect, touch_phase.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_type_ID:
					EditorGUI.LabelField (suitRect, touch_type.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, suitRect.center, inOutID);
		}

		enum stringInputFieldForWhat
		{
			general,

			scriptName,

			fileName,
		}

		Vector2 InOutGatePreCenter (Rect suitRect)
		{
			return new Vector2 (rect.center.x, suitRect.position.y + suitRect.height*0.5f);
		}

		void DrawStringInputField (int valueID, stringInputFieldForWhat forWhat, int column, int totalColumns)
		{
			//Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//	new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.stringValues_0_ID: Enums.stringValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			//DrawInputOutput (true, suitRect.center, inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					stringValues [valueID] = EditorGUI.TextField (suitRect, stringValues [valueID]);

					switch (forWhat)
					{
					case stringInputFieldForWhat.fileName:
						stringValues [valueID] = StringTreatment.FileName (stringValues [valueID]);
						break;

					case stringInputFieldForWhat.general:
						break;

					case stringInputFieldForWhat.scriptName:
						stringValues [valueID] = StringTreatment.ScriptName (stringValues [valueID]);
						break;
					}
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
		void DrawStringInputField (int valueID, stringInputFieldForWhat forWhat)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			string inOutID = valueID == 0? Enums.stringValues_0_ID: Enums.stringValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					stringValues [valueID] = EditorGUI.TextField (suitRect, stringValues [valueID]);

					switch (forWhat)
					{
					case stringInputFieldForWhat.fileName:
						stringValues [valueID] = StringTreatment.FileName (stringValues [valueID]);
						break;

					case stringInputFieldForWhat.general:
						break;

					case stringInputFieldForWhat.scriptName:
						stringValues [valueID] = StringTreatment.ScriptName (stringValues [valueID]);
						break;
					}
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}


		void DrawBoundsResultField ()
		{
			DrawLogicNodeLabel ("Center", 0, 2);
			DrawVector3ResultField (Enums.boundsCenterValue_ID, 1, 2);


			DrawLogicNodeLabel ("Extents", 0, 2);
			DrawVector3ResultField (Enums.boundsExtentsValue_ID, 1, 2);


			DrawLogicNodeLabel ("Max", 0, 2);
			DrawVector3ResultField (Enums.boundsMaxValue_ID, 1, 2);


			DrawLogicNodeLabel ("Min", 0, 2);
			DrawVector3ResultField (Enums.boundsMinValue_ID, 1, 2);


			DrawLogicNodeLabel ("Size", 0, 2);
			DrawVector3ResultField (Enums.boundsSizeValue_ID, 1, 2);
		}


		void DrawVector4InputField (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.vector4Values_0_ID: Enums.vector4Values_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);



			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					vector4Values [valueID] = EditorGUI.Vector4Field (
						suitRect, "", vector4Values [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}


		void DrawVector3InputField (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID =  valueID == 0? Enums.vector3Values_0_ID: Enums.vector3Values_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					vector3Values [valueID] = EditorGUI.Vector3Field (suitRect, "", vector3Values [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
		void DrawVector3InputField (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			string inOutID =  valueID == 0? Enums.vector3Values_0_ID: Enums.vector3Values_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					vector3Values [valueID] = EditorGUI.Vector3Field (suitRect, "", vector3Values [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}



		void DrawVector4ResultField (bool isLabel, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (isLabel)
			{		
				if (maximized)
					EditorGUI.LabelField (suitRect, 
						vector4Value.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
			}
			else		
			{
				if (maximized)
					vector4Value = EditorGUI.Vector4Field (suitRect, "", vector4Value);
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.vector4Value_ID);
		}


		void DrawVector4ResultField (bool isLabel)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			if (isLabel)
			{		
				if (maximized)
					EditorGUI.LabelField (suitRect, 
						vector4Value.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
			}
			else		
			{
				if (maximized)
					vector4Value = EditorGUI.Vector4Field (suitRect, "", vector4Value);
			}

			DrawInputOutput (false, suitRect.center,	Enums.vector4Value_ID);
		}


		void DrawVector3ResultField (string inOutID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.boundsCenterValue_ID:
					EditorGUI.LabelField (suitRect, boundsCenterValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.boundsExtentsValue_ID:
					EditorGUI.LabelField (suitRect, boundsExtentsValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.boundsMaxValue_ID:
					EditorGUI.LabelField (suitRect, boundsMaxValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.boundsMinValue_ID:
					EditorGUI.LabelField (suitRect, boundsMinValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.boundsSizeValue_ID:
					EditorGUI.LabelField (suitRect, boundsSizeValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;


				case Enums.raycastHitBarycentricCoordinate_ID:
					EditorGUI.LabelField (
						suitRect, raycastHitBarycentricCoordinate.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.raycastHitPoint_ID:
					EditorGUI.LabelField (suitRect, raycastHitPoint.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.raycastHitNormal_ID:
					EditorGUI.LabelField (suitRect, raycastHitNormal.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;


				case Enums.OffMeshLinkData_endPosition_ID:
					EditorGUI.LabelField (suitRect, OffMeshLinkData_endPosition.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.OffMeshLinkData_startPosition_ID:
					EditorGUI.LabelField (suitRect, OffMeshLinkData_startPosition.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;


					//
				case Enums.NavMeshHit_position_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_position.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.NavMeshHit_normal_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_normal.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), inOutID);
		}
		void DrawVector3ResultField (string inOutID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.boundsCenterValue_ID:
					EditorGUI.LabelField (suitRect, boundsCenterValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.boundsExtentsValue_ID:
					EditorGUI.LabelField (suitRect, boundsExtentsValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.boundsMaxValue_ID:
					EditorGUI.LabelField (suitRect, boundsMaxValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.boundsMinValue_ID:
					EditorGUI.LabelField (suitRect, boundsMinValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.boundsSizeValue_ID:
					EditorGUI.LabelField (suitRect, boundsSizeValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;


				case Enums.raycastHitBarycentricCoordinate_ID:
					EditorGUI.LabelField (
						suitRect, raycastHitBarycentricCoordinate.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.raycastHitPoint_ID:
					EditorGUI.LabelField (suitRect, raycastHitPoint.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.raycastHitNormal_ID:
					EditorGUI.LabelField (suitRect, raycastHitNormal.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;


				case Enums.OffMeshLinkData_endPosition_ID:
					EditorGUI.LabelField (suitRect, OffMeshLinkData_endPosition.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.OffMeshLinkData_startPosition_ID:
					EditorGUI.LabelField (suitRect, OffMeshLinkData_startPosition.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;


					//
				case Enums.NavMeshHit_position_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_position.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.NavMeshHit_normal_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_normal.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, suitRect.center, inOutID);
		}

		void DrawVector3ResultField (bool isLabel, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				if (isLabel)
					EditorGUI.LabelField (suitRect, vector3Value.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				else
					vector3Value = EditorGUI.Vector3Field (suitRect, "", vector3Value);
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.vector3Value_ID);
		}
		void DrawVector3ResultField (bool isLabel)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			if (maximized)
			{
				if (isLabel)
					EditorGUI.LabelField (suitRect, vector3Value.ToString (), 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				else
					vector3Value = EditorGUI.Vector3Field (suitRect, "", vector3Value);
			}

			DrawInputOutput (false, suitRect.center, Enums.vector3Value_ID);
		}

		void DrawVector2InputField (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.vector2Values_0_ID: Enums.vector2Values_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					vector2Values [valueID] = EditorGUI.Vector2Field (suitRect, "", vector2Values [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
		void DrawVector2InputField (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			string inOutID = valueID == 0? Enums.vector2Values_0_ID: Enums.vector2Values_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					vector2Values [valueID] = EditorGUI.Vector2Field (suitRect, "", vector2Values [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}


		void DrawVector2ResultField (bool isLabel, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (isLabel)
			{
				if (maximized)
					EditorGUI.LabelField (suitRect, vector2Value.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
			}
			else
			{
				vector2Value = EditorGUI.Vector2Field (suitRect, "", vector2Value);
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.vector2Value_ID);
		}

		void DrawVector2ResultField (bool isLabel)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (isLabel)
			{
				if (maximized)
					EditorGUI.LabelField (suitRect, vector2Value.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
			}
			else
			{
				vector2Value = EditorGUI.Vector2Field (suitRect, "", vector2Value);
			}

			DrawInputOutput (false, suitRect.center, Enums.vector2Value_ID);
		}

		void DrawVector2ResultField (string inOutID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.touch_deltaPosition_ID:
					EditorGUI.LabelField (suitRect, touch_deltaPosition.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_position_ID:
					EditorGUI.LabelField (suitRect, touch_position.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_rawPosition_ID:
					EditorGUI.LabelField (suitRect, touch_rawPosition.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;





				case Enums.hit2D_centroid_ID:
					EditorGUI.LabelField (suitRect, hit2D_centroid.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.hit2D_normal_ID:
					EditorGUI.LabelField (suitRect, hit2D_normal.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.hit2D_point_ID:
					EditorGUI.LabelField (suitRect, hit2D_point.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;



				case Enums.raycastHitLightmapCoord_ID:
					EditorGUI.LabelField (suitRect, raycastHitLightmapCoord.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.raycastHitTextureCoord_ID:
					EditorGUI.LabelField (suitRect, raycastHittextureCoord.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.raycastHitTextureCoord2_ID:
					EditorGUI.LabelField (suitRect, raycastHittextureCoord2.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), inOutID);
		}

		void DrawVector2ResultField (string inOutID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.touch_deltaPosition_ID:
					EditorGUI.LabelField (suitRect, touch_deltaPosition.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_position_ID:
					EditorGUI.LabelField (suitRect, touch_position.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_rawPosition_ID:
					EditorGUI.LabelField (suitRect, touch_rawPosition.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;





				case Enums.hit2D_centroid_ID:
					EditorGUI.LabelField (suitRect, hit2D_centroid.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.hit2D_normal_ID:
					EditorGUI.LabelField (suitRect, hit2D_normal.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.hit2D_point_ID:
					EditorGUI.LabelField (suitRect, hit2D_point.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;



				case Enums.raycastHitLightmapCoord_ID:
					EditorGUI.LabelField (suitRect, raycastHitLightmapCoord.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.raycastHitTextureCoord_ID:
					EditorGUI.LabelField (suitRect, raycastHittextureCoord.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.raycastHitTextureCoord2_ID:
					EditorGUI.LabelField (suitRect, raycastHittextureCoord2.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, suitRect.center, inOutID);
		}




		Enum DrawEnum (Enum selected, string label, string labelStyle)
		{
			if ( ! string.IsNullOrEmpty (label))
				DrawLabelField (FieldDrawType.label, label, labelStyle);
			
			return EditorGUI.EnumPopup (GetSuitableRect (FieldDrawType.variable), selected);
		}
		Enum DrawEnum (Enum selected, FieldDrawType fieldDrawType, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (fieldDrawType, column, totalColumns);
		
			Enum r = EditorGUI.EnumPopup (suitRect, selected);
		
			if (suitRect.Contains (eGlobal.mousePosition))
				DrawFloatingMessage (
					new Rect (eGlobal.mousePosition + new Vector2 (15f, -10f), Vector2.one), 
					selected.ToString ());
		
			return r;
		}


		void DrawTagField (int inputIndex)
		{
			stringValues [inputIndex] = EditorGUI.TagField (GetSuitableRect (FieldDrawType.variable),
				stringValues [inputIndex]);
		}
		void DrawTagField (int inputIndex, int column, int totalColumns)
		{
			stringValues [inputIndex] = EditorGUI.TagField (GetSuitableRect (FieldDrawType.label, 
				column, totalColumns), stringValues [inputIndex]);
		}

		void DrawGoToStateInputs ()
		{
			DrawBoolInputField (0);

			DrawInNodeInfo ("To see All states: SAVE graph");

			DrawLogicNodeLabel ("State To Go To", 0, 2);


			//Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			oldStateDestination = currentStateNames;

			//currentStateNames = (CurrentStatesNames)EditorGUI.EnumPopup (suitRect, currentStateNames);

			currentStateNames = (CurrentStatesNames)DrawEnum (currentStateNames, FieldDrawType.label, 1, 2);
		}


		public int keyCode_length = 0;
		public string keyCode_last;
		void DrawKeyCodeEnum ()
		{
			if ( ! maximized)
				return;

			DrawLogicNodeLabel ("Key", 0, 2);


			keyCode = (KeyCode)DrawEnum (keyCode,
				ref keyCode_length,
				ref keyCode_last, typeof(KeyCode), FieldDrawType.label, 1, 2);

			//GUI.Label (GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//	new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), 
			//	"Key", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));
			//
			//keyCode = (KeyCode)EditorGUI.EnumPopup (
			//	GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//	new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)),
			//	keyCode);
		}

		void DrawAxisNameEnum ()
		{
			if ( ! maximized)
				return;


			GUI.Label (GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), 
				"Axe Name", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));

			axeName = (AxeName)EditorGUI.EnumPopup (GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)),
				axeName);

		}

		void DrawKeyAndMouseTriggerWhenEnum ()
		{
			if (keyCode == KeyCode.Mouse0 ||
				keyCode == KeyCode.Mouse1 ||
				keyCode == KeyCode.Mouse2 ||
				keyCode == KeyCode.Mouse3 ||
				keyCode == KeyCode.Mouse4 ||
				keyCode == KeyCode.Mouse5 ||
				keyCode == KeyCode.Mouse6)
			{
				DrawMouseInputTriggerWhenEnum ();
			}
			else
			{
				DrawKeyCodeTriggerWhenEnum ();
			}
		}
		public int keyCodeTriggerWhen_length = 0;
		public string keyCodeTriggerWhen_last;
		void DrawKeyCodeTriggerWhenEnum ()
		{
			if ( ! maximized)
				return;
			
			DrawLogicNodeLabel ("Trigger When", 0, 2);



			keyCodeTriggerWhen = (KeyCodeTriggerWhen)DrawEnum (keyCodeTriggerWhen,
				ref keyCodeTriggerWhen_length, ref keyCodeTriggerWhen_last, typeof(KeyCodeTriggerWhen),
				FieldDrawType.label, 1, 2);

			//GUI.Label (GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//	new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), 
			//	"Trigger When", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));
			//
			//keyCodeTriggerWhen = (KeyCodeTriggerWhen)EditorGUI.EnumPopup (
			//	GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//		new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)),
			//	keyCodeTriggerWhen);
		}

		public int mouseInputTriggerWhen_length = 0;
		public string mouseInputTriggerWhen_last;
		void DrawMouseInputTriggerWhenEnum ()
		{
			if ( ! maximized)
				return;

			DrawLogicNodeLabel ("Trigger When", 0, 2);



			mouseInputTriggerWhen = (MouseInputTriggerWhen)DrawEnum (mouseInputTriggerWhen,
				ref mouseInputTriggerWhen_length, ref mouseInputTriggerWhen_last, typeof(MouseInputTriggerWhen),
				FieldDrawType.label, 1, 2);

			//GUI.Label (GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//	new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), 
			//	"Trigger When", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));
			//
			//mouseInputTriggerWhen = (MouseInputTriggerWhen)EditorGUI.EnumPopup (
			//	GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//		new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), 
			//	mouseInputTriggerWhen);
		}



		//void Draw2ColorFields ()
		//{			
		//	DrawColorField (0);
		//
		//	DrawColorField (1);
		//}

		void DrawColorInputField (int valueID, bool opacityIsLabel, float fixedOpacity)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));


			string inOutID = valueID == 0? Enums.colorValues_0_ID: Enums.colorValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if ( ! publicInputs [varIndex])
			{
				DrawColorVariableForCompute (valueID, suitRect, opacityIsLabel, fixedOpacity);
			}
			else if (publicInputs [varIndex])
			{
				DrawPublicInputFieldLabel (varIndex, suitRect);
			}




			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawColorInputField (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);


			string inOutID = valueID == 0? Enums.colorValues_0_ID: Enums.colorValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);


			if ( ! publicInputs [varIndex])
			{
				colorValues [valueID] = EditorGUI.ColorField (suitRect, colorValues [valueID]);
			}
			else if (publicInputs [varIndex])
			{
				DrawPublicInputFieldLabel (varIndex, suitRect);
			}




			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
		void DrawColorInputField (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));


			string inOutID = valueID == 0? Enums.colorValues_0_ID: Enums.colorValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);


			if ( ! publicInputs [varIndex])
			{
				colorValues [valueID] = EditorGUI.ColorField (suitRect, colorValues [valueID]);
			}
			else if (publicInputs [varIndex])
			{
				DrawPublicInputFieldLabel (varIndex, suitRect);
			}




			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
		void DrawColorVariableForCompute (int valueID, Rect fieldRect, bool opacityIsLabel, float fixedOpacity)
		{
			if ( ! opacityIsLabel)
			{
				if (valueID == 0)
				{

					DrawColorVariableForCompute ("Foreground", valueID, fieldRect, opacityIsLabel, fixedOpacity);
				}
				else
				{
					DrawColorVariableForCompute ("Background", valueID, fieldRect, opacityIsLabel, fixedOpacity);
				}
			}
			else if (opacityIsLabel)
			{
				if (valueID == 0)
				{

					DrawColorVariableForCompute ("Min", valueID, fieldRect, opacityIsLabel, fixedOpacity);
				}
				else
				{
					DrawColorVariableForCompute ("Max", valueID, fieldRect, opacityIsLabel, fixedOpacity);
				}
			}
		}
		void DrawColorVariableForCompute (string label, int valueID, Rect fieldRect, bool opacityIsLabel, float fixedOpacity)
		{
			Rect fieldRectLocal = new Rect ();

			float lastHorizontalLocal = 0f;



			fieldRectLocal = new Rect ( lastHorizontalLocal + fieldRect.x, fieldRect.y, 0.30f * fieldRect.width, fieldRect.height);

			lastHorizontalLocal = fieldRectLocal.x + fieldRectLocal.width;

			if (maximized)
				EditorGUI.LabelField (fieldRectLocal, label, Skins.guiSkin.GetStyle (Skins.logicNodeLabel));


			fieldRectLocal = new Rect ( lastHorizontalLocal, fieldRect.y, 0.25f * fieldRect.width, fieldRect.height);

			lastHorizontalLocal = fieldRectLocal.x + fieldRectLocal.width;

			if (maximized)
				colorValues [valueID] = EditorGUI.ColorField (fieldRectLocal, colorValues [valueID]);


			fieldRectLocal = new Rect ( lastHorizontalLocal, fieldRect.y, 0.25f * fieldRect.width, fieldRect.height);

			lastHorizontalLocal = fieldRectLocal.x + fieldRectLocal.width;

			if (maximized)
				EditorGUI.LabelField (fieldRectLocal, "Opacity", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));


			fieldRectLocal = new Rect ( lastHorizontalLocal, fieldRect.y, 0.20f * fieldRect.width, fieldRect.height);

			lastHorizontalLocal = fieldRectLocal.x + fieldRectLocal.width;

			if (maximized)
			if ( ! opacityIsLabel)
			{
				if ( ! (floatValues [valueID] >= 0f && floatValues [valueID] <= 1f))
					floatValues [valueID] = 1f;

				floatValues [valueID] = EditorGUI.FloatField (fieldRectLocal, floatValues [valueID]);

				//floatValues [valueID] = Mathf.Clamp (floatValues [valueID], 0f, 1f);
			}
			else if (opacityIsLabel)
			{
				fixedOpacity = Mathf.Clamp (fixedOpacity, 0f, 1f);

				EditorGUI.LabelField (fieldRectLocal, fixedOpacity.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeLabel));
			}
		}

		void DrawColorResultField (int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
				colorValue = EditorGUI.ColorField (suitRect, colorValue);

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.colorValue_ID);
		}
		void DrawColorResultField ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
				colorValue = EditorGUI.ColorField (suitRect, colorValue);

			DrawInputOutput (false, suitRect.center, Enums.colorValue_ID);
		}

		void DrawRectInputField (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = (valueID == 0)? Enums.rectValues_0_ID: Enums.rectValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if (! publicInputs [varIndex])
				{
					rectValues [valueID] = EditorGUI.RectField (suitRect, rectValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;

			suitRect = GetSuitableRect (FieldDrawType.variable);
		}

		void DrawRectInputField (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = (valueID == 0)? Enums.rectValues_0_ID: Enums.rectValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if (! publicInputs [varIndex])
				{
					rectValues [valueID] = EditorGUI.RectField (suitRect, rectValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;

			suitRect = GetSuitableRect (FieldDrawType.variable);
		}

		void DrawDoubleInputField ()
		{
			doubleValue = EditorGUI.DoubleField (GetSuitableRect (FieldDrawType.variable), doubleValue);
		}

		void DrawFloatInputField (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = (valueID == 0)? Enums.floatValues_0_ID: 
				(valueID == 1)? Enums.floatValues_1_ID: 
				(valueID == 2)? Enums.floatValues_2_ID: "";

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					floatValues [valueID] = EditorGUI.FloatField (suitRect, floatValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}



			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
		void DrawFloatInputField (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = (valueID == 0)? Enums.floatValues_0_ID: 
				(valueID == 1)? Enums.floatValues_1_ID: 
				(valueID == 2)? Enums.floatValues_2_ID: "";

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					floatValues [valueID] = EditorGUI.FloatField (suitRect, floatValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}



			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}


		void DrawM44EntierInputField (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, 
				new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			string inOutID = (valueID == 0)? Enums.m44Value_Input_0_entier_ID: Enums.m44Value_Input_1_entier_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, m44enierValueLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
		void DrawM44EntierInputField (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = (valueID == 0)? Enums.m44Value_Input_0_entier_ID: Enums.m44Value_Input_1_entier_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, m44enierValueLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}


		void DrawM44EntierResultField ()
		{		
			DrawLabelFields (new string[] {m44enierLabel,});

			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				EditorGUI.LabelField (suitRect, m44enierValueLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
			}

			DrawInputOutput (false, suitRect.center, Enums.m44Value_entier_ID); 
		}

		void DrawM44ResultField ()
		{
			DrawM44EntierResultField ();



			DrawLabelField (FieldDrawType.label, "Determinant", Skins.logicNodeLabel);

			DrawFloatResultField (Enums.m44ValueDeterminant_ID);


			DrawLabelField (FieldDrawType.label, "Is Identity", Skins.logicNodeLabel);

			DrawBoolResultField (Enums.m44ValueIsIdentity_ID);


			DrawLabelField (FieldDrawType.label, "Invertible", Skins.logicNodeLabel);

			DrawBoolResultField (Enums.m44ValueInvertible_ID);



			string l = "";

			string ioid = "";

			for (int i = 0; i < 16; i++)
			{
				l = "E " + (i/4).ToString () + (i%4).ToString ();

				ioid = "m44Value_" + i.ToString ();

				DrawLogicNodeLabel (l);


				Rect suitRect = GetSuitableRect (FieldDrawType.variable);

				EditorGUI.LabelField (suitRect, m44Value [i].ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));

				DrawInputOutput (false, suitRect.center, ioid);
			}
		}
		void DrawM44ResultField (bool _2Colums)
		{
			DrawM44EntierResultField ();


			DrawLogicNodeLabel ("Determinant", 0, 2);
			DrawFloatResultField (Enums.m44ValueDeterminant_ID, 1, 2);


			DrawLogicNodeLabel ("Is Identity", 0, 2);
			DrawBoolResultField (Enums.m44ValueIsIdentity_ID, 1, 2);


			DrawLogicNodeLabel ("Invertible", 0, 2);
			DrawBoolResultField (Enums.m44ValueInvertible_ID, 1, 2);



			string l = "";

			string ioid = "";

			for (int i = 0; i < 16; i++)
			{
				l = "E " + (i/4).ToString () + (i%4).ToString ();

				ioid = "m44Value_" + i.ToString ();

				DrawLogicNodeLabel (l, 0, 2);
				Rect suitRect = GetSuitableRect (FieldDrawType.label, 1, 2);
				EditorGUI.LabelField (suitRect, m44Value [i].ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));

				DrawInputOutput (false, InOutGatePreCenter (suitRect), ioid);
			}
		}

		void DrawM44ResultField (string [] labels)
		{
			DrawM44EntierResultField ();


			DrawLogicNodeLabel ("Determinant", 0, 2);
			DrawFloatResultField (Enums.m44ValueDeterminant_ID, 1, 2);


			DrawLogicNodeLabel ("Is Identity", 0, 2);
			DrawBoolResultField (Enums.m44ValueIsIdentity_ID, 1, 2);


			DrawLogicNodeLabel ("Invertible", 0, 2);
			DrawBoolResultField (Enums.m44ValueInvertible_ID, 1, 2);


			string l = "";

			string ioid = "";

			for (int i = 0; i < 16; i++)
			{
				l = labels [i];

				ioid = "m44Value_" + i.ToString ();

				DrawLogicNodeLabel (l, 0, 2);
				Rect suitRect = GetSuitableRect (FieldDrawType.label, 1, 2);
				EditorGUI.LabelField (suitRect, m44Value [i].ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));

				DrawInputOutput (false, InOutGatePreCenter (suitRect), ioid);
			}
		}




		void DrawFloatResultField (string inOutID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.touch_altitudeAngle_ID:
					EditorGUI.LabelField (suitRect, touch_altitudeAngle.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_azimuthAngle_ID:
					EditorGUI.LabelField (suitRect, touch_azimuthAngle.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_deltaTime_ID:
					EditorGUI.LabelField (suitRect, touch_deltaTime.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_maximumPossiblePressure_ID:
					EditorGUI.LabelField (suitRect, touch_maximumPossiblePressure.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_pressure_ID:
					EditorGUI.LabelField (suitRect, touch_pressure.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_radiusVariance_ID:
					EditorGUI.LabelField (suitRect, touch_radiusVariance.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_radius_ID:
					EditorGUI.LabelField (suitRect, touch_radius.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;




				case Enums.hit2D_distance_ID:
					EditorGUI.LabelField (suitRect, hit2D_distance.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.hit2D_fraction_ID:
					EditorGUI.LabelField (suitRect, hit2D_fraction.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;



				case Enums.raycastHitDistance_ID:
					EditorGUI.LabelField (suitRect, raycastHitDistance.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.m44ValueDeterminant_ID:
					EditorGUI.LabelField (suitRect, m44ValueDeterminant.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.NavMeshHit_distance_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_distance.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), inOutID);
		}

		void DrawFloatResultField (string inOutID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.touch_altitudeAngle_ID:
					EditorGUI.LabelField (suitRect, touch_altitudeAngle.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_azimuthAngle_ID:
					EditorGUI.LabelField (suitRect, touch_azimuthAngle.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_deltaTime_ID:
					EditorGUI.LabelField (suitRect, touch_deltaTime.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_maximumPossiblePressure_ID:
					EditorGUI.LabelField (suitRect, touch_maximumPossiblePressure.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_pressure_ID:
					EditorGUI.LabelField (suitRect, touch_pressure.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_radiusVariance_ID:
					EditorGUI.LabelField (suitRect, touch_radiusVariance.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.touch_radius_ID:
					EditorGUI.LabelField (suitRect, touch_radius.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;




				case Enums.hit2D_distance_ID:
					EditorGUI.LabelField (suitRect, hit2D_distance.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.hit2D_fraction_ID:
					EditorGUI.LabelField (suitRect, hit2D_fraction.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;



				case Enums.raycastHitDistance_ID:
					EditorGUI.LabelField (suitRect, raycastHitDistance.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.m44ValueDeterminant_ID:
					EditorGUI.LabelField (suitRect, m44ValueDeterminant.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.NavMeshHit_distance_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_distance.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, suitRect.center, inOutID);
		}

		void DrawFloatResultField (bool isLabel, int column ,int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				if (isLabel)
				{
					EditorGUI.LabelField (suitRect, floatValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					floatValue = EditorGUI.FloatField (suitRect, floatValue);
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.floatValue_ID); 
		}


		void DrawFloatResultField (bool isLabel)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				if (isLabel)
				{
					EditorGUI.LabelField (suitRect, floatValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					floatValue = EditorGUI.FloatField (suitRect, floatValue);
				}
			}

			DrawInputOutput (false, suitRect.center, Enums.floatValue_ID); 
		}

		string RectToString (Rect rect)
		{
			return "x: " + rect.x.ToString () + " y: " + rect.y.ToString () + "  " 
				+ " W: " + rect.width.ToString () + " H: " + rect.height.ToString ();
		}

		void DrawRectResultField (bool isLabel, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				if (isLabel)
				{
					EditorGUI.LabelField (suitRect, RectToString (rectValue), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					rectValue = EditorGUI.RectField (suitRect, rectValue);
					suitRect = GetSuitableRect (FieldDrawType.variable);
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.rectValue_ID); 
		}
			
		void DrawRectResultField (bool isLabel)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			if (maximized)
			{
				if (isLabel)
				{
					EditorGUI.LabelField (suitRect, RectToString (rectValue), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					rectValue = EditorGUI.RectField (suitRect, rectValue);
					suitRect = GetSuitableRect (FieldDrawType.variable);
				}
			}

			DrawInputOutput (false, suitRect.center, Enums.rectValue_ID); 
		}

		void DrawBoolResultField (string inOutID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.boolValue_ID:
					if (maximized)
						boolValue = EditorGUI.Toggle(suitRect, boolValue);
					break;

				case Enums.m44ValueIsIdentity_ID:
					EditorGUI.LabelField (suitRect, m44ValueIsIdentity? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.m44ValueInvertible_ID:
					EditorGUI.LabelField (suitRect, m44ValueInvertible? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.OffMeshLinkData_activated_ID:
					EditorGUI.LabelField (suitRect, OffMeshLinkData_activated? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.OffMeshLinkData_valid_ID:
					EditorGUI.LabelField (suitRect, OffMeshLinkData_valid? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;//


				case Enums.NavMeshHit_hit_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_hit? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), inOutID);
		}


		void DrawBoolResultField (string inOutID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));
			
			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.boolValue_ID:
					if (maximized)
						boolValue = EditorGUI.Toggle(suitRect, boolValue);
					break;

				case Enums.m44ValueIsIdentity_ID:
					EditorGUI.LabelField (suitRect, m44ValueIsIdentity? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.m44ValueInvertible_ID:
					EditorGUI.LabelField (suitRect, m44ValueInvertible? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.OffMeshLinkData_activated_ID:
					EditorGUI.LabelField (suitRect, OffMeshLinkData_activated? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;

				case Enums.OffMeshLinkData_valid_ID:
					EditorGUI.LabelField (suitRect, OffMeshLinkData_valid? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;//


				case Enums.NavMeshHit_hit_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_hit? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, suitRect.center, inOutID);
		}

		void DrawBoolResultField (int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
				EditorGUI.LabelField (suitRect, boolValue? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.boolValue_ID);
		}
		void DrawBoolResultField ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
				EditorGUI.LabelField (suitRect, boolValue? "true": "false", Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.boolValue_ID);
		}


		void DrawBoolInputField (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = (valueID == 0)? Enums.boolValues_0_ID: Enums.boolValues_1_ID;

			int varIndex = IndexOfInID (inOutID);


			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					boolValues [valueID] = EditorGUI.Toggle (
						suitRect, boolValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
		void DrawBoolInputField (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			string inOutID = (valueID == 0)? Enums.boolValues_0_ID: Enums.boolValues_1_ID;

			int varIndex = IndexOfInID (inOutID);


			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					boolValues [valueID] = EditorGUI.Toggle (
						suitRect, boolValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}



		void DrawIntResultField (string inOutID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.touch_fingerId_ID:
					EditorGUI.LabelField (suitRect, touch_fingerId.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;//

				case Enums.touch_tapCount_ID:
					EditorGUI.LabelField (suitRect, touch_tapCount.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;//



				case Enums.raycastHitTriangleIndex_ID:
					EditorGUI.LabelField (suitRect, raycastHitTriangleIndex.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;//

				case Enums.NavMeshHit_mask_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_mask.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), inOutID);
		}

		void DrawIntResultField (string inOutID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				switch (inOutID)
				{
				case Enums.touch_fingerId_ID:
					EditorGUI.LabelField (suitRect, touch_fingerId.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;//

				case Enums.touch_tapCount_ID:
					EditorGUI.LabelField (suitRect, touch_tapCount.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;//



				case Enums.raycastHitTriangleIndex_ID:
					EditorGUI.LabelField (suitRect, raycastHitTriangleIndex.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;//

				case Enums.NavMeshHit_mask_ID:
					EditorGUI.LabelField (suitRect, NavMeshHit_mask.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					break;
				}
			}

			DrawInputOutput (false, suitRect.center, inOutID);
		}

		void DrawIntResultField (bool isLable, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			//Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
			//	new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				if (isLable)
				{
					EditorGUI.LabelField (suitRect, intValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					intValue = EditorGUI.IntField (suitRect, intValue);
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.intValue_ID);
		}
		void DrawIntResultField (bool isLable)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				if (isLable)
				{
					EditorGUI.LabelField (suitRect, intValue.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					intValue = EditorGUI.IntField (suitRect, intValue);
				}
			}

			DrawInputOutput (false, suitRect.center, Enums.intValue_ID);
		}

		void DrawIntInputField (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.intValues_0_ID:
				valueID == 1? Enums.intValues_1_ID: Enums.intValues_2_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					intValues [valueID] = EditorGUI.IntField (suitRect, intValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawIntInputField (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			string inOutID = valueID == 0? Enums.intValues_0_ID:
				valueID == 1? Enums.intValues_1_ID: Enums.intValues_2_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					intValues [valueID] = EditorGUI.IntField (suitRect, intValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}


		void DrawTexture2DFieldInput (int valueID, int column, int totalColumns)
		{

			if (computeTexture2DType != ComputeTexture2DType.blendTwoTextures)
			{
				Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);


				string inOutID = 
					valueID == 0? Enums.texture2DValues_0_ID: Enums.texture2DValues_1_ID;

				int varIndex = IndexOfInID (inOutID);

				DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);


				if (maximized)
				{
					if ( ! publicInputs [varIndex])
					{
						texture2DValues [valueID] = 
							EditorGUI.ObjectField (suitRect, 
								texture2DValues [valueID], typeof (Texture2D), true) 
							as Texture2D;

						//AssignAssetID  (ref texture2DValues [valueID], ref texture2DValuesOld [valueID], ref texture2DValuesAssetsID [valueID]);
						ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
							FieldUniqueID (inOutID), texture2DValues [valueID]);
					}
					else if (publicInputs [varIndex])
					{
						DrawPublicInputFieldLabel (varIndex, suitRect);
					}
				}


				if (varIndex > -1 && varIndex < activeInputsFields.Length)
					activeInputsFields [varIndex] = true;
			}
			else 
			{
				DrawTexture2DFieldInputForBlend (valueID);
			}

			DrawObjectFieldFillingMessage();
		}

		void DrawTexture2DFieldInput (int valueID)
		{

			if (computeTexture2DType != ComputeTexture2DType.blendTwoTextures)
			{
				Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
					new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));


				string inOutID = 
					valueID == 0? Enums.texture2DValues_0_ID: Enums.texture2DValues_1_ID;

				int varIndex = IndexOfInID (inOutID);

				DrawInputOutput (true, suitRect.center, inOutID);


				if (maximized)
				{
					if ( ! publicInputs [varIndex])
					{
						texture2DValues [valueID] = 
							EditorGUI.ObjectField (suitRect, 
								texture2DValues [valueID], typeof (Texture2D), true) 
							as Texture2D;

						//AssignAssetID  (ref texture2DValues [valueID], ref texture2DValuesOld [valueID], ref texture2DValuesAssetsID [valueID]);
						ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
							FieldUniqueID (inOutID), texture2DValues [valueID]);
					}
					else if (publicInputs [varIndex])
					{
						DrawPublicInputFieldLabel (varIndex, suitRect);
					}
				}


				if (varIndex > -1 && varIndex < activeInputsFields.Length)
					activeInputsFields [varIndex] = true;
			}
			else 
			{
				DrawTexture2DFieldInputForBlend (valueID);
			}

			DrawObjectFieldFillingMessage();
		}


		void DrawTexture2DFieldInputForBlend (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));



			string inOutID = 
				valueID == 0? Enums.texture2DValues_0_ID: Enums.texture2DValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);


			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					texture2DValues [valueID] = 
						EditorGUI.ObjectField (new Rect (suitRect.x, suitRect.y, 
							suitRect.width*(2f/5f), suitRect.height), 
							texture2DValues [valueID], typeof (Texture2D), true) 
						as Texture2D;

					//AssignAssetID  (ref texture2DValues [valueID], ref texture2DValuesOld [valueID], ref texture2DValuesAssetsID [valueID]);
					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
						FieldUniqueID (inOutID), texture2DValues [valueID]);

					EditorGUI.LabelField (new Rect (suitRect.x + suitRect.width*(2f/5f), suitRect.y, 
						suitRect.width*(2f/5f), suitRect.height), "Opacity", 
						Skins.guiSkin.GetStyle (Skins.logicNodeLabel));

					if ( ! (floatValues [valueID] >= 0f && floatValues [valueID] <= 1f))
						floatValues [valueID] = 1f;

					floatValues [valueID] = EditorGUI.FloatField (
						new Rect (suitRect.x + suitRect.width*(4f/5f), suitRect.y, 
							suitRect.width*(1f/5f), suitRect.height), floatValues [valueID]);
					//floatValues [valueID] = Mathf.Clamp (floatValues [valueID], 0f, 1f);

				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;

			DrawObjectFieldFillingMessage();
		}

		void DrawTexture2DViewer (Texture2D tex, Rect recView)
		{
			GUI.Box (recView, tex, Skins.guiSkin.GetStyle (Skins.alphaBg));
		}

		void DrawTexture2DResultField (bool isLable, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				if (isLable)
				{
					if (texture2DValue != null)
					{
						EditorGUI.LabelField
						(suitRect, texture2DValue.name,
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
					else
					{
						EditorGUI.LabelField
						(suitRect, "none",
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
				}
				else
				{
					texture2DValue = 
						EditorGUI.ObjectField (suitRect,
							texture2DValue, typeof(Texture2D), false) 
						as Texture2D;

					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject(
						FieldUniqueID(Enums.texture2DValue_ID), texture2DValue);

				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.texture2DValue_ID);

			DrawObjectFieldFillingMessage();
		}

		void DrawTexture2DResultField (bool isLable)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				if (isLable)
				{
					if (texture2DValue != null)
					{
						EditorGUI.LabelField
						(suitRect, texture2DValue.name,
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
					else
					{
						EditorGUI.LabelField
						(suitRect, "none",
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
				}
				else
				{
					texture2DValue = 
						EditorGUI.ObjectField (suitRect,
							texture2DValue, typeof(Texture2D), false) 
						as Texture2D;

					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject(
						FieldUniqueID(Enums.texture2DValue_ID), texture2DValue);

				}
			}

			DrawInputOutput (false, suitRect.center, Enums.texture2DValue_ID);

			DrawObjectFieldFillingMessage();
		}


		void DrawShaderFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = 
				valueID == 0? Enums.shaderValues_0_ID: Enums.shaderValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);


			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					shaderValues [valueID] = 
						EditorGUI.ObjectField (suitRect, 
							shaderValues [valueID], typeof (Shader), true) 
						as Shader;

					//AssignAssetID  (ref shaderValues [valueID], ref shaderValuesOld [valueID], ref shaderValuesAssetsID [valueID]);	
					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
						FieldUniqueID (inOutID), shaderValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;

			DrawObjectFieldFillingMessage();
		}


		void DrawShaderFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			string inOutID = 
				valueID == 0? Enums.shaderValues_0_ID: Enums.shaderValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);


			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					shaderValues [valueID] = 
						EditorGUI.ObjectField (suitRect, 
							shaderValues [valueID], typeof (Shader), true) 
						as Shader;

					//AssignAssetID  (ref shaderValues [valueID], ref shaderValuesOld [valueID], ref shaderValuesAssetsID [valueID]);	
					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
						FieldUniqueID (inOutID), shaderValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;

			DrawObjectFieldFillingMessage();
		}
	

		void DrawShaderResultField (bool isLable, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				if (isLable)
				{
					if (shaderValue != null)
					{
						EditorGUI.LabelField
						(suitRect, shaderValue.name,
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
					else
					{
						EditorGUI.LabelField
						(suitRect, "none",
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
				}
				else if ( ! isLable)
				{
					shaderValue = 
						EditorGUI.ObjectField (suitRect,
							shaderValue, typeof(Shader), false) 
						as Shader;

					//AssignAssetID  (ref shaderValue, ref shaderValueOld,
					//	ref shaderValueAssetsID);

					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject(
						FieldUniqueID(Enums.shaderValue_ID), shaderValue);


				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.shaderValue_ID);

			DrawObjectFieldFillingMessage();
		}

		void DrawShaderResultField (bool isLable)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				if (isLable)
				{
					if (shaderValue != null)
					{
						EditorGUI.LabelField
						(suitRect, shaderValue.name,
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
					else
					{
						EditorGUI.LabelField
						(suitRect, "none",
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
				}
				else if ( ! isLable)
				{
					shaderValue = 
						EditorGUI.ObjectField (suitRect,
							shaderValue, typeof(Shader), false) 
						as Shader;

					//AssignAssetID  (ref shaderValue, ref shaderValueOld,
					//	ref shaderValueAssetsID);

					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject(
						FieldUniqueID(Enums.shaderValue_ID), shaderValue);


				}
			}

			DrawInputOutput (false, suitRect.center, Enums.shaderValue_ID);

			DrawObjectFieldFillingMessage();
		}


		void DrawMaterialResultField (bool isLable, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (maximized)
			{
				if (isLable)
				{
					if (materialValue != null)
					{
						EditorGUI.LabelField
						(suitRect, materialValue.name,
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
					else
					{
						EditorGUI.LabelField
						(suitRect, "none",
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
				}
				else if ( ! isLable)
				{
					materialValue = 
						EditorGUI.ObjectField (suitRect,
							materialValue, typeof(Material), false) 
						as Material;

					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject(
						FieldUniqueID(Enums.materialValue_ID), materialValue);
				}
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.materialValue_ID);

			DrawObjectFieldFillingMessage();
		}

		void DrawMaterialResultField (bool isLable)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
			{
				if (isLable)
				{
					if (materialValue != null)
					{
						EditorGUI.LabelField
						(suitRect, materialValue.name,
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
					else
					{
						EditorGUI.LabelField
						(suitRect, "none",
							Skins.guiSkin.GetStyle (Skins.logicNodeResult));
					}
				}
				else if ( ! isLable)
				{
					materialValue = 
						EditorGUI.ObjectField (suitRect,
							materialValue, typeof(Material), false) 
						as Material;

					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject(
						FieldUniqueID(Enums.materialValue_ID), materialValue);
				}
			}

			DrawInputOutput (false, suitRect.center, Enums.materialValue_ID);

			DrawObjectFieldFillingMessage();
		}



		void DrawMaterialFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = 
				valueID == 0? Enums.materialValues_0_ID: Enums.materialValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);


			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					materialValues [valueID] = 
						EditorGUI.ObjectField (suitRect, 
							materialValues [valueID], typeof (Material), true) 
						as Material;

					//AssignAssetID  (ref materialValues [valueID], ref materialValuesOld [valueID], ref materialValuesAssetsID [valueID]);
					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
						FieldUniqueID (inOutID), materialValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;

			DrawObjectFieldFillingMessage();
		}


		void DrawMaterialFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			string inOutID = 
				valueID == 0? Enums.materialValues_0_ID: Enums.materialValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);


			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					materialValues [valueID] = 
						EditorGUI.ObjectField (suitRect, 
							materialValues [valueID], typeof (Material), true) 
						as Material;

					//AssignAssetID  (ref materialValues [valueID], ref materialValuesOld [valueID], ref materialValuesAssetsID [valueID]);
					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
						FieldUniqueID (inOutID), materialValues [valueID]);
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;

			DrawObjectFieldFillingMessage();
		}


		void DrawPublicInputFieldLabel (int varIndex, Rect suitRect)
		{
			EditorGUI.LabelField (suitRect,
				inputsTypes [varIndex].ToString (), 
				Skins.guiSkin.GetStyle (Skins.logicNodeResult));
		}


		void DrawAudioClipFieldInput_Local ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			//string inOutID = 
			//	valueID == 0? Enums.materialValues_0_ID: Enums.materialValues_1_ID;

			//int varIndex = IndexOfInID (inOutID);

			//DrawInputOutput (true, suitRect.center, inOutID);


			if (maximized)
			{
				//if ( ! publicInputs [varIndex])
				//{
				audioClipValue_Local = 
					EditorGUI.ObjectField (suitRect, 
						audioClipValue_Local, typeof (AudioClip), true) 
					as AudioClip;

				ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
					FieldUniqueID (Enums.audioClip_LocalID), audioClipValue_Local);
				//}
				//else if (publicInputs [varIndex])
				//{
				//	DrawPublicInputFieldLabel (varIndex, suitRect);
				//}
			}

			//if (varIndex > -1 && varIndex < activeInputsFields.Length)
			//	activeInputsFields [varIndex] = true;

			DrawObjectFieldFillingMessage();
		}


		void DrawObjectFieldFillingMessage ()
		{
			if ( ! cameraDirectionalLightMessageWritten)
			{
				//string [] objectFieldFillingMessage  = new string[]{
				//	"GameObject Fields:\n",
				//	"For defaults, Main Camera and Directional Light,\n",
				//	"When filling them in a GameObject Field,\n",
				//	"Save both your scene and Diamond graph.\n",
				//	"Like so, they will be kept in there fields,\n",
				//	"for new sessions.\n",
				//};

				string[] objectFieldFillingMessage = new string[]{
					"Object Fields:\n",                    
					"When filling an Object Field\n",
					"(All fields with drag/drop functionality),\n",
					"Save both your scene and Diamond graph.\n",
					"Like so, they will be kept in there fields,\n",
					"for new sessions.\n",
					"No need to save each time you fill in\n",
					"an Object Field\n",
					"Saving once will care about all the already\n",
					"filled fields\n",
					"\n",
					"For Object Lists in result field, only with the 'Compute Type' 'Get'\n",
					"the objects will be conserved between unity sessions.\n",
					"\n",
					"So if you performed other operations like 'Merge With' for example\n",
					"and need to conserve Objects Lists result to your next session,\n",
					"select 'Get in the 'Compute Type' and save both diamond and unity\n",
					"scene by clicking on the diamonds double save button.\n",
				};

				List <string> tmp = new List<string> ();
				if (DrawObjectFieldFillingMessage_ThereIsAdditional)
				{
					for (int i = 0; i < objectFieldFillingMessage.Length; i++)
					{
						tmp.Add (objectFieldFillingMessage[i]);
					}

					for (int i = 0; i < DrawObjectFieldFillingMessage_Additional.Length; i++)
					{
						if (string.IsNullOrEmpty(DrawObjectFieldFillingMessage_Additional [i]))
							continue;

						tmp.Add (DrawObjectFieldFillingMessage_Additional [i]);
					}

					objectFieldFillingMessage = tmp.ToArray ();
					tmp = new List<string> ();
				}

				DrawMessageBoxUpLeft (objectFieldFillingMessage);

				cameraDirectionalLightMessageWritten = true;
			}
		}

		void DrawGameObjectListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? 
				Enums.gameObjectsListEntire0_ID: Enums.gameObjectsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "G.Object List ";

					EditorGUI.LabelField (suitRect, listLabel, 
						Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;


			DrawObjectFieldFillingMessage ();
		}

		void DrawGameObjectListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? 
				Enums.gameObjectsListEntire0_ID: Enums.gameObjectsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "GameObject List ";

					EditorGUI.LabelField (suitRect, listLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;


			DrawObjectFieldFillingMessage ();
		}


		void DrawGameObjectFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.gameObjectValues_0_ID: Enums.gameObjectValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					if ( ! attachedToGameObject [IndexOfInID (inOutID)])
					{
						if (string.IsNullOrEmpty (inputsSources [varIndex]))
						{
							gameObjectValues[valueID] =
								ScriptsCreatedByDiamond.IdentifiedObjectsActions.GetIdentifiedObject(FieldUniqueID(inOutID))
								as GameObject;
						}

						gameObjectValues [valueID] = 
							EditorGUI.ObjectField (
								suitRect, 
								gameObjectValues [valueID], 
								typeof (GameObject), true) as GameObject;


						//gameObjectValuesUIs [valueID] = 
						//	GameObjectFinderAux.AddComponent 
						//	(gameObjectValues [valueID], gameObjectValuesOld [valueID]);

						ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
							FieldUniqueID (inOutID), gameObjectValues [valueID]);
					}
					else if (attachedToGameObject [IndexOfInID (inOutID)])
					{
						EditorGUI.LabelField (suitRect, "The Attached To", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));
					}
				}
				else if (publicInputs [varIndex])
				{
					if ( ! attachedToGameObject [IndexOfInID (inOutID)])
					{
						DrawPublicInputFieldLabel (varIndex, suitRect);
					}
					else if (attachedToGameObject [IndexOfInID (inOutID)])
					{	
						EditorGUI.LabelField (suitRect, "The Attached To", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));						
					}
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;

			DrawObjectFieldFillingMessage ();
		}

		void DrawGameObjectFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.gameObjectValues_0_ID: Enums.gameObjectValues_1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					if ( ! attachedToGameObject [IndexOfInID (inOutID)])
					{
						if (string.IsNullOrEmpty (inputsSources [varIndex]))
						{
							gameObjectValues[valueID] =
								ScriptsCreatedByDiamond.IdentifiedObjectsActions.GetIdentifiedObject(FieldUniqueID(inOutID))
								as GameObject;
						}

						gameObjectValues [valueID] = 
							EditorGUI.ObjectField (
								suitRect, 
								gameObjectValues [valueID], 
								typeof (GameObject), true) as GameObject;


						//gameObjectValuesUIs [valueID] = 
						//	GameObjectFinderAux.AddComponent 
						//	(gameObjectValues [valueID], gameObjectValuesOld [valueID]);

						ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
							FieldUniqueID (inOutID), gameObjectValues [valueID]);
					}
					else if (attachedToGameObject [IndexOfInID (inOutID)])
					{
						EditorGUI.LabelField (suitRect, "The Attached To", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));
					}
				}
				else if (publicInputs [varIndex])
				{
					if ( ! attachedToGameObject [IndexOfInID (inOutID)])
					{
						DrawPublicInputFieldLabel (varIndex, suitRect);
					}
					else if (attachedToGameObject [IndexOfInID (inOutID)])
					{	
						EditorGUI.LabelField (suitRect, "The Attached To", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));						
					}
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;

			DrawObjectFieldFillingMessage ();
		}

		void DrawGameObjectListResultField (bool withAddButton, bool getfromIdentifiedObjects)
		{
			Rect suitRect = new Rect();
			if (withAddButton)
			{
				suitRect = GetSuitableRect(FieldDrawType.variable);

				if (GUI.Button(suitRect, "Add") && eGlobal.button == 0)
				{
					gameObjectsListValue.Add(gameObjectValue);
				}
			}

			intValue = gameObjectsListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.gameObjectsList_ID)] = gameObjectsListValue.Count;


			/////
			/////
			DrawGameObjectListResultField_entire ();


			suitRect = new Rect ();

			for (int i = 0; i < gameObjectsListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.gameObjectsList_ID)] =
						InOutRect (false, suitRect.center);
				}

				DrawGameObjectListResultField (suitRect, i, getfromIdentifiedObjects);
			}
		}
		void DrawGameObjectListResultField_entire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.gameObjectsListEntire_ID);
		}
		void DrawGameObjectListResultField (Rect suitRect, int i, bool getfromIdentifiedObjects)
		{
			if (maximized)
			{
				if (getfromIdentifiedObjects)
				{
					gameObjectsListValue [i] = ScriptsCreatedByDiamond.IdentifiedObjectsActions.GetIdentifiedObject(
						FieldUniqueID(Enums.gameObjectsList_ID, i)) as GameObject;
				}

				gameObjectsListValue [i] = EditorGUI.ObjectField (
					suitRect, gameObjectsListValue [i], typeof (GameObject), true) as GameObject;

				//if (i > -1 && i < gameObjectsListValueUIs.Count)
				//{
				//	gameObjectsListValueUIs [i] = 
				//		GameObjectFinderAux.AddComponent 
				//		(gameObjectsListValue [i], gameObjectsListValueOld [i]);
				//}

				ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
					FieldUniqueID (Enums.gameObjectsList_ID, i), gameObjectsListValue [i]);
			}
			//brb i
			DrawInputOutput (false, suitRect.center, Enums.gameObjectsList_ID, i);

			if (i == 0)
				DrawObjectFieldFillingMessage();
		}


		void DrawGameObjectResultField (ObjectResultDrawChoice drawChoice, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			switch (drawChoice)
			{
			case ObjectResultDrawChoice.itself:
				if (maximized)
				{
					gameObjectValue = ScriptsCreatedByDiamond.IdentifiedObjectsActions.GetIdentifiedObject(
						FieldUniqueID(Enums.gameObjectValue_ID)) as GameObject;

					gameObjectValue = EditorGUI.ObjectField (suitRect, gameObjectValue, typeof (GameObject), true) as GameObject;

					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject(
						FieldUniqueID(Enums.gameObjectValue_ID), gameObjectValue);
					//gameObjectValueUI = GameObjectFinderAux.AddComponent (gameObjectValue, gameObjectValueOld);
				}
				break;

			case ObjectResultDrawChoice.itsName:
				if (gameObjectValue == null)
				{
					EditorGUI.LabelField (suitRect, "none", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					EditorGUI.LabelField (suitRect, gameObjectValue.name, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				break;
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.gameObjectValue_ID);

			DrawObjectFieldFillingMessage();
		}
			
		void DrawGameObjectResultField (ObjectResultDrawChoice drawChoice)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			switch (drawChoice)
			{
			case ObjectResultDrawChoice.itself:
				if (maximized)
				{
					gameObjectValue = ScriptsCreatedByDiamond.IdentifiedObjectsActions.GetIdentifiedObject(
						FieldUniqueID(Enums.gameObjectValue_ID)) as GameObject;

					gameObjectValue = EditorGUI.ObjectField (suitRect, gameObjectValue, typeof (GameObject), true) as GameObject;

					ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject(
						FieldUniqueID(Enums.gameObjectValue_ID), gameObjectValue);
					//gameObjectValueUI = GameObjectFinderAux.AddComponent (gameObjectValue, gameObjectValueOld);
				}
				break;

			case ObjectResultDrawChoice.itsName:
				if (gameObjectValue == null)
				{
					EditorGUI.LabelField (suitRect, "none GameObject", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					EditorGUI.LabelField (suitRect, gameObjectValue.name, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				break;
			}

			DrawInputOutput (false, suitRect.center, Enums.gameObjectValue_ID);

			DrawObjectFieldFillingMessage();
		}

		void DrawGameObjectResultField (string inOutID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			switch (inOutID)
			{
			case Enums.hit2D_gameObject_ID:
				if (hit2D_gameObject == null)
				{
					EditorGUI.LabelField (suitRect, "none GameObject", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					EditorGUI.LabelField (suitRect, hit2D_gameObject.name, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				break;



			case Enums.raycastHitGameObject_ID:
				if (raycastHitGameObject == null)
				{
					EditorGUI.LabelField (suitRect, "none GameObject", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else
				{
					EditorGUI.LabelField (suitRect, raycastHitGameObject.name, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				break;
			}

			DrawInputOutput (false, suitRect.center, inOutID);
		}


		void DrawSweepTestResultField ()
		{
			DrawLabelField (FieldDrawType.label, "Hitting Something?", Skins.logicNodeLabel);


			DrawBoolResultField ();


			DrawLabelField (FieldDrawType.label, "RaycastHit BarycentricCoordinate", Skins.logicNodeLabel);

			DrawVector3ResultField (Enums.raycastHitBarycentricCoordinate_ID);


			DrawLabelField (FieldDrawType.label, "RaycastHit TriangleIndex", Skins.logicNodeLabel);

			DrawIntResultField (Enums.raycastHitTriangleIndex_ID);



			DrawLabelField (FieldDrawType.label, "RaycastHit Point", Skins.logicNodeLabel);

			DrawVector3ResultField (Enums.raycastHitPoint_ID);


			DrawLabelField (FieldDrawType.label, "RaycastHit Normal", Skins.logicNodeLabel);

			DrawVector3ResultField (Enums.raycastHitNormal_ID);


			DrawLabelField (FieldDrawType.label, "RaycastHit Distance", Skins.logicNodeLabel);

			DrawFloatResultField (Enums.raycastHitDistance_ID);



			DrawLabelField (FieldDrawType.label, "RaycastHit GameObject", Skins.logicNodeLabel);

			DrawGameObjectResultField (Enums.raycastHitGameObject_ID);



			DrawLabelField (FieldDrawType.label, "RaycastHit LightmapCoord", Skins.logicNodeLabel);

			DrawVector2ResultField (Enums.raycastHitLightmapCoord_ID);


			DrawLabelField (FieldDrawType.label, "RaycastHit TextureCoord", Skins.logicNodeLabel);

			DrawVector2ResultField (Enums.raycastHitTextureCoord_ID);

			DrawLabelField (FieldDrawType.label, "RaycastHit TextureCoord2", Skins.logicNodeLabel);

			DrawVector2ResultField (Enums.raycastHitTextureCoord2_ID);
		}

		void DrawHit_2D_ResultField ()
		{
			DrawLabelField (FieldDrawType.label, "Hit Something?", Skins.logicNodeLabel);

			DrawBoolResultField ();



			DrawLabelField (FieldDrawType.label, "RaycastHit2D Centroid", Skins.logicNodeLabel);

			DrawVector2ResultField (Enums.hit2D_centroid_ID);



			DrawLabelField (FieldDrawType.label, "RaycastHit2D Point", Skins.logicNodeLabel);

			DrawVector2ResultField (Enums.hit2D_point_ID);


			DrawLabelField (FieldDrawType.label, "RaycastHit2D Normal", Skins.logicNodeLabel);

			DrawVector2ResultField (Enums.hit2D_normal_ID);


			DrawLabelField (FieldDrawType.label, "RaycastHit2D Distance", Skins.logicNodeLabel);

			DrawFloatResultField (Enums.hit2D_distance_ID);


			DrawLabelField (FieldDrawType.label, "RaycastHit2D Fraction", Skins.logicNodeLabel);

			DrawFloatResultField (Enums.hit2D_fraction_ID);



			DrawLabelField (FieldDrawType.label, "RaycastHit2D GameObject", Skins.logicNodeLabel);

			DrawGameObjectResultField (Enums.hit2D_gameObject_ID);
		}

		void DrawOffMeshLinkDataResultField ()
		{
			DrawLabelField (FieldDrawType.label, "OffMeshLinkData", Skins.logicNodeLabel);

			DrawLabelField (FieldDrawType.label, "activated", Skins.logicNodeLabel);
			DrawBoolResultField (Enums.OffMeshLinkData_activated_ID);

			DrawLabelField (FieldDrawType.label, "startPosition", Skins.logicNodeLabel);
			DrawVector3ResultField (Enums.OffMeshLinkData_startPosition_ID);

			DrawLabelField (FieldDrawType.label, "endPosition", Skins.logicNodeLabel);
			DrawVector3ResultField (Enums.OffMeshLinkData_endPosition_ID);


			DrawLabelField (FieldDrawType.label, "valid", Skins.logicNodeLabel);
			DrawBoolResultField (Enums.OffMeshLinkData_valid_ID);

			DrawLabelField (FieldDrawType.label, "type", Skins.logicNodeLabel);
			DrawLabelField (FieldDrawType.label, OffMeshLinkData_Type.ToString (), Skins.logicNodeResult);
		}

		void DrawNavMeshHitResultField ()
		{

			DrawLabelField (FieldDrawType.label, "Is Something been hit?", Skins.logicNodeLabel);
			DrawBoolResultField ();


			DrawLabelField (FieldDrawType.label, "Distance to the point of hit", Skins.logicNodeLabel);
			DrawFloatResultField (Enums.NavMeshHit_distance_ID);

			DrawLabelField (FieldDrawType.label, "Flag set when hit", Skins.logicNodeLabel);
			DrawBoolResultField (Enums.NavMeshHit_hit_ID);

			DrawLabelField (FieldDrawType.label, "Mask of NavMesh area at point of hit", Skins.logicNodeLabel);
			DrawIntResultField (Enums.NavMeshHit_mask_ID);

			DrawLabelField (FieldDrawType.label, "Position of hit", Skins.logicNodeLabel);
			DrawVector3ResultField (Enums.NavMeshHit_position_ID);

			DrawLabelField (FieldDrawType.label, "Normal at the point of hit", Skins.logicNodeLabel);
			DrawVector3ResultField (Enums.NavMeshHit_normal_ID);
		}
		void DrawNavMeshHitResultField (bool withTheReturnedBool)
		{
			if (withTheReturnedBool)
			{
				DrawLabelField (FieldDrawType.label, "Is Something been hit?", Skins.logicNodeLabel);
				DrawBoolResultField ();
			}


			DrawLabelField (FieldDrawType.label, "Distance to the point of hit", Skins.logicNodeLabel);
			DrawFloatResultField (Enums.NavMeshHit_distance_ID);

			DrawLabelField (FieldDrawType.label, "Flag set when hit", Skins.logicNodeLabel);
			DrawBoolResultField (Enums.NavMeshHit_hit_ID);

			DrawLabelField (FieldDrawType.label, "Mask of NavMesh area at point of hit", Skins.logicNodeLabel);
			DrawIntResultField (Enums.NavMeshHit_mask_ID);

			DrawLabelField (FieldDrawType.label, "Position of hit", Skins.logicNodeLabel);
			DrawVector3ResultField (Enums.NavMeshHit_position_ID);

			DrawLabelField (FieldDrawType.label, "Normal at the point of hit", Skins.logicNodeLabel);
			DrawVector3ResultField (Enums.NavMeshHit_normal_ID);
		}


		void DrawRayResultField ()
		{
			DrawRayOriginResultField ();

			DrawRayDirectionResultField ();
		}
		void DrawRayOriginResultField ()
		{
			DrawLabelFields (new string[]{"Origin",});

			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
				EditorGUI.LabelField (suitRect, rayValueOrigin.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.rayOrigin_ID);
		}
		void DrawRayDirectionResultField ()
		{
			DrawLabelFields (new string[]{"Direction",});

			Rect suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			if (maximized)
				EditorGUI.LabelField (suitRect, rayValue.direction.ToString (), Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.rayDirection_ID);
		}


		void DrawRay ()
		{
			Rect suitRect = new Rect ();

			if (maximized)
				GUI.Label (GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
					new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), "Origin", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));

			suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));


			//if (logicType == LogicType.variable)
			//	DrawInputOutput (false, suitRect.center, Enums.rayOrigin_ID); 
			//else if (logicType == LogicType.computeOrOperation)
			//	DrawInputOutput (true, suitRect.center, Enums.rayOrigin_ID); 


			if (maximized)
			{
				if ( ! publicInputs [IndexOfInID (Enums.rayOrigin_ID)])
				{
					rayValueOrigin = EditorGUI.Vector3Field (suitRect, "", rayValueOrigin);
				}
				else if (publicInputs [IndexOfInID (Enums.rayOrigin_ID)])
				{
					DrawPublicInputFieldLabel (IndexOfInID (Enums.rayOrigin_ID), suitRect);
				}
			}

			rayValue.origin = rayValueOrigin;

			int varIndex = IndexOfInID (Enums.rayOrigin_ID);

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;




			if (maximized)
				GUI.Label (GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
					new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), "Direction", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));

			suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));


			//if (logicType == LogicType.variable)
			//	DrawInputOutput (false, suitRect.center, Enums.rayDirection_ID);
			//else if (logicType == LogicType.computeOrOperation)
			//	DrawInputOutput (true, suitRect.center, Enums.rayDirection_ID);


			if (maximized)
			{
				if ( ! publicInputs [IndexOfInID (Enums.rayDirection_ID)])
				{
					rayDirectionValueNotNormalized = EditorGUI.Vector3Field (suitRect, "", rayDirectionValueNotNormalized);

					rayValue.direction = rayDirectionValueNotNormalized.normalized;
				}
				else if (publicInputs [IndexOfInID (Enums.rayDirection_ID)])
				{
					DrawPublicInputFieldLabel (IndexOfInID (Enums.rayDirection_ID), suitRect);
				}
			}

			varIndex = IndexOfInID (Enums.rayDirection_ID);

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;


		}

		void DrawRay2D ()
		{
			Rect suitRect = new Rect ();

			int varIndex = IndexOfInID (Enums.ray2DOrigin_ID);

			if (maximized)
				GUI.Label (GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
					new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), "Origin", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));

			suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			//if (logicType == LogicType.variable)
			//	DrawInputOutput (false, suitRect.center, Enums.ray2DOrigin_ID);
			//else if (logicType == LogicType.condition)
			//	DrawInputOutput (true, suitRect.center, Enums.ray2DOrigin_ID);


			if (maximized)
			{
				if( ! publicInputs [varIndex])
				{
					ray2DValueOrigin = EditorGUI.Vector2Field (suitRect, "", ray2DValueOrigin);

					ray2DValue.origin = ray2DValueOrigin;
				}
				else if(publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}



			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;


			if (maximized)
				GUI.Label (GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
					new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), "Direction", Skins.guiSkin.GetStyle (Skins.logicNodeLabel));

			suitRect = GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
				new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++));

			//if (logicType == LogicType.variable)
			//	DrawInputOutput (false, suitRect.center, Enums.ray2DDirection_ID);
			//else if (logicType == LogicType.condition)
			//	DrawInputOutput (true, suitRect.center, Enums.ray2DDirection_ID);

			varIndex = IndexOfInID (Enums.ray2DDirection_ID);

			if (maximized)
			{
				if( ! publicInputs [varIndex])
				{
					ray2DDirectionValueNotNormalized = EditorGUI.Vector2Field (suitRect, "", ray2DDirectionValueNotNormalized);

					ray2DValue.direction = ray2DDirectionValueNotNormalized.normalized;

				}
				else if(publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}


			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}


		void DrawRemoveListElementButton (
			bool isAnInput, Rect inOutRect, string inOutID, int currentInOutListIndex)
		{
			Rect r = new Rect ();

			if (isAnInput)
			{
			}
			else
			{
				Vector2 rXSize = new Vector2 (inOutRect.width, inOutRect.height) * 0.75f;

				r = new Rect (inOutRect.x - inOutRect.width, inOutRect.center.y - rXSize.y*0.5f, rXSize.x, rXSize.y);
			}

			if (GUI.Button (r, "", Skins.guiSkin.GetStyle (Skins.x)) && eGlobal.button == 0)
			{
				RemoveListElement (isAnInput, inOutID, currentInOutListIndex);
			}
		}


		void DrawVector3ListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.vector3ListEntire0_ID: Enums.vector3ListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Vector3 List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawVector3ListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.vector3ListEntire0_ID: Enums.vector3ListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Vector3 List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
	
		void DrawVector3ListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect ();

			if (withAddButton)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (GUI.Button (suitRect, "Add") && eGlobal.button == 0)
				{
					vector3ListValue.Add (Vector3.zero);
				}
			}

			intValue = vector3ListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.vector3List_ID)] = vector3ListValue.Count;

			/////
			/////
			DrawVector3ListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < vector3ListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.vector3List_ID)] = InOutRect (false, suitRect.center);
				}

				DrawVector3ListResultField (suitRect, i);
			}
		}
		void DrawVector3ListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				vector3ListValue [i] = EditorGUI.Vector3Field (suitRect, "", vector3ListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.vector3List_ID, i);
		}
		void DrawVector3ListResultField (Rect suitRect, int i, bool isLabel, 
			bool withRemoveListElementButton)
		{
			if (maximized)
			{
				if ( ! isLabel)
					vector3ListValue [i] = EditorGUI.Vector3Field (suitRect, "", vector3ListValue [i]);
				else
					EditorGUI.LabelField (suitRect, vector3ListValue [i].ToString (), GetGuiStyle (Skins.logicNodeResult));
			}

			DrawInputOutput (false,  InOutGatePreCenter (suitRect), Enums.vector3List_ID, i, withRemoveListElementButton);
		}
		void DrawVector3ListResultField (int column, int totalColumns, string [] labels, bool isLabel, 
			bool withRemoveListElementButton)
		{
			if (labels.Length != vector3ListValue.Count)
				return;

			outputListCounts [IndexOfOutID (Enums.vector3List_ID)] = vector3ListValue.Count;

			/////
			/////
			//DrawBoolsListEntire ();

			Rect suitRect = new Rect ();

			for (int i = 0; i < vector3ListValue.Count; i++)
			{
				DrawLogicNodeLabel (labels [i], column-1, totalColumns);

				suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.vector3List_ID)] = 
						InOutRect (false, InOutGatePreCenter (suitRect));
				}

				DrawVector3ListResultField (suitRect, i, isLabel, withRemoveListElementButton);
			}
		}
		void DrawVector3ListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.vector3ListEntire_ID);
		}


		void DrawVector2ListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.vector2ListEntire0_ID: Enums.vector2ListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Vector2 List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawVector2ListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.vector2ListEntire0_ID: Enums.vector2ListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Vector2 List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
	
		void DrawVector2ListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect ();

			if (withAddButton)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (GUI.Button (suitRect, "Add") && eGlobal.button == 0)
				{
					vector2ListValue.Add (Vector2.zero);
				}
			}

			intValue = vector2ListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.vector2List_ID)] = vector2ListValue.Count;

			/////
			/////
			DrawVector2ListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < vector2ListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.vector2List_ID)] = InOutRect (false, suitRect.center);
				}

				DrawVector2ListResultField (suitRect, i);
			}
		}
		void DrawVector2ListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				vector2ListValue [i] = EditorGUI.Vector2Field (suitRect, "", vector2ListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.vector2List_ID, i);
		}
		void DrawVector2ListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.vector2ListEntire_ID);
		}

		void DrawVector4ListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.vector4ListEntire0_ID: Enums.vector4ListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Vector4 List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawVector4ListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.vector4ListEntire0_ID: Enums.vector4ListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Vector4 List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawVector4ListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect();

			if (withAddButton)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (GUI.Button (suitRect, "Add") && eGlobal.button == 0)
				{
					vector4ListValue.Add (Vector4.zero);
				}
			}

			intValue = vector4ListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.vector4List_ID)] = vector4ListValue.Count;

			/////
			/////
			DrawVector4ListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < vector4ListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.vector4List_ID)] = InOutRect (false, suitRect.center);
				}

				DrawVector4ListResultField (suitRect, i);
			}
		}
		void DrawVector4ListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				vector4ListValue [i] = EditorGUI.Vector4Field (suitRect, "", vector4ListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.vector4List_ID, i);
		}
		void DrawVector4ListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.vector4ListEntire_ID);
		}


		void DrawStringsListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable, column, totalColumns);

			string inOutID = valueID == 0? 
				Enums.stringsListEntire0_ID: Enums.stringsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "String List " + valueID.ToString ();

					EditorGUI.LabelField (suitRect, listLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawStringsListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? 
				Enums.stringsListEntire0_ID: Enums.stringsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "String List " + valueID.ToString ();

					EditorGUI.LabelField (suitRect, listLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
	
		void DrawStringsListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect ();

			if (withAddButton)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (GUI.Button (suitRect, "Add") && eGlobal.button == 0)
				{
					stringsListValue.Add ("");
				}
			}

			intValue = stringsListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.stringsList_ID)] = stringsListValue.Count;

			/////
			/////
			DrawStringsListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < stringsListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.stringsList_ID)] = InOutRect (false, suitRect.center);
				}

				DrawStringsListResultField (suitRect, i);
			}
		}
		void DrawStringsListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				stringsListValue [i] = EditorGUI.TextField (suitRect, stringsListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.stringsList_ID, i);
		}
		void DrawStringsListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.stringsListEntire_ID);
		}

		void DrawRectListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? 
				Enums.rectListEntire0_ID: Enums.rectListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "Rect List " + valueID.ToString ();

					EditorGUI.LabelField (suitRect, listLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawRectListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? 
				Enums.rectListEntire0_ID: Enums.rectListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "Rect List " + valueID.ToString ();

					EditorGUI.LabelField (suitRect, listLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
	
		void DrawRectListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect ();

			if (withAddButton)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (GUI.Button (suitRect, "Add") && eGlobal.button == 0)
				{
					rectListValue.Add (new Rect ());
				}
			}

			intValue = rectListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.rectList_ID)] = rectListValue.Count;

			/////
			/////
			DrawRectsListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < rectListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.rectList_ID)] = InOutRect (false, suitRect.center);
				}

				DrawRectListResultField (suitRect, i);
			}
		}
		void DrawRectsListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.rectListEntire_ID);


		}
		void DrawRectListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				rectListValue [i] = EditorGUI.RectField (suitRect, rectListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.rectList_ID, i);

			suitRect = GetSuitableRect (FieldDrawType.variable);
		}


		void DrawBoolListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? 
				Enums.boolsListEntire0_ID: Enums.boolsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "Bool List " + valueID.ToString ();

					EditorGUI.LabelField (suitRect, listLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}


		void DrawBoolListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? 
				Enums.boolsListEntire0_ID: Enums.boolsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "Bool List " + valueID.ToString ();

					EditorGUI.LabelField (suitRect, listLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawBoolListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect ();

			if (withAddButton)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (GUI.Button (suitRect, "Add") && eGlobal.button == 0)
				{
					boolsListValue.Add (false);
				}
			}

			intValue = boolsListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.boolsList_ID)] = boolsListValue.Count;

			/////
			/////
			DrawBoolsListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < boolsListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.boolsList_ID)] = InOutRect (false, suitRect.center);
				}

				DrawBoolListResultField (suitRect, i);
			}
		}
		void DrawBoolsListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.boolsListEntire_ID);

		}
		void DrawBoolListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				boolsListValue [i] = EditorGUI.Toggle (suitRect, boolsListValue [i]);
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.boolsList_ID, i);
		}
		void DrawBoolListResultField (Rect suitRect, int i, bool isLable)
		{
			if (maximized)
			{
				if ( ! isLable)
					boolsListValue [i] = EditorGUI.Toggle (suitRect, boolsListValue [i]);
				else
					EditorGUI.LabelField (suitRect, boolsListValue [i].ToString (), 
						GetGuiStyle (Skins.logicNodeResult));
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.boolsList_ID, i);
		}
		void DrawBoolListResultField (Rect suitRect, int i, bool isLable, bool withRemoveListElementButton)
		{
			if (maximized)
			{
				if ( ! isLable)
					boolsListValue [i] = EditorGUI.Toggle (suitRect, boolsListValue [i]);
				else
					EditorGUI.LabelField (suitRect, boolsListValue [i].ToString (), 
						GetGuiStyle (Skins.logicNodeResult));
			}

			DrawInputOutput (false, InOutGatePreCenter (suitRect), Enums.boolsList_ID, i,
				withRemoveListElementButton);
		}
		void DrawBoolListResultField (int column, int totalColumns, string [] labels)
		{
			if (labels.Length != boolsListValue.Count)
				return;

			outputListCounts [IndexOfOutID (Enums.boolsList_ID)] = boolsListValue.Count;

			/////
			/////
			//DrawBoolsListEntire ();

			Rect suitRect = new Rect ();

			for (int i = 0; i < boolsListValue.Count; i++)
			{
				DrawLogicNodeLabel (labels [i], column-1, totalColumns);

				suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.boolsList_ID)] = 
						InOutRect (false, InOutGatePreCenter (suitRect));
				}

				DrawBoolListResultField (suitRect, i);
			}
		}
		void DrawBoolListResultField (int column, int totalColumns, string [] labels, bool isLabel)
		{
			if (labels.Length != boolsListValue.Count)
				return;

			outputListCounts [IndexOfOutID (Enums.boolsList_ID)] = boolsListValue.Count;

			/////
			/////
			//DrawBoolsListEntire ();

			Rect suitRect = new Rect ();

			for (int i = 0; i < boolsListValue.Count; i++)
			{
				DrawLogicNodeLabel (labels [i], column-1, totalColumns);

				suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.boolsList_ID)] = 
						InOutRect (false, InOutGatePreCenter (suitRect));
				}

				DrawBoolListResultField (suitRect, i, isLabel);
			}
		}
		void DrawBoolListResultField (int column, int totalColumns, string [] labels, bool isLabel, 
			bool withRemoveListElementButton)
		{
			if (labels.Length != boolsListValue.Count)
				return;
			
			outputListCounts [IndexOfOutID (Enums.boolsList_ID)] = boolsListValue.Count;

			/////
			/////
			//DrawBoolsListEntire ();

			Rect suitRect = new Rect ();

			for (int i = 0; i < boolsListValue.Count; i++)
			{
				DrawLogicNodeLabel (labels [i], column-1, totalColumns);

				suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.boolsList_ID)] = 
						InOutRect (false, InOutGatePreCenter (suitRect));
				}

				DrawBoolListResultField (suitRect, i, isLabel, withRemoveListElementButton);
			}
		}


		void DrawTexture2DListFieldInput (int valueID, int column, int columns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, columns);

			string inOutID = valueID == 0? Enums.texture2DListEntire0_ID: Enums.texture2DListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{						
					EditorGUI.LabelField (suitRect, "Texture2D List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawTexture2DListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.texture2DListEntire0_ID: Enums.texture2DListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{						
					EditorGUI.LabelField (suitRect, "Texture2D List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawTexture2DListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect();

			if (withAddButton)
			{
				suitRect = GetSuitableRect(FieldDrawType.variable);

				if (GUI.Button(suitRect, "Add") && eGlobal.button == 0)
				{
					texture2DListValue.Add(null);
				}
			}

			intValue = texture2DListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.texture2DList_ID)] = texture2DListValue.Count;

			/////
			/////
			DrawTexture2DListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < texture2DListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.texture2DList_ID)] = InOutRect (false, suitRect.center);
				}

				DrawTexture2DListResultField (suitRect, i);
			}
		}
		void DrawTexture2DListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				texture2DListValue [i] = EditorGUI.ObjectField (
					suitRect, texture2DListValue [i], typeof (Texture2D), false) as Texture2D;

				ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
					FieldUniqueID (Enums.texture2DList_ID, i), texture2DListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.texture2DList_ID, i);

			DrawObjectFieldFillingMessage();
		}
		void DrawTexture2DListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.texture2DListEntire_ID);
		}


		void DrawMaterialListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.materialListEntire0_ID: Enums.materialListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Material List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawMaterialListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.materialListEntire0_ID: Enums.materialListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Material List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawMaterialListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect();

			if (withAddButton)
			{
				suitRect = GetSuitableRect(FieldDrawType.variable);

				if (GUI.Button(suitRect, "Add") && eGlobal.button == 0)
				{
					materialsListValue.Add(null);
				}
			}

			intValue = materialsListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.materialList_ID)] = materialsListValue.Count;

			/////wea
			/////
			DrawMaterialsListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < materialsListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.materialList_ID)] = InOutRect (false, suitRect.center);
				}

				DrawMaterialListResultField (suitRect, i);
			}
		}
		void DrawMaterialListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				materialsListValue [i] = EditorGUI.ObjectField (suitRect, materialsListValue [i], typeof (Material), false) as Material;

				ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
					FieldUniqueID (Enums.materialList_ID, i), materialsListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.materialList_ID, i);

			DrawObjectFieldFillingMessage();
		}
		void DrawMaterialsListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.materialListEntire_ID);
		}

		void DrawShaderListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.shaderListEntire0_ID: Enums.shaderListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Shader List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawShaderListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.shaderListEntire0_ID: Enums.shaderListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Shader List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawShaderListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect();
			if (withAddButton)
			{
				suitRect = GetSuitableRect(FieldDrawType.variable);

				if (GUI.Button(suitRect, "Add") && eGlobal.button == 0)
				{
					shaderListValue.Add(null);
				}
			}

			intValue = shaderListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.shaderList_ID)] = shaderListValue.Count;

			/////
			/////
			DrawShaderListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < shaderListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.shaderList_ID)] = InOutRect (false, suitRect.center);
				}

				DrawShaderListResultField (suitRect, i);
			}
		}
		void DrawShaderListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				shaderListValue [i] = EditorGUI.ObjectField (suitRect, shaderListValue [i], typeof(Shader), false) as Shader;

				ScriptsCreatedByDiamond.IdentifiedObjectsActions.SetIdentifiedObject (
					FieldUniqueID (Enums.shaderList_ID, i), shaderListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.shaderList_ID, i);

			DrawObjectFieldFillingMessage();
		}
		void DrawShaderListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.shaderListEntire_ID);
		}


		void DrawIntListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.intsListEntire0_ID: Enums.intsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Int List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawIntListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.intsListEntire0_ID: Enums.intsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Int List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
	
		void DrawIntListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect ();

			if (withAddButton)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (GUI.Button (suitRect, "Add") && eGlobal.button == 0)
				{
					intsListValue.Add (0);
				}
			}

			bool inventoryAndMakeObjectReady = 
				(computeIntListType == ComputeIntsListType.inventoryList) &&
				(inventoryListAction == InventoryListAction.makeObjectOfFollowingIndexReady);
			
			if ( ! inventoryAndMakeObjectReady)
			{
				intValue = intsListValue.Count;
				DrawLogicNodeLabel ("List Count", 0, 2);
				DrawIntResultField (true, 1, 2);
			}

			outputListCounts [IndexOfOutID (Enums.intsList_ID)] = intsListValue.Count;

			/////
			/////
			DrawIntsListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < intsListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.intsList_ID)] = InOutRect (false, suitRect.center);
				}

				DrawIntListResultField (suitRect, i);
			}
		}
		void DrawIntListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				intsListValue [i] = EditorGUI.IntField (suitRect, intsListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.intsList_ID, i);
		}
		void DrawIntsListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.intsListEntire_ID);
		}


		void DrawFloatListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? Enums.floatsListEntire0_ID: Enums.floatsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Float List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawFloatListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? Enums.floatsListEntire0_ID: Enums.floatsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					EditorGUI.LabelField (suitRect, "Float List", Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
	
		void DrawFloatListResultField (bool withAddbutton)
		{
			Rect suitRect = new Rect ();

			if (withAddbutton)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (GUI.Button (suitRect, "Add") && eGlobal.button == 0)
				{
					floatsListValue.Add (0f);
				}
			}

			DrawLogicNodeLabel ("List Count", 0, 2);
			intValue = floatsListValue.Count;
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.floatsList_ID)] = floatsListValue.Count;

			/////
			/////
			DrawFloatsListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < floatsListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.floatsList_ID)] = InOutRect (false, suitRect.center);
				}

				DrawFloatListResultField (suitRect, i);
			}
		}
		void DrawFloatListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				floatsListValue [i] = EditorGUI.FloatField (suitRect, floatsListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.floatsList_ID, i);
		}
		void DrawFloatsListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.floatsListEntire_ID);
		}

		void DrawColorListFieldInput (int valueID, int column, int totalColumns)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			string inOutID = valueID == 0? 
				Enums.colorsListEntire0_ID: Enums.colorsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, InOutGatePreCenter (suitRect), inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "Color List " + valueID.ToString ();

					EditorGUI.LabelField (suitRect, listLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}

		void DrawColorListFieldInput (int valueID)
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			string inOutID = valueID == 0? 
				Enums.colorsListEntire0_ID: Enums.colorsListEntire1_ID;

			int varIndex = IndexOfInID (inOutID);

			DrawInputOutput (true, suitRect.center, inOutID);

			if (maximized)
			{
				if ( ! publicInputs [varIndex])
				{
					string listLabel = "Color List " + valueID.ToString ();

					EditorGUI.LabelField (suitRect, listLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));
				}
				else if (publicInputs [varIndex])
				{
					DrawPublicInputFieldLabel (varIndex, suitRect);
				}
			}

			if (varIndex > -1 && varIndex < activeInputsFields.Length)
				activeInputsFields [varIndex] = true;
		}
	
		void DrawColorListResultField (bool withAddButton)
		{
			Rect suitRect = new Rect ();

			if (withAddButton)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (GUI.Button (suitRect, "Add") && eGlobal.button == 0)
				{
					colorsListValue.Add (Color.white);
				}
			}

			intValue = colorsListValue.Count;
			DrawLogicNodeLabel ("List Count", 0, 2);
			DrawIntResultField (true, 1, 2);

			outputListCounts [IndexOfOutID (Enums.colorsList_ID)] = colorsListValue.Count;

			/////
			/////
			DrawColorsListEntire ();

			suitRect = new Rect ();

			for (int i = 0; i < colorsListValue.Count; i++)
			{
				suitRect = GetSuitableRect (FieldDrawType.variable);

				if (i == 0)
				{
					firstRectOfListsOutput [IndexOfOutID (Enums.colorsList_ID)] = InOutRect (false, suitRect.center);
				}

				DrawColorListResultField (suitRect, i);
			}
		}
		void DrawColorListResultField (Rect suitRect, int i)
		{
			if (maximized)
			{
				colorsListValue [i] = EditorGUI.ColorField (suitRect, colorsListValue [i]);
			}

			DrawInputOutput (false, suitRect.center, Enums.colorsList_ID, i);
		}
		void DrawColorsListEntire ()
		{
			Rect suitRect = GetSuitableRect (FieldDrawType.variable);

			EditorGUI.LabelField (suitRect, entireListLabel, Skins.guiSkin.GetStyle (Skins.logicNodeResult));

			DrawInputOutput (false, suitRect.center, Enums.colorsListEntire_ID);
		}

		void DrawChooseSceneFromBuildScenes ()
		{
			if (GUI.Button (GetSuitableRect (FieldDrawType.label), "Choose Scene"))
			{
				GenericMenu menu = new GenericMenu ();

				for (int i = 0; i < UnityEngine.SceneManagement.SceneManager.sceneCount; i++)
				{
					UnityEngine.SceneManagement.Scene getedScene =
						UnityEngine.SceneManagement.SceneManager.GetSceneAt (i);

					string getedSceneName = getedScene.name;

					if (string.IsNullOrEmpty (getedSceneName))
						continue;

					menu.AddItem (new GUIContent (getedSceneName), false, SetThisToString_0, getedSceneName);
				}

				menu.ShowAsContext ();
			}
		}

		void DrawSpriteRendererTileInputs ()
		{
			DrawLogicNodeLabel ("Start Position", 0, 2);
			DrawVector3InputField (0, 1, 2);

			DrawLogicNodeLabel ("Total size of tiles", 0, 2);
			DrawVector2InputField (0, 1, 2);


			DrawLogicNodeLabel ("Rotate randomly", 0, 2);
			DrawBoolInputField (0, 3, 4);

			if ( ! boolValues [0])
			{
				DrawLogicNodeLabel ("Start Rotation", 0, 2);
				DrawFloatInputField (0, 1, 2);

				DrawLogicNodeLabel ("Rotate x, y", 0, 2);
				DrawBoolInputField (1, 3, 4);

				DrawLogicNodeLabel ("Rotate amount", 0, 2);
				if (boolValues [1])
				{
					DrawVector2InputField (1, 1, 2);
				}
				else if ( ! boolValues [1])
				{
					DrawFloatInputField (1, 1, 2);
				}
			}
		}

		void DrawTouchOutputField ()
		{
			if (true)
			{
				DrawLogicNodeLabel ("Altitude Angle", 0, 2);
				DrawFloatResultField (Enums.touch_altitudeAngle_ID, 1, 2);

				DrawLogicNodeLabel ("Azimut Angle", 0, 2);
				DrawFloatResultField (Enums.touch_azimuthAngle_ID, 1, 2);

				DrawLogicNodeLabel ("Delta Position", 0, 2);
				DrawVector2ResultField (Enums.touch_deltaPosition_ID, 1, 2);

				DrawLogicNodeLabel ("Delta Time", 0, 2);
				DrawFloatResultField (Enums.touch_deltaTime_ID, 1, 2);


				DrawLogicNodeLabel ("Finger ID", 0, 2);
				DrawIntResultField (Enums.touch_fingerId_ID, 1, 2);

				DrawLogicNodeLabel ("Maximum Possible Pressure", 0, 2);
				DrawFloatResultField (Enums.touch_maximumPossiblePressure_ID, 1, 2);

				DrawLogicNodeLabel ("Phase", 0, 2);
				DrawStringResultField (Enums.touch_phase_ID, 1, 2);

				DrawLogicNodeLabel ("Position", 0, 2);
				DrawVector2ResultField (Enums.touch_position_ID, 1, 2);


				DrawLogicNodeLabel ("Pressure", 0, 2);
				DrawFloatResultField (Enums.touch_pressure_ID, 1, 2);


				DrawLogicNodeLabel ("Radius", 0, 2);
				DrawFloatResultField (Enums.touch_radius_ID, 1, 2);

				DrawLogicNodeLabel ("Radius Variance", 0, 2);
				DrawFloatResultField (Enums.touch_radiusVariance_ID, 1, 2);

				DrawLogicNodeLabel ("Raw Position", 0, 2);
				DrawVector2ResultField (Enums.touch_rawPosition_ID, 1, 2);


				DrawLogicNodeLabel ("Tap Count", 0, 2);
				DrawIntResultField (Enums.touch_tapCount_ID, 1, 2);


				DrawLogicNodeLabel ("Type", 0, 2);
				DrawStringResultField (Enums.touch_type_ID, 1, 2);

			}
		}


		void DrawStringListMenuToString_0 (string [] menuNames, string [] notFoundMessage,
			int column, int totalColumns)
		{
			if (menuNames == null || menuNames.Length == 0)
			{
				for (int i = 0; i < notFoundMessage.Length; i++)
				{
					DrawInNodeInfo (notFoundMessage [i]);
				}

				return;
			}

			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (GUI.Button (suitRect, stringValues [0]))
			{
				GenericMenu menu = new GenericMenu ();

				for (int i = 0; i < menuNames.Length; i++)
				{
					if (string.IsNullOrEmpty (menuNames [i]))
						continue;

					menu.AddItem (new GUIContent (menuNames [i]), false, SetThisToString_0, menuNames [i]);
				}

				menu.ShowAsContext ();
			}

			if (suitRect.Contains (eGlobal.mousePosition))
				DrawFloatingMessage (
					new Rect (eGlobal.mousePosition + new Vector2 (15f, -10f), Vector2.one), 
					stringValues [0]);
		} 
		void DrawStringListMenuToString_0 (string buttonName, string [] menuNames, string [] notFoundMessage,
			int column, int totalColumns)
		{
			if (menuNames == null || menuNames.Length == 0)
			{
				for (int i = 0; i < notFoundMessage.Length; i++)
				{
					DrawInNodeInfo (notFoundMessage [i]);
				}

				return;
			}

			Rect suitRect = GetSuitableRect (FieldDrawType.label, column, totalColumns);

			if (GUI.Button (suitRect, buttonName))
			{
				GenericMenu menu = new GenericMenu ();

				for (int i = 0; i < menuNames.Length; i++)
				{
					if (string.IsNullOrEmpty (menuNames [i]))
						continue;

					menu.AddItem (new GUIContent (menuNames [i]), false, SetThisToString_0, menuNames [i]);
				}

				menu.ShowAsContext ();
			}

			if (suitRect.Contains (eGlobal.mousePosition))
				DrawFloatingMessage (
					new Rect (eGlobal.mousePosition + new Vector2 (15f, -10f), Vector2.one), 
					buttonName);
		} 
		void DrawStringListMenuToString_0 (string buttonName, string [] menuNames, string [] notFoundMessage)
		{
			if (menuNames == null || menuNames.Length == 0)
			{
				for (int i = 0; i < notFoundMessage.Length; i++)
				{
					DrawInNodeInfo (notFoundMessage [i]);
				}

				return;
			}

			Rect suitRect = GetSuitableRect (FieldDrawType.label);

			if (GUI.Button (suitRect, buttonName))
			{
				GenericMenu menu = new GenericMenu ();

				for (int i = 0; i < menuNames.Length; i++)
				{
					if (string.IsNullOrEmpty (menuNames [i]))
						continue;
					
					menu.AddItem (new GUIContent (menuNames [i]), false, SetThisToString_0, menuNames [i]);
				}

				menu.ShowAsContext ();
			}

			if (suitRect.Contains (eGlobal.mousePosition))
				DrawFloatingMessage (
					new Rect (eGlobal.mousePosition + new Vector2 (15f, -10f), Vector2.one), 
					buttonName);
		} 

		void DrawAnimationCurveInputField () 
		{
			animationCurve_ = EditorGUI.CurveField (GetSuitableRect (FieldDrawType.nodeName), animationCurve_);
		}

		static GUIStyle GetGuiStyle (string styleName)
		{
			return Skins.guiSkin.GetStyle (styleName);
		}

		//void IncrementColumnID ()
		//{
		//	columnID++;
		//
		//	if (columnID > columns-1)
		//		columnID = 0;
		//}
		#endregion Draw methods


		/// <summary>
		/// Removes the node.
		/// Responsible for removing the logicNode from the graph
		/// </summary>
		#region remove node
		void RemoveNode (Event e)
		{
			if (selectionState == SelectionState.selected)
			{
				if (MouseKeysEvents.ControlCommandAltKey (KeyCode.X, e))
				{
					if (EditorUtility.DisplayDialog ("Delete Logic Node",
						"Are you sure you want to delete this Logic Node? \n" +
						"\n" +
						"It is an irreversible action !",
						"Yes", "no"))
					{
						switch (logicType)
						{
						case LogicType.computeOrOperation:
							switch (variableType)
							{
							case VariableType.Bool:
								switch (computeBoolType)
								{
								case ComputeBoolType.goToState:
									for (int i = 0; i < logic.node.graph.nodes.Count; i++)
									{
										if (logic.node.graph.nodes [i].nodeName == currentStateNames.ToString ())
										{
											logic.node.RemoveDestination (i);
										}
									}
									break;
								}
								break;
							}
							break;
						}

						//RemoveAllAssetsPair ();
						ScriptsCreatedByDiamond.IdentifiedObjectsActions.RemoveNodeFieldPaires (uniqueID);

						logic.RemoveLogicNode (this);
					}
				}
			}
		}

		void RemoveNodeFromOptionsMenu ()
		{
			if (EditorUtility.DisplayDialog ("Delete Logic Node",
				"Are you sure you want to delete this Logic Node? \n" +
				"\n" +
				"It is an irreversible action !",
				"Yes", "no"))
			{
				switch (logicType)
				{
				case LogicType.computeOrOperation:
					switch (variableType)
					{
					case VariableType.Bool:
						switch (computeBoolType)
						{
						case ComputeBoolType.goToState:
							for (int i = 0; i < logic.node.graph.nodes.Count; i++)
							{
								if (logic.node.graph.nodes [i].nodeName == currentStateNames.ToString ())
								{
									logic.node.RemoveDestination (i);
								}
							}
							break;
						}
						break;
					}
					break;
				}

				//RemoveAllAssetsPair ();
				ScriptsCreatedByDiamond.IdentifiedObjectsActions.RemoveNodeFieldPaires (uniqueID);

				logic.RemoveLogicNode (this);
			}
		}

		public void RemoveNode ()
		{
			switch (logicType)
			{
			case LogicType.computeOrOperation:
				switch (variableType)
				{
				case VariableType.Bool:
					switch (computeBoolType)
					{
					case ComputeBoolType.goToState:
						for (int i = 0; i < logic.node.graph.nodes.Count; i++)
						{
							if (logic.node.graph.nodes [i].nodeName == currentStateNames.ToString ())
							{
								logic.node.RemoveDestination (i);
							}
						}
						break;
					}
					break;
				}
				break;
			}

			//RemoveAllAssetsPair ();
			ScriptsCreatedByDiamond.IdentifiedObjectsActions.RemoveNodeFieldPaires (uniqueID);

			//logic.RemoveLogicNode (this);
		}
		#endregion remove node


		/// <summary>
		/// Rename.
		/// Methodes for renaming the logicNode and checking to
		/// prevent names conflicts with other logicNodes
		/// </summary>
		#region rename
		void CheckNamesConflict ()
		{
			if (OtherLogicsNames ().Contains (nodeName))
			{
				EditorUtility.DisplayDialog ("Logic Node Same Name",
					sameNodeNameMessage, "Ok");

				renameCalled = true;
			}
		}

		void CheckNamesConflict_Update ()
		{
			if (OtherLogicsNames ().Contains (nodeName))
			{
				//Debug.LogWarning (sameNodeNameMessage);

				renameCalled = true;
			}
		}


		public void Update_4RandDigitesByLogicDuplication (string _4RandDigitesToAddInstead)
		{
			Update_4RandDigitesForUniqueID (_4RandDigitesToAddInstead);

			Update_4RandDigitesForAllInSources (_4RandDigitesToAddInstead);
		}

		void Update_4RandDigitesForUniqueID (string _4RandDigitesToAddInstead)
		{
			string uID_No_4RandDigites = UniqueID_No_4RandDigites (uniqueID);

			if (string.IsNullOrEmpty (uID_No_4RandDigites))
				return;

			uniqueID = uID_No_4RandDigites + _4RandDigitesToAddInstead;
		}

		void Update_4RandDigitesForAGivenUniqueID (string _4RandDigitesToAddInstead, ref string givenUniqueID)
		{
			string uID_No_4RandDigites = UniqueID_No_4RandDigites (givenUniqueID);

			if (string.IsNullOrEmpty (uID_No_4RandDigites))
				return;

			givenUniqueID = uID_No_4RandDigites + _4RandDigitesToAddInstead;
		}

		void Update_4RandDigitesForAllInSources (string _4RandDigitesToAddInstead)
		{
			for (int i = 0; i < inputsSources.Length; i++)
			{
				Update_4RandDigitesForAGivenUniqueID (_4RandDigitesToAddInstead, ref inputsSources [i]);
			}
		}

		string UniqueID_No_4RandDigites (string uIDToChange)
		{
			if (string.IsNullOrEmpty (uIDToChange))
				return "";

			string uID_4RandDigites = new string (
				new char []
				{
					uIDToChange [uniqueID.Length - 4],
					uIDToChange [uniqueID.Length - 3],
					uIDToChange [uniqueID.Length - 2],
					uIDToChange [uniqueID.Length - 1],
				});

			return StringTreatment.SubtractWeak (uIDToChange, uID_4RandDigites);
		}


		void DrawNameField ()
		{
			if (renameCalled)
			{
				nodeName = EditorGUI.TextField (
					GetSuitableRect (FieldDrawType.variable, 
						new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
						new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), 
					nodeName);

				nodeName = StringTreatment.ScriptName (nodeName);



				if (MouseKeysEvents.KeyIsUp (KeyCode.Return, eGlobal))
				{
					if ( ! string.IsNullOrEmpty (nodeName))
					{
						if (OtherLogicsNames ().Contains (nodeName))
						{
							EditorUtility.DisplayDialog ("Logic Node Same Name",
								sameNodeNameMessage, "Ok");
						}
						else if ( ! OtherLogicsNames ().Contains (nodeName))
						{
							renameCalled = false;
						}
					}
					else if (string.IsNullOrEmpty (nodeName))
					{
						EditorUtility.DisplayDialog ("Logic Node Name not valid",
							"Enter a valid Logic Node Name, \n" +
							"Empty names ar not allowed", "Ok");
					}
				}
			}
			else if ( ! renameCalled)
			{
				EditorGUI.LabelField (GetSuitableRect (FieldDrawType.label, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++)
					,
					new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), nodeName, Skins.guiSkin.GetStyle (Skins.logicNodeName));
			}

			DrawOptionButton ();
		}

		List <string> OtherLogicsNames ()
		{
			List <string> r = new List<string> ();

			for (int i = 0; i < logic.nodes.Count; i++)
			{
				if (logic.nodes [i] == this)
					continue;

				r.Add (logic.nodes [i].nodeName);
			}

			return r;
		}
		#endregion rename


		/// <summary>
		/// Link the inputs and the outputs.
		/// Methodes for linking the inputs and the outputs variables of the 
		/// logicNodes
		/// </summary>
		#region Link the inputs and the outputs variables
		void InitLinkedIndexToDestination ()
		{
			outputLinkedIndexToDestination = new int[outputsIDs.Length];

			for (int i = 0; i < outputLinkedIndexToDestination.Length; i++)
			{
				outputLinkedIndexToDestination [i] = -1;
			}


			outputListCounts = new int[outputsIDs.Length];

			for (int i = 0; i < outputListCounts.Length; i++)
			{
				outputListCounts [i] = 0;
			}
		}

		void InitInputSources ()
		{
			inputsSources = new string [inputsIDs.Length];

			for (int i = 0; i < inputsSources.Length; i++)
			{
				inputsSources [i] = "";
			}


			inputsSources_forPermition = new string [inputsIDs.Length];

			for (int i = 0; i < inputsSources_forPermition.Length; i++)
			{
				inputsSources_forPermition [i] = "";
			}
		}

		void InitPublicInputs ()
		{
			publicInputs = new bool[inputsIDs.Length];

			for (int i = 0; i < publicInputs.Length; i++)
			{
				publicInputs [i] = false;
			}


			attachedToGameObject = new bool[inputsIDs.Length];

			for (int i = 0; i < attachedToGameObject.Length; i++)
			{
				attachedToGameObject [i] = false;
			}
		}

		void InitPermittedInputs ()
		{
			permittedInputs = new bool[inputsIDs.Length];

			for (int i = 0; i < permittedInputs.Length; i++)
			{
				permittedInputs [i] = true;
			}
		}

		void InitDataFlowControlEnabled ()
		{
			if (dataFlowControlEnabled.Length == inputsIDs.Length)
				return;

			dataFlowControlEnabled = new bool[inputsIDs.Length];

			for (int i = 0; i < dataFlowControlEnabled.Length; i++)
			{
				dataFlowControlEnabled [i] = false;
			}
		}

		void ConnectWithProjectVariables ()
		{
			ConnectOutputsWithProjectVariables ();

			ConnectInputsWithProjectVariables ();
		}

		void ConnectOutputsWithProjectVariables ()
		{
			for (int i = 0; i < outputsRects.Length; i++)
			{
				if ( ! activeOutputs [i])
					continue;

				if (outputsRects [i].Contains (eGlobal.mousePosition))
				{
					for (int j = 0; j < Diamond.projectVariables.projectVariables.Count; j++)
					{
						if ( ! Diamond.projectVariables.projectVariables[j].setCalling)
							continue;
						if (Diamond.projectVariables.projectVariables[j].CorrespondingVariableType () !=
							outputsTypes [i])
							continue;

						if ( ! StringTreatment.IsEndWith_List (outputsIDs [i]))
						{
							Diamond.projectVariables.projectVariables[j].setSource = 
								uniqueID + 
								inOutAdressSeparator + 
								outputsIDs [i] + 
								inOutAdressSeparator +
								outAdressSignature;

							Diamond.projectVariables.projectVariables[j].setCalling = false;
						}
					}
				}
			}
		}

		void ConnectInputsWithProjectVariables ()
		{
			for (int i = 0; i < inputsRects.Length; i++)
			{
				if ( ! activeInputs [i])
					continue;
				
				if (inputsRects [i].Contains (eGlobal.mousePosition))
				{
					for (int j = 0; j < Diamond.projectVariables.projectVariables.Count; j++)
					{
						if ( ! Diamond.projectVariables.projectVariables[j].getSending)
							continue;
						if (Diamond.projectVariables.projectVariables[j].CorrespondingVariableType () !=
							inputsTypes [i])
							continue;

						inputsSources [i] = logic.inOutAdressCurrentToLink;
					}
				}
			}
		}


		List <int> GetActiveInputFieldsIndices ()
		{
			List <int> r = new List<int> ();

			for (int i = 0; i < activeInputsFields.Length; i++)
			{
				if (activeInputsFields [i])
				{
					r.Add (i);
				}
			}

			return r;
		}

		List <int> GetActiveInputIndices ()
		{
			List <int> r = new List<int> ();

			for (int i = 0; i < activeInputs.Length; i++)
			{
				if (activeInputs [i])
				{
					r.Add (i);
				}
			}

			return r;
		}

		List <int> GetActiveOutputIndices ()
		{
			List <int> r = new List<int> ();

			for (int i = 0; i < activeOutputs.Length; i++)
			{
				if (activeOutputs [i])
				{
					r.Add (i);
				}
			}

			return r;
		}


		void DisactivateAllOutputs ()
		{
			activeOutputs = new bool[outputsIDs.Length];

			for (int i = 0; i < activeOutputs.Length; i++)
			{
				activeOutputs [i] = false;
			}
		}

		void ActiveThisOutput (string ourputToActive)
		{
			for (int i = 0; i < activeOutputs.Length; i++)
			{
				if (outputsIDs [i] == ourputToActive)
				{
					activeOutputs [i] = true;
				}
			}
		}

		void DisactivateAllInputs ()
		{
			activeInputs = new bool[inputsIDs.Length];

			for (int i = 0; i < activeInputs.Length; i++)
			{
				activeInputs [i] = false;
			}

			activeInputsFields = new bool[inputsIDs.Length];

			for (int i = 0; i < activeInputsFields.Length; i++)
			{
				activeInputsFields [i] = false;
			}
		}


		void ActiveThisInput (string inputToActive)
		{
			for (int i = 0; i < activeInputs.Length; i++)
			{
				if (inputsIDs [i] == inputToActive)
				{
					activeInputs [i] = true;
				}
			}
		}

		void DisactivateThisInput (string inputToDisactivate)
		{
			for (int i = 0; i < activeInputs.Length; i++)
			{
				if (inputsIDs [i] == inputToDisactivate)
				{
					activeInputs [i] = false;
				}
			}
		}

		void DisactivateAllInputsAllOutputs ()
		{
			DisactivateAllInputs ();

			DisactivateAllOutputs ();
		}


		bool IsGameObject_0_InputLinked ()
		{
			if (string.IsNullOrEmpty (inputsSources [IndexOfInID (Enums.gameObjectValues_0_ID)]))
				return false;

			return true;
		}

		bool IsGameObject_0_AttachedTo ()
		{
			return attachedToGameObject [IndexOfInID (Enums.gameObjectValues_0_ID)];
		}




		void LinkInput_Bool_doIt_ID_boolValue_ID ( LogicNode sourceLogicNode)
		{
			doIT = sourceLogicNode.boolValue;
		}

		void LinkInput_Bool_doIt_ID_boolValues_0_ID ( LogicNode sourceLogicNode)
		{
			doIT = sourceLogicNode.boolValues [0];
		}

		void LinkInput_Bool_doIt_ID_boolValues_1_ID ( LogicNode sourceLogicNode)
		{
			doIT = sourceLogicNode.boolValues [1];
		}




		void LinkInput_RaycastV3_vector3Values_0_ID_raycastHitBarycentricCoordinate_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.raycastHitBarycentricCoordinate;
		}

		void LinkInput_RaycastV3_vector3Values_0_ID_raycastHitNormal_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.raycastHitNormal;
		}

		void LinkInput_RaycastV3_vector3Values_0_ID_raycastHitPoint_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.raycastHitPoint;
		}


		void LinkInput_RaycastV3_vector3Values_1_ID_raycastHitBarycentricCoordinate_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.raycastHitBarycentricCoordinate;
		}

		void LinkInput_RaycastV3_vector3Values_1_ID_raycastHitNormal_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.raycastHitNormal;
		}

		void LinkInput_RaycastV3_vector3Values_1_ID_raycastHitPoint_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.raycastHitPoint;
		}


		void LinkInput_RaycastV3_rayOrigin_ID_raycastHitBarycentricCoordinate_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.raycastHitBarycentricCoordinate);
		}

		void LinkInput_RaycastV3_rayOrigin_ID_raycastHitNormal_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.raycastHitNormal);
		}

		void LinkInput_RaycastV3_rayOrigin_ID_raycastHitPoint_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.raycastHitPoint);
		}


		void LinkInput_RaycastV3_rayDirection_ID_raycastHitBarycentricCoordinate_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.raycastHitBarycentricCoordinate);
		}

		void LinkInput_RaycastV3_rayDirection_ID_raycastHitNormal_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.raycastHitNormal);
		}

		void LinkInput_RaycastV3_rayDirection_ID_raycastHitPoint_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.raycastHitPoint);
		}



		void LinkInput_RaycastV3_vector2Values_0_ID_raycastHitLightmapCoord_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.raycastHitLightmapCoord;
		}

		void LinkInput_RaycastV3_vector2Values_0_ID_raycastHitTextureCoord_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.raycastHittextureCoord;
		}

		void LinkInput_RaycastV3_vector2Values_0_ID_raycastHitTextureCoord2_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.raycastHittextureCoord2;
		}


		void LinkInput_RaycastV3_vector2Values_1_ID_raycastHitLightmapCoord_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.raycastHitLightmapCoord;
		}

		void LinkInput_RaycastV3_vector2Values_1_ID_raycastHitTextureCoord_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.raycastHittextureCoord;
		}

		void LinkInput_RaycastV3_vector2Values_1_ID_raycastHitTextureCoord2_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.raycastHittextureCoord2;
		}



		void LinkInput_RaycastV3_ray2DOrigin_ID_raycastHitLightmapCoord_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.raycastHitLightmapCoord);
		}

		void LinkInput_RaycastV3_ray2DOrigin_ID_raycastHitTextureCoord_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.raycastHittextureCoord);
		}

		void LinkInput_RaycastV3_ray2DOrigin_ID_raycastHitTextureCoord2_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.raycastHittextureCoord2);
		}


		void LinkInput_RaycastV3_ray2DDirection_ID_raycastHitLightmapCoord_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.raycastHitLightmapCoord);
		}

		void LinkInput_RaycastV3_ray2DDirection_ID_raycastHitTextureCoord_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.raycastHittextureCoord);
		}

		void LinkInput_RaycastV3_ray2DDirection_ID_raycastHitTextureCoord2_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.raycastHittextureCoord2);
		}



		void LinkInput_RaycastV3_intValues_0_ID_raycastHitTriangleIndex_ID ( LogicNode sourceLogicNode)
		{
			intValues [0] = sourceLogicNode.raycastHitTriangleIndex;
		}

		void LinkInput_RaycastV3_intValues_1_ID_raycastHitTriangleIndex_ID ( LogicNode sourceLogicNode)
		{
			intValues [1] = sourceLogicNode.raycastHitTriangleIndex;
		}

		void LinkInput_RaycastV3_intValues_2_ID_raycastHitTriangleIndex_ID ( LogicNode sourceLogicNode)
		{
			intValues [2] = sourceLogicNode.raycastHitTriangleIndex;
		}



		void LinkInput_RaycastV3_floatValues_0_ID_raycastHitDistance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.raycastHitDistance;
		}

		void LinkInput_RaycastV3_floatValues_1_ID_raycastHitDistance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.raycastHitDistance;
		}

		void LinkInput_RaycastV3_floatValues_2_ID_raycastHitDistance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.raycastHitDistance;
		}






		void LinkInput_M44_floatValues_0_ID_m44Value_0_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [0];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_1_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [1];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_2_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [2];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_3_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [3];
		}


		void LinkInput_M44_floatValues_0_ID_m44Value_4_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [4];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_5_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [5];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_6_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [6];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_7_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [7];
		}


		void LinkInput_M44_floatValues_0_ID_m44Value_8_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [8];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_9_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [9];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_10_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [10];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_11_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [11];
		}


		void LinkInput_M44_floatValues_0_ID_m44Value_12_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [12];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_13_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [13];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_14_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [14];
		}

		void LinkInput_M44_floatValues_0_ID_m44Value_15_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44Value [15];
		}




		void LinkInput_M44_floatValues_1_ID_m44Value_0_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [0];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_1_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [1];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_2_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [2];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_3_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [3];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_4_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [4];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_5_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [5];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_6_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [6];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_7_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [7];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_8_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [8];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_9_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [9];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_10_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [10];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_11_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [11];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_12_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [12];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_13_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [13];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_14_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [14];
		}

		void LinkInput_M44_floatValues_1_ID_m44Value_15_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44Value [15];
		}


		void LinkInput_M44_floatValues_2_ID_m44Value_0_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [0];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_1_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [1];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_2_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [2];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_3_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [3];
		}


		void LinkInput_M44_floatValues_2_ID_m44Value_4_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [4];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_5_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [5];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_6_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [6];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_7_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [7];
		}


		void LinkInput_M44_floatValues_2_ID_m44Value_8_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [8];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_9_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [9];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_10_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [10];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_11_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [11];
		}


		void LinkInput_M44_floatValues_2_ID_m44Value_12_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [12];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_13_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [13];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_14_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [14];
		}

		void LinkInput_M44_floatValues_2_ID_m44Value_15_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44Value [15];
		}



		void LinkInput_M44_floatValues_0_ID_m44ValueDeterminant_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.m44ValueDeterminant;
		}

		void LinkInput_M44_floatValues_1_ID_m44ValueDeterminant_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.m44ValueDeterminant;
		}

		void LinkInput_M44_floatValues_2_ID_m44ValueDeterminant_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.m44ValueDeterminant;
		}




		void LinkInput_M44_boolValues_0_ID_m44ValueIsIdentity_ID ( LogicNode sourceLogicNode)
		{
			boolValues [0] = sourceLogicNode.m44ValueIsIdentity;
		}

		void LinkInput_M44_boolValues_0_ID_m44ValueInvertible_ID ( LogicNode sourceLogicNode)
		{
			boolValues [0] = sourceLogicNode.m44ValueInvertible;
		}


		void LinkInput_M44_boolValues_1_ID_m44ValueIsIdentity_ID ( LogicNode sourceLogicNode)
		{
			boolValues [1] = sourceLogicNode.m44ValueIsIdentity;
		}

		void LinkInput_M44_boolValues_1_ID_m44ValueInvertible_ID ( LogicNode sourceLogicNode)
		{
			boolValues [1] = sourceLogicNode.m44ValueInvertible;
		}



		void LinkInput_Material_materialValues_0_materialValue ( LogicNode sourceLogicNode)
		{
			materialValues [0] = sourceLogicNode.materialValue;
		}

		void LinkInput_Material_materialValues_0_materialValues_0 ( LogicNode sourceLogicNode)
		{
			materialValues [0] = sourceLogicNode.materialValues [0];
		}

		void LinkInput_Material_materialValues_0_materialValues_1 ( LogicNode sourceLogicNode)
		{
			materialValues [0] = sourceLogicNode.materialValues [1];
		}


		void LinkInput_Material_materialValues_1_materialValue ( LogicNode sourceLogicNode)
		{
			materialValues [1] = sourceLogicNode.materialValue;
		}

		void LinkInput_Material_materialValues_1_materialValues_0 ( LogicNode sourceLogicNode)
		{
			materialValues [1] = sourceLogicNode.materialValues [0];
		}

		void LinkInput_Material_materialValues_1_materialValues_1 ( LogicNode sourceLogicNode)
		{
			materialValues [1] = sourceLogicNode.materialValues [1];
		}





		void LinkInput_Texture2D_texture2DValues_0_ID_texture2DValue_ID ( LogicNode sourceLogicNode)
		{
			texture2DValues [0] = sourceLogicNode.texture2DValue;
		}

		void LinkInput_Texture2D_texture2DValues_0_ID_texture2DValues_0_ID ( LogicNode sourceLogicNode)
		{
			texture2DValues [0] = sourceLogicNode.texture2DValues [0];
		}

		void LinkInput_Texture2D_texture2DValues_0_ID_texture2DValues_1_ID ( LogicNode sourceLogicNode)
		{
			texture2DValues [0] = sourceLogicNode.texture2DValues [1];
		}


		void LinkInput_Texture2D_texture2DValues_1_ID_texture2DValue_ID ( LogicNode sourceLogicNode)
		{
			texture2DValues [1] = sourceLogicNode.texture2DValue;
		}

		void LinkInput_Texture2D_texture2DValues_1_ID_texture2DValues_0_ID ( LogicNode sourceLogicNode)
		{
			texture2DValues [1] = sourceLogicNode.texture2DValues [0];
		}

		void LinkInput_Texture2D_texture2DValues_1_ID_texture2DValues_1_ID ( LogicNode sourceLogicNode)
		{
			texture2DValues [1] = sourceLogicNode.texture2DValues [1];
		}



		void LinkInput_Shader_shaderValues_0_ID_shaderValue_ID ( LogicNode sourceLogicNode)
		{
			shaderValues [0] = sourceLogicNode.shaderValue;
		}

		void LinkInput_Shader_shaderValues_0_ID_shaderValues_0_ID ( LogicNode sourceLogicNode)
		{
			shaderValues [0] = sourceLogicNode.shaderValues [0];
		}

		void LinkInput_Shader_shaderValues_0_ID_shaderValues_1_ID ( LogicNode sourceLogicNode)
		{
			shaderValues [0] = sourceLogicNode.shaderValues [1];
		}


		void LinkInput_Shader_shaderValues_1_ID_shaderValue_ID ( LogicNode sourceLogicNode)
		{
			shaderValues [1] = sourceLogicNode.shaderValue;
		}

		void LinkInput_Shader_shaderValues_1_ID_shaderValues_0_ID ( LogicNode sourceLogicNode)
		{
			shaderValues [1] = sourceLogicNode.shaderValues [0];
		}

		void LinkInput_Shader_shaderValues_1_ID_shaderValues_1_ID ( LogicNode sourceLogicNode)
		{
			shaderValues [1] = sourceLogicNode.shaderValues [1];
		}





		void LinkInput_Vector4_vector4Values_0_ID_vector4Value_ID ( LogicNode sourceLogicNode)
		{
			vector4Values [0] = sourceLogicNode.vector4Value;
		}

		void LinkInput_Vector4_vector4Values_0_ID_vector4Values_0_ID ( LogicNode sourceLogicNode)
		{
			vector4Values [0] = sourceLogicNode.vector4Values [0];
		}

		void LinkInput_Vector4_vector4Values_0_ID_vector4Values_1_ID ( LogicNode sourceLogicNode)
		{
			vector4Values [0] = sourceLogicNode.vector4Values [1];
		}



		void LinkInput_Vector4_vector4Values_1_ID_vector4Value_ID ( LogicNode sourceLogicNode)
		{
			vector4Values [1] = sourceLogicNode.vector4Value;
		}

		void LinkInput_Vector4_vector4Values_1_ID_vector4Values_0_ID ( LogicNode sourceLogicNode)
		{
			vector4Values [1] = sourceLogicNode.vector4Values [0];
		}

		void LinkInput_Vector4_vector4Values_1_ID_vector4Values_1_ID ( LogicNode sourceLogicNode)
		{
			vector4Values [1] = sourceLogicNode.vector4Values [1];
		}



		void LinkInput_OffMeshLink_vector3Values_0_ID_OffMeshLinkData_startPosition_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.OffMeshLinkData_startPosition;
		}

		void LinkInput_OffMeshLink_vector3Values_0_ID_OffMeshLinkData_endPosition_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.OffMeshLinkData_endPosition;
		}


		void LinkInput_OffMeshLink_vector3Values_1_ID_OffMeshLinkData_startPosition_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.OffMeshLinkData_startPosition;
		}

		void LinkInput_OffMeshLink_vector3Values_1_ID_OffMeshLinkData_endPosition_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.OffMeshLinkData_endPosition;
		}


		void LinkInput_OffMeshLink_rayOrigin_ID_OffMeshLinkData_startPosition_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.OffMeshLinkData_startPosition);
		}

		void LinkInput_OffMeshLink_rayOrigin_ID_OffMeshLinkData_endPosition_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.OffMeshLinkData_endPosition);
		}

		void LinkInput_OffMeshLink_rayDirection_ID_OffMeshLinkData_startPosition_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.OffMeshLinkData_startPosition);
		}

		void LinkInput_OffMeshLink_rayDirection_ID_OffMeshLinkData_endPosition_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.OffMeshLinkData_endPosition);
		}



		void LinkInput_OffMeshLink_boolValues_0_ID_OffMeshLinkData_activated_ID ( LogicNode sourceLogicNode)
		{
			boolValues [0] = sourceLogicNode.OffMeshLinkData_activated;
		}

		void LinkInput_OffMeshLink_boolValues_0_ID_OffMeshLinkData_valid_ID ( LogicNode sourceLogicNode)
		{
			boolValues [0] = sourceLogicNode.OffMeshLinkData_valid;
		}


		void LinkInput_OffMeshLink_boolValues_1_ID_OffMeshLinkData_activated_ID ( LogicNode sourceLogicNode)
		{
			boolValues [1] = sourceLogicNode.OffMeshLinkData_activated;
		}

		void LinkInput_OffMeshLink_boolValues_1_ID_OffMeshLinkData_valid_ID ( LogicNode sourceLogicNode)
		{
			boolValues [1] = sourceLogicNode.OffMeshLinkData_valid;
		}


		void LinkInput_OffMeshLink_doIt_ID_OffMeshLinkData_activated_ID ( LogicNode sourceLogicNode)
		{
			doIT = sourceLogicNode.OffMeshLinkData_activated;
		}

		void LinkInput_OffMeshLink_doIt_ID_OffMeshLinkData_valid_ID ( LogicNode sourceLogicNode)
		{
			doIT = sourceLogicNode.OffMeshLinkData_valid;
		}


		void LinkInput_navMeshHit_intValues_0_ID_NavMeshHit_mask_ID ( LogicNode sourceLogicNode)
		{
			intValues [0] = sourceLogicNode.NavMeshHit_mask;
		}

		void LinkInput_navMeshHit_intValues_1_ID_NavMeshHit_mask_ID ( LogicNode sourceLogicNode)
		{
			intValues [1] = sourceLogicNode.NavMeshHit_mask;
		}

		void LinkInput_navMeshHit_intValues_2_ID_NavMeshHit_mask_ID ( LogicNode sourceLogicNode)
		{
			intValues [2] = sourceLogicNode.NavMeshHit_mask;
		}



		void LinkInput_navMeshHit_vector3Values_0_ID_NavMeshHit_normal_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.NavMeshHit_normal;
		}

		void LinkInput_navMeshHit_vector3Values_0_ID_NavMeshHit_position_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.NavMeshHit_position;
		}


		void LinkInput_navMeshHit_vector3Values_1_ID_NavMeshHit_normal_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.NavMeshHit_normal;
		}

		void LinkInput_navMeshHit_vector3Values_1_ID_NavMeshHit_position_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.NavMeshHit_position;
		}


		void LinkInput_navMeshHit_rayOrigin_ID_NavMeshHit_normal_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.NavMeshHit_normal);
		}

		void LinkInput_navMeshHit_rayOrigin_ID_NavMeshHit_position_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.NavMeshHit_position);
		}


		void LinkInput_navMeshHit_rayDirection_ID_NavMeshHit_normal_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.NavMeshHit_normal);
		}

		void LinkInput_navMeshHit_rayDirection_ID_NavMeshHit_position_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.NavMeshHit_position);
		}



		void LinkInput_mesh_meshValues_0_ID_meshValue_ID ( LogicNode sourceLogicNode)
		{
			meshValues [0] = sourceLogicNode.meshValue;
		}

		void LinkInput_mesh_meshValues_0_ID_meshValues_0_ID ( LogicNode sourceLogicNode)
		{
			meshValues [0] = sourceLogicNode.meshValues [0];
		}

		void LinkInput_mesh_meshValues_0_ID_meshValues_1_ID ( LogicNode sourceLogicNode)
		{
			meshValues [0] = sourceLogicNode.meshValues [1];
		}


		void LinkInput_mesh_meshValues_1_ID_meshValue_ID ( LogicNode sourceLogicNode)
		{
			meshValues [1] = sourceLogicNode.meshValue;
		}

		void LinkInput_mesh_meshValues_1_ID_meshValues_0_ID ( LogicNode sourceLogicNode)
		{
			meshValues [1] = sourceLogicNode.meshValues [0];
		}

		void LinkInput_mesh_meshValues_1_ID_meshValues_1_ID ( LogicNode sourceLogicNode)
		{
			meshValues [1] = sourceLogicNode.meshValues [1];
		}






		void LinkInput_Matrix4x4_m44Value_Input_0_entier_ID_m44Value_entier_ID ( LogicNode sourceLogicNode)
		{
			m44Value_Input_entier [0] = sourceLogicNode.m44Value_entier;
		}

		void LinkInput_Matrix4x4_m44Value_Input_0_entier_ID_m44Value_Input_0_entier_ID ( LogicNode sourceLogicNode)
		{
			m44Value_Input_entier [0] = sourceLogicNode.m44Value_Input_entier [0];
		}

		void LinkInput_Matrix4x4_m44Value_Input_0_entier_ID_m44Value_Input_1_entier_ID ( LogicNode sourceLogicNode)
		{
			m44Value_Input_entier [0] = sourceLogicNode.m44Value_Input_entier [1];
		}


		void LinkInput_Matrix4x4_m44Value_Input_1_entier_ID_m44Value_entier_ID ( LogicNode sourceLogicNode)
		{
			m44Value_Input_entier [1] = sourceLogicNode.m44Value_entier;
		}

		void LinkInput_Matrix4x4_m44Value_Input_1_entier_ID_m44Value_Input_0_entier_ID ( LogicNode sourceLogicNode)
		{
			m44Value_Input_entier [1] = sourceLogicNode.m44Value_Input_entier [0];
		}

		void LinkInput_Matrix4x4_m44Value_Input_1_entier_ID_m44Value_Input_1_entier_ID ( LogicNode sourceLogicNode)
		{
			m44Value_Input_entier [1] = sourceLogicNode.m44Value_Input_entier [1];
		}



		void LinkInput_rect_rectValues_0_ID_rectValue_ID ( LogicNode sourceLogicNode)
		{
			rectValues [0] = sourceLogicNode.rectValue;
		}

		void LinkInput_rect_rectValues_0_ID_rectValues_0_ID ( LogicNode sourceLogicNode)
		{
			rectValues [0] = sourceLogicNode.rectValues [0];
		}

		void LinkInput_rect_rectValues_0_ID_rectValues_1_ID ( LogicNode sourceLogicNode)
		{
			rectValues [0] = sourceLogicNode.rectValues [1];
		}


		void LinkInput_rect_rectValues_1_ID_rectValue_ID ( LogicNode sourceLogicNode)
		{
			rectValues [1] = sourceLogicNode.rectValue;
		}

		void LinkInput_rect_rectValues_1_ID_rectValues_0_ID ( LogicNode sourceLogicNode)
		{
			rectValues [1] = sourceLogicNode.rectValues [0];
		}

		void LinkInput_rect_rectValues_1_ID_rectValues_1_ID ( LogicNode sourceLogicNode)
		{
			rectValues [1] = sourceLogicNode.rectValues [1];
		}





		void LinkInput_GameObjectList_gameObjectsListEntire0_ID_gameObjectsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref gameObjectsListValues [0], sourceLogicNode.gameObjectsListValue);
		}

		void LinkInput_GameObjectList_gameObjectsListEntire0_ID_gameObjectsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref gameObjectsListValues [0], sourceLogicNode.gameObjectsListValues [0]);
		}

		void LinkInput_GameObjectList_gameObjectsListEntire0_ID_gameObjectsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref gameObjectsListValues [0], sourceLogicNode.gameObjectsListValues [1]);
		}


		void LinkInput_GameObjectList_gameObjectsListEntire1_ID_gameObjectsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref gameObjectsListValues [1], sourceLogicNode.gameObjectsListValue);
		}

		void LinkInput_GameObjectList_gameObjectsListEntire1_ID_gameObjectsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref gameObjectsListValues [1], sourceLogicNode.gameObjectsListValues [0]);
		}

		void LinkInput_GameObjectList_gameObjectsListEntire1_ID_gameObjectsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref gameObjectsListValues [1], sourceLogicNode.gameObjectsListValues [1]);
		}




		void LinkInput_boolList_boolsListEntire0_ID_boolsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref boolsListValues [0], sourceLogicNode.boolsListValue);
		}

		void LinkInput_boolList_boolsListEntire0_ID_boolsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref boolsListValues [0], sourceLogicNode.boolsListValues [0]);
		}

		void LinkInput_boolList_boolsListEntire0_ID_boolsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref boolsListValues [0], sourceLogicNode.boolsListValues [1]);
		}


		void LinkInput_boolList_boolsListEntire1_ID_boolsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref boolsListValues [1], sourceLogicNode.boolsListValue);
		}

		void LinkInput_boolList_boolsListEntire1_ID_boolsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref boolsListValues [1], sourceLogicNode.boolsListValues [0]);
		}

		void LinkInput_boolList_boolsListEntire1_ID_boolsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref boolsListValues [1], sourceLogicNode.boolsListValues [1]);
		}





		void LinkInput_colorList_colorsListEntire0_colorsListEntire ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref colorsListValues [0], sourceLogicNode.colorsListValue);
		}

		void LinkInput_colorList_colorsListEntire0_colorsListEntire0 ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref colorsListValues [0], sourceLogicNode.colorsListValues [0]);
		}

		void LinkInput_colorList_colorsListEntire0_colorsListEntire1 ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref colorsListValues [0], sourceLogicNode.colorsListValues [1]);
		}


		void LinkInput_colorList_colorsListEntire1_colorsListEntire ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref colorsListValues [1], sourceLogicNode.colorsListValue);
		}

		void LinkInput_colorList_colorsListEntire1_colorsListEntire0 ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref colorsListValues [1], sourceLogicNode.colorsListValues [0]);
		}

		void LinkInput_colorList_colorsListEntire1_colorsListEntire1 ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref colorsListValues [1], sourceLogicNode.colorsListValues [1]);
		}



		void LinkInput_floatsList_floatsListEntire0_ID_floatsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref floatsListValues [0], sourceLogicNode.floatsListValue);
		}

		void LinkInput_floatsList_floatsListEntire0_ID_floatsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref floatsListValues [0], sourceLogicNode.floatsListValues [0]);
		}

		void LinkInput_floatsList_floatsListEntire0_ID_floatsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref floatsListValues [0], sourceLogicNode.floatsListValues [1]);
		}


		void LinkInput_floatsList_floatsListEntire1_ID_floatsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref floatsListValues [1], sourceLogicNode.floatsListValue);
		}

		void LinkInput_floatsList_floatsListEntire1_ID_floatsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref floatsListValues [1], sourceLogicNode.floatsListValues [0]);
		}

		void LinkInput_floatsList_floatsListEntire1_ID_floatsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref floatsListValues [1], sourceLogicNode.floatsListValues [1]);
		}





		void LinkInput_intsList_intsListEntire0_ID_intsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref intsListValues [0], sourceLogicNode.intsListValue);
		}

		void LinkInput_intsList_intsListEntire0_ID_intsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref intsListValues [0], sourceLogicNode.intsListValues [0]);
		}

		void LinkInput_intsList_intsListEntire0_ID_intsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref intsListValues [0], sourceLogicNode.intsListValues [1]);
		}


		void LinkInput_intsList_intsListEntire1_ID_intsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref intsListValues [1], sourceLogicNode.intsListValue);
		}

		void LinkInput_intsList_intsListEntire1_ID_intsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref intsListValues [1], sourceLogicNode.intsListValues [0]);
		}

		void LinkInput_intsList_intsListEntire1_ID_intsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref intsListValues [1], sourceLogicNode.intsListValues [1]);
		}



		void LinkInput_stringsList_stringsListEntire0_ID_stringsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref stringsListValues [0], sourceLogicNode.stringsListValue);
		}

		void LinkInput_stringsList_stringsListEntire0_ID_stringsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref stringsListValues [0], sourceLogicNode.stringsListValues [0]);
		}

		void LinkInput_stringsList_stringsListEntire0_ID_stringsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref stringsListValues [0], sourceLogicNode.stringsListValues [1]);
		}


		void LinkInput_stringsList_stringsListEntire1_ID_stringsListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref stringsListValues [1], sourceLogicNode.stringsListValue);
		}

		void LinkInput_stringsList_stringsListEntire1_ID_stringsListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref stringsListValues [1], sourceLogicNode.stringsListValues [0]);
		}

		void LinkInput_stringsList_stringsListEntire1_ID_stringsListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref stringsListValues [1], sourceLogicNode.stringsListValues [1]);
		}


		void LinkInput_vector2List_vector2ListEntire0_ID_vector2ListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector2ListValues [0], sourceLogicNode.vector2ListValue);
		}

		void LinkInput_vector2List_vector2ListEntire0_ID_vector2ListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector2ListValues [0], sourceLogicNode.vector2ListValues [0]);
		}

		void LinkInput_vector2List_vector2ListEntire0_ID_vector2ListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector2ListValues [0], sourceLogicNode.vector2ListValues [1]);
		}


		void LinkInput_vector2List_vector2ListEntire1_ID_vector2ListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector2ListValues [1], sourceLogicNode.vector2ListValue);
		}

		void LinkInput_vector2List_vector2ListEntire1_ID_vector2ListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector2ListValues [1], sourceLogicNode.vector2ListValues [0]);
		}

		void LinkInput_vector2List_vector2ListEntire1_ID_vector2ListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector2ListValues [1], sourceLogicNode.vector2ListValues [1]);
		}



		void LinkInput_vector3List_vector3ListEntire0_ID_vector3ListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector3ListValues [0], sourceLogicNode.vector3ListValue);
		}

		void LinkInput_vector3List_vector3ListEntire0_ID_vector3ListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector3ListValues [0], sourceLogicNode.vector3ListValues [0]);
		}

		void LinkInput_vector3List_vector3ListEntire0_ID_vector3ListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector3ListValues [0], sourceLogicNode.vector3ListValues [1]);
		}

		void LinkInput_vector3List_vector3ListEntire1_ID_vector3ListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector3ListValues [1], sourceLogicNode.vector3ListValue);
		}

		void LinkInput_vector3List_vector3ListEntire1_ID_vector3ListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector3ListValues [1], sourceLogicNode.vector3ListValues [0]);
		}

		void LinkInput_vector3List_vector3ListEntire1_ID_vector3ListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector3ListValues [1], sourceLogicNode.vector3ListValues [1]);
		}



		void LinkInput_materialsList_materialListEntire0_ID_materialListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref materialsListValues [0], sourceLogicNode.materialsListValue);
		}

		void LinkInput_materialsList_materialListEntire0_ID_materialListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref materialsListValues [0], sourceLogicNode.materialsListValues [0]);
		}

		void LinkInput_materialsList_materialListEntire0_ID_materialListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref materialsListValues [0], sourceLogicNode.materialsListValues [1]);
		}


		void LinkInput_materialsList_materialListEntire1_ID_materialListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref materialsListValues [1], sourceLogicNode.materialsListValue);
		}

		void LinkInput_materialsList_materialListEntire1_ID_materialListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref materialsListValues [1], sourceLogicNode.materialsListValues [0]);
		}

		void LinkInput_materialsList_materialListEntire1_ID_materialListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref materialsListValues [1], sourceLogicNode.materialsListValues [1]);
		}




		void LinkInput_texture2dList_texture2DListEntire0_ID_texture2DListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref texture2DListValues [0], sourceLogicNode.texture2DListValue);
		}

		void LinkInput_texture2dList_texture2DListEntire0_ID_texture2DListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref texture2DListValues [0], sourceLogicNode.texture2DListValues [0]);
		}

		void LinkInput_texture2dList_texture2DListEntire0_ID_texture2DListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref texture2DListValues [0], sourceLogicNode.texture2DListValues [1]);
		}


		void LinkInput_texture2dList_texture2DListEntire1_ID_texture2DListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref texture2DListValues [1], sourceLogicNode.texture2DListValue);
		}

		void LinkInput_texture2dList_texture2DListEntire1_ID_texture2DListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref texture2DListValues [1], sourceLogicNode.texture2DListValues [0]);
		}

		void LinkInput_texture2dList_texture2DListEntire1_ID_texture2DListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref texture2DListValues [1], sourceLogicNode.texture2DListValues [1]);
		}



		void LinkInput_shadersList_shaderListEntire0_ID_shaderListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref shaderListValues [0], sourceLogicNode.shaderListValue);
		}

		void LinkInput_shadersList_shaderListEntire0_ID_shaderListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref shaderListValues [0], sourceLogicNode.shaderListValues [0]);
		}

		void LinkInput_shadersList_shaderListEntire0_ID_shaderListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref shaderListValues [0], sourceLogicNode.shaderListValues [1]);
		}


		void LinkInput_shadersList_shaderListEntire1_ID_shaderListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref shaderListValues [1], sourceLogicNode.shaderListValue);
		}

		void LinkInput_shadersList_shaderListEntire1_ID_shaderListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref shaderListValues [1], sourceLogicNode.shaderListValues [0]);
		}

		void LinkInput_shadersList_shaderListEntire1_ID_shaderListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref shaderListValues [1], sourceLogicNode.shaderListValues [1]);
		}




		void LinkInput_vector4List_vector4ListEntire0_ID_vector4ListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector4ListValues [0], sourceLogicNode.vector4ListValue);
		}

		void LinkInput_vector4List_vector4ListEntire0_ID_vector4ListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector4ListValues [0], sourceLogicNode.vector4ListValues [0]);
		}

		void LinkInput_vector4List_vector4ListEntire0_ID_vector4ListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector4ListValues [0], sourceLogicNode.vector4ListValues [1]);
		}


		void LinkInput_vector4List_vector4ListEntire1_ID_vector4ListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector4ListValues [1], sourceLogicNode.vector4ListValue);
		}

		void LinkInput_vector4List_vector4ListEntire1_ID_vector4ListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector4ListValues [1], sourceLogicNode.vector4ListValues [0]);
		}

		void LinkInput_vector4List_vector4ListEntire1_ID_vector4ListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref vector4ListValues [1], sourceLogicNode.vector4ListValues [1]);
		}



		void LinkInput_rectList_rectListEntire0_ID_rectListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref rectListValues [0], sourceLogicNode.rectListValue);
		}

		void LinkInput_rectList_rectListEntire0_ID_rectListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref rectListValues [0], sourceLogicNode.rectListValues [0]);
		}

		void LinkInput_rectList_rectListEntire0_ID_rectListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref rectListValues [0], sourceLogicNode.rectListValues [1]);
		}


		void LinkInput_rectList_rectListEntire1_ID_rectListEntire_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref rectListValues [1], sourceLogicNode.rectListValue);
		}

		void LinkInput_rectList_rectListEntire1_ID_rectListEntire0_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref rectListValues [1], sourceLogicNode.rectListValues [0]);
		}

		void LinkInput_rectList_rectListEntire1_ID_rectListEntire1_ID ( LogicNode sourceLogicNode)
		{
			ListOperations.ListValuesToAnother (ref rectListValues [1], sourceLogicNode.rectListValues [1]);
		}



		void LinkInput_hit2D_floatValues_0_ID_hit2D_distance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.hit2D_distance;
		}

		void LinkInput_hit2D_floatValues_0_ID_hit2D_fraction_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.hit2D_fraction;
		}


		void LinkInput_hit2D_floatValues_1_ID_hit2D_distance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.hit2D_distance;
		}

		void LinkInput_hit2D_floatValues_1_ID_hit2D_fraction_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.hit2D_fraction;
		}


		void LinkInput_hit2D_floatValues_2_ID_hit2D_distance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.hit2D_distance;
		}

		void LinkInput_hit2D_floatValues_2_ID_hit2D_fraction_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.hit2D_fraction;
		}




		void LinkInput_hit2D_vector2Values_0_ID_hit2D_centroid_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.hit2D_centroid;
		}

		void LinkInput_hit2D_vector2Values_0_ID_hit2D_normal_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.hit2D_normal;
		}

		void LinkInput_hit2D_vector2Values_0_ID_hit2D_point_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.hit2D_point;
		}


		void LinkInput_hit2D_vector2Values_1_ID_hit2D_centroid_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.hit2D_centroid;
		}

		void LinkInput_hit2D_vector2Values_1_ID_hit2D_normal_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.hit2D_normal;
		}

		void LinkInput_hit2D_vector2Values_1_ID_hit2D_point_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.hit2D_point;
		}





		void LinkInput_touch_vector2Values_0_ID_touch_position_ID  ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.touch_position;
		}

		void LinkInput_touch_vector2Values_0_ID_touch_deltaPosition_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.touch_deltaPosition;
		}

		void LinkInput_touch_vector2Values_0_ID_touch_rawPosition_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.touch_rawPosition;
		}


		void LinkInput_touch_vector2Values_1_ID_touch_position_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.touch_position;
		}

		void LinkInput_touch_vector2Values_1_ID_touch_deltaPosition_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.touch_deltaPosition;
		}

		void LinkInput_touch_vector2Values_1_ID_touch_rawPosition_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.touch_rawPosition;
		}


		void LinkInput_touch_ray2DOrigin_ID_touch_position_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.touch_position);
		}

		void LinkInput_touch_ray2DOrigin_ID_touch_deltaPosition_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.touch_deltaPosition);
		}

		void LinkInput_touch_ray2DOrigin_ID_touch_rawPosition_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.touch_rawPosition);
		}


		void LinkInput_touch_ray2DDirection_ID_touch_position_ID  ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.touch_position);
		}

		void LinkInput_touch_ray2DDirection_ID_touch_deltaPosition_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.touch_deltaPosition);
		}

		void LinkInput_touch_ray2DDirection_ID_touch_rawPosition_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.touch_rawPosition);
		}



		void LinkInput_touch_floatValues_0_ID_touch_altitudeAngle_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.touch_altitudeAngle;
		}

		void LinkInput_touch_floatValues_0_ID_touch_azimuthAngle_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.touch_azimuthAngle;
		}

		void LinkInput_touch_floatValues_0_ID_touch_deltaTime_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.touch_deltaTime;
		}

		void LinkInput_touch_floatValues_0_ID_touch_maximumPossiblePressure_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.touch_maximumPossiblePressure;
		}

		void LinkInput_touch_floatValues_0_ID_touch_pressure_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.touch_pressure;
		}

		void LinkInput_touch_floatValues_0_ID_touch_radius_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.touch_radius;
		}

		void LinkInput_touch_floatValues_0_ID_touch_radiusVariance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.touch_radiusVariance;
		}



		void LinkInput_touch_floatValues_1_ID_touch_altitudeAngle_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.touch_altitudeAngle;
		}

		void LinkInput_touch_floatValues_1_ID_touch_azimuthAngle_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.touch_azimuthAngle;
		}

		void LinkInput_touch_floatValues_1_ID_touch_deltaTime_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.touch_deltaTime;
		}

		void LinkInput_touch_floatValues_1_ID_touch_maximumPossiblePressure_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.touch_maximumPossiblePressure;
		}

		void LinkInput_touch_floatValues_1_ID_touch_pressure_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.touch_pressure;
		}

		void LinkInput_touch_floatValues_1_ID_touch_radius_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.touch_radius;
		}

		void LinkInput_touch_floatValues_1_ID_touch_radiusVariance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.touch_radiusVariance;
		}



		void LinkInput_touch_floatValues_2_ID_touch_altitudeAngle_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.touch_altitudeAngle;
		}

		void LinkInput_touch_floatValues_2_ID_touch_azimuthAngle_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.touch_azimuthAngle;
		}

		void LinkInput_touch_floatValues_2_ID_touch_deltaTime_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.touch_deltaTime;
		}

		void LinkInput_touch_floatValues_2_ID_touch_maximumPossiblePressure_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.touch_maximumPossiblePressure;
		}

		void LinkInput_touch_floatValues_2_ID_touch_pressure_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.touch_pressure;
		}

		void LinkInput_touch_floatValues_2_ID_touch_radius_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.touch_radius;
		}

		void LinkInput_touch_floatValues_2_ID_touch_radiusVariance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.touch_radiusVariance;
		}







		void LinkInput_touch_intValues_0_ID_touch_fingerId_ID ( LogicNode sourceLogicNode)
		{
			intValues [0] = sourceLogicNode.touch_fingerId;
		}

		void LinkInput_touch_intValues_0_ID_touch_tapCount_ID ( LogicNode sourceLogicNode)
		{
			intValues [0] = sourceLogicNode.touch_tapCount;
		}


		void LinkInput_touch_intValues_1_ID_touch_fingerId_ID ( LogicNode sourceLogicNode)
		{
			intValues [1] = sourceLogicNode.touch_fingerId;
		}

		void LinkInput_touch_intValues_1_ID_touch_tapCount_ID ( LogicNode sourceLogicNode)
		{
			intValues [1] = sourceLogicNode.touch_tapCount;
		}


		void LinkInput_touch_intValues_2_ID_touch_fingerId_ID ( LogicNode sourceLogicNode)
		{
			intValues [2] = sourceLogicNode.touch_fingerId;
		}

		void LinkInput_touch_intValues_2_ID_touch_tapCount_ID ( LogicNode sourceLogicNode)
		{
			intValues [2] = sourceLogicNode.touch_tapCount;
		}




		void LinkInput_touch_stringValues_0_ID_touch_phase_ID ( LogicNode sourceLogicNode)
		{
			stringValues [0] = sourceLogicNode.touch_phase.ToString ();
		}

		void LinkInput_touch_stringValues_0_ID_touch_type_ID ( LogicNode sourceLogicNode)
		{
			stringValues [0] = sourceLogicNode.touch_type.ToString ();
		}


		void LinkInput_touch_stringValues_1_ID_touch_phase_ID ( LogicNode sourceLogicNode)
		{
			stringValues [1] = sourceLogicNode.touch_phase.ToString ();
		}

		void LinkInput_touch_stringValues_1_ID_touch_type_ID ( LogicNode sourceLogicNode)
		{
			stringValues [1] = sourceLogicNode.touch_type.ToString ();
		}


		void LinkInputAction (int inIndex, string inID, string sourceNodeOutID, LogicNode sourceLogicNode)
		{	
			if ( ! logic.playing)
				return;

			if ( ! permittedInputs [inIndex])
				return;

			switch (inputsTypes [inIndex])
			{
			case VariableType.rectsList:
				switch (inID)
				{
				case Enums.rectListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.rectListEntire_ID:
						LinkInput_rectList_rectListEntire0_ID_rectListEntire_ID ( sourceLogicNode);
						break;

					case Enums.rectListEntire0_ID:
						LinkInput_rectList_rectListEntire0_ID_rectListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.rectListEntire1_ID:
						LinkInput_rectList_rectListEntire0_ID_rectListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rectListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.rectListEntire_ID:
						LinkInput_rectList_rectListEntire1_ID_rectListEntire_ID ( sourceLogicNode);
						break;

					case Enums.rectListEntire0_ID:
						LinkInput_rectList_rectListEntire1_ID_rectListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.rectListEntire1_ID:
						LinkInput_rectList_rectListEntire1_ID_rectListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;


			case VariableType.vector4List:
				switch (inID)
				{
				case Enums.vector4ListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector4ListEntire_ID:
						LinkInput_vector4List_vector4ListEntire0_ID_vector4ListEntire_ID ( sourceLogicNode);
						break;

					case Enums.vector4ListEntire0_ID:
						LinkInput_vector4List_vector4ListEntire0_ID_vector4ListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.vector4ListEntire1_ID:
						LinkInput_vector4List_vector4ListEntire0_ID_vector4ListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector4ListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector4ListEntire_ID:
						LinkInput_vector4List_vector4ListEntire1_ID_vector4ListEntire_ID ( sourceLogicNode);
						break;

					case Enums.vector4ListEntire0_ID:
						LinkInput_vector4List_vector4ListEntire1_ID_vector4ListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.vector4ListEntire1_ID:
						LinkInput_vector4List_vector4ListEntire1_ID_vector4ListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;


			case VariableType.shadersList:
				switch (inID)
				{
				case Enums.shaderListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.shaderListEntire_ID:
						LinkInput_shadersList_shaderListEntire0_ID_shaderListEntire_ID ( sourceLogicNode);
						break;

					case Enums.shaderListEntire0_ID:
						LinkInput_shadersList_shaderListEntire0_ID_shaderListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.shaderListEntire1_ID:
						LinkInput_shadersList_shaderListEntire0_ID_shaderListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.shaderListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.shaderListEntire_ID:
						LinkInput_shadersList_shaderListEntire1_ID_shaderListEntire_ID ( sourceLogicNode);
						break;

					case Enums.shaderListEntire0_ID:
						LinkInput_shadersList_shaderListEntire1_ID_shaderListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.shaderListEntire1_ID:
						LinkInput_shadersList_shaderListEntire1_ID_shaderListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;

			case VariableType.texture2DList:
				switch (inID)
				{
				case Enums.texture2DListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.texture2DListEntire_ID:
						LinkInput_texture2dList_texture2DListEntire0_ID_texture2DListEntire_ID ( sourceLogicNode);
						break;

					case Enums.texture2DListEntire0_ID:
						LinkInput_texture2dList_texture2DListEntire0_ID_texture2DListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.texture2DListEntire1_ID:
						LinkInput_texture2dList_texture2DListEntire0_ID_texture2DListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.texture2DListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.texture2DListEntire_ID:
						LinkInput_texture2dList_texture2DListEntire1_ID_texture2DListEntire_ID ( sourceLogicNode);
						break;

					case Enums.texture2DListEntire0_ID:
						LinkInput_texture2dList_texture2DListEntire1_ID_texture2DListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.texture2DListEntire1_ID:
						LinkInput_texture2dList_texture2DListEntire1_ID_texture2DListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;

			case VariableType.vector3List:
				switch (inID)
				{
				case Enums.vector3ListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector3ListEntire_ID:
						LinkInput_vector3List_vector3ListEntire0_ID_vector3ListEntire_ID ( sourceLogicNode);
						break;

					case Enums.vector3ListEntire0_ID:
						LinkInput_vector3List_vector3ListEntire0_ID_vector3ListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.vector3ListEntire1_ID:
						LinkInput_vector3List_vector3ListEntire0_ID_vector3ListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector3ListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector3ListEntire_ID:
						LinkInput_vector3List_vector3ListEntire1_ID_vector3ListEntire_ID ( sourceLogicNode);
						break;

					case Enums.vector3ListEntire0_ID:
						LinkInput_vector3List_vector3ListEntire1_ID_vector3ListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.vector3ListEntire1_ID:
						LinkInput_vector3List_vector3ListEntire1_ID_vector3ListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;


			case VariableType.stringsList:
				switch (inID)
				{
				case Enums.stringsListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.stringsListEntire_ID:
						LinkInput_stringsList_stringsListEntire0_ID_stringsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.stringsListEntire0_ID:
						LinkInput_stringsList_stringsListEntire0_ID_stringsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.stringsListEntire1_ID:
						LinkInput_stringsList_stringsListEntire0_ID_stringsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.stringsListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.stringsListEntire_ID:
						LinkInput_stringsList_stringsListEntire1_ID_stringsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.stringsListEntire0_ID:
						LinkInput_stringsList_stringsListEntire1_ID_stringsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.stringsListEntire1_ID:
						LinkInput_stringsList_stringsListEntire1_ID_stringsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;


			case VariableType.intsList:
				switch (inID)
				{
				case Enums.intsListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.intsListEntire_ID:
						LinkInput_intsList_intsListEntire0_ID_intsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.intsListEntire0_ID:
						LinkInput_intsList_intsListEntire0_ID_intsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.intsListEntire1_ID:
						LinkInput_intsList_intsListEntire0_ID_intsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.intsListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.intsListEntire_ID:
						LinkInput_intsList_intsListEntire1_ID_intsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.intsListEntire0_ID:
						LinkInput_intsList_intsListEntire1_ID_intsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.intsListEntire1_ID:
						LinkInput_intsList_intsListEntire1_ID_intsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;

			case VariableType.GameObjectList:
				switch (inID)
				{
				case Enums.gameObjectsListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.gameObjectsListEntire_ID:
						LinkInput_GameObjectList_gameObjectsListEntire0_ID_gameObjectsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.gameObjectsListEntire0_ID:
						LinkInput_GameObjectList_gameObjectsListEntire0_ID_gameObjectsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.gameObjectsListEntire1_ID:
						LinkInput_GameObjectList_gameObjectsListEntire0_ID_gameObjectsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.gameObjectsListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.gameObjectsListEntire_ID:
						LinkInput_GameObjectList_gameObjectsListEntire1_ID_gameObjectsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.gameObjectsListEntire0_ID:
						LinkInput_GameObjectList_gameObjectsListEntire1_ID_gameObjectsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.gameObjectsListEntire1_ID:
						LinkInput_GameObjectList_gameObjectsListEntire1_ID_gameObjectsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;


			case VariableType.rect:
				int lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.rectValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.rectList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.rectListValue.Count)
						{
							rectValues [0] = sourceLogicNode.rectListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.rectValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.rectList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.rectListValue.Count)
						{
							rectValues [1] = sourceLogicNode.rectListValue [lstIndex];
						}
						break;
					}
					break;
				}

				switch (inID)
				{
				case Enums.rectValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.rectValue_ID:
						LinkInput_rect_rectValues_0_ID_rectValue_ID ( sourceLogicNode);
						break;

					case Enums.rectValues_0_ID:
						LinkInput_rect_rectValues_0_ID_rectValues_0_ID ( sourceLogicNode);
						break;

					case Enums.rectValues_1_ID:
						LinkInput_rect_rectValues_0_ID_rectValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rectValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.rectValue_ID:
						LinkInput_rect_rectValues_1_ID_rectValue_ID ( sourceLogicNode);
						break;

					case Enums.rectValues_0_ID:
						LinkInput_rect_rectValues_1_ID_rectValues_0_ID ( sourceLogicNode);
						break;

					case Enums.rectValues_1_ID:
						LinkInput_rect_rectValues_1_ID_rectValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;



			case VariableType.Matrix4x4:
				switch (inID)
				{
				case Enums.m44Value_Input_0_entier_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44Value_entier_ID:
						LinkInput_Matrix4x4_m44Value_Input_0_entier_ID_m44Value_entier_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_Input_0_entier_ID:
						LinkInput_Matrix4x4_m44Value_Input_0_entier_ID_m44Value_Input_0_entier_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_Input_1_entier_ID:
						LinkInput_Matrix4x4_m44Value_Input_0_entier_ID_m44Value_Input_1_entier_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.m44Value_Input_1_entier_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44Value_entier_ID:
						LinkInput_Matrix4x4_m44Value_Input_1_entier_ID_m44Value_entier_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_Input_0_entier_ID:
						LinkInput_Matrix4x4_m44Value_Input_1_entier_ID_m44Value_Input_0_entier_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_Input_1_entier_ID:
						LinkInput_Matrix4x4_m44Value_Input_1_entier_ID_m44Value_Input_1_entier_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;


				//case VariableType.meshOnGameObject:
				//	switch (inID)
				//	{
				//	case Enums.meshValues_0_ID:
				//		switch (sourceNodeOutID)
				//		{
				//		case Enums.meshValue_ID:
				//			LinkInput_mesh_meshValues_0_ID_meshValue_ID ( sourceLogicNode);
				//			break;
				//
				//		case Enums.meshValues_0_ID:
				//			LinkInput_mesh_meshValues_0_ID_meshValues_0_ID ( sourceLogicNode);
				//			break;
				//
				//		case Enums.meshValues_1_ID:
				//			LinkInput_mesh_meshValues_0_ID_meshValues_1_ID ( sourceLogicNode);
				//			break;
				//
				//		}
				//
				//		break;
				//
				//	case Enums.meshValues_1_ID:
				//		switch (sourceNodeOutID)
				//		{
				//		case Enums.meshValue_ID:
				//			LinkInput_mesh_meshValues_1_ID_meshValue_ID ( sourceLogicNode);
				//			break;
				//
				//		case Enums.meshValues_0_ID:
				//			LinkInput_mesh_meshValues_1_ID_meshValues_0_ID ( sourceLogicNode);
				//			break;
				//
				//		case Enums.meshValues_1_ID:
				//			LinkInput_mesh_meshValues_1_ID_meshValues_1_ID ( sourceLogicNode);
				//			break;
				//
				//		}
				//
				//		break;
				//
				//	}
				//
				//	break;



			case VariableType.Vector4:
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.vector4Values_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.vector4List_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.vector4ListValue.Count)
						{
							vector4Values [0] = sourceLogicNode.vector4ListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.vector4Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector4List_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.vector4ListValue.Count)
						{
							vector4Values [1] = sourceLogicNode.vector4ListValue [lstIndex];
						}
						break;
					}
					break;
				}

				switch (inID)
				{
				case Enums.vector4Values_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector4Value_ID:
						LinkInput_Vector4_vector4Values_0_ID_vector4Value_ID ( sourceLogicNode);
						break;

					case Enums.vector4Values_0_ID:
						LinkInput_Vector4_vector4Values_0_ID_vector4Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector4Values_1_ID:
						LinkInput_Vector4_vector4Values_0_ID_vector4Values_1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector4Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector4Value_ID:
						LinkInput_Vector4_vector4Values_1_ID_vector4Value_ID ( sourceLogicNode);
						break;

					case Enums.vector4Values_0_ID:
						LinkInput_Vector4_vector4Values_1_ID_vector4Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector4Values_1_ID:
						LinkInput_Vector4_vector4Values_1_ID_vector4Values_1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;




			case VariableType.Shader:
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.shaderValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.shaderList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.shaderListValue.Count)
						{
							shaderValues [0] = sourceLogicNode.shaderListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.shaderValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.shaderList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.shaderListValue.Count)
						{
							shaderValues [1] = sourceLogicNode.shaderListValue [lstIndex];
						}
						break;
					}
					break;
				}

				switch (inID)
				{
				case Enums.shaderValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.shaderValue_ID:
						LinkInput_Shader_shaderValues_0_ID_shaderValue_ID ( sourceLogicNode);
						break;

					case Enums.shaderValues_0_ID:
						LinkInput_Shader_shaderValues_0_ID_shaderValues_0_ID ( sourceLogicNode);
						break;

					case Enums.shaderValues_1_ID:
						LinkInput_Shader_shaderValues_0_ID_shaderValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.shaderValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.shaderValue_ID:
						LinkInput_Shader_shaderValues_1_ID_shaderValue_ID ( sourceLogicNode);
						break;

					case Enums.shaderValues_0_ID:
						LinkInput_Shader_shaderValues_1_ID_shaderValues_0_ID ( sourceLogicNode);
						break;

					case Enums.shaderValues_1_ID:
						LinkInput_Shader_shaderValues_1_ID_shaderValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;


			case VariableType.Texture2D:
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.texture2DValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.texture2DList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.texture2DListValue.Count)
						{
							texture2DValues [0] = sourceLogicNode.texture2DListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.texture2DValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.texture2DList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.texture2DListValue.Count)
						{
							texture2DValues [1] = sourceLogicNode.texture2DListValue [lstIndex];
						}
						break;
					}
					break;
				}


				switch (inID)
				{
				case Enums.texture2DValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.texture2DValue_ID:
						LinkInput_Texture2D_texture2DValues_0_ID_texture2DValue_ID ( sourceLogicNode);
						break;

					case Enums.texture2DValues_0_ID:
						LinkInput_Texture2D_texture2DValues_0_ID_texture2DValues_0_ID ( sourceLogicNode);
						break;

					case Enums.texture2DValues_1_ID:
						LinkInput_Texture2D_texture2DValues_0_ID_texture2DValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.texture2DValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.texture2DValue_ID:
						LinkInput_Texture2D_texture2DValues_1_ID_texture2DValue_ID ( sourceLogicNode);
						break;

					case Enums.texture2DValues_0_ID:
						LinkInput_Texture2D_texture2DValues_1_ID_texture2DValues_0_ID ( sourceLogicNode);
						break;

					case Enums.texture2DValues_1_ID:
						LinkInput_Texture2D_texture2DValues_1_ID_texture2DValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;




			case VariableType.materialsList:
				switch (inID)
				{
				case Enums.materialListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.materialListEntire_ID:
						LinkInput_materialsList_materialListEntire0_ID_materialListEntire_ID ( sourceLogicNode);
						break;

					case Enums.materialListEntire0_ID:
						LinkInput_materialsList_materialListEntire0_ID_materialListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.materialListEntire1_ID:
						LinkInput_materialsList_materialListEntire0_ID_materialListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.materialListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.materialListEntire_ID:
						LinkInput_materialsList_materialListEntire1_ID_materialListEntire_ID ( sourceLogicNode);
						break;

					case Enums.materialListEntire0_ID:
						LinkInput_materialsList_materialListEntire1_ID_materialListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.materialListEntire1_ID:
						LinkInput_materialsList_materialListEntire1_ID_materialListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;

			case VariableType.Material:
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);


				switch (inID)
				{
				case Enums.materialValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.materialList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.materialsListValue.Count)
						{
							materialValues [0] = sourceLogicNode.materialsListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.materialValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.materialList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.materialsListValue.Count)
						{
							materialValues [1] = sourceLogicNode.materialsListValue [lstIndex];
						}
						break;
					}
					break;
				}


				switch (inID)
				{
				case Enums.materialValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.materialValue_ID:
						LinkInput_Material_materialValues_0_materialValue ( sourceLogicNode);
						break;

					case Enums.materialValues_0_ID:
						LinkInput_Material_materialValues_0_materialValues_0 ( sourceLogicNode);
						break;

					case Enums.materialValues_1_ID:
						LinkInput_Material_materialValues_0_materialValues_1 ( sourceLogicNode);
						break;

					}
					break;

				case Enums.materialValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.materialValue_ID:
						LinkInput_Material_materialValues_1_materialValue ( sourceLogicNode);
						break;

					case Enums.materialValues_0_ID:
						LinkInput_Material_materialValues_1_materialValues_0 ( sourceLogicNode);
						break;

					case Enums.materialValues_1_ID:
						LinkInput_Material_materialValues_1_materialValues_1 ( sourceLogicNode);
						break;

					}
					break;
				}
				break;





			case VariableType.vector2List:
				switch (inID)
				{
				case Enums.vector2ListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector2ListEntire_ID:
						LinkInput_vector2List_vector2ListEntire0_ID_vector2ListEntire_ID ( sourceLogicNode);
						break;

					case Enums.vector2ListEntire0_ID:
						LinkInput_vector2List_vector2ListEntire0_ID_vector2ListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.vector2ListEntire1_ID:
						LinkInput_vector2List_vector2ListEntire0_ID_vector2ListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector2ListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector2ListEntire_ID:
						LinkInput_vector2List_vector2ListEntire1_ID_vector2ListEntire_ID ( sourceLogicNode);
						break;

					case Enums.vector2ListEntire0_ID:
						LinkInput_vector2List_vector2ListEntire1_ID_vector2ListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.vector2ListEntire1_ID:
						LinkInput_vector2List_vector2ListEntire1_ID_vector2ListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;


			case VariableType.boolsList:
				switch (inID)
				{
				case Enums.boolsListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boolsListEntire_ID:
						LinkInput_boolList_boolsListEntire0_ID_boolsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.boolsListEntire0_ID:
						LinkInput_boolList_boolsListEntire0_ID_boolsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.boolsListEntire1_ID:
						LinkInput_boolList_boolsListEntire0_ID_boolsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.boolsListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boolsListEntire_ID:
						LinkInput_boolList_boolsListEntire1_ID_boolsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.boolsListEntire0_ID:
						LinkInput_boolList_boolsListEntire1_ID_boolsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.boolsListEntire1_ID:
						LinkInput_boolList_boolsListEntire1_ID_boolsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;

			case VariableType.Bool:
				switch (inID)
				{
				case Enums.boolValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boolValue_ID:
						LinkInput_Bool_boolValues_0_ID_boolValue_ID ( sourceLogicNode);
						break;

					case Enums.boolValues_0_ID:
						LinkInput_Bool_boolValues_0_ID_boolValues_0_ID ( sourceLogicNode);
						break;

					case Enums.boolValues_1_ID:
						LinkInput_Bool_boolValues_0_ID_boolValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.boolValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boolValue_ID:
						LinkInput_Bool_boolValues_1_ID_boolValue_ID ( sourceLogicNode);
						break;

					case Enums.boolValues_0_ID:
						LinkInput_Bool_boolValues_1_ID_boolValues_0_ID ( sourceLogicNode);
						break;

					case Enums.boolValues_1_ID:
						LinkInput_Bool_boolValues_1_ID_boolValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.doIt_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boolValue_ID:
						LinkInput_Bool_doIt_ID_boolValue_ID ( sourceLogicNode);
						break;

					case Enums.boolValues_0_ID:
						LinkInput_Bool_doIt_ID_boolValues_0_ID ( sourceLogicNode);
						break;

					case Enums.boolValues_1_ID:
						LinkInput_Bool_doIt_ID_boolValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.boolValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44ValueIsIdentity_ID:
						LinkInput_M44_boolValues_0_ID_m44ValueIsIdentity_ID ( sourceLogicNode);
						break;

					case Enums.m44ValueInvertible_ID:
						LinkInput_M44_boolValues_0_ID_m44ValueInvertible_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.boolValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44ValueIsIdentity_ID:
						LinkInput_M44_boolValues_1_ID_m44ValueIsIdentity_ID ( sourceLogicNode);
						break;

					case Enums.m44ValueInvertible_ID:
						LinkInput_M44_boolValues_1_ID_m44ValueInvertible_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.boolValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.OffMeshLinkData_activated_ID:
						LinkInput_OffMeshLink_boolValues_0_ID_OffMeshLinkData_activated_ID ( sourceLogicNode);
						break;

					case Enums.OffMeshLinkData_valid_ID:
						LinkInput_OffMeshLink_boolValues_0_ID_OffMeshLinkData_valid_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.boolValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.OffMeshLinkData_activated_ID:
						LinkInput_OffMeshLink_boolValues_1_ID_OffMeshLinkData_activated_ID ( sourceLogicNode);
						break;

					case Enums.OffMeshLinkData_valid_ID:
						LinkInput_OffMeshLink_boolValues_1_ID_OffMeshLinkData_valid_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.doIt_ID:
					switch (sourceNodeOutID)
					{
					case Enums.OffMeshLinkData_activated_ID:
						LinkInput_OffMeshLink_doIt_ID_OffMeshLinkData_activated_ID ( sourceLogicNode);
						break;

					case Enums.OffMeshLinkData_valid_ID:
						LinkInput_OffMeshLink_doIt_ID_OffMeshLinkData_valid_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.boolValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_hit_ID:
						LinkInput_navMeshHit_boolValues_0_ID_NavMeshHit_hit_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.boolValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_hit_ID:
						LinkInput_navMeshHit_boolValues_1_ID_NavMeshHit_hit_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.doIt_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_hit_ID:
						LinkInput_navMeshHit_doIt_ID_NavMeshHit_hit_ID ( sourceLogicNode);
						break;

					}

					break;

				}


				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.boolValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.boolsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.boolsListValue.Count)
						{
							boolValues [0] = sourceLogicNode.boolsListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.boolValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boolsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.boolsListValue.Count)
						{
							boolValues [1] = sourceLogicNode.boolsListValue [lstIndex];
						}
						break;
					}
					break;
				}
				break;



			case VariableType.colorsList:
				switch (inID)
				{
				case Enums.colorsListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.colorsListEntire_ID:
						LinkInput_colorList_colorsListEntire0_colorsListEntire ( sourceLogicNode);
						break;

					case Enums.colorsListEntire0_ID:
						LinkInput_colorList_colorsListEntire0_colorsListEntire0 ( sourceLogicNode);
						break;

					case Enums.colorsListEntire1_ID:
						LinkInput_colorList_colorsListEntire0_colorsListEntire1 ( sourceLogicNode);
						break;

					}

					break;

				case Enums.colorsListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.colorsListEntire_ID:
						LinkInput_colorList_colorsListEntire1_colorsListEntire ( sourceLogicNode);
						break;

					case Enums.colorsListEntire0_ID:
						LinkInput_colorList_colorsListEntire1_colorsListEntire0 ( sourceLogicNode);
						break;

					case Enums.colorsListEntire1_ID:
						LinkInput_colorList_colorsListEntire1_colorsListEntire1 ( sourceLogicNode);
						break;

					}

					break;

				}

				break;

			case VariableType.Color:
				switch (inID)
				{
				case Enums.colorValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.colorValue_ID:
						LinkInput_Color_colorValues_0_ID_colorValue_ID ( sourceLogicNode);
						break;

					case Enums.colorValues_0_ID:
						LinkInput_Color_colorValues_0_ID_colorValues_0_ID ( sourceLogicNode);
						break;

					case Enums.colorValues_1_ID:
						LinkInput_Color_colorValues_0_ID_colorValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.colorValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.colorValue_ID:
						LinkInput_Color_colorValues_1_ID_colorValue_ID ( sourceLogicNode);
						break;

					case Enums.colorValues_0_ID:
						LinkInput_Color_colorValues_1_ID_colorValues_0_ID ( sourceLogicNode);
						break;

					case Enums.colorValues_1_ID:
						LinkInput_Color_colorValues_1_ID_colorValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.colorValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.colorsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.colorsListValue.Count)
						{
							colorValues [0] = sourceLogicNode.colorsListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.colorValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.colorsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.colorsListValue.Count)
						{
							colorValues [1] = sourceLogicNode.colorsListValue [lstIndex];
						}
						break;
					}
					break;
				}
				break;


			case VariableType.floatsList:
				switch (inID)
				{
				case Enums.floatsListEntire0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.floatsListEntire_ID:
						LinkInput_floatsList_floatsListEntire0_ID_floatsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.floatsListEntire0_ID:
						LinkInput_floatsList_floatsListEntire0_ID_floatsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.floatsListEntire1_ID:
						LinkInput_floatsList_floatsListEntire0_ID_floatsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatsListEntire1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.floatsListEntire_ID:
						LinkInput_floatsList_floatsListEntire1_ID_floatsListEntire_ID ( sourceLogicNode);
						break;

					case Enums.floatsListEntire0_ID:
						LinkInput_floatsList_floatsListEntire1_ID_floatsListEntire0_ID ( sourceLogicNode);
						break;

					case Enums.floatsListEntire1_ID:
						LinkInput_floatsList_floatsListEntire1_ID_floatsListEntire1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;

			case VariableType.Float:
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.floatValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.floatsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.floatsListValue.Count)
						{
							floatValues [0] = sourceLogicNode.floatsListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.floatValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.floatsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.floatsListValue.Count)
						{
							floatValues [1] = sourceLogicNode.floatsListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.floatValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.floatsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.floatsListValue.Count)
						{
							floatValues [2] = sourceLogicNode.floatsListValue [lstIndex];
						}
						break;
					}
					break;
				}


				switch (inID)
				{
				case Enums.floatValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.floatValue_ID:
						LinkInput_Float_floatValues_0_ID_floatValue_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_0_ID:
						LinkInput_Float_floatValues_0_ID_floatValues_0_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_1_ID:
						LinkInput_Float_floatValues_0_ID_floatValues_1_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_2_ID:
						LinkInput_Float_floatValues_0_ID_floatValues_2_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.floatValue_ID:
						LinkInput_Float_floatValues_1_ID_floatValue_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_0_ID:
						LinkInput_Float_floatValues_1_ID_floatValues_0_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_1_ID:
						LinkInput_Float_floatValues_1_ID_floatValues_1_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_2_ID:
						LinkInput_Float_floatValues_1_ID_floatValues_2_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.floatValue_ID:
						LinkInput_Float_floatValues_2_ID_floatValue_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_0_ID:
						LinkInput_Float_floatValues_2_ID_floatValues_0_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_1_ID:
						LinkInput_Float_floatValues_2_ID_floatValues_1_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_2_ID:
						LinkInput_Float_floatValues_2_ID_floatValues_2_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.floatValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitDistance_ID:
						LinkInput_RaycastV3_floatValues_0_ID_raycastHitDistance_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitDistance_ID:
						LinkInput_RaycastV3_floatValues_1_ID_raycastHitDistance_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitDistance_ID:
						LinkInput_RaycastV3_floatValues_2_ID_raycastHitDistance_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.floatValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44Value_0_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_0_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_1_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_1_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_2_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_2_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_3_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_3_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_4_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_4_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_5_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_5_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_6_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_6_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_7_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_7_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_8_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_8_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_9_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_9_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_10_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_10_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_11_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_11_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_12_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_12_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_13_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_13_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_14_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_14_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_15_ID:
						LinkInput_M44_floatValues_0_ID_m44Value_15_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44Value_0_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_0_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_1_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_1_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_2_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_2_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_3_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_3_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_4_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_4_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_5_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_5_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_6_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_6_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_7_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_7_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_8_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_8_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_9_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_9_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_10_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_10_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_11_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_11_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_12_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_12_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_13_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_13_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_14_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_14_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_15_ID:
						LinkInput_M44_floatValues_1_ID_m44Value_15_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44Value_0_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_0_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_1_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_1_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_2_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_2_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_3_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_3_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_4_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_4_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_5_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_5_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_6_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_6_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_7_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_7_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_8_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_8_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_9_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_9_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_10_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_10_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_11_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_11_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_12_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_12_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_13_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_13_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_14_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_14_ID ( sourceLogicNode);
						break;

					case Enums.m44Value_15_ID:
						LinkInput_M44_floatValues_2_ID_m44Value_15_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.floatValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44ValueDeterminant_ID:
						LinkInput_M44_floatValues_0_ID_m44ValueDeterminant_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44ValueDeterminant_ID:
						LinkInput_M44_floatValues_1_ID_m44ValueDeterminant_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.m44ValueDeterminant_ID:
						LinkInput_M44_floatValues_2_ID_m44ValueDeterminant_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.floatValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_distance_ID:
						LinkInput_navMeshHit_floatValues_0_ID_NavMeshHit_distance_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_distance_ID:
						LinkInput_navMeshHit_floatValues_1_ID_NavMeshHit_distance_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_distance_ID:
						LinkInput_navMeshHit_floatValues_2_ID_NavMeshHit_distance_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.floatValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.hit2D_distance_ID:
						LinkInput_hit2D_floatValues_0_ID_hit2D_distance_ID ( sourceLogicNode);
						break;

					case Enums.hit2D_fraction_ID:
						LinkInput_hit2D_floatValues_0_ID_hit2D_fraction_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.hit2D_distance_ID:
						LinkInput_hit2D_floatValues_1_ID_hit2D_distance_ID ( sourceLogicNode);
						break;

					case Enums.hit2D_fraction_ID:
						LinkInput_hit2D_floatValues_1_ID_hit2D_fraction_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.hit2D_distance_ID:
						LinkInput_hit2D_floatValues_2_ID_hit2D_distance_ID ( sourceLogicNode);
						break;

					case Enums.hit2D_fraction_ID:
						LinkInput_hit2D_floatValues_2_ID_hit2D_fraction_ID ( sourceLogicNode);
						break;

					}

					break;

				}


				switch (inID)
				{
				case Enums.floatValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_altitudeAngle_ID:
						LinkInput_touch_floatValues_0_ID_touch_altitudeAngle_ID ( sourceLogicNode);
						break;

					case Enums.touch_azimuthAngle_ID:
						LinkInput_touch_floatValues_0_ID_touch_azimuthAngle_ID ( sourceLogicNode);
						break;

					case Enums.touch_deltaTime_ID:
						LinkInput_touch_floatValues_0_ID_touch_deltaTime_ID ( sourceLogicNode);
						break;

					case Enums.touch_maximumPossiblePressure_ID:
						LinkInput_touch_floatValues_0_ID_touch_maximumPossiblePressure_ID ( sourceLogicNode);
						break;

					case Enums.touch_pressure_ID:
						LinkInput_touch_floatValues_0_ID_touch_pressure_ID ( sourceLogicNode);
						break;

					case Enums.touch_radius_ID:
						LinkInput_touch_floatValues_0_ID_touch_radius_ID ( sourceLogicNode);
						break;

					case Enums.touch_radiusVariance_ID:
						LinkInput_touch_floatValues_0_ID_touch_radiusVariance_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_altitudeAngle_ID:
						LinkInput_touch_floatValues_1_ID_touch_altitudeAngle_ID ( sourceLogicNode);
						break;

					case Enums.touch_azimuthAngle_ID:
						LinkInput_touch_floatValues_1_ID_touch_azimuthAngle_ID ( sourceLogicNode);
						break;

					case Enums.touch_deltaTime_ID:
						LinkInput_touch_floatValues_1_ID_touch_deltaTime_ID ( sourceLogicNode);
						break;

					case Enums.touch_maximumPossiblePressure_ID:
						LinkInput_touch_floatValues_1_ID_touch_maximumPossiblePressure_ID ( sourceLogicNode);
						break;

					case Enums.touch_pressure_ID:
						LinkInput_touch_floatValues_1_ID_touch_pressure_ID ( sourceLogicNode);
						break;

					case Enums.touch_radius_ID:
						LinkInput_touch_floatValues_1_ID_touch_radius_ID ( sourceLogicNode);
						break;

					case Enums.touch_radiusVariance_ID:
						LinkInput_touch_floatValues_1_ID_touch_radiusVariance_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.floatValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_altitudeAngle_ID:
						LinkInput_touch_floatValues_2_ID_touch_altitudeAngle_ID ( sourceLogicNode);
						break;

					case Enums.touch_azimuthAngle_ID:
						LinkInput_touch_floatValues_2_ID_touch_azimuthAngle_ID ( sourceLogicNode);
						break;

					case Enums.touch_deltaTime_ID:
						LinkInput_touch_floatValues_2_ID_touch_deltaTime_ID ( sourceLogicNode);
						break;

					case Enums.touch_maximumPossiblePressure_ID:
						LinkInput_touch_floatValues_2_ID_touch_maximumPossiblePressure_ID ( sourceLogicNode);
						break;

					case Enums.touch_pressure_ID:
						LinkInput_touch_floatValues_2_ID_touch_pressure_ID ( sourceLogicNode);
						break;

					case Enums.touch_radius_ID:
						LinkInput_touch_floatValues_2_ID_touch_radius_ID ( sourceLogicNode);
						break;

					case Enums.touch_radiusVariance_ID:
						LinkInput_touch_floatValues_2_ID_touch_radiusVariance_ID ( sourceLogicNode);
						break;

					}

					break;

				}


				break;


			case VariableType.Int:
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);

				switch (inID)
				{
				case Enums.intValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_fingerId_ID:
						LinkInput_touch_intValues_0_ID_touch_fingerId_ID ( sourceLogicNode);
						break;

					case Enums.touch_tapCount_ID:
						LinkInput_touch_intValues_0_ID_touch_tapCount_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.intValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_fingerId_ID:
						LinkInput_touch_intValues_1_ID_touch_fingerId_ID ( sourceLogicNode);
						break;

					case Enums.touch_tapCount_ID:
						LinkInput_touch_intValues_1_ID_touch_tapCount_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.intValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_fingerId_ID:
						LinkInput_touch_intValues_2_ID_touch_fingerId_ID ( sourceLogicNode);
						break;

					case Enums.touch_tapCount_ID:
						LinkInput_touch_intValues_2_ID_touch_tapCount_ID ( sourceLogicNode);
						break;

					}

					break;

				}





				switch (inID)
				{
				case Enums.intValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.intsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.intsListValue.Count)
						{
							intValues [0] = sourceLogicNode.intsListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.intValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.intsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.intsListValue.Count)
						{
							intValues [1] = sourceLogicNode.intsListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.intValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.intsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.intsListValue.Count)
						{
							intValues [2] = sourceLogicNode.intsListValue [lstIndex];
						}
						break;
					}
					break;
				}

				switch (inID)
				{
				case Enums.intValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_mask_ID:
						LinkInput_navMeshHit_intValues_0_ID_NavMeshHit_mask_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.intValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_mask_ID:
						LinkInput_navMeshHit_intValues_1_ID_NavMeshHit_mask_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.intValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_mask_ID:
						LinkInput_navMeshHit_intValues_2_ID_NavMeshHit_mask_ID ( sourceLogicNode);
						break;

					}

					break;

				}


				switch (inID)
				{
				case Enums.intValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.intValue_ID:
						LinkInput_Int_intValues_0_ID_intValue_ID ( sourceLogicNode);
						break;

					case Enums.intValues_0_ID:
						LinkInput_Int_intValues_0_ID_intValues_0_ID ( sourceLogicNode);
						break;

					case Enums.intValues_1_ID:
						LinkInput_Int_intValues_0_ID_intValues_1_ID ( sourceLogicNode);
						break;

					case Enums.intValues_2_ID:
						LinkInput_Int_intValues_0_ID_intValues_2_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.intValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.intValue_ID:
						LinkInput_Int_intValues_1_ID_intValue_ID ( sourceLogicNode);
						break;

					case Enums.intValues_0_ID:
						LinkInput_Int_intValues_1_ID_intValues_0_ID ( sourceLogicNode);
						break;

					case Enums.intValues_1_ID:
						LinkInput_Int_intValues_1_ID_intValues_1_ID ( sourceLogicNode);
						break;

					case Enums.intValues_2_ID:
						LinkInput_Int_intValues_1_ID_intValues_2_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.intValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.intValue_ID:
						LinkInput_Int_intValues_2_ID_intValue_ID ( sourceLogicNode);
						break;

					case Enums.intValues_0_ID:
						LinkInput_Int_intValues_2_ID_intValues_0_ID ( sourceLogicNode);
						break;

					case Enums.intValues_1_ID:
						LinkInput_Int_intValues_2_ID_intValues_1_ID ( sourceLogicNode);
						break;

					case Enums.intValues_2_ID:
						LinkInput_Int_intValues_2_ID_intValues_2_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.intValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitTriangleIndex_ID:
						LinkInput_RaycastV3_intValues_0_ID_raycastHitTriangleIndex_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.intValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitTriangleIndex_ID:
						LinkInput_RaycastV3_intValues_1_ID_raycastHitTriangleIndex_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.intValues_2_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitTriangleIndex_ID:
						LinkInput_RaycastV3_intValues_2_ID_raycastHitTriangleIndex_ID ( sourceLogicNode);
						break;

					}

					break;

				}
				break;



			case VariableType.String:
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);

				switch (inID)
				{
				case Enums.stringValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_phase_ID:
						LinkInput_touch_stringValues_0_ID_touch_phase_ID ( sourceLogicNode);
						break;

					case Enums.touch_type_ID:
						LinkInput_touch_stringValues_0_ID_touch_type_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.stringValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_phase_ID:
						LinkInput_touch_stringValues_1_ID_touch_phase_ID ( sourceLogicNode);
						break;

					case Enums.touch_type_ID:
						LinkInput_touch_stringValues_1_ID_touch_type_ID ( sourceLogicNode);
						break;

					}

					break;

				}



				switch (inID)
				{
				case Enums.stringValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.stringsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.stringsListValue.Count)
						{
							stringValues [0] = sourceLogicNode.stringsListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.stringValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.stringsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.stringsListValue.Count)
						{
							stringValues [1] = sourceLogicNode.stringsListValue [lstIndex];
						}
						break;
					}
					break;
				}


				switch (inID)
				{
				case Enums.stringValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.stringValue_ID:
						LinkInput_String_stringValues_0_ID_stringValue_ID ( sourceLogicNode);
						break;

					case Enums.stringValues_0_ID:
						LinkInput_String_stringValues_0_ID_stringValues_0_ID ( sourceLogicNode);
						break;

					case Enums.stringValues_1_ID:
						LinkInput_String_stringValues_0_ID_stringValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.stringValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.stringValue_ID:
						LinkInput_String_stringValues_1_ID_stringValue_ID ( sourceLogicNode);
						break;

					case Enums.stringValues_0_ID:
						LinkInput_String_stringValues_1_ID_stringValues_0_ID ( sourceLogicNode);
						break;

					case Enums.stringValues_1_ID:
						LinkInput_String_stringValues_1_ID_stringValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				break;


			case VariableType.Vector2:
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.vector2Values_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.vector2List_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.vector2ListValue.Count)
						{
							vector2Values [0] = sourceLogicNode.vector2ListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.vector2Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector2List_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.vector2ListValue.Count)
						{
							vector2Values [1] = sourceLogicNode.vector2ListValue [lstIndex];
						}
						break;
					}
					break;
				}

				switch (inID)
				{
				case Enums.floatValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.floatValue_ID:
						LinkInput_Vector2_floatValues_0_ID_floatValue_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_0_ID:
						LinkInput_Vector2_floatValues_0_ID_floatValues_0_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_1_ID:
						LinkInput_Vector2_floatValues_0_ID_floatValues_1_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_2_ID:
						LinkInput_Vector2_floatValues_0_ID_floatValues_2_ID ( sourceLogicNode);
						break;
					}

					break;

				case Enums.vector2Values_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector2Value_ID:
						LinkInput_Vector2_vector2Values_0_ID_vector2Value_ID ( sourceLogicNode);
						break;

					case Enums.vector2Values_0_ID:
						LinkInput_Vector2_vector2Values_0_ID_vector2Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector2Values_1_ID:
						LinkInput_Vector2_vector2Values_0_ID_vector2Values_1_ID ( sourceLogicNode);
						break;

					case Enums.ray2DOrigin_ID:
						LinkInput_Vector2_vector2Values_0_ID_ray2DOrigin_ID ( sourceLogicNode);
						break;

					case Enums.ray2DDirection_ID:
						LinkInput_Vector2_vector2Values_0_ID_ray2DDirection_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector2Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector2Value_ID:
						LinkInput_Vector2_vector2Values_1_ID_vector2Value_ID ( sourceLogicNode);
						break;

					case Enums.vector2Values_0_ID:
						LinkInput_Vector2_vector2Values_1_ID_vector2Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector2Values_1_ID:
						LinkInput_Vector2_vector2Values_1_ID_vector2Values_1_ID ( sourceLogicNode);
						break;

					case Enums.ray2DOrigin_ID:
						LinkInput_Vector2_vector2Values_1_ID_ray2DOrigin_ID ( sourceLogicNode);
						break;

					case Enums.ray2DDirection_ID:
						LinkInput_Vector2_vector2Values_1_ID_ray2DDirection_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.ray2DOrigin_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector2Value_ID:
						LinkInput_Ray2D_ray2DOrigin_ID_vector2Value_ID ( sourceLogicNode);
						break;

					case Enums.vector2Values_0_ID:
						LinkInput_Ray2D_ray2DOrigin_ID_vector2Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector2Values_1_ID:
						LinkInput_Ray2D_ray2DOrigin_ID_vector2Values_1_ID ( sourceLogicNode);
						break;

					case Enums.ray2DOrigin_ID:
						LinkInput_Ray2D_ray2DOrigin_ID_ray2DOrigin_ID ( sourceLogicNode);
						break;

					case Enums.ray2DDirection_ID:
						LinkInput_Ray2D_ray2DOrigin_ID_ray2DDirection_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.ray2DDirection_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector2Value_ID:
						LinkInput_Ray2D_ray2DDirection_ID_vector2Value_ID ( sourceLogicNode);
						break;

					case Enums.vector2Values_0_ID:
						LinkInput_Ray2D_ray2DDirection_ID_vector2Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector2Values_1_ID:
						LinkInput_Ray2D_ray2DDirection_ID_vector2Values_1_ID ( sourceLogicNode);
						break;

					case Enums.ray2DOrigin_ID:
						LinkInput_Ray2D_ray2DDirection_ID_ray2DOrigin_ID ( sourceLogicNode);
						break;

					case Enums.ray2DDirection_ID:
						LinkInput_Ray2D_ray2DDirection_ID_ray2DDirection_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.vector2Values_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitLightmapCoord_ID:
						LinkInput_RaycastV3_vector2Values_0_ID_raycastHitLightmapCoord_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitTextureCoord_ID:
						LinkInput_RaycastV3_vector2Values_0_ID_raycastHitTextureCoord_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitTextureCoord2_ID:
						LinkInput_RaycastV3_vector2Values_0_ID_raycastHitTextureCoord2_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector2Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitLightmapCoord_ID:
						LinkInput_RaycastV3_vector2Values_1_ID_raycastHitLightmapCoord_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitTextureCoord_ID:
						LinkInput_RaycastV3_vector2Values_1_ID_raycastHitTextureCoord_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitTextureCoord2_ID:
						LinkInput_RaycastV3_vector2Values_1_ID_raycastHitTextureCoord2_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.ray2DOrigin_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitLightmapCoord_ID:
						LinkInput_RaycastV3_ray2DOrigin_ID_raycastHitLightmapCoord_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitTextureCoord_ID:
						LinkInput_RaycastV3_ray2DOrigin_ID_raycastHitTextureCoord_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitTextureCoord2_ID:
						LinkInput_RaycastV3_ray2DOrigin_ID_raycastHitTextureCoord2_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.ray2DDirection_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitLightmapCoord_ID:
						LinkInput_RaycastV3_ray2DDirection_ID_raycastHitLightmapCoord_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitTextureCoord_ID:
						LinkInput_RaycastV3_ray2DDirection_ID_raycastHitTextureCoord_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitTextureCoord2_ID:
						LinkInput_RaycastV3_ray2DDirection_ID_raycastHitTextureCoord2_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.vector2Values_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.hit2D_centroid_ID:
						LinkInput_hit2D_vector2Values_0_ID_hit2D_centroid_ID ( sourceLogicNode);
						break;

					case Enums.hit2D_normal_ID:
						LinkInput_hit2D_vector2Values_0_ID_hit2D_normal_ID ( sourceLogicNode);
						break;

					case Enums.hit2D_point_ID:
						LinkInput_hit2D_vector2Values_0_ID_hit2D_point_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector2Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.hit2D_centroid_ID:
						LinkInput_hit2D_vector2Values_1_ID_hit2D_centroid_ID ( sourceLogicNode);
						break;

					case Enums.hit2D_normal_ID:
						LinkInput_hit2D_vector2Values_1_ID_hit2D_normal_ID ( sourceLogicNode);
						break;

					case Enums.hit2D_point_ID:
						LinkInput_hit2D_vector2Values_1_ID_hit2D_point_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.vector2Values_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_position_ID:
							LinkInput_touch_vector2Values_0_ID_touch_position_ID ( sourceLogicNode);
						break;

					case Enums.touch_deltaPosition_ID:
						LinkInput_touch_vector2Values_0_ID_touch_deltaPosition_ID ( sourceLogicNode);
						break;

					case Enums.touch_rawPosition_ID:
						LinkInput_touch_vector2Values_0_ID_touch_rawPosition_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector2Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_position_ID:
							LinkInput_touch_vector2Values_1_ID_touch_position_ID ( sourceLogicNode);
						break;

					case Enums.touch_deltaPosition_ID:
						LinkInput_touch_vector2Values_1_ID_touch_deltaPosition_ID ( sourceLogicNode);
						break;

					case Enums.touch_rawPosition_ID:
						LinkInput_touch_vector2Values_1_ID_touch_rawPosition_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.ray2DOrigin_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_position_ID:
							LinkInput_touch_ray2DOrigin_ID_touch_position_ID ( sourceLogicNode);
						break;

					case Enums.touch_deltaPosition_ID:
						LinkInput_touch_ray2DOrigin_ID_touch_deltaPosition_ID ( sourceLogicNode);
						break;

					case Enums.touch_rawPosition_ID:
						LinkInput_touch_ray2DOrigin_ID_touch_rawPosition_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.ray2DDirection_ID:
					switch (sourceNodeOutID)
					{
					case Enums.touch_position_ID:
							LinkInput_touch_ray2DDirection_ID_touch_position_ID ( sourceLogicNode);
						break;

					case Enums.touch_deltaPosition_ID:
						LinkInput_touch_ray2DDirection_ID_touch_deltaPosition_ID ( sourceLogicNode);
						break;

					case Enums.touch_rawPosition_ID:
						LinkInput_touch_ray2DDirection_ID_touch_rawPosition_ID ( sourceLogicNode);
						break;

					}

					break;

				}
				break;



			case VariableType.Vector3:
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.vector3Values_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.vector3List_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.vector3ListValue.Count)
						{
							vector3Values [0] = sourceLogicNode.vector3ListValue [lstIndex];
						}
						break;
					}
					break;

				case Enums.vector3Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector3List_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.vector3ListValue.Count)
						{
							vector3Values [1] = sourceLogicNode.vector3ListValue [lstIndex];
						}
						break;
					}
					break;
				}

				switch (inID)
				{
				case Enums.vector3Values_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_normal_ID:
						LinkInput_navMeshHit_vector3Values_0_ID_NavMeshHit_normal_ID ( sourceLogicNode);
						break;

					case Enums.NavMeshHit_position_ID:
						LinkInput_navMeshHit_vector3Values_0_ID_NavMeshHit_position_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector3Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_normal_ID:
						LinkInput_navMeshHit_vector3Values_1_ID_NavMeshHit_normal_ID ( sourceLogicNode);
						break;

					case Enums.NavMeshHit_position_ID:
						LinkInput_navMeshHit_vector3Values_1_ID_NavMeshHit_position_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rayOrigin_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_normal_ID:
						LinkInput_navMeshHit_rayOrigin_ID_NavMeshHit_normal_ID ( sourceLogicNode);
						break;

					case Enums.NavMeshHit_position_ID:
						LinkInput_navMeshHit_rayOrigin_ID_NavMeshHit_position_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rayDirection_ID:
					switch (sourceNodeOutID)
					{
					case Enums.NavMeshHit_normal_ID:
						LinkInput_navMeshHit_rayDirection_ID_NavMeshHit_normal_ID ( sourceLogicNode);
						break;

					case Enums.NavMeshHit_position_ID:
						LinkInput_navMeshHit_rayDirection_ID_NavMeshHit_position_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.floatValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.floatValue_ID:
						LinkInput_Vector3_floatValues_0_ID_floatValue_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_0_ID:
						LinkInput_Vector3_floatValues_0_ID_floatValues_0_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_1_ID:
						LinkInput_Vector3_floatValues_0_ID_floatValues_1_ID ( sourceLogicNode);
						break;

					case Enums.floatValues_2_ID:
						LinkInput_Vector3_floatValues_0_ID_floatValues_2_ID ( sourceLogicNode);
						break;
					}

					break;

				case Enums.vector3Values_0_ID:
					switch (sourceNodeOutID)
					{

					case Enums.vector3Value_ID:
						LinkInput_Vector3_vector3Values_0_ID_vector3Value_ID ( sourceLogicNode);
						break;

					case Enums.vector3Values_0_ID:
						LinkInput_Vector3_vector3Values_0_ID_vector3Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector3Values_1_ID:
						LinkInput_Vector3_vector3Values_0_ID_vector3Values_1_ID ( sourceLogicNode);
						break;

					case Enums.rayOrigin_ID:
						LinkInput_Vector3_vector3Values_0_ID_rayOrigin_ID ( sourceLogicNode);
						break;

					case Enums.rayDirection_ID:
						LinkInput_Vector3_vector3Values_0_ID_rayDirection_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector3Values_1_ID:
					switch (sourceNodeOutID)
					{

					case Enums.vector3Value_ID:
						LinkInput_Vector3_vector3Values_1_ID_vector3Value_ID ( sourceLogicNode);
						break;

					case Enums.vector3Values_0_ID:
						LinkInput_Vector3_vector3Values_1_ID_vector3Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector3Values_1_ID:
						LinkInput_Vector3_vector3Values_1_ID_vector3Values_1_ID ( sourceLogicNode);
						break;

					case Enums.rayOrigin_ID:
						LinkInput_Vector3_vector3Values_1_ID_rayOrigin_ID ( sourceLogicNode);
						break;

					case Enums.rayDirection_ID:
						LinkInput_Vector3_vector3Values_1_ID_rayDirection_ID ( sourceLogicNode);
						break;

					}

					break;

				}


				switch (inID)
				{
				case Enums.rayOrigin_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector3Value_ID:
						LinkInput_Ray_rayOrigin_ID_vector3Value_ID ( sourceLogicNode);
						break;

					case Enums.vector3Values_0_ID:
						LinkInput_Ray_rayOrigin_ID_vector3Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector3Values_1_ID:
						LinkInput_Ray_rayOrigin_ID_vector3Values_1_ID ( sourceLogicNode);
						break;

					case Enums.rayOrigin_ID:
						LinkInput_Ray_rayOrigin_ID_rayOrigin_ID ( sourceLogicNode);
						break;

					case Enums.rayDirection_ID:
						LinkInput_Ray_rayOrigin_ID_rayDirection_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rayDirection_ID:
					switch (sourceNodeOutID)
					{
					case Enums.vector3Value_ID:
						LinkInput_Ray_rayDirection_ID_vector3Value_ID ( sourceLogicNode);
						break;

					case Enums.vector3Values_0_ID:
						LinkInput_Ray_rayDirection_ID_vector3Values_0_ID ( sourceLogicNode);
						break;

					case Enums.vector3Values_1_ID:
						LinkInput_Ray_rayDirection_ID_vector3Values_1_ID ( sourceLogicNode);
						break;

					case Enums.rayOrigin_ID:
						LinkInput_Ray_rayDirection_ID_rayOrigin_ID ( sourceLogicNode);
						break;

					case Enums.rayDirection_ID:
						LinkInput_Ray_rayDirection_ID_rayDirection_ID ( sourceLogicNode);
						break;

					}

					break;

				}


				switch (inID)
				{
				case Enums.vector3Values_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boundsCenterValue_ID:
						LinkInput_GameObject_vector3Values_0_ID_boundsCenterValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsExtentsValue_ID:
						LinkInput_GameObject_vector3Values_0_ID_boundsExtentsValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsMaxValue_ID:
						LinkInput_GameObject_vector3Values_0_ID_boundsMaxValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsMinValue_ID:
						LinkInput_GameObject_vector3Values_0_ID_boundsMinValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsSizeValue_ID:
						LinkInput_GameObject_vector3Values_0_ID_boundsSizeValue_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector3Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boundsCenterValue_ID:
						LinkInput_GameObject_vector3Values_1_ID_boundsCenterValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsExtentsValue_ID:
						LinkInput_GameObject_vector3Values_1_ID_boundsExtentsValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsMaxValue_ID:
						LinkInput_GameObject_vector3Values_1_ID_boundsMaxValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsMinValue_ID:
						LinkInput_GameObject_vector3Values_1_ID_boundsMinValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsSizeValue_ID:
						LinkInput_GameObject_vector3Values_1_ID_boundsSizeValue_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rayOrigin_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boundsCenterValue_ID:
						LinkInput_GameObject_rayOrigin_ID_boundsCenterValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsExtentsValue_ID:
						LinkInput_GameObject_rayOrigin_ID_boundsExtentsValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsMaxValue_ID:
						LinkInput_GameObject_rayOrigin_ID_boundsMaxValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsMinValue_ID:
						LinkInput_GameObject_rayOrigin_ID_boundsMinValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsSizeValue_ID:
						LinkInput_GameObject_rayOrigin_ID_boundsSizeValue_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rayDirection_ID:
					switch (sourceNodeOutID)
					{
					case Enums.boundsCenterValue_ID:
						LinkInput_GameObject_rayDirection_ID_boundsCenterValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsExtentsValue_ID:
						LinkInput_GameObject_rayDirection_ID_boundsExtentsValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsMaxValue_ID:
						LinkInput_GameObject_rayDirection_ID_boundsMaxValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsMinValue_ID:
						LinkInput_GameObject_rayDirection_ID_boundsMinValue_ID ( sourceLogicNode);
						break;

					case Enums.boundsSizeValue_ID:
						LinkInput_GameObject_rayDirection_ID_boundsSizeValue_ID ( sourceLogicNode);
						break;

					}

					break;

				}


				switch (inID)
				{
				case Enums.vector3Values_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitBarycentricCoordinate_ID:
						LinkInput_RaycastV3_vector3Values_0_ID_raycastHitBarycentricCoordinate_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitNormal_ID:
						LinkInput_RaycastV3_vector3Values_0_ID_raycastHitNormal_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitPoint_ID:
						LinkInput_RaycastV3_vector3Values_0_ID_raycastHitPoint_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector3Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitBarycentricCoordinate_ID:
						LinkInput_RaycastV3_vector3Values_1_ID_raycastHitBarycentricCoordinate_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitNormal_ID:
						LinkInput_RaycastV3_vector3Values_1_ID_raycastHitNormal_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitPoint_ID:
						LinkInput_RaycastV3_vector3Values_1_ID_raycastHitPoint_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rayOrigin_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitBarycentricCoordinate_ID:
						LinkInput_RaycastV3_rayOrigin_ID_raycastHitBarycentricCoordinate_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitNormal_ID:
						LinkInput_RaycastV3_rayOrigin_ID_raycastHitNormal_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitPoint_ID:
						LinkInput_RaycastV3_rayOrigin_ID_raycastHitPoint_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rayDirection_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitBarycentricCoordinate_ID:
						LinkInput_RaycastV3_rayDirection_ID_raycastHitBarycentricCoordinate_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitNormal_ID:
						LinkInput_RaycastV3_rayDirection_ID_raycastHitNormal_ID ( sourceLogicNode);
						break;

					case Enums.raycastHitPoint_ID:
						LinkInput_RaycastV3_rayDirection_ID_raycastHitPoint_ID ( sourceLogicNode);
						break;

					}

					break;

				}


				switch (inID)
				{
				case Enums.vector3Values_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.OffMeshLinkData_startPosition_ID:
						LinkInput_OffMeshLink_vector3Values_0_ID_OffMeshLinkData_startPosition_ID ( sourceLogicNode);
						break;

					case Enums.OffMeshLinkData_endPosition_ID:
						LinkInput_OffMeshLink_vector3Values_0_ID_OffMeshLinkData_endPosition_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.vector3Values_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.OffMeshLinkData_startPosition_ID:
						LinkInput_OffMeshLink_vector3Values_1_ID_OffMeshLinkData_startPosition_ID ( sourceLogicNode);
						break;

					case Enums.OffMeshLinkData_endPosition_ID:
						LinkInput_OffMeshLink_vector3Values_1_ID_OffMeshLinkData_endPosition_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rayOrigin_ID:
					switch (sourceNodeOutID)
					{
					case Enums.OffMeshLinkData_startPosition_ID:
						LinkInput_OffMeshLink_rayOrigin_ID_OffMeshLinkData_startPosition_ID ( sourceLogicNode);
						break;

					case Enums.OffMeshLinkData_endPosition_ID:
						LinkInput_OffMeshLink_rayOrigin_ID_OffMeshLinkData_endPosition_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.rayDirection_ID:
					switch (sourceNodeOutID)
					{
					case Enums.OffMeshLinkData_startPosition_ID:
						LinkInput_OffMeshLink_rayDirection_ID_OffMeshLinkData_startPosition_ID ( sourceLogicNode);
						break;

					case Enums.OffMeshLinkData_endPosition_ID:
						LinkInput_OffMeshLink_rayDirection_ID_OffMeshLinkData_endPosition_ID ( sourceLogicNode);
						break;

					}

					break;

				}
				break;


			case VariableType.GameObject:
				switch (inID)
				{
				case Enums.gameObjectValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitGameObject_ID:
						LinkInput_RaycastV3_gameObjectValues_0_ID_raycastHitGameObject_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.gameObjectValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.raycastHitGameObject_ID:
						LinkInput_RaycastV3_gameObjectValues_1_ID_raycastHitGameObject_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.gameObjectValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.gameObjectValue_ID:
						LinkInput_RaycastV3_gameObjectValues_0_ID_gameObjectValue_ID ( sourceLogicNode);
						break;

					case Enums.gameObjectValues_0_ID:
						LinkInput_RaycastV3_gameObjectValues_0_ID_gameObjectValues_0_ID ( sourceLogicNode);
						break;

					case Enums.gameObjectValues_1_ID:
						LinkInput_RaycastV3_gameObjectValues_0_ID_gameObjectValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.gameObjectValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.gameObjectValue_ID:
						LinkInput_RaycastV3_gameObjectValues_1_ID_gameObjectValue_ID ( sourceLogicNode);
						break;

					case Enums.gameObjectValues_0_ID:
						LinkInput_RaycastV3_gameObjectValues_1_ID_gameObjectValues_0_ID ( sourceLogicNode);
						break;

					case Enums.gameObjectValues_1_ID:
						LinkInput_RaycastV3_gameObjectValues_1_ID_gameObjectValues_1_ID ( sourceLogicNode);
						break;

					}

					break;

				}

				switch (inID)
				{
				case Enums.gameObjectValues_0_ID:
					switch (sourceNodeOutID)
					{
					case Enums.hit2D_gameObject_ID:
						LinkInput_hit2D_gameObjectValues_0_ID_hit2D_gameObject_ID ( sourceLogicNode);
						break;

					}

					break;

				case Enums.gameObjectValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.hit2D_gameObject_ID:
						LinkInput_hit2D_gameObjectValues_1_ID_hit2D_gameObject_ID ( sourceLogicNode);
						break;

					}

					break;

				}




				//listlink
				lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources [IndexOfInID (inID)]);
				switch (inID)
				{
				case Enums.gameObjectValues_0_ID:		
					switch (sourceNodeOutID)
					{
					case Enums.gameObjectsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.gameObjectsListValue.Count)
						{
							gameObjectValues [0] = sourceLogicNode.gameObjectsListValue [lstIndex];

							gameObjectValuesOld [0] = gameObjectValues [0];
						}
						break;
					}
					break;

				case Enums.gameObjectValues_1_ID:
					switch (sourceNodeOutID)
					{
					case Enums.gameObjectsList_ID:
						if (lstIndex >-1 && lstIndex < sourceLogicNode.gameObjectsListValue.Count)
						{
							gameObjectValues [1] = sourceLogicNode.gameObjectsListValue [lstIndex];

							gameObjectValuesOld [1] = gameObjectValues [1];
						}
						break;
					}
					break;
				}
				break;
			}
		}


		void LinkInput_navMeshHit_boolValues_0_ID_NavMeshHit_hit_ID ( LogicNode sourceLogicNode)
		{
			boolValues [0] = sourceLogicNode.NavMeshHit_hit;
		}

		void LinkInput_navMeshHit_boolValues_1_ID_NavMeshHit_hit_ID ( LogicNode sourceLogicNode)
		{
			boolValues [1] = sourceLogicNode.NavMeshHit_hit;
		}

		void LinkInput_navMeshHit_doIt_ID_NavMeshHit_hit_ID ( LogicNode sourceLogicNode)
		{
			doIT = sourceLogicNode.NavMeshHit_hit;
		}




		void LinkInput_navMeshHit_floatValues_0_ID_NavMeshHit_distance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.NavMeshHit_distance;
		}

		void LinkInput_navMeshHit_floatValues_1_ID_NavMeshHit_distance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.NavMeshHit_distance;
		}

		void LinkInput_navMeshHit_floatValues_2_ID_NavMeshHit_distance_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.NavMeshHit_distance;
		}


		void LinkInput_RaycastV3_gameObjectValues_0_ID_gameObjectValue_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 0;

			gameObjectValues [inGoVID] = sourceLogicNode.gameObjectValue;

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}

		void LinkInput_RaycastV3_gameObjectValues_0_ID_gameObjectValues_0_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 0;

			gameObjectValues [inGoVID] = sourceLogicNode.gameObjectValues [0];

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}

		void LinkInput_RaycastV3_gameObjectValues_0_ID_gameObjectValues_1_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 0;

			gameObjectValues [inGoVID] = sourceLogicNode.gameObjectValues [1];

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}



		void LinkInput_RaycastV3_gameObjectValues_1_ID_gameObjectValue_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 1;

			gameObjectValues [inGoVID] = sourceLogicNode.gameObjectValue;

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}

		void LinkInput_RaycastV3_gameObjectValues_1_ID_gameObjectValues_0_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 1;

			gameObjectValues [inGoVID] = sourceLogicNode.gameObjectValues [0];

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}

		void LinkInput_RaycastV3_gameObjectValues_1_ID_gameObjectValues_1_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 1;

			gameObjectValues [inGoVID] = sourceLogicNode.gameObjectValues [1];

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}




		void LinkInput_RaycastV3_gameObjectValues_0_ID_raycastHitGameObject_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 0;

			gameObjectValues [inGoVID] = sourceLogicNode.raycastHitGameObject;

			//gameObjectValuesOld [0] = gameObjectValues [0];

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}

		void LinkInput_RaycastV3_gameObjectValues_1_ID_raycastHitGameObject_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 1;

			gameObjectValues [inGoVID] = sourceLogicNode.raycastHitGameObject;

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}


		void LinkInput_hit2D_gameObjectValues_0_ID_hit2D_gameObject_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 0;

			gameObjectValues [inGoVID] = sourceLogicNode.hit2D_gameObject;

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}

		void LinkInput_hit2D_gameObjectValues_1_ID_hit2D_gameObject_ID ( LogicNode sourceLogicNode)
		{
			int inGoVID = 1;

			gameObjectValues [inGoVID] = sourceLogicNode.hit2D_gameObject;

			//gameObjectValuesUIs [inGoVID] = 
			//	GameObjectFinderAux.AddComponent 
			//	(gameObjectValues [inGoVID], gameObjectValuesOld [inGoVID]);
		}



		void LinkInput_GameObject_vector3Values_0_ID_boundsCenterValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.boundsCenterValue;
		}

		void LinkInput_GameObject_vector3Values_0_ID_boundsExtentsValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.boundsExtentsValue;
		}

		void LinkInput_GameObject_vector3Values_0_ID_boundsMaxValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.boundsMaxValue;
		}

		void LinkInput_GameObject_vector3Values_0_ID_boundsMinValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.boundsMinValue;
		}

		void LinkInput_GameObject_vector3Values_0_ID_boundsSizeValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.boundsSizeValue;
		}

		void LinkInput_GameObject_vector3Values_1_ID_boundsCenterValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.boundsCenterValue;
		}

		void LinkInput_GameObject_vector3Values_1_ID_boundsExtentsValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.boundsExtentsValue;
		}

		void LinkInput_GameObject_vector3Values_1_ID_boundsMaxValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.boundsMaxValue;
		}

		void LinkInput_GameObject_vector3Values_1_ID_boundsMinValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.boundsMinValue;
		}

		void LinkInput_GameObject_vector3Values_1_ID_boundsSizeValue_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.boundsSizeValue;
		}

		void LinkInput_GameObject_rayOrigin_ID_boundsCenterValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.boundsCenterValue); 
		}

		void LinkInput_GameObject_rayOrigin_ID_boundsExtentsValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.boundsExtentsValue); 
		}

		void LinkInput_GameObject_rayOrigin_ID_boundsMaxValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.boundsMaxValue); 
		}

		void LinkInput_GameObject_rayOrigin_ID_boundsMinValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.boundsMinValue); 
		}

		void LinkInput_GameObject_rayOrigin_ID_boundsSizeValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.boundsSizeValue); 
		}

		void LinkInput_GameObject_rayDirection_ID_boundsCenterValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.boundsCenterValue); 
		}

		void LinkInput_GameObject_rayDirection_ID_boundsExtentsValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.boundsExtentsValue); 
		}

		void LinkInput_GameObject_rayDirection_ID_boundsMaxValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.boundsMaxValue); 
		}

		void LinkInput_GameObject_rayDirection_ID_boundsMinValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.boundsMinValue); 
		}

		void LinkInput_GameObject_rayDirection_ID_boundsSizeValue_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.boundsSizeValue); 
		}




		void SetRay2DValueOrigine (Vector2 v)
		{
			ray2DValueOrigin = v; 

			ray2DValue.origin = v;
		}

		void SetRay2DDirectionValue (Vector3 v)
		{
			ray2DDirectionValueNotNormalized = v;

			ray2DValue.direction = v.normalized;
		}

		void LinkInput_Ray2D_ray2DOrigin_ID_vector2Value_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.vector2Value);
		}

		void LinkInput_Ray2D_ray2DOrigin_ID_vector2Values_0_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.vector2Values [0]);
		}

		void LinkInput_Ray2D_ray2DOrigin_ID_vector2Values_1_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.vector2Values [1]);
		}

		void LinkInput_Ray2D_ray2DOrigin_ID_ray2DOrigin_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.ray2DValueOrigin);
		}

		void LinkInput_Ray2D_ray2DOrigin_ID_ray2DDirection_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DValueOrigine (sourceLogicNode.ray2DDirectionValueNotNormalized);
		}

		void LinkInput_Ray2D_ray2DDirection_ID_vector2Value_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.vector2Value);
		}

		void LinkInput_Ray2D_ray2DDirection_ID_vector2Values_0_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.vector2Values [0]);
		}

		void LinkInput_Ray2D_ray2DDirection_ID_vector2Values_1_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.vector2Values [1]);
		}

		void LinkInput_Ray2D_ray2DDirection_ID_ray2DOrigin_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.ray2DValueOrigin);
		}

		void LinkInput_Ray2D_ray2DDirection_ID_ray2DDirection_ID ( LogicNode sourceLogicNode)
		{
			SetRay2DDirectionValue (sourceLogicNode.ray2DDirectionValueNotNormalized);
		}


		void SetRayValueOrigine (Vector3 v)
		{
			rayValueOrigin = v; 

			rayValue.origin = v;
		}

		void SetRayDirectionValue (Vector3 v)
		{
			rayDirectionValueNotNormalized = v;

			rayValue.direction = v.normalized;
		}

		void LinkInput_Ray_rayOrigin_ID_vector3Value_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.vector3Value);
		}

		void LinkInput_Ray_rayOrigin_ID_vector3Values_0_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.vector3Values [0]);
		}

		void LinkInput_Ray_rayOrigin_ID_vector3Values_1_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.vector3Values [1]);
		}

		void LinkInput_Ray_rayOrigin_ID_rayOrigin_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.rayValueOrigin);
		}

		void LinkInput_Ray_rayOrigin_ID_rayDirection_ID ( LogicNode sourceLogicNode)
		{
			SetRayValueOrigine (sourceLogicNode.rayDirectionValueNotNormalized);
		}

		void LinkInput_Ray_rayDirection_ID_vector3Value_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.vector3Value);
		}

		void LinkInput_Ray_rayDirection_ID_vector3Values_0_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.vector3Values [0]);
		}

		void LinkInput_Ray_rayDirection_ID_vector3Values_1_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.vector3Values [1]);
		}

		void LinkInput_Ray_rayDirection_ID_rayOrigin_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.rayValueOrigin);
		}

		void LinkInput_Ray_rayDirection_ID_rayDirection_ID ( LogicNode sourceLogicNode)
		{
			SetRayDirectionValue (sourceLogicNode.rayDirectionValueNotNormalized);
		}



		void LinkInput_Vector3_floatValues_0_ID_floatValue_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValue;
		}

		void LinkInput_Vector3_floatValues_0_ID_floatValues_0_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValues [0];
		}

		void LinkInput_Vector3_floatValues_0_ID_floatValues_1_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValues [1];
		}

		void LinkInput_Vector3_floatValues_0_ID_floatValues_2_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValues [2];
		}

		void LinkInput_Vector3_vector3Values_0_ID_vector3Value_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.vector3Value;
		}

		void LinkInput_Vector3_vector3Values_0_ID_vector3Values_0_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.vector3Values [0];
		}

		void LinkInput_Vector3_vector3Values_0_ID_vector3Values_1_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.vector3Values [1];
		}

		void LinkInput_Vector3_vector3Values_0_ID_rayOrigin_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.rayValueOrigin;
		}

		void LinkInput_Vector3_vector3Values_0_ID_rayDirection_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [0] = sourceLogicNode.rayDirectionValueNotNormalized;
		}


		void LinkInput_Vector3_vector3Values_1_ID_vector3Value_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.vector3Value;
		}

		void LinkInput_Vector3_vector3Values_1_ID_vector3Values_0_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.vector3Values [0];
		}

		void LinkInput_Vector3_vector3Values_1_ID_vector3Values_1_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.vector3Values [1];
		}

		void LinkInput_Vector3_vector3Values_1_ID_rayOrigin_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.rayValueOrigin;
		}

		void LinkInput_Vector3_vector3Values_1_ID_rayDirection_ID ( LogicNode sourceLogicNode)
		{
			vector3Values [1] = sourceLogicNode.rayDirectionValueNotNormalized;
		}



		void LinkInput_Vector2_floatValues_0_ID_floatValue_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValue;
		}

		void LinkInput_Vector2_floatValues_0_ID_floatValues_0_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValues [0];
		}

		void LinkInput_Vector2_floatValues_0_ID_floatValues_1_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValues [1];
		}

		void LinkInput_Vector2_floatValues_0_ID_floatValues_2_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValues [2];
		}

		void LinkInput_Vector2_vector2Values_0_ID_vector2Value_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.vector2Value;
		}

		void LinkInput_Vector2_vector2Values_0_ID_vector2Values_0_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.vector2Values [0];
		}

		void LinkInput_Vector2_vector2Values_0_ID_vector2Values_1_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.vector2Values [1];
		}

		void LinkInput_Vector2_vector2Values_0_ID_ray2DOrigin_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.ray2DValueOrigin;
		}

		void LinkInput_Vector2_vector2Values_0_ID_ray2DDirection_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [0] = sourceLogicNode.ray2DDirectionValueNotNormalized;
		}

		void LinkInput_Vector2_vector2Values_1_ID_vector2Value_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.vector2Value;
		}

		void LinkInput_Vector2_vector2Values_1_ID_vector2Values_0_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.vector2Values [0];
		}

		void LinkInput_Vector2_vector2Values_1_ID_vector2Values_1_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.vector2Values [1];
		}

		void LinkInput_Vector2_vector2Values_1_ID_ray2DOrigin_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.ray2DValueOrigin;
		}

		void LinkInput_Vector2_vector2Values_1_ID_ray2DDirection_ID ( LogicNode sourceLogicNode)
		{
			vector2Values [1] = sourceLogicNode.ray2DDirectionValueNotNormalized;
		}





		void LinkInput_Bool_boolValues_0_ID_boolValue_ID ( LogicNode sourceLogicNode)
		{
			boolValues [0] = sourceLogicNode.boolValue;
		}

		void LinkInput_Bool_boolValues_0_ID_boolValues_0_ID ( LogicNode sourceLogicNode)
		{
			boolValues [0] = sourceLogicNode.boolValues [0];
		}

		void LinkInput_Bool_boolValues_0_ID_boolValues_1_ID ( LogicNode sourceLogicNode)
		{
			boolValues [0] = sourceLogicNode.boolValues [1];
		}


		void LinkInput_Bool_boolValues_1_ID_boolValue_ID ( LogicNode sourceLogicNode)
		{
			boolValues [1] = sourceLogicNode.boolValue;
		}

		void LinkInput_Bool_boolValues_1_ID_boolValues_0_ID ( LogicNode sourceLogicNode)
		{
			boolValues [1] = sourceLogicNode.boolValues [0];
		}

		void LinkInput_Bool_boolValues_1_ID_boolValues_1_ID ( LogicNode sourceLogicNode)
		{
			boolValues [1] = sourceLogicNode.boolValues [1];
		}



		void LinkInput_Color_colorValues_0_ID_colorValue_ID ( LogicNode sourceLogicNode)
		{
			colorValues [0] = sourceLogicNode.colorValue;
		}

		void LinkInput_Color_colorValues_0_ID_colorValues_0_ID ( LogicNode sourceLogicNode)
		{
			colorValues [0] = sourceLogicNode.colorValues [0];
		}

		void LinkInput_Color_colorValues_0_ID_colorValues_1_ID ( LogicNode sourceLogicNode)
		{
			colorValues [0] = sourceLogicNode.colorValues [1];
		}

		void LinkInput_Color_colorValues_1_ID_colorValue_ID ( LogicNode sourceLogicNode)
		{
			colorValues [1] = sourceLogicNode.colorValue;
		}

		void LinkInput_Color_colorValues_1_ID_colorValues_0_ID ( LogicNode sourceLogicNode)
		{
			colorValues [1] = sourceLogicNode.colorValues [0];
		}

		void LinkInput_Color_colorValues_1_ID_colorValues_1_ID ( LogicNode sourceLogicNode)
		{
			colorValues [1] = sourceLogicNode.colorValues [1];
		}



		void LinkInput_Float_floatValues_0_ID_floatValue_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValue;
		}

		void LinkInput_Float_floatValues_0_ID_floatValues_0_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValues [0];
		}

		void LinkInput_Float_floatValues_0_ID_floatValues_1_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValues [1];
		}

		void LinkInput_Float_floatValues_0_ID_floatValues_2_ID ( LogicNode sourceLogicNode)
		{
			floatValues [0] = sourceLogicNode.floatValues [2];
		}

		void LinkInput_Float_floatValues_1_ID_floatValue_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.floatValue;
		}

		void LinkInput_Float_floatValues_1_ID_floatValues_0_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.floatValues [0];
		}

		void LinkInput_Float_floatValues_1_ID_floatValues_1_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.floatValues [1];
		}

		void LinkInput_Float_floatValues_1_ID_floatValues_2_ID ( LogicNode sourceLogicNode)
		{
			floatValues [1] = sourceLogicNode.floatValues [2];
		}

		void LinkInput_Float_floatValues_2_ID_floatValue_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.floatValue;
		}

		void LinkInput_Float_floatValues_2_ID_floatValues_0_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.floatValues [0];
		}

		void LinkInput_Float_floatValues_2_ID_floatValues_1_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.floatValues [1];
		}

		void LinkInput_Float_floatValues_2_ID_floatValues_2_ID ( LogicNode sourceLogicNode)
		{
			floatValues [2] = sourceLogicNode.floatValues [2];
		}



		void LinkInput_Int_intValues_0_ID_intValue_ID ( LogicNode sourceLogicNode)
		{
			intValues [0] = sourceLogicNode.intValue;
		}

		void LinkInput_Int_intValues_0_ID_intValues_0_ID ( LogicNode sourceLogicNode)
		{
			intValues [0] = sourceLogicNode.intValues [0];
		}

		void LinkInput_Int_intValues_0_ID_intValues_1_ID ( LogicNode sourceLogicNode)
		{
			intValues [0] = sourceLogicNode.intValues [1];
		}

		void LinkInput_Int_intValues_0_ID_intValues_2_ID ( LogicNode sourceLogicNode)
		{
			intValues [0] = sourceLogicNode.intValues [2];
		}

		void LinkInput_Int_intValues_1_ID_intValue_ID ( LogicNode sourceLogicNode)
		{
			intValues [1] = sourceLogicNode.intValue;
		}

		void LinkInput_Int_intValues_1_ID_intValues_0_ID ( LogicNode sourceLogicNode)
		{
			intValues [1] = sourceLogicNode.intValues [0];
		}

		void LinkInput_Int_intValues_1_ID_intValues_1_ID ( LogicNode sourceLogicNode)
		{
			intValues [1] = sourceLogicNode.intValues [1];
		}

		void LinkInput_Int_intValues_1_ID_intValues_2_ID ( LogicNode sourceLogicNode)
		{
			intValues [1] = sourceLogicNode.intValues [2];
		}

		void LinkInput_Int_intValues_2_ID_intValue_ID ( LogicNode sourceLogicNode)
		{
			intValues [2] = sourceLogicNode.intValue;
		}

		void LinkInput_Int_intValues_2_ID_intValues_0_ID ( LogicNode sourceLogicNode)
		{
			intValues [2] = sourceLogicNode.intValues [0];
		}

		void LinkInput_Int_intValues_2_ID_intValues_1_ID ( LogicNode sourceLogicNode)
		{
			intValues [2] = sourceLogicNode.intValues [1];
		}

		void LinkInput_Int_intValues_2_ID_intValues_2_ID ( LogicNode sourceLogicNode)
		{
			intValues [2] = sourceLogicNode.intValues [2];
		}


		void LinkInput_String_stringValues_0_ID_stringValue_ID ( LogicNode sourceLogicNode)
		{
			stringValues [0] = sourceLogicNode.stringValue;
		}

		void LinkInput_String_stringValues_0_ID_stringValues_0_ID ( LogicNode sourceLogicNode)
		{
			stringValues [0] = sourceLogicNode.stringValues [0];
		}

		void LinkInput_String_stringValues_0_ID_stringValues_1_ID ( LogicNode sourceLogicNode)
		{
			stringValues [0] = sourceLogicNode.stringValues [1];
		}

		void LinkInput_String_stringValues_1_ID_stringValue_ID ( LogicNode sourceLogicNode)
		{
			stringValues [1] = sourceLogicNode.stringValue;
		}

		void LinkInput_String_stringValues_1_ID_stringValues_0_ID ( LogicNode sourceLogicNode)
		{
			stringValues [1] = sourceLogicNode.stringValues [0];
		}

		void LinkInput_String_stringValues_1_ID_stringValues_1_ID ( LogicNode sourceLogicNode)
		{
			stringValues [1] = sourceLogicNode.stringValues [1];
		}

		//e1
		// 90



		//
		void LinkInputWithProjectVariable (string inID, string inSource, int inIndex)
		{
			if (string.IsNullOrEmpty (inSource))
				return;

			string sourceUID = InOutAdressCurrentToLinkToUniqueID (inSource);

			ProjectVariable sourcePv = Diamond.projectVariables.ProjectVariableOnUniqueID (sourceUID);

			if (sourcePv == null)
				return;

			if ( ! sourcePv.getState)
				return;

			DrawLink_Pv (sourcePv.getRect.center, inputsRects [inIndex].center, sourcePv.Showing (), permittedInputs [inIndex]);

			LinkInputWithProjectVariableAction (inIndex, inID, sourcePv);
		}

		void DrawLink_Pv (Vector2 start, Vector2 end, bool showing, bool permittedInput)
		{
			if ( ! showing)
				return;

			//ColorsArithmetic.RGB_255_To_Normalized (31f, 208f, 235f, 1f);
			Color linkColor_Pv = ColorsArithmetic.RGB_255_To_Normalized (25f, 250f, 235f, 1f);

			//float tanLength_Pv = -100f;

			//float linkWidth_Pv = 5f;

			Vector2 startTan_Pv = Vector2.one;

			Vector2 endTan_Pv = Vector2.one;

			//tanLength_Pv = 30f;

			startTan_Pv = start + new Vector2 (tanLength, 0f);

			endTan_Pv = end + new Vector2 (-tanLength, 0f);


			Color linkColorToDraw = permittedInput? linkColor_Pv: 
				ColorModifierSimple.SemiDot (linkColor_Pv, new Vector4 (1f, 1f, 1f, notPermittedInputAlphaColor));

			Handles.DrawBezier (start, end, startTan_Pv, endTan_Pv, linkColorToDraw, null, linkWidth);
		} 

		void LinkInputWithProjectVariableAction (int inIndex, string inID, ProjectVariable sourcePv)
		{
			if ( ! permittedInputs [inIndex])
				return;

			switch (inputsTypes [inIndex])
			{
			case VariableType.Bool:
				switch (inID)
				{
				case Enums.boolValues_0_ID:
					boolValues [0] = sourcePv.boolValue;
					break;

				case Enums.boolValues_1_ID:
					boolValues [1] = sourcePv.boolValue;
					break;
				}
				break;

			case VariableType.Float:
				switch (inID)
				{
				case Enums.floatValues_0_ID:
					floatValues [0] = sourcePv.floatValue;
					break;

				case Enums.floatValues_1_ID:
					floatValues [1] = sourcePv.floatValue;
					break;

				case Enums.floatValues_2_ID:
					floatValues [2] = sourcePv.floatValue;
					break;
				}
				break;

			case VariableType.Int:
				switch (inID)
				{
				case Enums.intValues_0_ID:
					intValues [0] = sourcePv.intValue;
					break;

				case Enums.intValues_1_ID:
					intValues [1] = sourcePv.intValue;
					break;

				case Enums.intValues_2_ID:
					intValues [2] = sourcePv.intValue;
					break;
				}
				break;

			case VariableType.String:
				switch (inID)
				{
				case Enums.stringValues_0_ID:
					stringValues [0] = sourcePv.stringValue;
					break;

				case Enums.stringValues_1_ID:
					stringValues [1] = sourcePv.stringValue;
					break;
				}
				break;


			case VariableType.Vector2:
				switch (inID)
				{
				case Enums.vector2Values_0_ID:
					vector2Values [0] = sourcePv.vector2Value;
					break;

				case Enums.vector2Values_1_ID:
					vector2Values [1] = sourcePv.vector2Value;
					break;
				}
				break;

			case VariableType.Vector3:
				switch (inID)
				{
				case Enums.vector3Values_0_ID:
					vector3Values [0] = sourcePv.vector3Value;
					break;

				case Enums.vector3Values_1_ID:
					vector3Values [1] = sourcePv.vector3Value;
					break;
				}
				break;

			case VariableType.Vector4:
				switch (inID)
				{
				case Enums.vector4Values_0_ID:
					vector4Values [0] = sourcePv.vector4Value;
					break;

				case Enums.vector4Values_1_ID:
					vector4Values [1] = sourcePv.vector4Value;
					break;
				}
				break;

			case VariableType.GameObject:
				switch (inID)
				{
				case Enums.gameObjectValues_0_ID:
					gameObjectValues [0] = sourcePv.gameObjectValue;
					break;

				case Enums.gameObjectValues_1_ID:
					gameObjectValues [1] = sourcePv.gameObjectValue;
					break;
				}
				break;
			}
		}

		void LinkInput (string inID, string inSource, int inIndex)
		{
			if (string.IsNullOrEmpty (inSource))
				return;

			string sourceUID = InOutAdressCurrentToLinkToUniqueID (inSource);

			if (sourceUID.Length > 0)
			{
				if (sourceUID [0] == 'v')
				{
					if ( ! Diamond.projectVariables.ProjectVariableStillHereOnUniqueID (sourceUID))
					{
						inputsSources [inIndex] = "";

						return;
					}
				}
				else if ( ! SourceLogicNodeStillHereOnUniqueID (sourceUID))
				{
					inputsSources [inIndex] = "";

					return;
				}
			}



			LogicNode sourceLogicNode = GetLogicNodeOnUniqueID (sourceUID);


			string sourceNodeOutID = InOutAdressCurrentToLinkToInOutID (inSource);

			int sourceNodeOutIndex = IndexOfOutID (sourceNodeOutID);

			if (sourceNodeOutIndex < 0 || sourceNodeOutIndex > sourceLogicNode.activeOutputs.Length-1)
				return;

			if ( ! sourceLogicNode.activeOutputs [sourceNodeOutIndex])
				return;


			DrawLink (sourceLogicNode.outputsRects [sourceNodeOutIndex].center, 
				inputsRects [inIndex].center, permittedInputs [inIndex], inID);

			LinkInputAction (inIndex, inID, sourceNodeOutID, sourceLogicNode);

		}

		void LinkInput (string inID, string inSource, int inIndex, int currentInOutListIndex)
		{
			if ( ! string.IsNullOrEmpty  (logic.inOutAdressCurrentToLink))
			{
				if (InOutAdressCurrentToLinkToUniqueID (logic.inOutAdressCurrentToLink) == inSource)
				{
					return;
				}
			}

			//
			if (string.IsNullOrEmpty (inSource))
				return;

			string sourceUID = InOutAdressCurrentToLinkToUniqueID (inSource);

			if (sourceUID.Length > 0)
			{
				if (sourceUID [0] == 'v')
				{
					if ( ! Diamond.projectVariables.ProjectVariableStillHereOnUniqueID (sourceUID))
					{
						inputsSources [inIndex] = "";

						return;
					}
				}
				else if ( ! SourceLogicNodeStillHereOnUniqueID (sourceUID))
				{
					inputsSources [inIndex] = "";

					return;
				}
			}
			//

			//string sourceUID = InOutAdressCurrentToLinkToUniqueID (inSource);
			//
			//if ( ! SourceLogicNodeStillHereOnUniqueID (sourceUID))
			//{
			//	inputsSources [inIndex] = "";
			//
			//	return;
			//}

			LogicNode sourceLogicNode = GetLogicNodeOnUniqueID (sourceUID);


			string sourceNodeOutID = InOutAdressCurrentToLinkToInOutID (inSource, currentInOutListIndex);

			int sourceNodeOutIndex = IndexOfOutID (sourceNodeOutID);

			if (sourceNodeOutIndex < 0 || sourceNodeOutIndex > sourceLogicNode.activeOutputs.Length-1)
				return;

			if ( ! sourceLogicNode.activeOutputs [sourceNodeOutIndex])
				return;


			//DrawLink (sourceLogicNode.outputsRects [sourceNodeOutIndex].center, inputsRects [inIndex].center);


			if (InoutAdressToLinkToListIndex (inSource) > -1 && 
				InoutAdressToLinkToListIndex (inSource) < sourceLogicNode.outputListCounts [sourceNodeOutIndex])
			{
				DrawLink (GetDecaledListRect (sourceLogicNode, sourceNodeOutIndex, inSource).center, 
					inputsRects [inIndex].center, permittedInputs [inIndex], inID);
			}

			LinkInputAction (inIndex, inID, sourceNodeOutID, sourceLogicNode);

		}




		void RemoveListElement (bool isAnInput, string inOutID, int currentInOutListIndex)
		{
			if ( ! IsAListForInOutID (inOutID))
				return;

			switch (inOutID)
			{
			case Enums.gameObjectsList_ID:				
				gameObjectsListValue.RemoveAt (currentInOutListIndex);
				break;


			case Enums.rectList_ID:
				rectListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.shaderList_ID:
				shaderListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.vector4List_ID:
				vector4ListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.texture2DList_ID:
				texture2DListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.materialList_ID:
				materialsListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.vector2List_ID:
				vector2ListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.vector3List_ID:
				vector3ListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.boolsList_ID:
				boolsListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.floatsList_ID:
				floatsListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.intsList_ID:
				intsListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.stringsList_ID:
				stringsListValue.RemoveAt (currentInOutListIndex);
				break;

			case Enums.colorsList_ID:
				colorsListValue.RemoveAt (currentInOutListIndex);
				break;
			}
		}

		bool IsAListForInOutID (string inOutID)
		{
			if (string.IsNullOrEmpty (inOutID))
				return false;

			string before_ = StringTreatment.BeforeThat (inOutID, '_');

			if (string.IsNullOrEmpty (before_))
				return false;

			bool r = StringTreatment.IsEndWith_List (before_);

			return r;
		}


		string GetInRectSkin (string inID, int currentInOutListIndex)
		{
			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				return Skins.get;
			
			if (InOutAdressCurrentToLinkToInOutDirection () == inAdressSignature)
			{
				if (InOutAdressCurrentToLinkToUniqueID () == uniqueID)
				{
					if (InOutAdressCurrentToLinkToInOutID () == inID)
						return Skins.magnetInvert;
					else
						return Skins.get;
				}
				else
				{
					return Skins.get;
				}
			}
			
			if (IsInOutTypeSame (InOutAdressCurrentToLinkToInOutID (), inID) || 
				IsInOutTypeSameWeak (InOutAdressCurrentToLinkToInOutID (currentInOutListIndex), inID) )
			{
				return Skins.magnetInvert;
			}
			else
			{
				if (Nv_IsInOutTypeSame (InOutAdressCurrentToLinkToInOutID (), inID) || 
					Nv_IsInOutTypeSameWeak (InOutAdressCurrentToLinkToInOutID (currentInOutListIndex), inID) )
				{
					return Skins.magnetInvert;
				}

				return Skins.get;
			}
		}

		string GetOutRectSkin (string outID, int currentInOutListIndex)
		{
			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				return Skins.get;
			
			if (InOutAdressCurrentToLinkToInOutDirection () == outAdressSignature)
			{
				if (InOutAdressCurrentToLinkToUniqueID () == uniqueID)
				{
					if (outID == InOutAdressCurrentToLinkToInOutID () ||
						outID == InOutAdressCurrentToLinkToInOutID (currentInOutListIndex))
						return Skins.magnet;
					else
						return Skins.get;
				}
				else
				{
					return Skins.get;
				}
			}

			if ( ! IsInOutTypeSame (outID, InOutAdressCurrentToLinkToInOutID ()))
			{
				if ( Nv_IsInOutTypeSame (outID, InOutAdressCurrentToLinkToInOutID ()))
				{
					return Skins.magnet;
				}

				return Skins.get;
			}

			return Skins.magnet;
		}


		void DrawInputOutput (bool isAnInput, Vector2 atPosition, string inOutID,
			int currentInOutListIndex)
		{
			Rect inOutRect = InOutRect (isAnInput, atPosition);

			if (isAnInput)
			{
				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				{
					if ( ! publicInputs [IndexOfInID (inOutID)])
					{
						GUI.Box (inOutRect, "", Skins.guiSkin.GetStyle (GetInRectSkin (inOutID, currentInOutListIndex)));

						AssignInOutRect (isAnInput, inOutID, inOutRect);
					}
				}
			}
			else if ( ! isAnInput)
			{
				GUI.Box (inOutRect, "", Skins.guiSkin.GetStyle (GetOutRectSkin (inOutID, currentInOutListIndex)));

				AssignInOutRect (isAnInput, inOutID, inOutRect, currentInOutListIndex);
			}

			if (isAnInput)
			{
				Rect inputOptionsRect = new Rect (inOutRect.x + 1f*inOutRect.width, inOutRect.y, inOutRect.width, inOutRect.height);

				string inputOptionsRectSkin = Skins.asterix;
				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				if (publicInputs [IndexOfInID (inOutID)])
					inputOptionsRectSkin = Skins.publicVariable;

				if (GUI.Button (inputOptionsRect, "", Skins.guiSkin.GetStyle (inputOptionsRectSkin)) && eGlobal.button == 0)
				{
					OpenInputFieldOptionsMenu (inOutRect, inOutID);
				}

				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				{
					if ( ! publicInputs [IndexOfInID (inOutID)])
					{


						ActiveThisInput (inOutID);

						DrawInputPermissionButton (inOutRect, IndexOfInID (inOutID));

					}
				}
			}
			else
			{
				ActiveThisOutput (inOutID);
			}


			DrawRemoveListElementButton (isAnInput, inOutRect, inOutID, currentInOutListIndex);


			DrawCurrentLink (isAnInput, inOutRect, inOutID, currentInOutListIndex);

			if ( ! string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				AssignInputSource (isAnInput, inOutRect, inOutID);

			if (isAnInput)
			if ( ! string.IsNullOrEmpty (inputsSources [IndexOfInID (inOutID)]))
				DrawEstablishedLinks (currentInOutListIndex);

			DrawFloatingType (isAnInput, inOutRect, inOutID);

			DrawVariableTypeColor (inOutRect, inOutID);
		}

		void DrawInputOutput (bool isAnInput, Vector2 atPosition, string inOutID,
			int currentInOutListIndex, bool withRemoveElementButton)
		{
			Rect inOutRect = InOutRect (isAnInput, atPosition);

			if (isAnInput)
			{
				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				{
					if ( ! publicInputs [IndexOfInID (inOutID)])
					{
						GUI.Box (inOutRect, "", Skins.guiSkin.GetStyle (GetInRectSkin (inOutID, currentInOutListIndex)));

						AssignInOutRect (isAnInput, inOutID, inOutRect);
					}
				}
			}
			else if ( ! isAnInput)
			{
				GUI.Box (inOutRect, "", Skins.guiSkin.GetStyle (GetOutRectSkin (inOutID, currentInOutListIndex)));

				AssignInOutRect (isAnInput, inOutID, inOutRect, currentInOutListIndex);
			}

			if (isAnInput)
			{
				Rect inputOptionsRect = new Rect (inOutRect.x + 1f*inOutRect.width, inOutRect.y, inOutRect.width, inOutRect.height);

				string inputOptionsRectSkin = Skins.asterix;
				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				if (publicInputs [IndexOfInID (inOutID)])
					inputOptionsRectSkin = Skins.publicVariable;

				if (GUI.Button (inputOptionsRect, "", Skins.guiSkin.GetStyle (inputOptionsRectSkin)) && eGlobal.button == 0)
				{
					OpenInputFieldOptionsMenu (inOutRect, inOutID);
				}

				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				{
					if ( ! publicInputs [IndexOfInID (inOutID)])
					{


						ActiveThisInput (inOutID);

						DrawInputPermissionButton (inOutRect, IndexOfInID (inOutID));

					}
				}
			}
			else
			{
				ActiveThisOutput (inOutID);
			}

			if (withRemoveElementButton)
				DrawRemoveListElementButton (isAnInput, inOutRect, inOutID, currentInOutListIndex);


			DrawCurrentLink (isAnInput, inOutRect, inOutID, currentInOutListIndex);

			if ( ! string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				AssignInputSource (isAnInput, inOutRect, inOutID);

			if (isAnInput)
			if ( ! string.IsNullOrEmpty (inputsSources [IndexOfInID (inOutID)]))
				DrawEstablishedLinks (currentInOutListIndex);

			DrawFloatingType (isAnInput, inOutRect, inOutID);

			DrawVariableTypeColor (inOutRect, inOutID);
		}


		void DrawInputOutput (bool isAnInput, Vector2 atPosition, string inOutID)
		{
			Rect inOutRect = InOutRect (isAnInput, atPosition);

			if (isAnInput)
			{
				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				{
					if ( ! publicInputs [IndexOfInID (inOutID)])
					{
						if (inOutID == Enums.doIt_ID)
						{
							if ( ! alwaysDoIt)
							{
								GUI.Box (inOutRect, "", Skins.guiSkin.GetStyle (GetInRectSkin (inOutID, -1)));

								AssignInOutRect (isAnInput, inOutID, inOutRect);

								ActiveThisInput (inOutID);

								DrawInputPermissionButton (inOutRect, IndexOfInID (inOutID));
							}
						}
						else if (inOutID != Enums.doIt_ID)
						{
							GUI.Box (inOutRect, "", Skins.guiSkin.GetStyle (GetInRectSkin (inOutID, -1)));

							AssignInOutRect (isAnInput, inOutID, inOutRect);

							ActiveThisInput (inOutID);

							DrawInputPermissionButton (inOutRect, IndexOfInID (inOutID));
						}
					}

				}
			}
			else if ( ! isAnInput)
			{
				GUI.Box (inOutRect, "", Skins.guiSkin.GetStyle (GetOutRectSkin (inOutID, -1)));

				AssignInOutRect (isAnInput, inOutID, inOutRect);
			}

			if (isAnInput)
			{
				Rect inputOptionsRect = 
					new Rect (inOutRect.x + 1f*inOutRect.width, 
						inOutRect.y, inOutRect.width, inOutRect.height);

				string inputOptionsRectSkin = Skins.asterix;
				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				if (publicInputs [IndexOfInID (inOutID)])
					inputOptionsRectSkin = Skins.publicVariable;

				if (GUI.Button (inputOptionsRect, "", Skins.guiSkin.GetStyle (inputOptionsRectSkin)) && eGlobal.button == 0)
				{
					OpenInputFieldOptionsMenu (inOutRect, inOutID);
				}

				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				{
					if ( ! publicInputs [IndexOfInID (inOutID)])
					{
						if (inOutID == Enums.doIt_ID)
						{
							if ( ! alwaysDoIt)
							{
								GUI.Box (inOutRect, "", Skins.guiSkin.GetStyle (GetInRectSkin (inOutID, -1)));

								AssignInOutRect (isAnInput, inOutID, inOutRect);

								ActiveThisInput (inOutID);

								DrawInputPermissionButton (inOutRect, IndexOfInID (inOutID));
							}
						}
						else if (inOutID != Enums.doIt_ID)
						{
							GUI.Box (inOutRect, "", Skins.guiSkin.GetStyle (GetInRectSkin (inOutID, -1)));

							AssignInOutRect (isAnInput, inOutID, inOutRect);

							ActiveThisInput (inOutID);

							DrawInputPermissionButton (inOutRect, IndexOfInID (inOutID));
						}
					}
				}
			}
			else if ( ! isAnInput)
			{
				ActiveThisOutput (inOutID);
			}


			DrawCurrentLink (isAnInput, inOutRect, inOutID);

			if ( ! string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				AssignInputSource (isAnInput, inOutRect, inOutID);

			if (isAnInput)
			if ( ! string.IsNullOrEmpty (inputsSources [IndexOfInID (inOutID)]))
				DrawEstablishedLinks (-1);

			DrawFloatingType (isAnInput, inOutRect, inOutID);

			DrawVariableTypeColor (inOutRect, inOutID);
		}

		void DrawVariableTypeColor (Rect inOutRect, string inOutID)
		{
			if (IsList (inOutID))
				return;
			
			float reductFactor = 0.3f;

			Rect drawingRect = new Rect (
				rect.x + rect.width - (1f+reductFactor)*inOutRect.width, inOutRect.y + 
				reductFactor*inOutRect.height, 
				inOutRect.width*(1f-reductFactor), inOutRect.height*(1f-reductFactor));

			GUI.backgroundColor = Diamond.namesToSave.variableTypeColor [
				InOutIDToVariableTypeEnumIndex (inOutID)];
			
			GUI.Box (drawingRect, "");

			GUI.backgroundColor = Color.white;
		}

		public static bool IsList (string inOutID)
		{
			return StringTreatment.IsEndWith_List (StringTreatment.BeforeThat (inOutID, '_'));
		}

		void DrawFloatingType (bool isAnInput, Rect inOutRect, string inOutID)
		{
			if ( ! inOutRect.Contains (eGlobal.mousePosition))
				return;

			Vector2 pos = inOutRect.center;

			string inOutIDTypeName = InOutIDToTypeName (isAnInput, inOutID);

			float characterShifting = 2.5f*(float)inOutIDTypeName.Length;

			Vector2 shift = new Vector2 (40f, -35f);

			if (isAnInput)
			{
				pos = pos + new Vector2 ((-shift.x) - characterShifting, shift.y);
			}
			else
			{
				pos = pos + new Vector2 ((0.8f*shift.x) + characterShifting, shift.y);
			}

			DrawFloatingMessage (pos, inOutIDTypeName);
		}



		void DrawInputPermissionButton (Rect inOutRect, int indexOfInput)
		{
			if ( ! dataFlowControlEnabled [indexOfInput])
			{
				permittedInputs [indexOfInput] = true;

				return;
			}

			string skinPermission = permittedInputs [indexOfInput]? Skins.gate: Skins.gateBloc;

			if ( ! string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
			{
				if (InOutAdressCurrentToLinkToInOutDirection () == outAdressSignature)
				{
					if (IsInOutTypeSame (InOutAdressCurrentToLinkToInOutID (), Enums.boolValues_0_ID) || 
						IsInOutTypeSameWeak (InOutAdressCurrentToLinkToInOutID (0), Enums.boolValues_0_ID) )
					{
						skinPermission = permittedInputs [indexOfInput]? Skins.gateWaiting: Skins.gateBlocWaiting;
					}
				}
			}

			Rect inputPermissionRect = new Rect (inOutRect.position + new Vector2 (-inOutRect.width, 0f), 
				inOutRect.size);

			if (GUI.Button (inputPermissionRect, "", GetGuiStyle (skinPermission)) && eGlobal.button == 0)
			{
				GenericMenu menu = new GenericMenu ();

				string menuString = permittedInputs [indexOfInput]? blockThisInput: allowThisInput;

				menu.AddItem (new GUIContent (menuString), false, AllowBlockInput, indexOfInput.ToString ());

				if ( ! string.IsNullOrEmpty (inputsSources_forPermition [indexOfInput]))
					menu.AddItem (new GUIContent (breackTheLink), false, 
						BreakInputPermissionInputLink, indexOfInput.ToString ());

				menu.ShowAsContext ();
			}

			InputPermissionButton_AssignInput (inputPermissionRect, indexOfInput);

			InputPermissionButton_DrawLink (inputPermissionRect, indexOfInput);

			InputPermission_LinkAction (indexOfInput);
		}

		void InputPermission_LinkAction (int indexOfInput)
		{
			if (string.IsNullOrEmpty (inputsSources_forPermition [indexOfInput]))
				return;

			LogicNode sourceLogicNode = logic.LogicNodeByUniqueID (
				InOutAdressCurrentToLinkToUniqueID (inputsSources_forPermition [indexOfInput]));

			if (sourceLogicNode == null)
				return;

			if ( ! sourceLogicNode.activeOutputs [IndexOfOutID (
				InOutAdressCurrentToLinkToInOutID (inputsSources_forPermition [indexOfInput]))])
			{
				return;
			}

			int lstIndex = sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources_forPermition [indexOfInput]);

			switch (InOutAdressCurrentToLinkToInOutID (inputsSources_forPermition [indexOfInput]))
			{
			case Enums.boolValue_ID:
				permittedInputs [indexOfInput] = sourceLogicNode.boolValue;
				break;

			case Enums.boolValues_0_ID:
				permittedInputs [indexOfInput] = sourceLogicNode.boolValues [0];
				break;

			case Enums.boolValues_1_ID:
				permittedInputs [indexOfInput] = sourceLogicNode.boolValues [1];
				break;

			case Enums.m44ValueIsIdentity_ID:
				permittedInputs [indexOfInput] = sourceLogicNode.m44ValueIsIdentity;
				break;

			case Enums.m44ValueInvertible_ID:
				permittedInputs [indexOfInput] = sourceLogicNode.m44ValueInvertible;
				break;


			case Enums.OffMeshLinkData_activated_ID:
				permittedInputs [indexOfInput] = sourceLogicNode.OffMeshLinkData_activated;
				break;

			case Enums.OffMeshLinkData_valid_ID:
				permittedInputs [indexOfInput] = sourceLogicNode.OffMeshLinkData_valid;
				break;

			case Enums.NavMeshHit_hit_ID:
				permittedInputs [indexOfInput] = sourceLogicNode.NavMeshHit_hit;
				break;

			}

			switch (InOutAdressCurrentToLinkToInOutID (inputsSources_forPermition [indexOfInput], -1))
			{
			case Enums.boolsList_ID:
				if (lstIndex >-1 && lstIndex < sourceLogicNode.boolsListValue.Count)
				{
					permittedInputs [indexOfInput] = sourceLogicNode.boolsListValue [lstIndex];
				}
				break;
			}
		}

		void InputPermissionButton_DrawLink (Rect inputPermissionRect, int indexOfInput)
		{
			if (string.IsNullOrEmpty (inputsSources_forPermition [indexOfInput]))
				return;

			LogicNode sourceLogicNode = logic.LogicNodeByUniqueID (
				InOutAdressCurrentToLinkToUniqueID (inputsSources_forPermition [indexOfInput]));

			if (sourceLogicNode == null)
			{
				inputsSources_forPermition [indexOfInput] = "";

				return;
			}

			if ( ! sourceLogicNode.activeOutputs [IndexOfOutID (
				InOutAdressCurrentToLinkToInOutID (inputsSources_forPermition [indexOfInput]))])
			{
				inputsSources_forPermition [indexOfInput] = "";

				return;
			}


			Color inputPermissionLinkColor = new Color (linkColor.g, linkColor.g, linkColor.b, linkColor.a);

			Rect facingOutRect = sourceLogicNode.InOutRectOfThisInOutID (false, 
				InOutAdressCurrentToLinkToInOutID (inputsSources_forPermition [indexOfInput]));

			if ( ! sourceLogicNode.IsAListOutSource (inputsSources_forPermition [indexOfInput]))
			{
				DrawLink_PermissionButton (
					facingOutRect.center + gapPermissionLinkDraw * new Vector2 (0f, facingOutRect.height), 
					inputPermissionRect.center + gapPermissionLinkDraw * new Vector2 (0f, inputPermissionRect.height), inputPermissionLinkColor);
			}
			else if (sourceLogicNode.IsAListOutSource (inputsSources_forPermition [indexOfInput]))
			{
				//int listIndexFinal = sourceLogicNode.InoutAdressCurrentToLinkToListIndex ();

				string sourceNodeOutID =
					sourceLogicNode.InOutAdressCurrentToLinkToInOutID (inputsSources_forPermition [indexOfInput], 0);

				int sourceNodeOutIndex = sourceLogicNode.IndexOfOutID (sourceNodeOutID);

				if (sourceNodeOutIndex < 0 || sourceNodeOutIndex > sourceLogicNode.activeOutputs.Length-1)
					return;

				if ( ! sourceLogicNode.activeOutputs [sourceNodeOutIndex])
					return;

				if (sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources_forPermition [indexOfInput]) > -1 && 
					sourceLogicNode.InoutAdressToLinkToListIndex (inputsSources_forPermition [indexOfInput]) < 
					sourceLogicNode.outputListCounts [sourceNodeOutIndex])
				{
					DrawLink_PermissionButton (
						sourceLogicNode.GetDecaledListRect (sourceLogicNode, sourceNodeOutIndex, inputsSources_forPermition [indexOfInput]).center
						+ gapPermissionLinkDraw * new Vector2 (0f, inputPermissionRect.height),
						inputPermissionRect.center + gapPermissionLinkDraw * new Vector2 (0f, inputPermissionRect.height),
						inputPermissionLinkColor);
				}
			}
		}



		void InputPermissionButton_AssignInput (Rect inputPermissionRect, int indexOfInput)
		{
			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				return;

			if (InOutAdressCurrentToLinkToInOutDirection () == inAdressSignature)
				return;

			string sourceLogicNodeOutID = InOutAdressCurrentToLinkToInOutID ();

			//if ( ! IsInOutTypeSameWeak (sourceLogicNodeOutID, Enums.boolValues_0_ID))
			//	return;
			//Debug.Log (logic.inOutAdressCurrentToLink);
			if ( ! inputPermissionRect.Contains (eGlobal.mousePosition))
				return;


			LogicNode sourceLogicNode = logic.LogicNodeByUniqueID (InOutAdressCurrentToLinkToUniqueID ());

			if (sourceLogicNode == null)
				return;

			if ( ! sourceLogicNode.IsAListOutSource (logic.inOutAdressCurrentToLink))
			{
				if ( ! IsInOutTypeSame (sourceLogicNodeOutID, Enums.boolValues_0_ID))
					return;

				inputsSources_forPermition [indexOfInput] = logic.inOutAdressCurrentToLink;

			}
			else if (sourceLogicNode.IsAListOutSource (logic.inOutAdressCurrentToLink))
			{
				if (sourceLogicNode.outputsTypes [IndexOfOutID (sourceLogicNodeOutID)] != VariableType.boolsList)
					return;

				inputsSources_forPermition [indexOfInput] = logic.inOutAdressCurrentToLink;

				SetOutputLinkedIndexToDestination ();
			}
		}


		void BreakInputPermissionInputLink (object indexOfInput)
		{
			int i = int.Parse (indexOfInput.ToString ());

			inputsSources_forPermition [i] = "";
		}

		void AllowBlockInput (object indexOfInput)
		{
			int i = int.Parse (indexOfInput.ToString ());

			permittedInputs [i] = ! permittedInputs [i];
		}

		bool IsInputHotKeyIndexInRange ()
		{
			bool r = false;

			if (inputHotKeyIndex > -1 &&
				inputHotKeyIndex < GetActiveInputFieldsIndices ().Count)
			{
				r = true;
			}

			return r;
		}
		void IncrementHotKeysInputOptionsMenu ()
		{
			if (selectionState == SelectionState.notSelected)
			{
				inputHotKeyIndex = -1;

				return;
			}

			if (MouseKeysEvents.ControlCommandAltKey (KeyCode.R, eGlobal))
			{
				inputHotKeyIndex = -1;

				return;
			}

			if (MouseKeysEvents.ControlCommandAltKey (KeyCode.I, eGlobal))
			{
				List <int> activeInputFieldsIndices = GetActiveInputFieldsIndices ();

				inputHotKeyIndex++;

				if (inputHotKeyIndex > activeInputFieldsIndices.Count-1)
				{
					inputHotKeyIndex = 0;
				}


				if (IsInputHotKeyIndexInRange ())
				{
					eGlobal.mousePosition = 
						inputsRects [activeInputFieldsIndices [inputHotKeyIndex]].position;

					OpenInputFieldOptionsMenu (
						inputsRects [activeInputFieldsIndices [inputHotKeyIndex]],
						inputsIDs [activeInputFieldsIndices [inputHotKeyIndex]]);
				}
			}
		}

		void OpenInputFieldOptionsMenu (Rect inOutRect, string inOutID)
		{			
			variableFieldIDToMakePublicPrivate = inOutID;

			int inIndex = IndexOfInID (inOutID);

			if (inIndex > -1 && inIndex < publicInputs.Length)
			{

				string makeThisVariblePubPrivMenu = 
					publicInputs [IndexOfInID (inOutID)]? "Make this variable private":
					"Make this variable public";

				GenericMenu menu = new GenericMenu ();

				if ( ! attachedToGameObject [IndexOfInID (inOutID)])
				{
					if (inOutID == Enums.doIt_ID)
					{
						if ( ! alwaysDoIt)
						{
							menu.AddItem (new GUIContent (makeThisVariblePubPrivMenu), false, MakeVariablePublicPrivate);
						}
					}
					else if (inOutID != Enums.doIt_ID)
					{
						menu.AddItem (new GUIContent (makeThisVariblePubPrivMenu), false, MakeVariablePublicPrivate);
					}
				}

				if (inOutID == Enums.gameObjectValues_0_ID ||
					inOutID == Enums.gameObjectValues_1_ID)
				{
					if ( ! attachedToGameObject [IndexOfInID (inOutID)])
					{
						menu.AddItem (new GUIContent ("Make this gameObject the attached to one"), false, 
							MakeGameObjectTheAttachedToGameObject);
					}
					else
					{
						menu.AddItem (new GUIContent ("Make this gameObject other than the attached to one"), false, 
							MakeGameObjectOtherThanTheAttachedToOne);
					}
				}

				if (inOutID == Enums.doIt_ID)
				{
					if ( ! publicInputs [IndexOfInID (inOutID)])
					{
						if ( ! noAlwaysDoItOption)
						{
							if ( ! alwaysDoIt)
							{
								menu.AddItem (new GUIContent (alwaysDoItOrder), false, 
									AlwaysDoIt);
							}
							if (alwaysDoIt)
							{
								menu.AddItem (new GUIContent (dontDoItAllTheTimeExpression), false, 
									DontDoItAllTheTime);
							}
						}
					}
				}

				if ( ! string.IsNullOrEmpty (inputsSources [inIndex]))
					menu.AddItem (new GUIContent (breackTheLink), false, BreackTheLink, inOutID);

				menu.AddItem (new GUIContent (
					dataFlowControlEnabled [inIndex]?"Disable Control of Data Flow":"Enable Control of Data Flow"),
					false, EnableDisableDataFlowControl, inOutID);

				menu.ShowAsContext ();
			}
		}

		void EnableDisableDataFlowControl (object so)
		{
			dataFlowControlEnabled [IndexOfInID (so.ToString ())] = 
				! dataFlowControlEnabled [IndexOfInID (so.ToString ())];
		}

		void BreackTheLink (object so)
		{
			inputsSources [IndexOfInID (so.ToString ())] = "";
		}


		void MakeVariablePublicPrivate ()
		{
			if (string.IsNullOrEmpty (variableFieldIDToMakePublicPrivate))
				return;

			////Debug.Log (variableFieldIDToMakePublicPrivate);

			publicInputs [IndexOfInID (variableFieldIDToMakePublicPrivate)] = 
				! publicInputs [IndexOfInID (variableFieldIDToMakePublicPrivate)];
		}

		void MakeGameObjectTheAttachedToGameObject ()
		{
			attachedToGameObject [IndexOfInID (variableFieldIDToMakePublicPrivate)] = true;

			publicInputs [IndexOfInID (variableFieldIDToMakePublicPrivate)] = true;
		}

		void MakeGameObjectOtherThanTheAttachedToOne ()
		{
			attachedToGameObject [IndexOfInID (variableFieldIDToMakePublicPrivate)] = false;

			publicInputs [IndexOfInID (variableFieldIDToMakePublicPrivate)] = false;
		}


		void AssignInputSource (bool isAnInput, Rect inOutRect, string inOutID)
		{
			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				return;

			string facingLogicNodeUniqueID = InOutAdressCurrentToLinkToUniqueID ();

			LogicNode facingLogicNode = GetLogicNodeOnUniqueID (facingLogicNodeUniqueID);

			if (facingLogicNodeUniqueID == uniqueID)
				return;


			if (isAnInput)
			{
				if (! IsInOutTypeSameWeak (InOutAdressCurrentToLinkToInOutID (-1), inOutID))
				{
					if ( ! IsInOutTypeSame (InOutAdressCurrentToLinkToInOutID (), inOutID))
						return;
				}

				if (InOutAdressCurrentToLinkToInOutDirection () == outAdressSignature)
				{
					if (inOutRect.Contains (eGlobal.mousePosition) ||
						inOutRect.Contains (logic.linkExtremity))
					{
						AssignInputSource (inOutID);
					}
				}
			}
			else if ( ! isAnInput)
			{
				if (! IsInOutTypeSameWeak (inOutID, InOutAdressCurrentToLinkToInOutID (-1) ))
				{
					if ( ! IsInOutTypeSame (inOutID, InOutAdressCurrentToLinkToInOutID ()))
					{

						if (! Nv_IsInOutTypeSameWeak (inOutID, InOutAdressCurrentToLinkToInOutID (-1) ))
						{
							if ( ! Nv_IsInOutTypeSame (inOutID, InOutAdressCurrentToLinkToInOutID ()))
							{
								return;
							}
						}

						if (InOutAdressCurrentToLinkToInOutDirection () == inAdressSignature)
						{
							if (inOutRect.Contains (eGlobal.mousePosition) ||
								inOutRect.Contains (logic.linkExtremity))
							{
								Nv_AssignInputSource (inOutID, facingLogicNode);
							}
						}

						return;
					}
				}

				if (InOutAdressCurrentToLinkToInOutDirection () == inAdressSignature)
				{
					if (inOutRect.Contains (eGlobal.mousePosition) ||
						inOutRect.Contains (logic.linkExtremity))
					{
						AssignInputSource (inOutID, facingLogicNode);
					}
				}
			}
		}

		void AssignInputSource (string inOutID)
		{
			for (int i = 0; i < inputsIDs.Length; i++)
			{
				if (inOutID == inputsIDs [i])
				{
					inputsSources [i] = logic.inOutAdressCurrentToLink;

					if (IsAListOutSource (logic.inOutAdressCurrentToLink))
					{
						SetOutputLinkedIndexToDestination ();
					}
					break;
				}
			}
		}


		void AssignInputSource (string inOutID, LogicNode facingLogicNode)
		{
			string facingInOutID = InOutAdressCurrentToLinkToInOutID ();

			for (int i = 0; i < facingLogicNode.inputsIDs.Length; i++)
			{
				if (facingInOutID == facingLogicNode.inputsIDs [i])
				{
					facingLogicNode.inputsSources [i] = 
						uniqueID + inOutAdressSeparator + inOutID + inOutAdressSeparator + outAdressSignature; 

					break;
				}
			}
		}

		void Nv_AssignInputSource (string inOutID, LogicNode facingLogicNode)
		{
			string facingInOutID = InOutAdressCurrentToLinkToInOutID ();

			for (int i = 0; i < facingLogicNode.nv_inputsIDs.Length; i++)
			{
				if (facingInOutID == facingLogicNode.nv_inputsIDs [i])
				{
					facingLogicNode.nv_inputsSources [i] = 
						uniqueID + inOutAdressSeparator + inOutID + inOutAdressSeparator + outAdressSignature; 

					break;
				}
			}
		}

		public void SetOutputLinkedIndexToDestination ()
		{
			listIndexFinal = InoutAdressCurrentToLinkToListIndex ();


			LogicNode sourceNodeForIndex = 
				logic.LogicNodeByUniqueID (InOutAdressCurrentToLinkToUniqueID ());

			if (sourceNodeForIndex != null)
			{
				int outIndex = 
					sourceNodeForIndex.IndexOfOutID (InOutAdressCurrentToLinkToInOutID (-1));

				if (outIndex > -1 && outIndex < sourceNodeForIndex.outputLinkedIndexToDestination.Length)
				{
					sourceNodeForIndex.outputLinkedIndexToDestination [outIndex] 
					= listIndexFinal;
				}
			}

			////Debug.Log (listIndexFinal);
		}

		public int InoutAdressCurrentToLinkToListIndex ()
		{
			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				return -1;

			if ( ! IsAListOutSource (logic.inOutAdressCurrentToLink))
				return -1;

			if (string.IsNullOrEmpty (StringTreatment.AfterThat (
				InOutAdressCurrentToLinkToInOutID (logic.inOutAdressCurrentToLink), '_')))
				return -1;

			return int.Parse  (StringTreatment.AfterThat (
				InOutAdressCurrentToLinkToInOutID (logic.inOutAdressCurrentToLink), '_'));
		}

		public int InoutAdressToLinkToListIndex (string inSource)
		{
			if (string.IsNullOrEmpty (inSource))
				return -1;

			if ( ! IsAListOutSource (inSource))
			{
				////Debug.Log (inSource);
				return -1;
			}

			if (string.IsNullOrEmpty (StringTreatment.AfterThat (
				InOutAdressCurrentToLinkToInOutID (inSource), '_')))
				return -1;

			return int.Parse  (StringTreatment.AfterThat (
				InOutAdressCurrentToLinkToInOutID (inSource), '_'));
		}

		public static int OutIDToListIndex (string s)
		{
			if (string.IsNullOrEmpty (s))
				return -1;

			return int.Parse  (StringTreatment.AfterThat (s, '_'));
		}

		public static int GetVariableTypeEnumIndex (VariableType vt)
		{
			int r = -1;

			string [] variableTypeNames = Enum.GetNames (typeof (VariableType));

			for (int i = 0; i < variableTypeNames.Length; i++)
			{
				if (variableTypeNames [i] == vt.ToString ())
				{
					return i;
				}
			}

			return r;
		}

		int InOutIDToVariableTypeEnumIndex (string inOutID)
		{
			int r = -1;

			for (int i = 0; i < inputsTypes.Length; i++)
			{
				if (inputsIDs [i] == inOutID)
				{
					string [] variableTypeNames = Enum.GetNames (typeof (VariableType));

					for (int j = 0; j < variableTypeNames.Length; j++)
					{
						if (variableTypeNames [j] == inputsTypes [i].ToString ())
						{
							return j;
						}
					}
				}
			}

			for (int i = 0; i < outputsTypes.Length; i++)
			{
				if (outputsIDs [i] == inOutID)
				{
					string [] variableTypeNames = Enum.GetNames (typeof (VariableType));

					for (int j = 0; j < variableTypeNames.Length; j++)
					{
						if (variableTypeNames [j] == outputsTypes [i].ToString ())
						{
							return j;
						}
					}
				}
			}

			return r;
		}

		string InOutIDToTypeName (bool isAnInput, string inOutID)
		{
			string r = "Type Not Found";

			if (string.IsNullOrEmpty (inOutID))
				return r;

			if (isAnInput)
				r = InIDToTypeName (inOutID);
			else
				r = OutIDToTypeName (inOutID);
			
			return r;
		}

		string InIDToTypeName (string inID)
		{
			string r = "Type Not Found";

			for (int i = 0; i < inputsIDs.Length; i++)
			{
				if (inputsIDs [i] == inID)
				{
					r = CsScriptWriter.VariableTypeToDeclarationString (inputsTypes [i]);

					break;
				}
			}

			return r;
		}

		string OutIDToTypeName (string outID)
		{
			string r = "Type Not Found";

			for (int i = 0; i < outputsIDs.Length; i++)
			{
				if (outputsIDs [i] == outID)
				{
					r = CsScriptWriter.VariableTypeToDeclarationString (outputsTypes [i]);

					break;
				}
			}

			return r;
		}

		bool IsInOutTypeSame (string outID, string inID)
		{
			bool retVal = false;


			VariableType varType_out = VariableType.Bool;

			VariableType varType_in = VariableType.Color;


			bool loopAllOuts = false;

			for (int i = 0; i < outputsIDs.Length; i++)
			{
				if (outputsIDs [i] == outID)
				{
					varType_out = outputsTypes [i];

					break;
				}

				if (i == outputsIDs.Length - 1)
					loopAllOuts = true;
			}


			bool loopAllInts = false;

			for (int i = 0; i < inputsIDs.Length; i++)
			{
				if (inputsIDs [i] == inID)
				{
					varType_in = inputsTypes [i];

					break;
				}

				if (i == inputsIDs.Length - 1)
					loopAllInts = true;
			}


			if (loopAllInts || loopAllOuts)
				return false;



			if (varType_in == varType_out)
				retVal = true;
			
			return retVal;
		}

		bool IsInOutTypeSameWeak (string outID, string inID)
		{
			bool retVal = false;


			VariableType varType_out = VariableType.Bool;

			VariableType varType_in = VariableType.Color;


			bool loopAllOuts = false;

			for (int i = 0; i < outputsIDs.Length; i++)
			{
				if (outputsIDs [i] == outID)
				{
					varType_out = outputsTypes [i];

					break;
				}

				if (i == outputsIDs.Length - 1)
					loopAllOuts = true;
			}


			bool loopAllInts = false;

			for (int i = 0; i < inputsIDs.Length; i++)
			{
				if (inputsIDs [i] == inID)
				{
					varType_in = inputsTypes [i];

					break;
				}

				if (i == inputsIDs.Length - 1)
					loopAllInts = true;
			}


			if (loopAllInts || loopAllOuts)
				return false;


			if (varType_in == varType_out)
				return false;




			switch (varType_out)
			{
			case VariableType.boolsList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.boolsList, 
					outID, Enums.boolsList_ID, 
					varType_in, VariableType.Bool);
				break;

			case VariableType.colorsList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.colorsList, 
					outID, Enums.colorsList_ID, 
					varType_in, VariableType.Color);
				break;

			case VariableType.floatsList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.floatsList, 
					outID, Enums.floatsList_ID, 
					varType_in, VariableType.Float);
				break;

			case VariableType.GameObjectList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.GameObjectList, 
					outID, Enums.gameObjectsList_ID, 
					varType_in, VariableType.GameObject);
				break;

			case VariableType.intsList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.intsList, 
					outID, Enums.intsList_ID, 
					varType_in, VariableType.Int);
				break;

			case VariableType.materialsList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.materialsList, 
					outID, Enums.materialList_ID, 
					varType_in, VariableType.Material);
				break;

			case VariableType.rectsList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.rectsList, 
					outID, Enums.rectList_ID, 
					varType_in, VariableType.rect);
				break;

			case VariableType.shadersList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.shadersList, 
					outID, Enums.shaderList_ID, 
					varType_in, VariableType.Shader);
				break;

			case VariableType.stringsList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.stringsList, 
					outID, Enums.stringsList_ID, 
					varType_in, VariableType.String);
				break;

			case VariableType.texture2DList:
				retVal = WeakInOutPermission (
					varType_out, VariableType.texture2DList, 
					outID, Enums.texture2DList_ID, 
					varType_in, VariableType.Texture2D);
				break;

			case VariableType.vector2List:
				retVal = WeakInOutPermission (
					varType_out, VariableType.vector2List, 
					outID, Enums.vector2List_ID, 
					varType_in, VariableType.Vector2);
				break;

			case VariableType.vector3List:
				retVal = WeakInOutPermission (
					varType_out, VariableType.vector3List, 
					outID, Enums.vector3List_ID, 
					varType_in, VariableType.Vector3);
				break;

			case VariableType.vector4List:
				retVal = WeakInOutPermission (
					varType_out, VariableType.vector4List, 
					outID, Enums.vector4List_ID, 
					varType_in, VariableType.Vector4);
				break;
			}

			return retVal;
		}
		bool WeakInOutPermission (VariableType varType_out, VariableType outputListType, 
			string outID, string OutListID, 
			VariableType varType_in, VariableType inputFieldType)
		{
			bool retVal = false;

			if (varType_out == outputListType)
			{
				if (outID == OutListID)
				{
					if (varType_in == inputFieldType)
					{
						retVal = true;
					}
				}
				else if (outID != OutListID)
				{
					retVal = false;
				}
			}

			return retVal;
		}



		void IncrementOutIndexForHotKeyLinking ()
		{
			if (selectionState == SelectionState.notSelected)
			{
				outIndexForHotKeyLinking = -1;

				outListIndexForHotKeyLinking = 0;
				return;
			}

			if (MouseKeysEvents.ControlCommandAltKey (KeyCode.R, eGlobal))
			{
				logic.inOutAdressCurrentToLink = "";

				outIndexForHotKeyLinking = -1;

				outListIndexForHotKeyLinking = 0;
			}

			if (MouseKeysEvents.ControlCommandAltKey (KeyCode.L, eGlobal))
			{
				inputIndexForHotKeyLinking = -1;

				List <int> activeOutputIndices = GetActiveOutputIndices ();

				if (IsOutIndexForHotKeyLinkingInRange ())
				{
					if (StringTreatment.IsEndWith_List (
						outputsIDs [
							activeOutputIndices [outIndexForHotKeyLinking]]))
					{
						outListIndexForHotKeyLinking++;

						if (outListIndexForHotKeyLinking > intValue - 1)
						{
							outListIndexForHotKeyLinking = 0;


							outIndexForHotKeyLinking++;

							if (outIndexForHotKeyLinking > activeOutputIndices.Count - 1)
							{
								outIndexForHotKeyLinking = 0;
							}
						}
					}
					else if ( ! StringTreatment.IsEndWith_List (
						outputsIDs [
							activeOutputIndices [outIndexForHotKeyLinking]]))
					{
						outIndexForHotKeyLinking++;

						if (outIndexForHotKeyLinking > 
							activeOutputIndices.Count - 1)
						{
							outIndexForHotKeyLinking = 0;
						}
					}
				}
				else
				{
					outIndexForHotKeyLinking = 0;
				}

				if (IsOutIndexForHotKeyLinkingInRange ())
				{
					string inOutID = outputsIDs [
						activeOutputIndices [
							outIndexForHotKeyLinking]];

					if (StringTreatment.IsEndWith_List (inOutID))
					{
						logic.linkExtremity = 
							outputsRects [IndexOfOutID (inOutID)].center +
							new Vector2 (nearLinkExtremity, 0f);
					}
					else if ( ! StringTreatment.IsEndWith_List (inOutID))
					{
						logic.linkExtremity = 
							outputsRects [IndexOfOutID (inOutID)].center +
							new Vector2 (nearLinkExtremity, 0f);
					}
				}
			}


			if (IsOutIndexForHotKeyLinkingInRange ())
			{
				List <int> activeOutputIndices = GetActiveOutputIndices ();

				if (StringTreatment.IsEndWith_List (
					outputsIDs [
						activeOutputIndices [outIndexForHotKeyLinking]]))
				{
					string inOutID = outputsIDs [
						activeOutputIndices [
							outIndexForHotKeyLinking]];

					int currentInOutListIndex = outListIndexForHotKeyLinking;

					logic.inOutAdressCurrentToLink =
						uniqueID + inOutAdressSeparator 
						+ inOutID + "_" + currentInOutListIndex.ToString ()
						+ inOutAdressSeparator 
						+ outAdressSignature;

					onDragInOutListIndex = currentInOutListIndex;

					DrawCurrentLink (false, new Rect (), 
						inOutID, currentInOutListIndex);
				}
				else if ( ! StringTreatment.IsEndWith_List (
					outputsIDs [
						activeOutputIndices [outIndexForHotKeyLinking]]))
				{
					string inOutID = outputsIDs [
						activeOutputIndices [
							outIndexForHotKeyLinking]];

					logic.inOutAdressCurrentToLink = 
						uniqueID + 
						inOutAdressSeparator + 
						inOutID + 
						inOutAdressSeparator +
						outAdressSignature;

					DrawCurrentLink (false, new Rect (), inOutID);
				}
			}
		}
		bool IsOutIndexForHotKeyLinkingInRange ()
		{
			bool r = false;

			if (outIndexForHotKeyLinking > -1 &&
				outIndexForHotKeyLinking < GetActiveOutputIndices ().Count)
			{
				r = true;
			}

			return r;
		}


		void IncrementInputIndexForHotKeyLinking ()
		{
			if (selectionState == SelectionState.notSelected)
			{
				inputIndexForHotKeyLinking = -1;
				return;
			}

			if (MouseKeysEvents.ControlCommandAltKey (KeyCode.R, eGlobal))
			{
				logic.inOutAdressCurrentToLink = "";

				inputIndexForHotKeyLinking = -1;
			}

			if (MouseKeysEvents.ControlCommandAltKey (KeyCode.P, eGlobal))
			{
				outIndexForHotKeyLinking = -1;

				inputIndexForHotKeyLinking++;

				List <int> activeInputIndices = GetActiveInputIndices ();

				if (inputIndexForHotKeyLinking > activeInputIndices.Count - 1)
				{
					inputIndexForHotKeyLinking = 0;
				}

				if (IsInputIndexForHotKeyLinkingInRange ())
				{
					string inOutID = inputsIDs 
						[activeInputIndices [inputIndexForHotKeyLinking]];

					logic.linkExtremity = 
						inputsRects [IndexOfInID (inOutID)].center
						+
						new Vector2 (-nearLinkExtremity, 0f);
				}

				if (IsInputIndexForHotKeyLinkingInRange ())
				{
					string inOutID = inputsIDs 
						[activeInputIndices [inputIndexForHotKeyLinking]];

					if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) 
						< publicInputs.Length)
					{
						if (publicInputs [IndexOfInID (inOutID)])
							return;
					}

					logic.inOutAdressCurrentToLink = 
						uniqueID + 
						inOutAdressSeparator + inOutID + inOutAdressSeparator +
						(inAdressSignature);

					DrawCurrentLink (true, new Rect (), inOutID);
				}
			}
		}
		bool IsInputIndexForHotKeyLinkingInRange ()
		{
			bool r = false;

			if (inputIndexForHotKeyLinking > -1 &&
				inputIndexForHotKeyLinking < GetActiveInputIndices ().Count)
			{
				r = true;
			}

			return r;
		}


		void DrawCurrentLink (bool isAnInput, Rect inOutRect, string inOutID)
		{
			if ( ! maximized)
				return;

			if ( ! string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
			{
				if (eGlobal.button == 0)
				{
					if (eGlobal.type == EventType.MouseDown)
					{
						logic.inOutAdressCurrentToLink = "";
					}
				}
			}

			if (isAnInput)
			{
				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) 
					< publicInputs.Length)
				if (publicInputs [IndexOfInID (inOutID)])
					return;
			}

			if (inOutRect.Contains (eGlobal.mousePosition))
			{
				if (eGlobal.button == 0)
				{
					if (eGlobal.type == EventType.MouseDown)
					{
						logic.inOutAdressCurrentToLink = 
							uniqueID + 
							inOutAdressSeparator + inOutID + inOutAdressSeparator +
							(isAnInput? inAdressSignature: outAdressSignature);

						eGlobal.type = EventType.Ignore;
					}
				}
			}



			if ( ! string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
			{
				if (IsThisInOutIDActive (isAnInput, InOutAdressCurrentToLinkToInOutID ()))
				{
					Vector2 linkExtrend = eGlobal.mousePosition;

					if (outIndexForHotKeyLinking != -1 
						|| inputIndexForHotKeyLinking !=-1)
					{
						linkExtrend = logic.linkExtremity;
					}

					DrawLink (InOutRectOfThisInOutID (
						isAnInput, InOutAdressCurrentToLinkToInOutID ()).center, 
						linkExtrend, isAnInput, true);
				}
			}
		}

		void DrawCurrentLink (bool isAnInput, Rect inOutRect, string inOutID, 
			int currentInOutListIndex)
		{
			if ( ! maximized)
				return;

			if ( ! string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
			{
				if (eGlobal.button == 0)
				{
					if (eGlobal.type == EventType.MouseDown)
					{
						logic.inOutAdressCurrentToLink = "";
					}
				}
			}


			if (isAnInput)
			{
				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < publicInputs.Length)
				if (publicInputs [IndexOfInID (inOutID)])
					return;

			}

			if (inOutRect.Contains (eGlobal.mousePosition))
			{
				if (eGlobal.button == 0)
				{
					if (eGlobal.type == EventType.MouseDown)
					{					
						logic.inOutAdressCurrentToLink =
							uniqueID + inOutAdressSeparator 
							+ inOutID + "_" + currentInOutListIndex.ToString ()
							+ inOutAdressSeparator 
							+ (isAnInput? inAdressSignature: outAdressSignature);

						onDragInOutListIndex = currentInOutListIndex;

						eGlobal.type = EventType.Ignore;
					}
				}
			}


			if ( ! string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
			{
				if (IsThisInOutIDActive (isAnInput, InOutAdressCurrentToLinkToInOutID
					(currentInOutListIndex)))
				{
					Vector2 linkExtrend = eGlobal.mousePosition;

					if (outIndexForHotKeyLinking != -1 
						|| inputIndexForHotKeyLinking !=-1)
					{
						linkExtrend = logic.linkExtremity;
					}

					DrawLink (InOutRectOfThisInOutID (
						isAnInput, 
						InOutAdressCurrentToLinkToInOutID
						(currentInOutListIndex)).center, 
						linkExtrend, isAnInput, true);
				}
			}
		}

		void DrawEstablishedLinks (int currentInOutListIndex)
		{
			List <int> activeLinkedInputs = new List<int> ();

			for (int i = 0; i < activeInputs.Length; i++)
			{
				if (activeInputs [i])
				{
					if ( ! string.IsNullOrEmpty (inputsSources [i]))
					{
						activeLinkedInputs.Add (i);
					}
				}
			}

			if (activeLinkedInputs.Count == 0)
				return;

			for (int i = 0; i < activeLinkedInputs.Count; i++)
			{
				if (inputsSources [activeLinkedInputs [i]].Length < 1)
					continue;

				if (inputsSources [activeLinkedInputs [i]][0] == 'v')
				{
					LinkInputWithProjectVariable (inputsIDs [activeLinkedInputs [i]], 
						inputsSources [activeLinkedInputs [i]],
						activeLinkedInputs [i]);
				}
				else
				{
					if (IsAListOutSource (inputsSources [activeLinkedInputs [i]]))
					{
						LinkInput (inputsIDs [activeLinkedInputs [i]], inputsSources [activeLinkedInputs [i]],
							activeLinkedInputs [i], currentInOutListIndex);
					}
					else if ( ! IsAListOutSource (inputsSources [activeLinkedInputs [i]]))
					{
						LinkInput (inputsIDs [activeLinkedInputs [i]], inputsSources [activeLinkedInputs [i]],
							activeLinkedInputs [i]);
					}
				}
			}
		}


		public bool IsAListOutSource (string inSource)
		{
			string inOutID = InOutAdressCurrentToLinkToInOutID (inSource, -1);

			return StringTreatment.IsEndWith_List (inOutID);
		}


		public Rect GetDecaledListRect (LogicNode sourceLogicNode, int sourceNodeOutIndex, string inSource)
		{
			Rect r = sourceLogicNode.firstRectOfListsOutput [sourceNodeOutIndex];

			if (sourceLogicNode.outputLinkedIndexToDestination [sourceNodeOutIndex] > -1)
			{
				int i = InoutAdressToLinkToListIndex (inSource);
				////Debug.Log (i);

				if (sourceLogicNode.variableType == VariableType.rectsList)
				{
					i = 2 * InoutAdressToLinkToListIndex (inSource);
				}

				r = new Rect (r.x, r.y + i*r.height, r.width, r.height);
			}

			return r;
		}


		bool SourceLogicNodeStillHere (string inSource)
		{
			bool retVal = false;

			string uID = InOutAdressCurrentToLinkToUniqueID (inSource);

			for (int i = 0; i < logic.nodes.Count; i++)
			{
				if (logic.nodes [i].uniqueID == uID)
				{
					retVal = true;

					break;
				}
			}

			return retVal;
		}

		bool SourceLogicNodeStillHereOnUniqueID (string uID)
		{
			bool retVal = false;

			for (int i = 0; i < logic.nodes.Count; i++)
			{
				if (logic.nodes [i].uniqueID == uID)
				{
					retVal = true;

					break;
				}
			}

			return retVal;
		}


		LogicNode GetLogicNode (string str)
		{
			LogicNode retVal = null;

			string uID = InOutAdressCurrentToLinkToUniqueID (str);

			for (int i = 0; i < logic.nodes.Count; i++)
			{
				if (logic.nodes [i].uniqueID == uID)
				{
					retVal = logic.nodes [i];

					break;
				}
			}

			return retVal;
		}

		public LogicNode GetLogicNodeOnUniqueID (string uID)
		{
			LogicNode retVal = null;

			if (string.IsNullOrEmpty (uID))
				return null;

			for (int i = 0; i < logic.nodes.Count; i++)
			{
				if (logic.nodes [i].uniqueID == uID)
				{
					retVal = logic.nodes [i];

					break;
				}
			}

			return retVal;
		}



		void DrawLink (Vector2 start, Vector2 end, bool isAnInput, bool permittedInput)
		{
			if (start == Vector2.zero)
				return;

			if (InOutAdressCurrentToLinkToUniqueID () != uniqueID)
				return;

			Vector2 startTan = start + new Vector2 (isAnInput? -tanLength: tanLength, 0f);

			Vector2 endTan = end + new Vector2 (isAnInput? tanLength: -tanLength, 0f);

			Color linkColorToDraw = permittedInput? linkColor: 
				ColorModifierSimple.SemiDot (linkColor, new Vector4 (1f, 1f, 1f, notPermittedInputAlphaColor));

			Handles.DrawBezier (start, end, startTan, endTan, linkColorToDraw, null, linkWidth);
		}

		void DrawLink_PermissionButton (Vector2 start, Vector2 end, Color linkColorToDraw)
		{
			float linkTanCoef = LinkTanCoef (start, end);

			Vector2 startTan = start + new Vector2 (linkTanCoef*tanLength, 0f);

			Vector2 endTan = end + new Vector2 (0f, 100f*Mathf.Sign (-end.y+start.y));

			Handles.DrawBezier (start, end, startTan, endTan, linkColorToDraw, null, linkWidth);
		}

		void DrawLink (Vector2 start, Vector2 end, bool permittedInput, string inID)
		{
			float linkTanCoef = LinkTanCoef (start, end);

			Vector2 startTan = start + new Vector2 (linkTanCoef*tanLength, 0f);

			Vector2 endTan = end + new Vector2 (-linkTanCoef*tanLength, 0f);

			Color variableTypeLinnkColor = Diamond.namesToSave.variableTypeColor [
				InOutIDToVariableTypeEnumIndex (inID)];

			Color linkColorToDraw = permittedInput? variableTypeLinnkColor: 
				ColorModifierSimple.SemiDot (variableTypeLinnkColor, 
					new Vector4 (1f, 1f, 1f, notPermittedInputAlphaColor));

			Handles.DrawBezier (start, end, startTan, endTan, linkColorToDraw, null, linkWidth);
		}

		float LinkTanCoef (Vector2 start, Vector2 end)
		{
			float r = 1f;

			Vector2 delta = end - start;

			Vector2 deltaN = delta.normalized;

			float mult = 0.025f;

			float dotX = Vector2.Dot (delta, new Vector2 (1f, 0f)) * mult;

			//float dotY = Vector2.Dot (delta, new Vector2 (0f, 1f)) * mult;

			r = Mathf.Min (Mathf.Abs (dotX), 7f);

			return r;
		}

		string InOutAdressCurrentToLinkToUniqueID ()
		{
			string retVal = "";

			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				return "";

			for (int i = 0; i < logic.inOutAdressCurrentToLink.Length; i++)
			{
				if (logic.inOutAdressCurrentToLink [i] == inOutAdressSeparator)
					break;

				retVal += logic.inOutAdressCurrentToLink [i];
			}

			return retVal;
		}

		public string InOutAdressCurrentToLinkToUniqueID (string inSource)
		{
			string retVal = "";

			if (string.IsNullOrEmpty (inSource))
				return "";

			for (int i = 0; i < inSource.Length; i++)
			{
				if (inSource [i] == inOutAdressSeparator)
					break;

				retVal += inSource [i];
			}

			return retVal;
		}



		string InOutAdressCurrentToLinkToInOutID ()
		{
			string retVal = "";

			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				return "";

			int firstSeparatorID = -1;

			for (int i = 0; i < logic.inOutAdressCurrentToLink.Length; i++)
			{
				if (logic.inOutAdressCurrentToLink [i] == inOutAdressSeparator)
				{
					firstSeparatorID = i;

					break;
				}
			}

			if (firstSeparatorID == -1 || firstSeparatorID == logic.inOutAdressCurrentToLink.Length-1)
				return "";


			int secondSeparatorID = -1;

			for (int i = firstSeparatorID+1; i < logic.inOutAdressCurrentToLink.Length; i++)
			{
				if (logic.inOutAdressCurrentToLink [i] == inOutAdressSeparator)
				{
					secondSeparatorID = i;

					break;
				}
			}


			if (secondSeparatorID == -1 || secondSeparatorID == logic.inOutAdressCurrentToLink.Length-1 ||
				secondSeparatorID == firstSeparatorID + 1)
				return "";


			for (int i = firstSeparatorID + 1; i < secondSeparatorID; i++)
			{
				retVal += logic.inOutAdressCurrentToLink [i];
			}

			return retVal;
		}

		string InOutAdressCurrentToLinkToInOutID (int currentInOutListIndex)
		{
			string retVal = "";

			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				return "";

			int firstSeparatorID = -1;

			for (int i = 0; i < logic.inOutAdressCurrentToLink.Length; i++)
			{
				if (logic.inOutAdressCurrentToLink [i] == inOutAdressSeparator)
				{
					firstSeparatorID = i;

					break;
				}
			}

			if (firstSeparatorID == -1 || firstSeparatorID == logic.inOutAdressCurrentToLink.Length-1)
				return "";


			int secondSeparatorID = -1;

			for (int i = firstSeparatorID+1; i < logic.inOutAdressCurrentToLink.Length; i++)
			{
				if (logic.inOutAdressCurrentToLink [i] == inOutAdressSeparator)
				{
					secondSeparatorID = i;

					break;
				}
			}


			if (secondSeparatorID == -1 || secondSeparatorID == logic.inOutAdressCurrentToLink.Length-1 ||
				secondSeparatorID == firstSeparatorID + 1)
				return "";


			for (int i = firstSeparatorID + 1; i < secondSeparatorID; i++)
			{
				retVal += logic.inOutAdressCurrentToLink [i];
			}

			return StringTreatment.BeforeThat (retVal, '_');
		}

		public string InOutAdressCurrentToLinkToInOutID (string str)
		{
			string retVal = "";

			if (string.IsNullOrEmpty (str))
				return "";

			int firstSeparatorID = -1;

			for (int i = 0; i < str.Length; i++)
			{
				if (str [i] == inOutAdressSeparator)
				{
					firstSeparatorID = i;

					break;
				}
			}

			if (firstSeparatorID == -1 || firstSeparatorID == str.Length-1)
				return "";


			int secondSeparatorID = -1;

			for (int i = firstSeparatorID+1; i < str.Length; i++)
			{
				if (str [i] == inOutAdressSeparator)
				{
					secondSeparatorID = i;

					break;
				}
			}


			if (secondSeparatorID == -1 || secondSeparatorID == str.Length-1 ||
				secondSeparatorID == firstSeparatorID + 1)
				return "";


			for (int i = firstSeparatorID + 1; i < secondSeparatorID; i++)
			{
				retVal += str [i];
			}



			return retVal;
		}

		public string InOutAdressCurrentToLinkToInOutID (string str, int currentInOutListIndex)
		{
			string retVal = "";

			if (string.IsNullOrEmpty (str))
				return "";

			int firstSeparatorID = -1;

			for (int i = 0; i < str.Length; i++)
			{
				if (str [i] == inOutAdressSeparator)
				{
					firstSeparatorID = i;

					break;
				}
			}

			if (firstSeparatorID == -1 || firstSeparatorID == str.Length-1)
				return "";


			int secondSeparatorID = -1;

			for (int i = firstSeparatorID+1; i < str.Length; i++)
			{
				if (str [i] == inOutAdressSeparator)
				{
					secondSeparatorID = i;

					break;
				}
			}


			if (secondSeparatorID == -1 || secondSeparatorID == str.Length-1 ||
				secondSeparatorID == firstSeparatorID + 1)
				return "";


			for (int i = firstSeparatorID + 1; i < secondSeparatorID; i++)
			{
				retVal += str [i];
			}

			return StringTreatment.BeforeThat (retVal, '_');
		}


		string InOutAdressCurrentToLinkToInOutDirection ()
		{
			string retVal = "";

			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				return "";

			int firstSeparatorID = -1;

			for (int i = 0; i < logic.inOutAdressCurrentToLink.Length; i++)
			{
				if (logic.inOutAdressCurrentToLink [i] == inOutAdressSeparator)
				{
					firstSeparatorID = i;

					break;
				}
			}

			if (firstSeparatorID == -1 || firstSeparatorID == logic.inOutAdressCurrentToLink.Length-1)
				return "";


			int secondSeparatorID = -1;

			for (int i = firstSeparatorID+1; i < logic.inOutAdressCurrentToLink.Length; i++)
			{
				if (logic.inOutAdressCurrentToLink [i] == inOutAdressSeparator)
				{
					secondSeparatorID = i;

					break;
				}
			}


			if (secondSeparatorID == -1 || secondSeparatorID == logic.inOutAdressCurrentToLink.Length-1 ||
				secondSeparatorID == firstSeparatorID + 1)
				return "";


			for (int i = secondSeparatorID + 1; i < logic.inOutAdressCurrentToLink.Length; i++)
			{
				retVal += logic.inOutAdressCurrentToLink [i];
			}

			return retVal;
		}

		string InOutAdressCurrentToLinkToInOutDirection (string str)
		{
			string retVal = "";

			if (string.IsNullOrEmpty (str))
				return "";

			int firstSeparatorID = -1;

			for (int i = 0; i < str.Length; i++)
			{
				if (str [i] == inOutAdressSeparator)
				{
					firstSeparatorID = i;

					break;
				}
			}

			if (firstSeparatorID == -1 || firstSeparatorID == str.Length-1)
				return "";


			int secondSeparatorID = -1;

			for (int i = firstSeparatorID+1; i < str.Length; i++)
			{
				if (str [i] == inOutAdressSeparator)
				{
					secondSeparatorID = i;

					break;
				}
			}


			if (secondSeparatorID == -1 || secondSeparatorID == str.Length-1 ||
				secondSeparatorID == firstSeparatorID + 1)
				return "";


			for (int i = secondSeparatorID + 1; i < str.Length; i++)
			{
				retVal += str [i];
			}

			return retVal;
		}



		Vector2 InOutAdressCurrentToLinkToRectCenter (string str)
		{
			Vector2 retVal = new Vector2 ();

			string inOutDir = InOutAdressCurrentToLinkToInOutDirection (str);

			string inOutID = InOutAdressCurrentToLinkToInOutID (str);


			if (inOutDir == inAdressSignature)
			{
				if (IndexOfInID (inOutID) > -1 && IndexOfInID (inOutID) < inputsRects.Length)
					retVal = inputsRects [IndexOfInID (inOutID)].center;
			}
			else if (inOutDir == outAdressSignature)
			{
				if (IndexOfOutID (inOutID) > -1 && IndexOfOutID (inOutID) < outputsRects.Length)
					retVal = outputsRects [IndexOfOutID (inOutID)].center;
			}

			return retVal;
		}

		public int IndexOfInID (string inID)
		{
			int retVal = -1;

			for (int i = 0; i < inputsIDs.Length; i++)
			{
				if (inputsIDs [i] == inID)
				{
					retVal = i;

					break;
				}
			}

			return retVal;
		}

		public int IndexOfOutID (string outID)
		{
			int retVal = -1;

			if (string.IsNullOrEmpty(outID))
				return -1;

			string retValBefore_ = StringTreatment.BeforeThat (outID, '_');
			if (StringTreatment.IsEndWith_List (retValBefore_))
			{
				outID = retValBefore_;
			}

			for (int i = 0; i < outputsIDs.Length; i++)
			{
				if (outputsIDs [i] == outID)
				{
					retVal = i;

					break;
				}
			}

			return retVal;
		}

		bool IsThisInOutIDActive (bool isAnInput, string inOutID)
		{
			bool retVal = false;

			if (string.IsNullOrEmpty (inOutID))
				return false;

			if (isAnInput)
			{
				for (int i = 0; i < inputsIDs.Length; i++)
				{
					if (inputsIDs [i] == inOutID)
					{
						if (activeInputs [i])
							retVal = true;

						break;
					}
				}
			}
			else
			{
				for (int i = 0; i < outputsIDs.Length; i++)
				{
					if (outputsIDs [i] == inOutID)
					{
						if (activeOutputs [i])
							retVal = true;

						break;
					}
				}
			}

			return retVal;
		}


		Rect InOutRectOfThisInOutID (bool isAnInput, string inOutID)
		{
			Rect retVal = new Rect ();

			if (string.IsNullOrEmpty (inOutID))
				return new Rect ();

			if (isAnInput)
			{
				for (int i = 0; i < inputsRects.Length; i++)
				{
					if (inputsIDs [i] == inOutID)
					{
						retVal = inputsRects [i];

						break;
					}
				}
			}
			else
			{
				for (int i = 0; i < outputsRects.Length; i++)
				{
					if (outputsIDs [i] == inOutID)
					{
						retVal = outputsRects [i];

						break;
					}
				}
			}

			return retVal;
		}



		void AssignInOutRect (bool isAnInput, string inOutID, Rect inOutRect)
		{
			if (isAnInput)
				AssignInRect (inOutID, inOutRect);
			else
				AssignOutRect (inOutID, inOutRect);
		}

		void AssignInOutRect (bool isAnInput, string inOutID, Rect inOutRect, int currentInOutListIndex)
		{
			if (isAnInput)
				AssignInRect (inOutID, inOutRect);
			else
				AssignOutRect (inOutID, inOutRect, currentInOutListIndex);
		}

		void AssignInRect (string inOutID, Rect inOutRect)
		{
			for (int i = 0; i < inputsIDs.Length; i++)
			{
				if (inputsIDs [i] == inOutID)
				{
					inputsRects [i] = inOutRect;

					break;
				}
			}
		}

		void AssignOutRect (string inOutID, Rect inOutRect)
		{
			for (int i = 0; i < outputsIDs.Length; i++)
			{
				if (outputsIDs [i] == inOutID)
				{
					outputsRects [i] = inOutRect;

					break;
				}
			}
		}

		void AssignOutRect (string inOutID, Rect inOutRect, int currentInOutListIndex)
		{

			int i = IndexOfOutID (inOutID);

			if (outputLinkedIndexToDestination [i] == -1)
			{
				if (currentInOutListIndex == onDragInOutListIndex)
				{
					outputsRects [i] = inOutRect;
				}
			}
			else
			{
				if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
				{
					if (currentInOutListIndex == outputLinkedIndexToDestination [i])
					{
						outputsRects [i] = inOutRect;
					}
				}
				else
				{
					if (currentInOutListIndex == onDragInOutListIndex)
					{
						outputsRects [i] = inOutRect;
					}
				}
			}
		}


		void InitInOutRects ()
		{
			inputsRects = new Rect [inputsIDs.Length];

			for (int i = 0; i < inputsRects.Length; i++)
			{
				inputsRects [i] = new Rect ();
			}


			outputsRects = new Rect [outputsIDs.Length];

			for (int i = 0; i < outputsRects.Length; i++)
			{
				outputsRects [i] = new Rect ();
			}


			firstRectOfListsOutput = new Rect [outputsIDs.Length];

			for (int i = 0; i < firstRectOfListsOutput.Length; i++)
			{
				firstRectOfListsOutput [i] = new Rect ();
			}
		}

		Rect InOutRect (bool isAnInput, Vector2 atPosition)
		{
			float inOutRectSize = Skins.logicNodeRectStep.y * 1f;

			float inOutRectSizeQuarter = 0.25f*inOutRectSize;

			Vector2 inOutRectCenter = new Vector2 (atPosition.x + 
				(rect.width*0.5f + inOutRectSizeQuarter)*(isAnInput?-1f:1f), atPosition.y);

			Vector2 inOutRectLeftTop = inOutRectCenter + 
				new Vector2 ( - 2f*inOutRectSizeQuarter, - 2f*inOutRectSizeQuarter);


			return new Rect (inOutRectLeftTop.x, inOutRectLeftTop.y, inOutRectSize, inOutRectSize); 
		}
	
		string FieldUniqueID (string inOutID)
		{
			return uniqueID + inOutAdressSeparator + inOutID;
		}
		string FieldUniqueID (string inOutID, int currentInOutListIndex)
		{
			return uniqueID + inOutAdressSeparator + inOutID + "_" + currentInOutListIndex.ToString ();
		}

		#endregion Link the inputs and the outputs variables


		/// <summary>
		/// GameObject fields treatment
		/// Special and necessary treatment of the Game Object fields to safely
		/// conserve them in the graph and in the generated scripts.
		/// </summary>
		#region GameObject fields treatment
		void AssignGameObjectField (ref GameObject goR, ref GameObject goOR, GameObject goV)
		{
			goR = goV;

			goOR = goV;
		}

		void ManageAttachedGameObject ()
		{
			if (variableType != VariableType.GameObject)
				return;
		}
		#endregion GameObject fields treatment


		/// <summary>
		/// The Actions.
		/// All methodes used by the logicNode to execute its logic.
		/// Not all these methodes are executed everytime, only the methodes
		/// corresponding to the case defined by the combination of 3 enum cases:
		/// logicType, variableType, and computeType, will be executed.
		/// </summary>
		#region actions
		partial void AdaptOnLogicType ();





		void ApplyComputeM44 ()
		{
			ComputeMatrix44_InputFields ();
			if (logic.playing)ComputeMatrix44 ();
			ComputeMatrix44_OutputFields ();
		}
		void ComputeMatrix44_InputFields ()
		{
			computeMatrix44Type = (ComputeMatrix44Type)DrawEnumComputeType (computeMatrix44Type,
				ref computeMatrix44Type_length, ref computeMatrix44Type_last, 
				typeof (ComputeMatrix44Type));

			switch (computeMatrix44Type)
			{
			case ComputeMatrix44Type.getDeterminant:
				DrawM44EntierInputField (0);
				break;

			case ComputeMatrix44Type.add:
				DrawM44EntierInputField (0);
				DrawM44EntierInputField (1);
				break;

			}
		}
		void ComputeMatrix44 ()
		{
			switch (computeMatrix44Type)
			{
			case ComputeMatrix44Type.getDeterminant:
				floatValue = m44Value_Input_entier [0].determinant;
				break;

			case ComputeMatrix44Type.add:
				M44_0_add_1 ();
				break;

			}
		}
		void ComputeMatrix44_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeMatrix44Type)
			{
			case ComputeMatrix44Type.getDeterminant:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Matrix4x4-determinant.html", 
					"");
				break;

			case ComputeMatrix44Type.add:
				DrawM44ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Add all the values of the matrices and put the result of each addition at the ",
					"corresponding place in a result matrix",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}
		void M44_0_add_1 ()
		{
			m44Value = new float[16];

			float [] tmp_0 = new float[16];

			float [] tmp_1 = new float[16];

			tmp_0 = SetM44ValueToArray (m44Value_Input_entier [0]);

			tmp_1 = SetM44ValueToArray (m44Value_Input_entier [1]);

			for (int i = 0; i < m44Value.Length; i++)
			{
				m44Value [i] = tmp_0 [i] + tmp_1 [i];
			}

			m44Value_entier = GetM44 (m44Value);

			SetM44Value (m44Value_entier);
		}

		void ApplyComputeNavMeshAgent ()
		{
			ComputeNavMeshAgent_InputFields ();

			if (logic.playing)ComputeNavMeshAgent ();

			ComputeNavMeshAgent_OutputFields ();
		}

		public int obstacleAvoidanceType_length = 0;
		public string obstacleAvoidanceType_last;

		void ComputeNavMeshAgent_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeNavMeshAgentType = (ComputeNavMeshAgentType)DrawEnumComputeType (
						computeNavMeshAgentType, ref computeNavMeshAgentType_length,
						ref computeNavMeshAgentType_last, typeof (ComputeNavMeshAgentType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				navMeshAgent = gameObjectValues [0].GetComponent <UnityEngine.AI.NavMeshAgent>();

				if (navMeshAgent == null)
				{
					DrawInNodeInfo ("Add UnityEngine.AI.NavMeshAgent To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						navMeshAgent == null;

					return;
				}

			}
			computeNavMeshAgentType = (ComputeNavMeshAgentType)DrawEnumComputeType (
				computeNavMeshAgentType, ref computeNavMeshAgentType_length,
				ref computeNavMeshAgentType_last, typeof (ComputeNavMeshAgentType));

			switch (computeNavMeshAgentType)
			{
			case ComputeNavMeshAgentType.Stop:

				break;

			case ComputeNavMeshAgentType.shouldTheAgentUpdateTheTransformRotation:
				DrawBoolInputField (0);
				break;

			case ComputeNavMeshAgentType.shouldTheAgentUpdateTheTransformPosition:
				DrawBoolInputField (0);
				break;

			case ComputeNavMeshAgentType.setStoppingDistance:
				DrawFloatInputField (0);
				break;

			case ComputeNavMeshAgentType.setSpeed:
				DrawFloatInputField (0);
				break;

			case ComputeNavMeshAgentType.setRadius:
				DrawFloatInputField (0);
				break;



			case ComputeNavMeshAgentType.setObstacleAvoidanceType:
				obstacleAvoidanceType = (UnityEngine.AI.ObstacleAvoidanceType)DrawEnum (obstacleAvoidanceType, 
					ref obstacleAvoidanceType_length, ref obstacleAvoidanceType_last, 
					typeof(UnityEngine.AI.ObstacleAvoidanceType),
					"Obstacle Avoidance Type", Skins.logicNodeLabel);

				break;

			case ComputeNavMeshAgentType.setNextPosition:
				DrawVector3InputField (0);
				break;

			case ComputeNavMeshAgentType.setHeight:
				DrawFloatInputField (0);
				break;

			case ComputeNavMeshAgentType.SetDestinationWithReturn:
				DrawVector3InputField (0);
				break;

			case ComputeNavMeshAgentType.setDestination:
				DrawVector3InputField (0);
				break;

			case ComputeNavMeshAgentType.setCurrentVelocity:
				DrawVector3InputField (0);
				break;

			case ComputeNavMeshAgentType.setBaseOffset:
				DrawFloatInputField (0); floatValues [0] = Mathf.Max (0f, floatValues [0]);

				break;

			case ComputeNavMeshAgentType.setAvoidancePriority:
				DrawLabelFields (new string[]
					{
						"Most important = 0",

						"Least important = 99",

						"Default = 50",
					});

				DrawIntInputField (0); intValues [0] = Mathf.Clamp (intValues [0], 0, 99);

				break;

			case ComputeNavMeshAgentType.setAutoTraverseOffMeshLink:
				DrawBoolInputField (0);
				break;

			case ComputeNavMeshAgentType.setAutoRepath:
				DrawBoolInputField (0);
				break;

			case ComputeNavMeshAgentType.setAutoBraking:
				DrawBoolInputField (0);
				break;

			case ComputeNavMeshAgentType.setAreaMask:
				DrawLabelField (FieldDrawType.label, "For default layers:", Skins.logicNodeLabel);

				DrawLabelFields (new string[]
					{
						"-1" + StringTreatment.rArrow + "everything",

						"0" + StringTreatment.rArrow + "nothing",

						"1" + StringTreatment.rArrow + "walkable",

						"2" + StringTreatment.rArrow + "not walkable",

						"3" + StringTreatment.rArrow + "walkable + not walkable",

						"4" + StringTreatment.rArrow + "jump",

						"5" + StringTreatment.rArrow + "walkable + jump",

						"6" + StringTreatment.rArrow + "not walkable + jump",

						"changes are effective only in editor",
					});

				DrawIntInputField (0); intValues [0] = Mathf.Max (-1, intValues [0]);
				break;

			case ComputeNavMeshAgentType.SetAreaCost:
				DrawLabelField (FieldDrawType.label, "Of area of index", 
					Skins.logicNodeLabel);

				DrawIntInputField (0); intValues [0] = Mathf.Clamp (intValues [0], 0, 31);

				DrawLabelField (FieldDrawType.label, "Cost", 
					Skins.logicNodeLabel);
				DrawFloatInputField (0);
				break;

			case ComputeNavMeshAgentType.setAngularSpeed:
				DrawFloatInputField (0);
				break;

			case ComputeNavMeshAgentType.setAcceleration:
				DrawFloatInputField (0);
				break;

			case ComputeNavMeshAgentType.SamplePathPositionGetInfoFacingTheAgent:
				DrawLabelFields (new string[]
					{
						"Get Info Facing the Agent",

						"Mask of which areas can be used by trac",
					});

				DrawIntInputField (0);

				DrawLabelField (FieldDrawType.label, "For default layers:", Skins.logicNodeLabel);

				DrawLabelFields (new string[]
					{
						"-1" + StringTreatment.rArrow + "everything",

						"0" + StringTreatment.rArrow + "nothing",

						"1" + StringTreatment.rArrow + "walkable",

						"2" + StringTreatment.rArrow + "not walkable",

						"3" + StringTreatment.rArrow + "walkable + not walkable",

						"4" + StringTreatment.rArrow + "jump",

						"5" + StringTreatment.rArrow + "walkable + jump",

						"6" + StringTreatment.rArrow + "not walkable + jump",

						"changes are effective only in editor",
					});


				DrawLabelFields (new string[]
					{
						"Distance of tracing",
					});

				DrawFloatInputField (0);
				break;

			case ComputeNavMeshAgentType.Resume:

				break;

			case ComputeNavMeshAgentType.ResetPath:

				break;

			case ComputeNavMeshAgentType.RayCast:
				DrawLabelFields (new string[]
					{
						"More Efficient than Physics.RayCast",
						"Put the End of the Ray",
					});

				DrawVector3InputField (0);
				break;

			case ComputeNavMeshAgentType.Move:
				DrawLabelFields (new string[] {"Do Quick Movment by this Vector"});

				DrawVector3InputField (0);
				break;

			case ComputeNavMeshAgentType.isAgentUpdatingTransformRotation:

				break;

			case ComputeNavMeshAgentType.isAgentUpdatingTransformPosition:

				break;

			case ComputeNavMeshAgentType.getStoppingDistance:

				break;

			case ComputeNavMeshAgentType.getSteeringTarget:

				break;

			case ComputeNavMeshAgentType.getSpeed:

				break;

			case ComputeNavMeshAgentType.getRemainingDistance:

				break;

			case ComputeNavMeshAgentType.getRadius:

				break;

			case ComputeNavMeshAgentType.getPathStatus:
				DrawLabelFields (new string[]
					{
						"-1" + StringTreatment.rArrow + "Path Invalid",
						"0.5" + StringTreatment.rArrow + "Path Cannot Reach Destination",
						"1" + StringTreatment.rArrow + "Path Can Reach Destination",
					});
				break;

			case ComputeNavMeshAgentType.getNextPosition:

				break;

			case ComputeNavMeshAgentType.getNextOffMeshLinkData:

				break;

			case ComputeNavMeshAgentType.getIsPathStale:

				break;

			case ComputeNavMeshAgentType.getIsPathPending:

				break;

			case ComputeNavMeshAgentType.getIsOnOffMeshLink:

				break;

			case ComputeNavMeshAgentType.getIsOnNavMesh:

				break;

			case ComputeNavMeshAgentType.getHeight:

				break;

			case ComputeNavMeshAgentType.getHasPath:

				break;

			case ComputeNavMeshAgentType.getDestination:

				break;

			case ComputeNavMeshAgentType.getDesiredVelocity:

				break;

			case ComputeNavMeshAgentType.getCurrentVelocity:

				break;

			case ComputeNavMeshAgentType.getCurrentOffMeshLinkData:

				break;

			case ComputeNavMeshAgentType.getBaseOffset:

				break;

			case ComputeNavMeshAgentType.getAvoidancePriority:

				break;

			case ComputeNavMeshAgentType.getAutoTraverseOffMeshLink:

				break;

			case ComputeNavMeshAgentType.getAutoRepath:

				break;

			case ComputeNavMeshAgentType.getAutoBraking:

				break;

			case ComputeNavMeshAgentType.getAreaMask:
				DrawLabelField (FieldDrawType.label, "For default layers:", Skins.logicNodeLabel);

				DrawLabelFields (new string[]
					{
						"-1" + StringTreatment.rArrow + "everything",

						"0" + StringTreatment.rArrow + "nothing",

						"1" + StringTreatment.rArrow + "walkable",

						"2" + StringTreatment.rArrow + "not walkable",

						"3" + StringTreatment.rArrow + "walkable + not walkable",

						"4" + StringTreatment.rArrow + "jump",

						"5" + StringTreatment.rArrow + "walkable + jump",

						"6" + StringTreatment.rArrow + "not walkable + jump",
					});
				break;

			case ComputeNavMeshAgentType.GetAreaCost:
				DrawLabelField (FieldDrawType.label, "Of area of index", 
					Skins.logicNodeLabel);

				DrawIntInputField (0);
				intValues [0] = Mathf.Clamp (intValues [0], 0, 31);
				break;

			case ComputeNavMeshAgentType.getAngularSpeed:

				break;

			case ComputeNavMeshAgentType.getAcceleration:

				break;

			case ComputeNavMeshAgentType.FindClosestEdge:

				break;

			case ComputeNavMeshAgentType.CompleteOffMeshLink:

				break;

			case ComputeNavMeshAgentType.ActivateCurrentOffMeshLink:
				DrawBoolInputField (0);
				break;

			}
			DrawDoItButton();
		}
		void ComputeNavMeshAgent ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeNavMeshAgentType)
			{
			case ComputeNavMeshAgentType.Stop:
				navMeshAgent.isStopped = true;
				break;

			case ComputeNavMeshAgentType.shouldTheAgentUpdateTheTransformRotation:
				navMeshAgent.updateRotation = boolValues [0];
				break;

			case ComputeNavMeshAgentType.shouldTheAgentUpdateTheTransformPosition:
				navMeshAgent.updatePosition = boolValues [0];
				break;

			case ComputeNavMeshAgentType.setStoppingDistance:
				navMeshAgent.stoppingDistance = floatValues [0];
				break;

			case ComputeNavMeshAgentType.setSpeed:
				navMeshAgent.speed = floatValues [0];
				break;

			case ComputeNavMeshAgentType.setRadius:
				navMeshAgent.radius = floatValues [0];
				break;

			case ComputeNavMeshAgentType.setObstacleAvoidanceType:
				navMeshAgent.obstacleAvoidanceType = obstacleAvoidanceType;
				break;

			case ComputeNavMeshAgentType.setNextPosition:
				navMeshAgent.nextPosition = vector3Values [0];
				break;

			case ComputeNavMeshAgentType.setHeight:
				navMeshAgent.height = floatValues [0];
				break;

			case ComputeNavMeshAgentType.SetDestinationWithReturn:
				boolValue = navMeshAgent.SetDestination (vector3Values [0]);
				break;

			case ComputeNavMeshAgentType.setDestination:
				navMeshAgent.destination = vector3Values [0];
				break;

			case ComputeNavMeshAgentType.setCurrentVelocity:
				navMeshAgent.velocity = vector3Values [0];
				break;

			case ComputeNavMeshAgentType.setBaseOffset:
				navMeshAgent.baseOffset = floatValues [0];
				break;

			case ComputeNavMeshAgentType.setAvoidancePriority:
				navMeshAgent.avoidancePriority = intValues [0];
				break;

			case ComputeNavMeshAgentType.setAutoTraverseOffMeshLink:
				navMeshAgent.autoTraverseOffMeshLink = boolValues [0];
				break;

			case ComputeNavMeshAgentType.setAutoRepath:
				navMeshAgent.autoRepath = boolValues [0];
				break;

			case ComputeNavMeshAgentType.setAutoBraking:
				navMeshAgent.autoBraking = boolValues [0];
				break;

			case ComputeNavMeshAgentType.setAreaMask:
				navMeshAgent.areaMask = intValues [0];
				break;

			case ComputeNavMeshAgentType.SetAreaCost:
				navMeshAgent.SetAreaCost (intValues [0], floatValues [0]);
				break;

			case ComputeNavMeshAgentType.setAngularSpeed:
				navMeshAgent.angularSpeed = floatValues [0];
				break;

			case ComputeNavMeshAgentType.setAcceleration:
				navMeshAgent.acceleration = floatValues [0];
				break;

			case ComputeNavMeshAgentType.SamplePathPositionGetInfoFacingTheAgent:
				boolValue = navMeshAgent.SamplePathPosition (intValues [0], floatValues [0], out navMeshHit);

				ExtractNavMeshHitValues ();
				break;

			case ComputeNavMeshAgentType.Resume:
				navMeshAgent.isStopped = false;
				break;

			case ComputeNavMeshAgentType.ResetPath:
				navMeshAgent.ResetPath ();
				break;

			case ComputeNavMeshAgentType.RayCast:
				boolValue = navMeshAgent.Raycast (vector3Values [0], out navMeshHit);

				ExtractNavMeshHitValues ();
				break;

			case ComputeNavMeshAgentType.Move:
				navMeshAgent.Move (vector3Values [0]);
				break;

			case ComputeNavMeshAgentType.isAgentUpdatingTransformRotation:
				boolValue = navMeshAgent.updateRotation;
				break;

			case ComputeNavMeshAgentType.isAgentUpdatingTransformPosition:
				boolValue = navMeshAgent.updatePosition;
				break;

			case ComputeNavMeshAgentType.getStoppingDistance:
				floatValue = navMeshAgent.stoppingDistance;
				break;

			case ComputeNavMeshAgentType.getSteeringTarget:
				vector3Value = navMeshAgent.steeringTarget;
				break;

			case ComputeNavMeshAgentType.getSpeed:
				floatValue = navMeshAgent.speed;
				break;

			case ComputeNavMeshAgentType.getRemainingDistance:
				floatValue = navMeshAgent.remainingDistance;
				break;

			case ComputeNavMeshAgentType.getRadius:
				floatValue = navMeshAgent.radius;
				break;

			case ComputeNavMeshAgentType.getPathStatus:
				switch (navMeshAgent.pathStatus)
				{
				case UnityEngine.AI.NavMeshPathStatus.PathComplete:
					floatValue = 1f;
					break;

				case UnityEngine.AI.NavMeshPathStatus.PathInvalid:
					floatValue = -1f;
					break;

				case UnityEngine.AI.NavMeshPathStatus.PathPartial:
					floatValue = 0.5f;
					break;
				}
				break;

			case ComputeNavMeshAgentType.getNextPosition:
				vector3Value = navMeshAgent.nextPosition;
				break;

			case ComputeNavMeshAgentType.getNextOffMeshLinkData:
				OffMeshLinkData_activated = navMeshAgent.nextOffMeshLinkData.activated;

				OffMeshLinkData_endPosition = navMeshAgent.nextOffMeshLinkData.endPos;

				OffMeshLinkData_startPosition = navMeshAgent.nextOffMeshLinkData.startPos;

				OffMeshLinkData_valid = navMeshAgent.nextOffMeshLinkData.valid;


				OffMeshLinkData_Type = navMeshAgent.nextOffMeshLinkData.linkType;
				break;

			case ComputeNavMeshAgentType.getIsPathStale:
				boolValue = navMeshAgent.isPathStale;
				break;

			case ComputeNavMeshAgentType.getIsPathPending:
				boolValue = navMeshAgent.pathPending;
				break;

			case ComputeNavMeshAgentType.getIsOnOffMeshLink:
				boolValue = navMeshAgent.isOnOffMeshLink;
				break;

			case ComputeNavMeshAgentType.getIsOnNavMesh:
				boolValue = navMeshAgent.isOnNavMesh;
				break;

			case ComputeNavMeshAgentType.getHeight:
				floatValue = navMeshAgent.height;
				break;

			case ComputeNavMeshAgentType.getHasPath:
				boolValue = navMeshAgent.hasPath;
				break;

			case ComputeNavMeshAgentType.getDestination:
				vector3Value = navMeshAgent.destination;
				break;

			case ComputeNavMeshAgentType.getDesiredVelocity:
				vector3Value = navMeshAgent.desiredVelocity;
				break;

			case ComputeNavMeshAgentType.getCurrentVelocity:
				vector3Value = navMeshAgent.velocity;
				break;

			case ComputeNavMeshAgentType.getCurrentOffMeshLinkData:
				OffMeshLinkData_activated = navMeshAgent.currentOffMeshLinkData.activated;

				OffMeshLinkData_endPosition = navMeshAgent.currentOffMeshLinkData.endPos;

				OffMeshLinkData_startPosition = navMeshAgent.currentOffMeshLinkData.startPos;

				OffMeshLinkData_valid = navMeshAgent.currentOffMeshLinkData.valid;


				OffMeshLinkData_Type = navMeshAgent.currentOffMeshLinkData.linkType;
				break;

			case ComputeNavMeshAgentType.getBaseOffset:
				floatValue = navMeshAgent.baseOffset;
				break;

			case ComputeNavMeshAgentType.getAvoidancePriority:
				intValue = navMeshAgent.avoidancePriority;
				break;

			case ComputeNavMeshAgentType.getAutoTraverseOffMeshLink:
				boolValue = navMeshAgent.autoTraverseOffMeshLink;
				break;

			case ComputeNavMeshAgentType.getAutoRepath:
				boolValue = navMeshAgent.autoRepath;
				break;

			case ComputeNavMeshAgentType.getAutoBraking:
				boolValue = navMeshAgent.autoBraking;
				break;

			case ComputeNavMeshAgentType.getAreaMask:
				intValue = navMeshAgent.areaMask;
				break;

			case ComputeNavMeshAgentType.GetAreaCost:
				floatValue = navMeshAgent.GetAreaCost (intValues [0]);
				break;

			case ComputeNavMeshAgentType.getAngularSpeed:
				floatValue = navMeshAgent.angularSpeed;
				break;

			case ComputeNavMeshAgentType.getAcceleration:
				floatValue = navMeshAgent.acceleration;
				break;

			case ComputeNavMeshAgentType.FindClosestEdge:
				boolValue = navMeshAgent.FindClosestEdge (out navMeshHit);

				ExtractNavMeshHitValues ();
				break;

			case ComputeNavMeshAgentType.CompleteOffMeshLink:
				navMeshAgent.CompleteOffMeshLink ();
				break;

			case ComputeNavMeshAgentType.ActivateCurrentOffMeshLink:
				navMeshAgent.ActivateCurrentOffMeshLink (boolValues [0]);
				break;

			}
		}
		void ComputeNavMeshAgent_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeNavMeshAgentType)
			{
			case ComputeNavMeshAgentType.Stop:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isStopped.html", 
					"");
				break;

			case ComputeNavMeshAgentType.shouldTheAgentUpdateTheTransformRotation:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-updateRotation.html", 
					"");
				break;

			case ComputeNavMeshAgentType.shouldTheAgentUpdateTheTransformPosition:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-updatePosition.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setStoppingDistance:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-stoppingDistance.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setSpeed:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-speed.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setRadius:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-radius.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setObstacleAvoidanceType:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.ObstacleAvoidanceType.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setNextPosition:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-nextPosition.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setHeight:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,

				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-height.html", 
					"");
				break;

			case ComputeNavMeshAgentType.SetDestinationWithReturn:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.SetDestination.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setDestination:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-destination.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setCurrentVelocity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-velocity.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setBaseOffset:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-baseOffset.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setAvoidancePriority:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-avoidancePriority.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setAutoTraverseOffMeshLink:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoTraverseOffMeshLink.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setAutoRepath:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoRepath.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setAutoBraking:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoBraking.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setAreaMask:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-areaMask.html", 
					"");
				break;

			case ComputeNavMeshAgentType.SetAreaCost:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMesh.SetAreaCost.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setAngularSpeed:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-angularSpeed.html", 
					"");
				break;

			case ComputeNavMeshAgentType.setAcceleration:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-acceleration.html", 
					"");
				break;

			case ComputeNavMeshAgentType.SamplePathPositionGetInfoFacingTheAgent:
				DrawNavMeshHitResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.SamplePathPosition.html", 
					"");
				break;

			case ComputeNavMeshAgentType.Resume:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isStopped.html", 
					"");
				break;

			case ComputeNavMeshAgentType.ResetPath:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.ResetPath.html", 
					"");
				break;

			case ComputeNavMeshAgentType.RayCast:
				DrawNavMeshHitResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.Raycast.html", 
					"");
				break;

			case ComputeNavMeshAgentType.Move:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.Move.html", 
					"");
				break;

			case ComputeNavMeshAgentType.isAgentUpdatingTransformRotation:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-updateRotation.html", 
					"");
				break;

			case ComputeNavMeshAgentType.isAgentUpdatingTransformPosition:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-updatePosition.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getStoppingDistance:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-stoppingDistance.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getSteeringTarget:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-steeringTarget.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getSpeed:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-speed.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getRemainingDistance:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-remainingDistance.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getRadius:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-radius.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getPathStatus:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshPathStatus.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getNextPosition:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-nextPosition.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getNextOffMeshLinkData:
				DrawOffMeshLinkDataResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-nextOffMeshLinkData.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getIsPathStale:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isPathStale.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getIsPathPending:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-pathPending.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getIsOnOffMeshLink:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isOnOffMeshLink.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getIsOnNavMesh:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isOnNavMesh.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getHeight:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-height.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getHasPath:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-hasPath.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getDestination:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-destination.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getDesiredVelocity:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-desiredVelocity.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getCurrentVelocity:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-velocity.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getCurrentOffMeshLinkData:
				DrawOffMeshLinkDataResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-currentOffMeshLinkData.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getBaseOffset:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-baseOffset.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getAvoidancePriority:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-avoidancePriority.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getAutoTraverseOffMeshLink:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoTraverseOffMeshLink.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getAutoRepath:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoRepath.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getAutoBraking:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoBraking.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getAreaMask:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-areaMask.html", 
					"");
				break;

			case ComputeNavMeshAgentType.GetAreaCost:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMesh.GetAreaCost.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getAngularSpeed:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-angularSpeed.html", 
					"");
				break;

			case ComputeNavMeshAgentType.getAcceleration:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-acceleration.html", 
					"");
				break;

			case ComputeNavMeshAgentType.FindClosestEdge:
				DrawNavMeshHitResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMesh.FindClosestEdge.html", 
					"");
				break;

			case ComputeNavMeshAgentType.CompleteOffMeshLink:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.CompleteOffMeshLink.html", 
					"");
				break;

			case ComputeNavMeshAgentType.ActivateCurrentOffMeshLink:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.ActivateCurrentOffMeshLink.html", 
					"");
				break;

			}
		}


		void ApplyComputeParticleSystem ()
		{
			DrawObjectFieldFillingMessage_ThereIsAdditional = true;
			DrawObjectFieldFillingMessage_Additional = new string[]
			{
				"\n",
				"With Unity version 5.3.1, you may have this error:\n",
				"Particle System - Invalid AABB / IsFinite errors\n",
				"For now, I Reproduced this error when I used particle system world space\n",
				"as a simulation spca\n",
				"This is a bug reported with ticket \n",
				"755423_a1621g7nsq609m0g\n",
				"Normally, it is solved in other versions\n",
			};

			ComputeParticleSystem_InputFields ();
			if (logic.playing)ComputeParticleSystem ();
			ComputeParticleSystem_OutputFields ();

			DrawObjectFieldFillingMessage_ThereIsAdditional = false;
			DrawObjectFieldFillingMessage_Additional = new string[1];
		}	


		public int particleSystemSimulationSpace_length = 0;
		public string particleSystemSimulationSpace_last;

		public int particleSystemScalingMode_length = 0;
		public string particleSystemScalingMode_last;

		void ComputeParticleSystem_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeParticleSystemType = (ComputeParticleSystemType)DrawEnumComputeType (
						computeParticleSystemType, ref computeParticleSystemType_length,
						ref computeParticleSystemType_last, typeof (ComputeParticleSystemType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				particleSystem = gameObjectValues [0].GetComponent <ParticleSystem>();

				if (particleSystem == null)
				{
					DrawInNodeInfo ("Add ParticleSystem To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						particleSystem == null;

					return;
				}
				psMain = particleSystem.main;
			}
			computeParticleSystemType = (ComputeParticleSystemType)DrawEnumComputeType (
				computeParticleSystemType, ref computeParticleSystemType_length,
				ref computeParticleSystemType_last, typeof (ComputeParticleSystemType));

			switch (computeParticleSystemType)
			{
			case ComputeParticleSystemType.Stop:

				break;

			case ComputeParticleSystemType.setStartSpeed:
				DrawFloatInputField (0);
				break;

			case ComputeParticleSystemType.setStartSize:
				DrawFloatInputField (0);
				break;

			case ComputeParticleSystemType.setStartRotation3D:
				DrawBoolInputField (0);
				break;

			case ComputeParticleSystemType.setStartRotation:
				DrawFloatInputField (0);
				break;

			case ComputeParticleSystemType.setStartLifeTime:
				DrawFloatInputField (0);
				break;

			case ComputeParticleSystemType.setStartDelay:
				DrawFloatInputField (0);
				break;

			case ComputeParticleSystemType.setStartColor:
				DrawColorInputField (0);
				break;


			case ComputeParticleSystemType.setSimulationSpace:
				particleSystemSimulationSpace = (ParticleSystemSimulationSpace)DrawEnum (
					particleSystemSimulationSpace, 
					ref particleSystemSimulationSpace_length,
					ref particleSystemSimulationSpace_last, typeof(ParticleSystemSimulationSpace),
					"Simulation Space", Skins.logicNodeLabel);
				break;



			case ComputeParticleSystemType.setScalingMode:
				particleSystemScalingMode = (ParticleSystemScalingMode)DrawEnum (particleSystemScalingMode,
					ref particleSystemScalingMode_length,
					ref particleSystemScalingMode_last, typeof(ParticleSystemScalingMode),
					"Scaling Mode", Skins.logicNodeLabel);
				break;

			case ComputeParticleSystemType.setRandomSeed:
				DrawIntInputField (0);
				break;

			case ComputeParticleSystemType.setPlayOnAwake:
				DrawBoolInputField (0);
				break;

			case ComputeParticleSystemType.setPlaybackTime:
				DrawFloatInputField (0);
				break;

			case ComputeParticleSystemType.setPlaybackSpeed:
				DrawFloatInputField (0);
				break;

			case ComputeParticleSystemType.setMaxParticles:
				DrawIntInputField (0);
				break;

			case ComputeParticleSystemType.setIsLooping:
				DrawBoolInputField (0);
				break;

			case ComputeParticleSystemType.setGravityModifier:
				DrawFloatInputField (0);
				break;

			case ComputeParticleSystemType.Play:

				break;

			case ComputeParticleSystemType.Pause:

				break;

			case ComputeParticleSystemType.getStartSpeed:

				break;

			case ComputeParticleSystemType.getStartSize:

				break;

			case ComputeParticleSystemType.getStartRotation3D:

				break;

			case ComputeParticleSystemType.getStartRotation:

				break;

			case ComputeParticleSystemType.getStartLifeTime:

				break;

			case ComputeParticleSystemType.getStartDelay:

				break;

			case ComputeParticleSystemType.getStartColor:

				break;

			case ComputeParticleSystemType.getRandomSeed:

				break;

			case ComputeParticleSystemType.getPlayOnAwake:

				break;

			case ComputeParticleSystemType.getPlaybackTime:

				break;

			case ComputeParticleSystemType.getPlaybackSpeed:

				break;

			case ComputeParticleSystemType.getParticleCount:

				break;

			case ComputeParticleSystemType.getMaxParticles:

				break;

			case ComputeParticleSystemType.getIsStopped:

				break;

			case ComputeParticleSystemType.getIsPlaying:

				break;

			case ComputeParticleSystemType.getIsPaused:

				break;

			case ComputeParticleSystemType.getIsLooping:

				break;

			case ComputeParticleSystemType.getIsAlive:

				break;

			case ComputeParticleSystemType.getGravityModifier:

				break;

			case ComputeParticleSystemType.getDuration:

				break;

			case ComputeParticleSystemType.EmitImmediat:
				DrawLogicNodeLabel ("Particles Count", 0, 2);
				DrawIntInputField (0, 1, 2);
				break;

			}
			DrawDoItButton();
		}
		void ComputeParticleSystem ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeParticleSystemType)
			{
			case ComputeParticleSystemType.Stop:
				particleSystem.Stop ();
				break;

			case ComputeParticleSystemType.setStartSpeed:
				psMain.startSpeed = floatValues [0];
				break;

			case ComputeParticleSystemType.setStartSize:
				psMain.startSize = floatValues [0];
				break;

			case ComputeParticleSystemType.setStartRotation3D:
				psMain.startRotation3D = boolValues [0];
				break;

			case ComputeParticleSystemType.setStartRotation:
				psMain.startRotation = floatValues [0];
				break;

			case ComputeParticleSystemType.setStartLifeTime:
				psMain.startLifetime = floatValues [0];
				break;

			case ComputeParticleSystemType.setStartDelay:
				psMain.startDelay = floatValues [0];
				break;

			case ComputeParticleSystemType.setStartColor:
				psMain.startColor = colorValues [0];
				break;

			case ComputeParticleSystemType.setSimulationSpace:
				psMain.simulationSpace = particleSystemSimulationSpace;
				break;

			case ComputeParticleSystemType.setScalingMode:
				psMain.scalingMode = particleSystemScalingMode;
				break;

			case ComputeParticleSystemType.setRandomSeed:
				particleSystem.randomSeed = (uint)intValues [0];
				break;

			case ComputeParticleSystemType.setPlayOnAwake:
				psMain.playOnAwake = boolValues [0];
				break;

			case ComputeParticleSystemType.setPlaybackTime:
				particleSystem.time = floatValues [0];
				break;

			case ComputeParticleSystemType.setPlaybackSpeed:
				psMain.simulationSpeed = floatValues [0];
				break;

			case ComputeParticleSystemType.setMaxParticles:
				psMain.maxParticles = intValues [0];
				break;

			case ComputeParticleSystemType.setIsLooping:
				psMain.loop = boolValues [0];
				break;

			case ComputeParticleSystemType.setGravityModifier:
				psMain.gravityModifier = floatValues [0];
				break;

			case ComputeParticleSystemType.Play:
				particleSystem.Play ();
				break;

			case ComputeParticleSystemType.Pause:
				particleSystem.Pause ();
				break;

			case ComputeParticleSystemType.getStartSpeed:
				floatValue = particleSystem.main.startSpeed.constant;
				break;

			case ComputeParticleSystemType.getStartSize:
				floatValue = psMain.startSize.constant;
				break;

			case ComputeParticleSystemType.getStartRotation3D:
				boolValue = psMain.startRotation3D;
				break;

			case ComputeParticleSystemType.getStartRotation:
				floatValue = psMain.startRotation.constant;
				break;

			case ComputeParticleSystemType.getStartLifeTime:
				floatValue = psMain.startLifetime.constant;
				break;

			case ComputeParticleSystemType.getStartDelay:
				floatValue = psMain.startDelay.constant;
				break;

			case ComputeParticleSystemType.getStartColor:
				colorValue = psMain.startColor.color;
				break;

			case ComputeParticleSystemType.getRandomSeed:
				intValue = (int)particleSystem.randomSeed;
				break;

			case ComputeParticleSystemType.getPlayOnAwake:
				boolValue = psMain.playOnAwake;
				break;

			case ComputeParticleSystemType.getPlaybackTime:
				floatValue = particleSystem.time;
				break;

			case ComputeParticleSystemType.getPlaybackSpeed:
				floatValue = psMain.simulationSpeed;
				break;

			case ComputeParticleSystemType.getParticleCount:
				intValue = particleSystem.particleCount;
				break;

			case ComputeParticleSystemType.getMaxParticles:
				intValue = psMain.maxParticles;
				break;

			case ComputeParticleSystemType.getIsStopped:
				boolValue = particleSystem.isStopped;
				break;

			case ComputeParticleSystemType.getIsPlaying:
				boolValue = particleSystem.isPlaying;
				break;

			case ComputeParticleSystemType.getIsPaused:
				boolValue = particleSystem.isPaused;
				break;

			case ComputeParticleSystemType.getIsLooping:
				boolValue = psMain.loop;
				break;

			case ComputeParticleSystemType.getIsAlive:
				boolValue = particleSystem.IsAlive ();
				break;

			case ComputeParticleSystemType.getGravityModifier:
				floatValue = psMain.gravityModifier.constant;
				break;

			case ComputeParticleSystemType.getDuration:
				floatValue = psMain.duration;
				break;

			case ComputeParticleSystemType.EmitImmediat:
				particleSystem.Emit (intValues [0]);
				break;

			}
		}
		void ComputeParticleSystem_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeParticleSystemType)
			{
			case ComputeParticleSystemType.Stop:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.Stop.html", 
					"");
				break;

			case ComputeParticleSystemType.setStartSpeed:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startSpeed.html", 
					"");
				break;

			case ComputeParticleSystemType.setStartSize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startSize.html", 
					"");
				break;

			case ComputeParticleSystemType.setStartRotation3D:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startRotation3D.html", 
					"");
				break;

			case ComputeParticleSystemType.setStartRotation:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startRotation.html", 
					"");
				break;

			case ComputeParticleSystemType.setStartLifeTime:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startLifetime.html", 
					"");
				break;

			case ComputeParticleSystemType.setStartDelay:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startDelay.html", 
					"");
				break;

			case ComputeParticleSystemType.setStartColor:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startColor.html", 
					"");
				break;

			case ComputeParticleSystemType.setSimulationSpace:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-simulationSpace.html", 
					"");
				break;

			case ComputeParticleSystemType.setScalingMode:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-scalingMode.html", 
					"");
				break;

			case ComputeParticleSystemType.setRandomSeed:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-randomSeed.html", 
					"");
				break;

			case ComputeParticleSystemType.setPlayOnAwake:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-playOnAwake.html", 
					"");
				break;

			case ComputeParticleSystemType.setPlaybackTime:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-time.html", 
					"");
				break;

			case ComputeParticleSystemType.setPlaybackSpeed:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-simulationSpeed.html", 
					"");
				break;

			case ComputeParticleSystemType.setMaxParticles:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-maxParticles.html", 
					"");
				break;

			case ComputeParticleSystemType.setIsLooping:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-loop.html", 
					"");
				break;

			case ComputeParticleSystemType.setGravityModifier:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-gravityModifier.html", 
					"");
				break;

			case ComputeParticleSystemType.Play:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.Play.html", 
					"");
				break;

			case ComputeParticleSystemType.Pause:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.Pause.html", 
					"");
				break;

			case ComputeParticleSystemType.getStartSpeed:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startSpeed.html", 
					"");
				break;

			case ComputeParticleSystemType.getStartSize:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startSize.html", 
					"");
				break;

			case ComputeParticleSystemType.getStartRotation3D:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startRotation3D.html", 
					"");
				break;

			case ComputeParticleSystemType.getStartRotation:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startRotation.html", 
					"");
				break;

			case ComputeParticleSystemType.getStartLifeTime:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startLifetime.html", 
					"");
				break;

			case ComputeParticleSystemType.getStartDelay:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startDelay.html", 
					"");
				break;

			case ComputeParticleSystemType.getStartColor:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startColor.html", 
					"");
				break;

			case ComputeParticleSystemType.getRandomSeed:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-randomSeed.html", 
					"");
				break;

			case ComputeParticleSystemType.getPlayOnAwake:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-playOnAwake.html", 
					"");
				break;

			case ComputeParticleSystemType.getPlaybackTime:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-time.html", 
					"");
				break;

			case ComputeParticleSystemType.getPlaybackSpeed:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-simulationSpeed.html", 
					"");
				break;

			case ComputeParticleSystemType.getParticleCount:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-particleCount.html", 
					"");
				break;

			case ComputeParticleSystemType.getMaxParticles:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-maxParticles.html", 
					"");
				break;

			case ComputeParticleSystemType.getIsStopped:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-isStopped.html", 
					"");
				break;

			case ComputeParticleSystemType.getIsPlaying:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-isPlaying.html", 
					"");
				break;

			case ComputeParticleSystemType.getIsPaused:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-isPaused.html", 
					"");
				break;

			case ComputeParticleSystemType.getIsLooping:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-loop.html", 
					"");
				break;

			case ComputeParticleSystemType.getIsAlive:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.IsAlive.html", 
					"");
				break;

			case ComputeParticleSystemType.getGravityModifier:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-gravityModifier.html", 
					"");
				break;

			case ComputeParticleSystemType.getDuration:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-duration.html", 
					"");
				break;

			case ComputeParticleSystemType.EmitImmediat:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.Emit.html", 
					"");
				break;

			}
		}


		void ApplyComputeShader ()
		{
			DoNotCheckShader_0 ();

			ComputeShader_InputFields ();
			if (logic.playing)ComputeShader ();
			ComputeShader_OutputFields ();
		}
		void ComputeShader_InputFields ()
		{
			linkedOrAttachedTo = shaderValues [0] == null;

			if ( ! doNotCheckShader_0)
			{
				if (computeShaderType != ComputeShaderType.get)
					DrawShaderFieldInput (0);

				if (computeShaderType != ComputeShaderType.get)
				if ( ! linkedOrAttachedTo)
				{
					if (shaderValues [0] == null)
					{
						DrawInNodeInfo ("Fill in the Shader field");

						computeShaderType = (ComputeShaderType)DrawEnumComputeType (computeShaderType,
							ref computeShaderType_length, ref computeShaderType_last, typeof (ComputeShaderType));

						return;
					}

				}
			}
			else if (doNotCheckShader_0)
			{
				linkedOrAttachedTo = false;
			}
			computeShaderType = (ComputeShaderType)DrawEnumComputeType (computeShaderType,
				ref computeShaderType_length, ref computeShaderType_last, typeof (ComputeShaderType));

			switch (computeShaderType)
			{
			case ComputeShaderType.listenToTransferredData:
				DrawInNodeInfo ("Default value: In the above shader field");
				DrawStringListMenuToString_0 (
					"Data Name", MezanixDiamondShaderNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeShaderType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeShaderType.getName:

				break;

			case ComputeShaderType.setName:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeShaderType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_shader_DrawInputs ();
				break;

			case ComputeShaderType.WarmupAllShaders:

				break;

			case ComputeShaderType.setMaximumLOD:
				DrawIntInputField (0);
				break;

			case ComputeShaderType.getRenderQueue:

				break;

			case ComputeShaderType.getMaximumLOD:

				break;

			case ComputeShaderType.getIsSupported:

				break;

			case ComputeShaderType.forAllShadersSetGlobalVector4:
				DrawShadersGetGlobalPropertieModeEnum ();
				DrawVector4InputField (0);
				break;

			case ComputeShaderType.forAllShadersSetGlobalTexture:
				DrawShadersGetGlobalPropertieModeEnum ();
				DrawTexture2DFieldInput (0);
				break;

			case ComputeShaderType.forAllShadersSetGlobalMaximumLOD:
				DrawInputsForShaderSetMaximumLOD ();
				break;

			case ComputeShaderType.forAllShadersSetGlobalInt:
				DrawShadersGetGlobalPropertieModeEnum ();
				DrawIntInputField (1);
				break;

			case ComputeShaderType.forAllShadersSetGlobalFloat:
				DrawShadersGetGlobalPropertieModeEnum ();
				DrawFloatInputField (0);
				break;

			case ComputeShaderType.forAllShadersSetGlobalColor:
				DrawShadersGetGlobalPropertieModeEnum ();
				DrawColorInputField (0);
				break;

			case ComputeShaderType.forAllShadersPropertyToID:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeShaderType.forAllShadersIsKeywordEnabled:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeShaderType.forAllShadersGetGlobalMaximumLOD:

				break;

			case ComputeShaderType.forAllShadersEnableKeyword:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeShaderType.forAllShadersDisableKeyword:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeShaderType.FindAShaderByName:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			}
			if (computeShaderType == ComputeShaderType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeShader ()
		{
			bool notDataTransfer = ! (computeShaderType == ComputeShaderType.sendMeAsTransferredData ||
				computeShaderType == ComputeShaderType.listenToTransferredData);
			if (notDataTransfer)
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			switch (computeShaderType)
			{
			case ComputeShaderType.listenToTransferredData:
				shaderValue = MezanixDiamondGetShader (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveShader (stringValues [0]);
				}
				break;

			case ComputeShaderType.sendMeAsTransferredData:
				MezanixDiamondSetShader (stringValues [0]);

				break;

			case ComputeShaderType.getName:
				if (shaderValues [0] != null)
				{
					stringValue = shaderValues [0].name;
				}
				break;

			case ComputeShaderType.setName:
				if (shaderValues [0] != null)
				{
					shaderValues [0].name = stringValues [0];

					shaderValue = shaderValues [0];
				}
				break;

			case ComputeShaderType.get:
				ForGet_shader_Compute ();
				break;

			case ComputeShaderType.WarmupAllShaders:
				Shader.WarmupAllShaders ();
				break;

			case ComputeShaderType.setMaximumLOD:
				if (shaderValues [0] != null)
				{
					shaderValues [0].maximumLOD = intValues [0];

					shaderValue = shaderValues [0];
				}
				break;

			case ComputeShaderType.getRenderQueue:
				if (shaderValues [0] != null)
				{
					intValue = shaderValues [0].renderQueue;
				}
				break;

			case ComputeShaderType.getMaximumLOD:
				if (shaderValues [0] != null)
				{
					intValue = shaderValues [0].maximumLOD;
				}
				break;

			case ComputeShaderType.getIsSupported:
				if (shaderValues [0] != null)
				{
					boolValue = shaderValues [0].isSupported;
				}
				break;

			case ComputeShaderType.forAllShadersSetGlobalVector4:
				switch (shadersGetGlobalPropertieMode)
				{
				case ShadersGetGlobalPropertieMode.byName:
					Shader.SetGlobalVector (stringValues [0], vector4Values [0]);
					break;

				case ShadersGetGlobalPropertieMode.byNameID:
					Shader.SetGlobalVector (intValues [0], vector4Values [0]);
					break;
				}
				break;

			case ComputeShaderType.forAllShadersSetGlobalTexture:
				if (texture2DValues [0] != null)
				{
					switch (shadersGetGlobalPropertieMode)
					{
					case ShadersGetGlobalPropertieMode.byName:
						Shader.SetGlobalTexture (stringValues [0], texture2DValues [0]);
						break;

					case ShadersGetGlobalPropertieMode.byNameID:
						Shader.SetGlobalTexture (intValues [0], texture2DValues [0]);
						break;
					}
				}
				break;

			case ComputeShaderType.forAllShadersSetGlobalMaximumLOD:
				Shader.globalMaximumLOD = intValues [0];
				break;

			case ComputeShaderType.forAllShadersSetGlobalInt:
				switch (shadersGetGlobalPropertieMode)
				{
				case ShadersGetGlobalPropertieMode.byName:
					Shader.SetGlobalInt (stringValues [0], intValues [1]);
					break;

				case ShadersGetGlobalPropertieMode.byNameID:
					Shader.SetGlobalInt (intValues [0], intValues [1]);
					break;
				}
				break;

			case ComputeShaderType.forAllShadersSetGlobalFloat:
				switch (shadersGetGlobalPropertieMode)
				{
				case ShadersGetGlobalPropertieMode.byName:
					Shader.SetGlobalFloat (stringValues [0], floatValues [0]);
					break;

				case ShadersGetGlobalPropertieMode.byNameID:
					Shader.SetGlobalFloat (intValues [0], floatValues [0]);
					break;
				}
				break;

			case ComputeShaderType.forAllShadersSetGlobalColor:
				switch (shadersGetGlobalPropertieMode)
				{
				case ShadersGetGlobalPropertieMode.byName:
					Shader.SetGlobalColor (stringValues [0], colorValues [0]);
					break;

				case ShadersGetGlobalPropertieMode.byNameID:
					Shader.SetGlobalColor (intValues [0], colorValues [0]);
					break;
				}
				break;

			case ComputeShaderType.forAllShadersPropertyToID:
				intValue = Shader.PropertyToID (stringValues [0]);
				break;

			case ComputeShaderType.forAllShadersIsKeywordEnabled:
				boolValue = Shader.IsKeywordEnabled (stringValues [0]);
				break;

			case ComputeShaderType.forAllShadersGetGlobalMaximumLOD:
				intValue = Shader.globalMaximumLOD;
				break;

			case ComputeShaderType.forAllShadersEnableKeyword:
				Shader.EnableKeyword (stringValues [0]);
				break;

			case ComputeShaderType.forAllShadersDisableKeyword:
				Shader.DisableKeyword (stringValues [0]);
				break;

			case ComputeShaderType.FindAShaderByName:
				shaderValue = Shader.Find (stringValues [0]);
				break;

			}
		}
		void ComputeShader_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeShaderType)
			{
			case ComputeShaderType.listenToTransferredData:
				DrawShaderResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeShaderType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeShaderType.getName:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The name of the object (shader).",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Object-name.html", 
					"");
				break;

			case ComputeShaderType.setName:
				DrawShaderResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The name of the object (shader).",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Object-name.html", 
					"");
				break;

			case ComputeShaderType.get:
				ForGet_shader_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeShaderType.WarmupAllShaders:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Fully load all shaders to prevent future performance hiccups..",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.WarmupAllShaders.html", 
					"");
				break;

			case ComputeShaderType.setMaximumLOD:
				DrawShaderResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Shader LOD level for this shader.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader-maximumLOD.html", 
					"");
				break;

			case ComputeShaderType.getRenderQueue:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Render queue of this shader. (Read Only)",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader-renderQueue.html", 
					"");
				break;

			case ComputeShaderType.getMaximumLOD:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Shader LOD level for this shader.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader-maximumLOD.html", 
					"");
				break;

			case ComputeShaderType.getIsSupported:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Can this shader run on the end-users graphics card? (Read Only)",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader-isSupported.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersSetGlobalVector4:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Sets a global vector property for all shaders.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalVector.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersSetGlobalTexture:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Sets a global texture property for all shaders.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalTexture.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersSetGlobalMaximumLOD:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Shader LOD level for all shaders.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader-globalMaximumLOD.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersSetGlobalInt:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Sets a global int property for all shaders.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalInt.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersSetGlobalFloat:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Sets a global float property for all shaders.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalFloat.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersSetGlobalColor:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Sets a global color property for all shaders.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalColor.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersPropertyToID:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Gets unique identifier for a shader property name.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.PropertyToID.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersIsKeywordEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Is global shader keyword enabled?",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.IsKeywordEnabled.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersGetGlobalMaximumLOD:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Shader LOD level for all shaders.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader-globalMaximumLOD.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersEnableKeyword:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Set a global shader keyword.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.EnableKeyword.html", 
					"");
				break;

			case ComputeShaderType.forAllShadersDisableKeyword:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Unset a global shader keyword.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.DisableKeyword.html", 
					"");
				break;

			case ComputeShaderType.FindAShaderByName:
				DrawShaderResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Finds a shader with the given name.",
					"Shader.Find can be used to switch to another shader without having to keep a reference to the shader.",
					"name is the name you can see in the shader popup of any material, for example 'Standard', 'Unlit/Texture',",
					"'Legacy Shaders/Diffuse' etc.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Shader.Find.html", 
					"");
				break;

			}
		}


		void ApplyComputeTexture2D ()
		{
			DoNotCheckTexture2D_0 ();

			ComputeTexture2D_InputFields();
			if (logic.playing)ComputeTexture2D ();
			ComputeTexture2D_OutputFields();

		}
		void ComputeTexture2D_InputFields ()
		{
			linkedOrAttachedTo = texture2DValues [0] == null;

			if ( ! doNotCheckTexture2D_0)
			{
				if (computeTexture2DType != ComputeTexture2DType.get)
					DrawTexture2DFieldInput (0);

				if (computeTexture2DType != ComputeTexture2DType.get)
				if ( ! linkedOrAttachedTo)
				{
					if (texture2DValues [0] == null)
					{
						DrawInNodeInfo ("Fill in the Texture2D field");

						computeTexture2DType = (ComputeTexture2DType)DrawEnumComputeType (computeTexture2DType,
							ref computeTexture2DType_length, ref computeTexture2DType_last, typeof (ComputeTexture2DType));

						return;
					}

				}
			}
			else if (doNotCheckTexture2D_0)
			{
				linkedOrAttachedTo = false;
			}
			computeTexture2DType = (ComputeTexture2DType)DrawEnumComputeType (computeTexture2DType,
				ref computeTexture2DType_length, ref computeTexture2DType_last, typeof (ComputeTexture2DType));
			

			switch (computeTexture2DType)
			{
			case ComputeTexture2DType.applySetPixelChanges:
				DrawLogicNodeLabel ("Update mipmaps?", 0, 2);
				DrawBoolInputField (0, 3, 4);				
				DrawLogicNodeLabel ("Make NotReadable?", 0, 2);
				DrawBoolInputField (1, 3, 4);
				break;

			case ComputeTexture2DType.listenToTransferredData:
				DrawInNodeInfo ("Default value: In the above texture field");
				DrawStringListMenuToString_0 (
					"Data Name", MezanixDiamondTexture2DNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Consume the data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeTexture2DType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeTexture2DType.getName:

				break;

			case ComputeTexture2DType.setName:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeTexture2DType.metallicSmoothnessAndOcclusionToTexture:
				DrawInNodeInfo (textureReadableInNode);
				DrawLogicNodeLabel ("The Second Texture (for occlusion)");
				DrawTexture2DFieldInput (1);

				if (texture2DValues [0] != null && 
					texture2DValues [1] != null)
				{
					if (texture2DValues [0].width != texture2DValues [1].width)
					{
						DrawLabelField (FieldDrawType.label, textureNoSameWidthInfo, Skins.logicNodeLabel);

						return;
					}
					else if (texture2DValues [0].height != texture2DValues [1].height)
					{
						DrawLabelField (FieldDrawType.label, textureNoSameHeightInfo, Skins.logicNodeLabel);

						return;
					}
				}

				break;

			case ComputeTexture2DType.metallicAndSmoothnesToTexture:
				DrawInNodeInfo (textureReadableInNode);
				DrawLogicNodeLabel ("The Second Texture (for smoothness)");
				DrawTexture2DFieldInput (1);

				if (texture2DValues [0] != null && 
					texture2DValues [1] != null)
				{
					if (texture2DValues [0].width != texture2DValues [1].width)
					{
						DrawLabelField (FieldDrawType.label, textureNoSameWidthInfo, Skins.logicNodeLabel);

						return;
					}
					else if (texture2DValues [0].height != texture2DValues [1].height)
					{
						DrawLabelField (FieldDrawType.label, textureNoSameHeightInfo, Skins.logicNodeLabel);

						return;
					}
				}

				break;

			case ComputeTexture2DType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_texture2D_DrawInputs ();
				break;

			case ComputeTexture2DType.writeTextureToFile:
				DrawMessageBoxUpLeftToPutAdvacedReadableTextures (new string []
					{
						"\n",
						" Texture Files, Write's Destination:\n",
						"Assets/TexturesCreatedByDiamond\n",
					});
				DrawPrepareTexture2DInputs (PrepareTexture2DForWhat.write);

				break;

			case ComputeTexture2DType.SwitchColors:
				DrawInputsFor_ComputeTexture2DType_SwitchColorsType ();
				break;

			case ComputeTexture2DType.setWrapMode:
				DrawTextureWrapModeEnum ();
				break;

			case ComputeTexture2DType.SetPixelAccordingToAChannelValue:
				DrawInNodeInfo (textureReadableInNode);
				DrawLabelField (FieldDrawType.label, "Texture To Get Pixel From", Skins.logicNodeLabel);
				DrawTexture2DFieldInput (1);

				if (texture2DValues [0] != null && texture2DValues [1] != null)
				{
					if (texture2DValues [0].width == texture2DValues [1].width)
					{
						if (texture2DValues [0].height == texture2DValues [1].height)
						{
							DrawInputsFor_ComputeTexture2DType_SetChannelFromAnother (
								"According To value in texture to change", 1);

							DrawLabelField (FieldDrawType.label, "With Tolerance of", Skins.logicNodeLabel);
							DrawIntInputField (2);
							intValues [2] = Mathf.Clamp (intValues [2], 18, 512);



							DrawInNodeInfo (dontOfenRunTimeInfo);

						}
						else
						{
							DrawLabelField (FieldDrawType.nodeName, textureNoSameHeightInfo, Skins.InNodeMessageInfo);

							return;
						}
					}
					else
					{
						DrawLabelField (FieldDrawType.nodeName, textureNoSameWidthInfo, Skins.InNodeMessageInfo);

						return;
					}
				}
				break;

			case ComputeTexture2DType.SetPixel:
				DrawInNodeInfo (textureReadableInNode);
				DrawInputsForSetPixel ();
				break;

			case ComputeTexture2DType.setMipMapBias:
				DrawFloatInputField (0);
				break;

			case ComputeTexture2DType.setFilterMode:
				DrawFilterModeEnum ();
				break;

			case ComputeTexture2DType.SetColorAccordingToAChannelValue:
				DrawInNodeInfo (textureReadableInNode);
				DrawLabelField (FieldDrawType.label, "Put This Color", Skins.logicNodeLabel);
				DrawColorInputField (0);

				DrawInputsFor_ComputeTexture2DType_SetChannelFromAnother ("According To This Channel value", 1);

				DrawLabelField (FieldDrawType.label, "With Tolerance of", Skins.logicNodeLabel);
				DrawIntInputField (2);
				intValues [2] = Mathf.Clamp (intValues [2], 18, 512);



				DrawInNodeInfo (dontOfenRunTimeInfo);
				break;

			case ComputeTexture2DType.SetChannelsToThisTexture:
				DrawInNodeInfo (textureReadableInNode);
				DrawInputsFor_ComputeTexture2DType_SetChannelsComingFromTexture ();

				if (texture2DValues [0] != null && 
					texture2DValues [1] != null)
				{
					if (texture2DValues [0].width != texture2DValues [1].width)
					{
						DrawLabelField (FieldDrawType.nodeName, "Textures widths aren't equal",
							Skins.InNodeMessageInfo);

						return;
					}
					else if (texture2DValues [0].height != texture2DValues [1].height)
					{
						DrawLabelField (FieldDrawType.nodeName, "Textures heights aren't equal",
							Skins.InNodeMessageInfo);

						return;
					}
				}


				break;

			case ComputeTexture2DType.SetChannels:
				DrawInNodeInfo (textureReadableInNode);
				DrawInputsFor_ComputeTexture2DType_SetChannels ();
				break;

			case ComputeTexture2DType.SetChannelAccordingToAnotherChannelValue:
				DrawInNodeInfo (textureReadableInNode);
				DrawInputsFor_ComputeTexture2DType_SetChannelFromAnother ("Put This Value", 0);

				DrawInputsFor_ComputeTexture2DType_SetChannelFromAnother ("According To This One", 1);

				DrawLabelField (FieldDrawType.label, "With Tolerance of", Skins.logicNodeLabel);
				DrawIntInputField (2);
				intValues [2] = Mathf.Clamp (intValues [2], 18, 512);

				DrawLabelField (FieldDrawType.label, "Keep other Channels?", Skins.logicNodeLabel);
				DrawBoolInputField (0);
				if ( ! boolValues [0])
				{
					if (channels [0] == TextureComputer.ComputeOn.red ||
						channels [0] == TextureComputer.ComputeOn.green ||
						channels [0] == TextureComputer.ComputeOn.blue)
					{
						DrawLabelField (FieldDrawType.label, "Keep Alpha?", Skins.logicNodeLabel);
						DrawBoolInputField (1);
					}
				}

				DrawInNodeInfo (dontOfenRunTimeInfo);
				break;

			case ComputeTexture2DType.setAnisoLevel:
				DrawIntInputField (0);
				break;

			case ComputeTexture2DType.MirrorAndRotate:
				DrawMirrorTexture2D_DirectionEnum ();
				break;

			case ComputeTexture2DType.getWidth:

				break;

			case ComputeTexture2DType.GetPixelBilinear:
				DrawInNodeInfo (textureReadableInNode);
				DrawLabelField (FieldDrawType.label, "At u, v", Skins.logicNodeLabel);
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeTexture2DType.GetPixel:
				DrawInNodeInfo (textureReadableInNode);
				DrawLabelField (FieldDrawType.label, "At x, y", Skins.logicNodeLabel);
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeTexture2DType.getMipMapCount:

				break;

			case ComputeTexture2DType.getMipMapBias:

				break;

			case ComputeTexture2DType.getHeight:

				break;

			case ComputeTexture2DType.getAnisoLevel:

				break;

			case ComputeTexture2DType.ExtractChannels:
				DrawInNodeInfo (textureReadableInNode);
				DrawInputsFor_ComputeTexture2DType_ExtractChannels ();
				break;

			case ComputeTexture2DType.ComputeNormalMap:
				DrawInputsFor_ComputeTexture2DType_ComputeNormalMap ();
				DrawInNodeInfo (textureReadableInNode);

				break;

			case ComputeTexture2DType.Compress:
				DrawInNodeInfo (textureReadableInNode);
				DrawLabelField (FieldDrawType.label, "Is highQuality Compression", Skins.logicNodeLabel);

				DrawBoolInputField (0);
				break;

			case ComputeTexture2DType.CaptureGameViewScreenshot:
				DrawInputsForCaptureGameViewScreenshot ();

				break;

			case ComputeTexture2DType.blendTwoTextures:
				DrawInNodeInfo (textureReadableInNode);
				DrawTexture2DFieldInput (1);

				if (texture2DValues [0] != null && 
					texture2DValues [1] != null)
				{
					if (texture2DValues [0].width != texture2DValues [1].width)
					{
						DrawLabelField (FieldDrawType.label, textureNoSameWidthInfo, Skins.logicNodeLabel);

						return;
					}
					else if (texture2DValues [0].height != texture2DValues [1].height)
					{
						DrawLabelField (FieldDrawType.label, textureNoSameHeightInfo, Skins.logicNodeLabel);

						return;
					}
				}
				DrawPrepareTexture2DInputs (PrepareTexture2DForWhat.blend);

				break;

			case ComputeTexture2DType.AuthorANewUniColorTexture:
				DrawLogicNodeLabel ("width, height", 0, 2);
				DrawVector2InputField (0, 1, 2);
				vector2Values [0] = Vector2.Max (new Vector2(8f, 8f), vector2Values [0]);
				DrawColorInputField (0);
				break;

			}
			if (computeTexture2DType == ComputeTexture2DType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeTexture2D ()
		{
			bool notDataTransfer = ! (computeTexture2DType == ComputeTexture2DType.sendMeAsTransferredData ||
				computeTexture2DType == ComputeTexture2DType.listenToTransferredData);
			if (notDataTransfer)
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			switch (computeTexture2DType)
			{
			case ComputeTexture2DType.applySetPixelChanges:
				if (texture2DValues [0] != null)
				{
					texture2DValues [0].Apply (boolValues [0], boolValues [1]);

					texture2DValue = texture2DValues [0];
				}
				break;

			case ComputeTexture2DType.listenToTransferredData:
				texture2DValue = MezanixDiamondGetTexture2D (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveTexture2D (stringValues [0]);
				}
				break;

			case ComputeTexture2DType.sendMeAsTransferredData:
				MezanixDiamondSetTexture2D (stringValues [0]);

				break;

			case ComputeTexture2DType.getName:
				if (texture2DValues [0] != null)
				{
					stringValue = texture2DValues [0].name;
				}
				break;

			case ComputeTexture2DType.setName:
				if (texture2DValues [0] != null)
				{
					texture2DValues [0].name = stringValues [0];

					texture2DValue = texture2DValues [0];
				}
				break;

			case ComputeTexture2DType.metallicSmoothnessAndOcclusionToTexture:
				Texture2D_0_1_metallicSmoothnessAndOcclusionToTexture ();
				break;

			case ComputeTexture2DType.metallicAndSmoothnesToTexture:
				Texture2D_0_1_metallicAndSmoothnesToTexture ();
				break;

			case ComputeTexture2DType.get:
				ForGet_texture2D_Compute ();
				break;

			case ComputeTexture2DType.writeTextureToFile:
				SetTexture2D_0_WriteFile ();
				break;

			case ComputeTexture2DType.SwitchColors:
				Texture2D_0_SwitchColors ();
				break;

			case ComputeTexture2DType.setWrapMode:
				if (texture2DValues [0] == null)
				{
					return;
				}

				texture2DValues [0].wrapMode = textureWrapMode;

				texture2DValue = texture2DValues [0];
				break;

			case ComputeTexture2DType.SetPixelAccordingToAChannelValue:
				Texture2D_0_SetPixelAccordingToAChannelValue ();
				break;

			case ComputeTexture2DType.SetPixel:
				SetTexture2D_0_SetPixel ();
				break;

			case ComputeTexture2DType.setMipMapBias:
				if (texture2DValues [0] == null)
				{
					return;
				}

				texture2DValues [0].mipMapBias = floatValues [0];

				texture2DValue = texture2DValues [0];
				break;

			case ComputeTexture2DType.setFilterMode:
				if (texture2DValues [0] == null)
				{
					return;
				}

				texture2DValues [0].filterMode = filterMode;

				texture2DValue = texture2DValues [0];
				break;

			case ComputeTexture2DType.SetColorAccordingToAChannelValue:
				Texture2D_0_SetColorAccordingToAChannelValue ();
				break;

			case ComputeTexture2DType.SetChannelsToThisTexture:
				Texture2D_0_SetChannelsComingFromTexture ();
				break;

			case ComputeTexture2DType.SetChannels:
				Texture2D_0_SetChannels ();
				break;

			case ComputeTexture2DType.SetChannelAccordingToAnotherChannelValue:
				Texture2D_0_SetChannelAccordingToAnotherChannelValue ();
				break;

			case ComputeTexture2DType.setAnisoLevel:
				if (texture2DValues [0] == null)
				{
					return;
				}

				texture2DValues [0].anisoLevel = intValues [0];

				texture2DValue = texture2DValues [0];
				break;

			case ComputeTexture2DType.MirrorAndRotate:
				Texture2D_0_Mirror ();
				break;

			case ComputeTexture2DType.getWidth:
				if (texture2DValues [0] == null)
				{
					return;
				}

				intValue = texture2DValues [0].width;
				break;

			case ComputeTexture2DType.GetPixelBilinear:
				GetTexture2D_0_PixelBilinear ();
				break;

			case ComputeTexture2DType.GetPixel:
				GetTexture2D_0_Pixel ();
				break;

			case ComputeTexture2DType.getMipMapCount:
				if (texture2DValues [0] == null)
				{
					return;
				}

				intValue = texture2DValues [0].mipmapCount;
				break;

			case ComputeTexture2DType.getMipMapBias:
				if (texture2DValues [0] == null)
				{
					return;
				}

				floatValue = texture2DValues [0].mipMapBias;
				break;

			case ComputeTexture2DType.getHeight:
				if (texture2DValues [0] == null)
				{
					return;
				}

				intValue = texture2DValues [0].height;
				break;

			case ComputeTexture2DType.getAnisoLevel:
				if (texture2DValues [0] == null)
				{
					return;
				}

				intValue = texture2DValues [0].anisoLevel;
				break;

			case ComputeTexture2DType.ExtractChannels:
				Texture2D_0_ExtractChannels ();
				break;

			case ComputeTexture2DType.ComputeNormalMap:
				Texture2D_0_ComputeNormalMap ();
				break;

			case ComputeTexture2DType.Compress:
				Texture2D_0_Compress ();
				break;

			case ComputeTexture2DType.CaptureGameViewScreenshot:
				Texture2D_CaptureGameViewScreenshot ();
				break;

			case ComputeTexture2DType.blendTwoTextures:
				Texture2D_0_1_Blend ();
				break;

			case ComputeTexture2DType.AuthorANewUniColorTexture:
				Texture2D_AuthorANewUniColorTexture ();
				break;

			}
		}
		void ComputeTexture2D_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeTexture2DType)
			{
			case ComputeTexture2DType.applySetPixelChanges:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Actually apply all previous SetPixel and SetPixels changes.",
					"If updateMipmaps is true, the mipmap levels are recalculated as well,",
					"using the base level as a source. Usually you want to use true in all cases",
					"except when you've modified the mip levels yourself using SetPixels.",
					"By default updateMipmaps is set to true. If makeNoLongerReadable is true,",
					"texture will be marked as no longer readable and memory will be freed after ",
					"uploading to GPU. By default makeNoLongerReadable is set to false.",
					"Apply is a potentially expensive operation, so you'll want to change ",
					"as many pixels as possible between Apply calls.",
					"Alternatively, if you don't need to access the pixels on the CPU,",
					"you could use Graphics.CopyTexture for fast GPU-side texture data copies.",
					"The texture has to have Is Readable flag set in the import settings.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture2D.Apply.html", 
					"");
				break;

			case ComputeTexture2DType.listenToTransferredData:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.getName:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The name of the object (texture2D).",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Object-name.html", 
					"");
				break;

			case ComputeTexture2DType.setName:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The name of the object (texture2D).",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Object-name.html", 
					"");
				break;

			case ComputeTexture2DType.metallicSmoothnessAndOcclusionToTexture:
				DrawLabelField (FieldDrawType.label, "Result Texture", Skins.logicNodeLabel);
				DrawTexture2DResultField (true);
				DrawTexture2DViwersForBlend ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Takes the red channel of the first texture and put it in",
					"the red channel (Metallic) of the result texture.",
					"Takes the alpha channel of the first texture and put it in",
					"the alpha channel (Smoothness) of the result texture.",
					"",
					"Takes the red channel of the second texture and put it in",
					"the green channel (Occlusion) of the result texture.",
					"for the second input texture (Occlusion map) use a rgb texture with equal values on all channels",
					"Like so, the red channel used bye the node represent the grayscale of your input textures",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.metallicAndSmoothnesToTexture:
				DrawLabelField (FieldDrawType.label, "Result Texture", Skins.logicNodeLabel);
				DrawTexture2DResultField (true);
				DrawTexture2DViwersForBlend ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Takes the red channel of the first texture and put it in",
					"the red channel (Metallic) of the result texture.",
					"",
					"Takes the red channel of the second texture and put it in",
					"the alpha channel (Smoothness) of the result texture.",
					"for the input textures use a rgb texture with equal values on all channels",
					"Like so, the red channel used bye the node represent the grayscale of your input textures",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.get:
				ForGet_texture2D_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.writeTextureToFile:
				DrawTexture2DResultField (true);
				DrawLogicNodeLabel ("Only in editor use for now");


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Write this texture to a .JPG or .PNG file.",
					"Like so it will be in your project assets (hard drive), so you can use it for this project",
					"or for an another project.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.SwitchColors:
				DrawTexture2DResultField (true);				DrawTexture2DViwersForTextureTransform ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Do a switch between two of the R, G and B channels",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.setWrapMode:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Wrap mode (Repeat or Clamp) of the texture.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture-wrapMode.html", 
					"");
				break;

			case ComputeTexture2DType.SetPixelAccordingToAChannelValue:
				DrawTexture2DResultField (true);				DrawTexture2DViwersForBlend ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Find pixels according to a search value on a channel.",
					"The search value can be by enlarged by the tolerance of search.",
					"Once a pixel is found, put in it the corresponding pixel that come from the second texture",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.SetPixel:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Sets pixel color at coordinates (x,y).",
					"This function works only on RGBA32, ARGB32, RGB24 and Alpha8 texture formats.",
					"For other formats SetPixel is ignored.",
					"The texture also has to have Read/Write Enabled flag set in the import settings.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture2D.SetPixel.html", 
					"");
				break;

			case ComputeTexture2DType.setMipMapBias:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Mip map bias of the texture.",
					"A positive bias makes a texture appear extra blurry, while a negative bias sharpens",
					"the texture. Note that using large negative bias can reduce performance,",
					"so it's not recommended to use more than -0.5 negative bias. In most cases better",
					"sharpening of the texture can be achieved by using anisotropic filtering.",
					"Also note that mip map bias does not work with MaterialPropertyBlocks, and some platforms,",
					"e.g., OpenGL ES based do not support it without custom shaders.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture-mipMapBias.html", 
					"");
				break;

			case ComputeTexture2DType.setFilterMode:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Filtering mode for textures. Corresponds to the settings in a texture inspector.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/FilterMode.html", 
					"");
				break;

			case ComputeTexture2DType.SetColorAccordingToAChannelValue:
				DrawTexture2DResultField (true);				DrawTexture2DViwersForTextureTransform ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Find pixels according to a search value on a channel.",
					"The search value can be by enlarged by the tolerance of search.",
					"Once a pixel is found, put in it the color you want.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.SetChannelsToThisTexture:
				DrawTexture2DResultField (true);				DrawTexture2DViwersForBlend ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"For all pixels,",
					"pick a channel from the second texture and put it in the first one",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.SetChannels:
				DrawTexture2DResultField (true);				DrawTexture2DViwersForTextureTransform ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"For All pixels, set a uniform value to the choosen channel ",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.SetChannelAccordingToAnotherChannelValue:
				DrawTexture2DResultField (true);
				DrawTexture2DViwersForTextureTransform ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Find pixels according to a search value on a channel.",
					"The search value can be by enlarged by the tolerance of search.",
					"Once a pixel is found, put in it a choosen value for a choosen channel.",
					"You can toggle to keep other channels or to down them to zero.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.setAnisoLevel:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Anisotropic filtering level of the texture.",
					"Anisotropic filtering makes textures look better when viewed at a shallow angle,",
					"but comes at a performance cost in the graphics hardware. Usually you use it on floor,",
					"ground or road textures to make them look better.",
					"The value range of this variable goes from 1 to 9, where 1 equals no filtering applied",
					"and 9 equals full filtering applied. As the value gets bigger, the texture is clearer at",
					"shallow angles. Lower values mean the texture will be more blurry at shallow angles.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture-anisoLevel.html", 
					"");
				break;

			case ComputeTexture2DType.MirrorAndRotate:
				DrawTexture2DResultField (true);				DrawTexture2DViwersForTextureTransform ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Do mirroring and rotation operations on the texture",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.getWidth:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Width of the texture in pixels.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture-width.html", 
					"");
				break;

			case ComputeTexture2DType.GetPixelBilinear:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns filtered pixel color at normalized coordinates (u, v).",
					"The texture must have the Read/Write Enabled flag set in the import settings,",
					"otherwise this function will fail. GetPixelBilinear is not available on Textures using",
					"Crunch texture compression.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture2D.GetPixelBilinear.html", 
					"");
				break;

			case ComputeTexture2DType.GetPixel:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns pixel color at coordinates (x, y).",
					"The texture must have the Read/Write Enabled flag set in the import settings,",
					"otherwise this function will fail. GetPixel is not available on Textures using",
					"Crunch texture compression.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture2D.GetPixel.html", 
					"");
				break;

			case ComputeTexture2DType.getMipMapCount:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"How many mipmap levels are in this texture (Read Only).",
					"The returned value includes the base level as well, so it is always 1 or more.",
					"Mipmap count is used if you use GetPixels or SetPixels to fetch or modify the different",
					"mip levels. For example, you could change a texture so that each mip level is tinted in a",
					"different color - then in the game you'd see which mip levels are actually visible.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture2D-mipmapCount.html", 
					"");
				break;

			case ComputeTexture2DType.getMipMapBias:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Mip map bias of the texture.",
					"A positive bias makes a texture appear extra blurry, while a negative bias sharpens",
					"the texture. Note that using large negative bias can reduce performance,",
					"so it's not recommended to use more than -0.5 negative bias. In most cases better",
					"sharpening of the texture can be achieved by using anisotropic filtering.",
					"Also note that mip map bias does not work with MaterialPropertyBlocks, and some platforms,",
					"e.g., OpenGL ES based do not support it without custom shaders.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture-mipMapBias.html", 
					"");
				break;

			case ComputeTexture2DType.getHeight:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Height of the texture in pixels.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture-height.html", 
					"");
				break;

			case ComputeTexture2DType.getAnisoLevel:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Anisotropic filtering level of the texture.",
					"Anisotropic filtering makes textures look better when viewed at a shallow angle,",
					"but comes at a performance cost in the graphics hardware. Usually you use it on floor,",
					"ground or road textures to make them look better.",
					"The value range of this variable goes from 1 to 9, where 1 equals no filtering applied",
					"and 9 equals full filtering applied. As the value gets bigger, the texture is clearer at",
					"shallow angles. Lower values mean the texture will be more blurry at shallow angles.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture-anisoLevel.html", 
					"");
				break;

			case ComputeTexture2DType.ExtractChannels:
				DrawTexture2DResultField (true);
				DrawTexture2DViwersForTextureTransform ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Extract the channel you want, as it or its intensity as a gray scale",
					"If you use grayscale, the resulting texture still a 4 channels texture",
					"with the same value at R, G and B",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.ComputeNormalMap:
				DrawTexture2DResultField (true);
				DrawTexture2DViwersForTextureTransform ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Compute a Normal map based on your texture.",
					"You can choose the channel on which you want to compute the normal.",
					"You can also choose the intensity of your normal",
					"The flip Y toggle helps to fit with OpenGL or DirectX API conventions",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.Compress:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Compress texture into DXT format.",
					"Use this to compress textures generated at runtime. Compressed textures use less graphics",
					"memory and are faster to render.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Texture2D.Compress.html", 
					"");
				break;

			case ComputeTexture2DType.CaptureGameViewScreenshot:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Captures a screenshot at path filename as a PNG file.",
					"If the image file exists already, it will be overwritten. The location where the image is",
					"written to can include a directory/folder list. For example on macOS the PNG file could be",
					"written to /tmp/ScreenGrab.png. With no directory/folder list the image will be written",
					"into the Project folder. CaptureScreenshot() can also be used from the Editor, for example",
					"in a custom EditorWindow. By default the screen grabbed image will also be written into the",
					"Project folder. Also, the Game view must be selected in order for the Editor screen capture",
					"to work.",
					"When superSize parameter is larger than 1, a larger resolution screenshot will be produced.",
					"For example, passing 4 will make the screenshot be 4x4 larger than it would normally be.",
					"This is useful to produce screenshots for printing.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Application.CaptureScreenshot.html", 
					"");
				break;

			case ComputeTexture2DType.blendTwoTextures:
				DrawLabelField (FieldDrawType.label, "SAVE", Skins.logicNodeLabel);
				WriteToTheDiscBlendedTextureButton (Texture2D_WriteFile_TextureValue);
				DrawLabelField (FieldDrawType.label, "Result Texture", Skins.logicNodeLabel);
				DrawTexture2DResultField (true);
				DrawTexture2DViwersForBlend ();


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Blend two texture2D with different blend modes.",
					"Like in image editor programs",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DType.AuthorANewUniColorTexture:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Create a new uni-color texture2D",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void Texture2D_0_1_Blend ()
		{
			if (texture2DValues [0] != null)
			{
				if (texture2DValues [1] != null)
				{
					Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
						TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

					Color [] colors_1;

					Color [] colors_0;

					Color [] colorsRes;



					colors_1 = texture2DValues [1].GetPixels ();

					colors_0 = texture2DValues [0].GetPixels ();

					colorsRes = colors_0;

					for (int i = 0; i < colorsRes.Length; i++)
					{
						colorValues [1] = colors_1 [i];

						colorValues [0] = colors_0 [i];

						ApplyComputeColorNoGUI ();

						colorsRes [i] = colorValue;
					}


					tex.SetPixels (colorsRes);

					tex.Apply ();

					texture2DValue = tex;

					tex = null;
				}
			}
		}
		void SetTexture2D_0_WriteFile ()
		{
			if (texture2DValues [0] != null)
			{
				intValues [0] = Mathf.Clamp (intValues [0], 0 , 100);

				string WritenFileTexturePath = TextureWriter.WriteTexture (
					texture2DValues [0], textureEncodeType, intValues [0], stringValues [0],
					writeTextureFormat, boolValues [0], boolValues [1],
					vector2Values [0], vector2Values [1], false);

				texture2DValue = (Texture2D)AssetDatabase.LoadAssetAtPath (WritenFileTexturePath, typeof (Texture2D));

			}
		}
		void Texture2D_WriteFile_TextureValue ()
		{
			string WritenFileTexturePath = Texture2D_WriteFile (texture2DValue);
			////Debug.Log (WritenFileTexturePath);
			texture2DValue = (Texture2D)AssetDatabase.LoadAssetAtPath (WritenFileTexturePath, typeof (Texture2D));
		}
		string Texture2D_WriteFile (Texture2D tex)
		{
			string r = "";

			if (tex != null)
			{
				intValues [0] = Mathf.Clamp (intValues [0], 0 , 100);

				string fileName = stringValues [0];


				r = TextureWriter.WriteTexture (tex, textureEncodeType, intValues [0],
					fileName,
					writeTextureFormat, boolValues [0], boolValues [1],
					Vector2.zero, new Vector2 ((float)tex.width, (float)tex.height), false);
			}

			return r;
		}
		void Texture2D_0_1_metallicSmoothnessAndOcclusionToTexture ()
		{
			if (texture2DValues [0] != null)
			{
				if (texture2DValues [1] != null)
				{
					Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

					Color [] colors_1 = texture2DValues [1].GetPixels ();

					Color [] colors_0 = texture2DValues [0].GetPixels ();

					Color [] colorsRes = new Color [colors_1.Length];


					for (int i = 0; i < colorsRes.Length; i++)
					{
						colorsRes [i] = new Color (colors_0 [i].r, colors_1 [i].r, 0f, colors_0 [i].a);
					}

					tex.SetPixels (colorsRes);

					tex.Apply ();

					texture2DValue = tex;

					texture2DValue.name = "Metallic_Smoothness_Occlusion";

					tex = null;
				}
			}
		}
		void Texture2D_0_1_metallicAndSmoothnesToTexture ()
		{
			if (texture2DValues [0] != null)
			{
				if (texture2DValues [1] != null)
				{
					Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

					Color [] colors_1 = texture2DValues [1].GetPixels ();

					Color [] colors_0 = texture2DValues [0].GetPixels ();

					Color [] colorsRes = new Color [colors_1.Length];


					for (int i = 0; i < colorsRes.Length; i++)
					{
						colorsRes [i] = new Color (colors_0 [i].r, 0f, 0f, colors_1 [i].r);
					}

					tex.SetPixels (colorsRes);

					tex.Apply ();

					texture2DValue = tex;

					texture2DValue.name = "Metallic_Smoothness";

					tex = null;
				}
			}
		}


		void ApplyComputeBool ()
		{
			ComputeBool_InputFields ();
			if (logic.playing)ComputeBool ();
			ComputeBool_OutputFields ();
		}

		public int loadSceneMode_length = 0;
		public string loadSceneMode_last;

		void ComputeBool_InputFields ()
		{
			computeBoolType = (ComputeBoolType)DrawEnumComputeType (computeBoolType, ref computeBoolType_length,
				ref computeBoolType_last, typeof (ComputeBoolType));

			switch (computeBoolType)
			{
			case ComputeBoolType.atStateStart:
				DrawLogicNodeLabel ("start pulses", 0, 2);
				DrawIntInputField (1, 1, 2);
				intValues [1] = Mathf.Max (intValues [1], 1);
				break;

			case ComputeBoolType.listenToTransferredData:
				DrawStringListMenuToString_0 (
					"Data Name", MezanixDiamondBoolNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawBoolInputField (1, 3, 4);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawDoItButton ();

				break;

			case ComputeBoolType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawInNodeInfo ("Play logic, name data, click doIT");
				DrawDoItButton ();

				break;

			case ComputeBoolType.invertPeriodically:
				DrawLogicNodeLabel ("Period", 0, 2);
				DrawFloatInputField (0, 1, 2);
				floatValues [0] = Mathf.Abs (floatValues [0]);
				break;

			case ComputeBoolType.invertAtPulse:
				DrawBoolInputField (0);
				break;

			case ComputeBoolType.listenToEvent:
				DrawStringListMenuToString_0 ("Event Name", MezanixDiamondEventNames (), noEventFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Consume event?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawDoItButton ();

				break;

			case ComputeBoolType.sendEvent:
				DrawLogicNodeLabel ("Event Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawInNodeInfo ("Play logic, name event, click doIT");
				DrawDoItButton ();

				break;

			case ComputeBoolType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (1, 3, 4);
				ForGet_bool_DrawInputs ();
				break;

			case ComputeBoolType.sendATruePulseWithDelay:
				DrawBoolInputField (0);
				DrawFloatInputField (0);
				floatValues [0] = Mathf.Max (0f, floatValues [0]);

				break;

			case ComputeBoolType.quitApplication:
				DrawBoolInputField (0);
				break;

			case ComputeBoolType.atGameStart:
				DrawLogicNodeLabel ("Start pulses?", 0, 2);
				DrawIntInputField (1, 1, 2);
				intValues [1] = Mathf.Max (intValues [1], 1);
				break;

			case ComputeBoolType.loadScene:
				DrawBoolInputField (0);
				DrawChooseSceneFromBuildScenes ();



				DrawLogicNodeLabel (stringValues [0]);

				DrawLogicNodeLabel ("Load mode", 0, 2);
				loadSceneMode = (UnityEngine.SceneManagement.LoadSceneMode)DrawEnum (					
					loadSceneMode,
					ref loadSceneMode_length, ref loadSceneMode_last, typeof(UnityEngine.SceneManagement.LoadSceneMode),
					FieldDrawType.label, 1, 2);
				//loadSceneMode = (UnityEngine.SceneManagement.LoadSceneMode)DrawEnum (loadSceneMode,
				//	"Load Scene Mode", Skins.logicNodeLabel);
				break;

			case ComputeBoolType.itIsNot:
				DrawBoolInputField (0);
				break;

			case ComputeBoolType.toString:
				DrawBoolInputField (0);
				break;

			case ComputeBoolType.toFloat:
				DrawBoolInputField (0);
				break;

			case ComputeBoolType.or:
				DrawBoolInputField (0);
				DrawBoolInputField (1);
				break;

			case ComputeBoolType.goToState:
				DrawGoToStateInputs ();
				break;

			case ComputeBoolType.and:
				DrawBoolInputField (0);
				DrawBoolInputField (1);
				break;

			}
		}
		void ComputeBool ()
		{
			switch (computeBoolType)
			{
			case ComputeBoolType.atStateStart:
				if (intValues [0] < intValues [1]+1)
				{
					intValues [0]++;
					boolValue = true;
				}

				if (intValues [0] >= intValues [1]+1)
				{
					boolValue = false;
				}

				break;

			case ComputeBoolType.listenToTransferredData:
				boolValue = MezanixDiamondGetBool (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveBool (stringValues [0]);
				}

				break;

			case ComputeBoolType.sendMeAsTransferredData:
				MezanixDiamondSetBool (stringValues [0]);

				break;

			case ComputeBoolType.invertPeriodically:
				floatValues [1] -= Time.deltaTime;

				if (floatValues [1] <= 0f)
				{
					floatValues [1] = floatValues [0];

					boolValue = ! boolValue;
				}

				break;

			case ComputeBoolType.invertAtPulse:
				if (boolValues [0])
				{
					boolValue = ! boolValue;

					boolValues [0] = false;
				}
				break;

			case ComputeBoolType.listenToEvent:
				boolValue = MezanixDiamondGetEvent (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveEvent (stringValues [0]);
				}

				break;

			case ComputeBoolType.sendEvent:
				MezanixDiamondSetEvent (stringValues [0]);

				break;

			case ComputeBoolType.get:
				ForGet_bool_Compute ();
				break;

			case ComputeBoolType.sendATruePulseWithDelay:
				boolValue = false;

				if (boolValues [0])
				{
					startCounting = true;
				}

				if (startCounting)
				{
					downCounterForBoolImpulse -= Time.deltaTime;

					if (downCounterForBoolImpulse < 0f)
					{
						downCounterForBoolImpulse = floatValues [0];

						boolValue = true;

						startCounting = false;
					}
				}


				break;

			case ComputeBoolType.quitApplication:
				if (boolValues [0])
					Application.Quit ();
				break;

			case ComputeBoolType.atGameStart:
				if (intValues [0] < intValues [1]+1)
				{
					intValues [0]++;
					boolValue = true;
				}

				if (intValues [0] >= intValues [1]+1)
				{
					boolValue = false;
				}

				break;

			case ComputeBoolType.loadScene:
				if (boolValues [0])
				{
					UnityEngine.SceneManagement.SceneManager.LoadScene (stringValues [0], loadSceneMode);
				}

				break;

			case ComputeBoolType.itIsNot:
				boolValue = !boolValues [0];
				break;

			case ComputeBoolType.toString:
				stringValue = boolValues [0].ToString ();
				break;

			case ComputeBoolType.toFloat:
				floatValue = boolValues [0]? 1f: 0f;
				break;

			case ComputeBoolType.or:
				boolValue = (boolValues [0] || boolValues [1]);
				break;

			case ComputeBoolType.goToState:
				GoToState ();
				break;

			case ComputeBoolType.and:
				boolValue = (boolValues [0] && boolValues [1]);
				break;

			}
		}
		void ComputeBool_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeBoolType)
			{
			case ComputeBoolType.atStateStart:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a number of true pulses at the game start and ",
					"after that, a false at every frame when playing.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.listenToTransferredData:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.invertPeriodically:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"the output bool is inverted periodically",
					"P.S. the editor time is faster than game time",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.invertAtPulse:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"If the input bool receive a true impulse,",
					"the output bool is inverted",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.listenToEvent:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to an event by its name.",
					"If you want to listen to this event at this moment",
					"and no need to listen to it later, it's recommended",
					"to consume it.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.sendEvent:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send an event by its name. The name can be used",
					"by another graph (script) to listen to this event.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.get:
				ForGet_bool_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.sendATruePulseWithDelay:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Wait for some delay and return one true pulseSometimes you need that to trigger an action delayed in time",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.quitApplication:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Quits the player application.",
					"Quit is ignored in the editor",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Application.Quit.html", 
					"");
				break;

			case ComputeBoolType.atGameStart:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a number of true pulses at the game start and ",
					"after that, a false at every frame when playing.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.loadScene:


				documentationMessage = 
					new string[]
				{
					"",
					"Load the scene of chosen scene name",
					"Choose also the loading mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.itIsNot:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Use it to inverse a bool",
					"If the checkbox is checked:",
					"Return false",
					"If not:",
					"Return true.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.toString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"If the checkbox is checked:",
					"Return the string (word or phrase) 'True'",
					"If not:",
					"Return the string (word or phrase) 'False'.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.toFloat:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"If the checkbox is checked:",
					"Return a float (decimal) equal 1.",
					"If not:",
					"Return a float (decimal) equal zero.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.or:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Return true",
					"if one of checkboxes",
					"are checked.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.goToState:


				documentationMessage = 
					new string[]
				{
					"",
					"When the checkboxe",
					"is checked:",
					"Go to The choosen state.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolType.and:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Return true only",
					"if both checkboxes",
					"are checked.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}



		//	Color c0 = colorValues [0];
		//
		//	//Color c1 = 
		//
		//	float o = floatValues [0];
		//
		//
		//	float o1 = floatValues [1];
		//
		//	Color cm1 = new Color (0f, 0f, 0f, 0f);
		//
		//	Color c1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);

		void ApplyComputeColor ()
		{
			ComputeColor_InputFields ();
			if (logic.playing) ComputeColor ();
			ComputeColor_OutputFields ();
		}
		void ComputeColor_InputFields ()
		{
			computeColorType = (ComputeColorType)DrawEnumComputeType (computeColorType, ref computeColorType_length,
				ref computeColorType_last, typeof (ComputeColorType));

			switch (computeColorType)
			{
			case ComputeColorType.listenToTransferredData:
				DrawStringListMenuToString_0 (
					"Data Name", MezanixDiamondColorNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawColorInputField (0, 1, 2);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeColorType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawColorInputField (0, 1, 2);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeColorType.toString:
				DrawColorInputField (0);
				break;

			case ComputeColorType.vividLight:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.Switch:
				DrawBoolInputField (0);
				DrawColorInputField (0);
				DrawBoolInputField (1);
				DrawColorInputField (1);
				break;

			case ComputeColorType.subtract:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.softLight:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.screen:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.saturation:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.randomHsv:
				DrawColorInputField (0, true, 1f);
				DrawColorInputField (1, true, 1f);
				break;

			case ComputeColorType.pinLight:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.overlay:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.multiply:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.luminosity:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.linearLight:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.linearDodge:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.linearBurn:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.lighten:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.hue:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.hardMix:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.hardLight:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_color_DrawInputs ();
				break;

			case ComputeColorType.exclusion:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.difference:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.darken:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.colorDodge:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.colorBurn:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.color:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			case ComputeColorType.animationCurvePickValue:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value", 0, 2);
				DrawColorInputField (0, 1, 2);				
				DrawLogicNodeLabel ("End value", 0, 2);
				DrawColorInputField (1, 1, 2);				
				DrawLogicNodeLabel ("Pick time", 0, 2);
				DrawFloatInputField (2, 1, 2);	
				floatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);

				break;

			case ComputeColorType.animationCurve:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value", 0, 2);
				DrawColorInputField (0, 1, 2);				 
				DrawLogicNodeLabel ("End value", 0, 2);
				DrawColorInputField (1, 1, 2);				
				DrawLogicNodeLabel ("Duration", 0, 2);
				DrawFloatInputField (2, 1, 2);				
				floatValues [2] = Mathf.Max (0.1f, floatValues [2]);

				break;

			case ComputeColorType.add:
				DrawColorInputField (0, false, 1f);
				DrawColorInputField (1, false, 1f);
				break;

			}
			if (computeColorType == ComputeColorType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeColor ()
		{
			if ( ! doIT)
			{
				return;
			}

			Color c0 = colorValues [0];
			
			//Color c1 = 
			
			float o = floatValues [0];
			
			
			float o1 = floatValues [1];
			
			Color cm1 = new Color (0f, 0f, 0f, 0f);
			
			Color c1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);

			switch (computeColorType)
			{
			case ComputeColorType.listenToTransferredData:
				colorValue = MezanixDiamondGetColor (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveColor (stringValues [0]);
				}

				break;

			case ComputeColorType.sendMeAsTransferredData:
				MezanixDiamondSetColor (stringValues [0]);

				break;

			case ComputeColorType.toString:
				stringValue = colorValues [0].ToString ();

				break;

			case ComputeColorType.vividLight:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.VividLight (c0, c1o), c1o, o);
				break;

			case ComputeColorType.Switch:
				if (boolValues [0] && ! boolValues [1])
				{
					colorValue = colorValues [0];
				}
				if (boolValues [1] && ! boolValues [0])
				{
					colorValue = colorValues [1];
				}
				break;

			case ComputeColorType.subtract:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Subtract (c0, c1o), c1o, o);
				break;

			case ComputeColorType.softLight:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.SoftLight (c0, c1o), c1o, o);
				break;

			case ComputeColorType.screen:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Screen (c0, c1o), c1o, o);
				break;

			case ComputeColorType.saturation:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Saturation (c0, c1o), c1o, o);
				break;

			case ComputeColorType.randomHsv:
				colorValue = UnityEngine.Random.ColorHSV (
					ColorsArithmetic.RGBToHSV (colorValues [0]) [0], ColorsArithmetic.RGBToHSV (colorValues [1]) [0],
					ColorsArithmetic.RGBToHSV (colorValues [0]) [1], ColorsArithmetic.RGBToHSV (colorValues [1]) [1],
					ColorsArithmetic.RGBToHSV (colorValues [0]) [2], ColorsArithmetic.RGBToHSV (colorValues [1]) [2]);
				break;

			case ComputeColorType.pinLight:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.PinLight (c0, c1o), c1o, o);
				break;

			case ComputeColorType.overlay:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Overlay (c0, c1o), c1o, o);
				break;

			case ComputeColorType.multiply:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Multiply (c0, c1o), c1o, o);
				break;

			case ComputeColorType.luminosity:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Luminosity (c0, c1o), c1o, o);
				break;

			case ComputeColorType.linearLight:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearLight (c0, c1o), c1o, o);
				break;

			case ComputeColorType.linearDodge:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearDodge (c0, c1o), c1o, o);
				break;

			case ComputeColorType.linearBurn:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearBurn (c0, c1o), c1o, o);
				break;

			case ComputeColorType.lighten:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Lighten (c0, c1o), c1o, o);
				break;

			case ComputeColorType.hue:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Hue (c0, c1o), c1o, o);
				break;

			case ComputeColorType.hardMix:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardMix (c0, c1o), c1o, o);
				break;

			case ComputeColorType.hardLight:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardLight (c0, c1o), c1o, o);
				break;

			case ComputeColorType.get:
				ForGet_color_Compute ();
				break;

			case ComputeColorType.exclusion:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Exclusion (c0, c1o), c1o, o);
				break;

			case ComputeColorType.difference:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Difference (c0, c1o), c1o, o);
				break;

			case ComputeColorType.darken:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Darken (c0, c1o), c1o, o);
				break;

			case ComputeColorType.colorDodge:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorDodge (c0, c1o), c1o, o);
				break;

			case ComputeColorType.colorBurn:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorBurn (c0, c1o), c1o, o);
				break;

			case ComputeColorType.color:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Color_ (c0, c1o), c1o, o);
				break;

			case ComputeColorType.animationCurvePickValue:
				colorValue = Color.Lerp (colorValues [0], colorValues [1], animationCurve_.Evaluate (floatValues [2]));
				break;

			case ComputeColorType.animationCurve:
				//forMeMezanix_2_Idle_F.forMeMezanix_2_Idle.forMeMezanix_2.StartCoroutine (RunAnimationCurve_color ());
				break;

			case ComputeColorType.add:
				PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Add (c0, c1o), c1o, o);
				break;

			}
		}
		void ComputeColor_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeColorType)
			{
			case ComputeColorType.listenToTransferredData:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.toString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Output the string expression of the color",
					"(r, g, b, a)",
					"color values in unity C# are normalized ",
					"between 0 and 1",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.vividLight:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The vividLight blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.Switch:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the value corresponding of the checked box,",
					"if noth boxes have the same value, the node will not compute",
					"and it will conserve it's old output",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.subtract:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The subtract blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.softLight:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The softLight blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.screen:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The screen blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.saturation:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The saturation blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.randomHsv:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Generates a random color from HSV and alpha ranges.",
					"The 2 input colors are used as min and max for the random",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.pinLight:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The pinLight blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.overlay:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The overlay blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.multiply:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The multiply blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.luminosity:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The Luminosity blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.linearLight:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The LinearLight blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.linearDodge:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The LinearDodge blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.linearBurn:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The LinearBurn blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.lighten:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The Lighten blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.hue:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The Hue blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.hardMix:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The HardMix blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.hardLight:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The HardLight blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.get:
				ForGet_color_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.exclusion:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The Exclusion blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.difference:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The Difference blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.darken:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The Darken blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.colorDodge:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The color dodge blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.colorBurn:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The color burn blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.color:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The 'Color' color blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.animationCurvePickValue:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Pick a color value on a curve,",
					"between the start and the end value.",
					"You have to choose the time corresponding to your value",
					"The time is the horizontal axis of the curve.",
					"The 'picked' color, the start and the end colors are on the",
					"vertical axis of the curve",
					"",
					"About the horizontal axis:",
					"This axis is commonly called time, but in the case of this node",
					"it is an axis having values from 0 to 1 (normalized),",
					"so this node is usful for drawing any curves shape and 'picking'",
					"a color value (vertical axis) on the curve corresponding of any",
					"position in the horizontal axis, 0 is the left of the horizontal axis,",
					"1 is its right and between them is a value on the axis.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.animationCurve:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Animate a color on a curve,",
					"between the start and the end value.",
					"You have to define the animation time (duration).",
					"The time is the horizontal axis of the curve.",
					"The animated color, the start and the end colors are on the",
					"vertical axis of the curve",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorType.add:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The Add color blend mode",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeColorNoGUI ()
		{
			Color c0 = colorValues [0];
		
			//Color c1 = 
		
			float o = floatValues [0];
		
		
			float o1 = floatValues [1];
		
			Color cm1 = new Color (0f, 0f, 0f, 0f);
		
			Color c1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);
		
		
			switch (colorBlendMode)
			{
			case ColorBlendMode.add:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Add (c0, c1o), c1o, o);
				break;
		
			case ColorBlendMode.color:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Color_ (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.colorBurn:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorBurn (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.colorDodge:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorDodge (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.darken:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Darken (c0, c1o), c1o, o);
		
				break;
		
		
		
		
			case ColorBlendMode.difference:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Difference (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.exclusion:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Exclusion (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.hardLight:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardLight (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.hardMix:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardMix (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.hue:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Hue (c0, c1o), c1o, o);
		
				break;
		
		
		
		
		
			case ColorBlendMode.lighten:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Lighten (c0, c1o), c1o, o);
				break;
		
			case ColorBlendMode.linearBurn:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearBurn (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.linearDodge:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearDodge (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.linearLight:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearLight (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.luminosity:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Luminosity (c0, c1o), c1o, o);
		
				break;
		
		
		
		
		
			case ColorBlendMode.multiply:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Multiply (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.overlay:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Overlay (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.pinLight:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.PinLight (c0, c1o), c1o, o);
		
				break;
		
			case ColorBlendMode.randomHsv:
				colorValue = UnityEngine.Random.ColorHSV (
					ColorsArithmetic.RGBToHSV (colorValues [0]) [0], ColorsArithmetic.RGBToHSV (colorValues [1]) [0],
					ColorsArithmetic.RGBToHSV (colorValues [0]) [1], ColorsArithmetic.RGBToHSV (colorValues [1]) [1],
					ColorsArithmetic.RGBToHSV (colorValues [0]) [2], ColorsArithmetic.RGBToHSV (colorValues [1]) [2]);
		
				break;
		
			case ColorBlendMode.saturation:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Saturation (c0, c1o), c1o, o);
		
				break;

			case ColorBlendMode.screen:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Screen (c0, c1o), c1o, o);
				break;
		
			case ColorBlendMode.softLight:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.SoftLight (c0, c1o), c1o, o);
				break;
		
			case ColorBlendMode.subtract:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Subtract (c0, c1o), c1o, o);
				break;
		
			case ColorBlendMode.vividLight:
				colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.VividLight (c0, c1o), c1o, o);
				break;
			}
		
		}
		//void ApplyComputeColor ()
		//{	
		//	DrawLogicNodeLabel ("Compute Type");
		//	computeColorType = (ComputeColorType)EditorGUI.EnumPopup (GetSuitableRect (FieldDrawType.variable, new Vector2 (fieldIDGlobal [0], fieldIDGlobal [1]++),
		//		new Vector2 (fieldsCountGlobal [0], fieldsCountGlobal [1]++)), 
		//		computeColorType);
		//
		//	Color c0 = colorValues [0];
		//
		//	//Color c1 = 
		//
		//	float o = floatValues [0];
		//
		//
		//	float o1 = floatValues [1];
		//
		//	Color cm1 = new Color (0f, 0f, 0f, 0f);
		//
		//	Color c1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);
		//
		//
		//	switch (computeColorType)
		//	{
		//	case ComputeColorType.add:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Add (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.color:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Color_ (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.colorBurn:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorBurn (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.colorDodge:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorDodge (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.darken:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Darken (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.difference:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Difference (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.exclusion:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Exclusion (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.get:
		//		DrawColorResultField ();
		//		break;
		//
		//	case ComputeColorType.hardLight:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardLight (c0, c1o), c1o, o);
		//
		//		break;
		//
		//	case ComputeColorType.hardMix:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardMix (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.hue:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Hue (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.lighten:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Lighten (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.linearBurn:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearBurn (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.linearDodge:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearDodge (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.linearLight:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearLight (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.luminosity:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Luminosity (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.multiply:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Multiply (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.overlay:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Overlay (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.pinLight:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.PinLight (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.randomHsv:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = UnityEngine.Random.ColorHSV (
		//			ColorsArithmetic.RGBToHSV (colorValues [0]) [0], ColorsArithmetic.RGBToHSV (colorValues [1]) [0],
		//			ColorsArithmetic.RGBToHSV (colorValues [0]) [1], ColorsArithmetic.RGBToHSV (colorValues [1]) [1],
		//			ColorsArithmetic.RGBToHSV (colorValues [0]) [2], ColorsArithmetic.RGBToHSV (colorValues [1]) [2]);
		//
		//		break;
		//
		//	case ComputeColorType.saturation:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Saturation (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.screen:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Screen (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.softLight:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.SoftLight (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.subtract:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Subtract (c0, c1o), c1o, o);
		//		break;
		//
		//	case ComputeColorType.animationCurve:
		//		DrawAnimationCurveInputField ();
		//		DrawLogicNodeLabel ("Curve start value");
		//		DrawColorInputField (0);
		//		DrawLogicNodeLabel ("Curve end value");
		//		DrawColorInputField (1);
		//		DrawLogicNodeLabel ("Curve animation time");
		//		DrawFloatInputField (2);
		//		DrawDoItButton();
		//		DrawInNodeInfo (workOnlyOnGeneratedScripts);
		//		break;
		//
		//	case ComputeColorType.Switch:
		//		DrawLogicNodeLabel ("Want this value?");
		//		DrawBoolInputField (0);
		//		DrawColorInputField (0);
		//		DrawLogicNodeLabel ("Or this one?");
		//		DrawBoolInputField (1);
		//		DrawColorInputField (1);
		//		if (boolValues [0] && ! boolValues [1])
		//		{
		//			colorValue = colorValues [0];
		//		}
		//		if (boolValues [1] && ! boolValues [0])
		//		{
		//			colorValue = colorValues [1];
		//		}
		//		break;
		//
		//	case ComputeColorType.vividLight:
		//		Draw2ColorFields ();
		//		PrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); 
		//		colorValue = ColorsArithmetic.Opacity (ColorsArithmetic.VividLight (c0, c1o), c1o, o);
		//		break;
		//
		//	}
		//
		//	//Color c0 = colorValues [0];
		//	//
		//	////Color c1 = 
		//	//
		//	//float o = floatValues [0];
		//	//
		//	//
		//	//float o1 = floatValues [1];
		//	//
		//	//Color cm1 = new Color (0f, 0f, 0f, 0f);
		//	//
		//	//Color c1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);
		//
		//
		//	if (computeColorType != ComputeColorType.get)
		//		DrawColorResultField ();
		//	//DrawResult ();
		//}

		void PrepareToColorCompute (ref Color c0,  ref float o, ref float o1, ref Color cm1, ref Color c1o)
		{
			c0 = colorValues [0];

			//Color c1 = 

			o = floatValues [0];


			o1 = floatValues [1];

			cm1 = new Color (0f, 0f, 0f, 0f);

			c1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);
		}


		void DebugRay (Vector2 start, Vector2 direction, float distance)
		{
			Vector3 startV3 = new Vector3 (start.x, start.y, 0f);

			Vector3 directionV3 = new Vector3 (direction.x, direction.y, 0f);

			Vector3 endV3 = startV3 + directionV3.normalized * distance;

			Debug.DrawLine (startV3, endV3, linkColor, Time.smoothDeltaTime);
		}
		void DebugRay (Vector3 start, Vector3 direction, float distance)
		{
			Vector3 end = start + direction.normalized * distance;

			Debug.DrawLine (start, end, linkColor, Time.smoothDeltaTime);
		}

		void ApplyComputeRay2D ()
		{
			ResetRayCasthit_2D_Infos ();

			ComputeRay2D_InputFields ();
			if (logic.playing)ComputeRay2D ();
			ComputeRay2D_OutputFields ();
		}
		void ComputeRay2D_InputFields ()
		{
			//bool linkedOrAttachedTo = IsGameObject_0_InputLinked () || IsGameObject_0_AttachedTo ();

			computeRay2DType = (ComputeRay2DType)DrawEnumComputeType (computeRay2DType, ref computeRay2DType_length,
				ref computeRay2DType_last, typeof (ComputeRay2DType));

			switch (computeRay2DType)
			{
			case ComputeRay2DType.Raycast:
				DrawLogicNodeLabel ("Origine", 0, 2);
				DrawVector2InputField (0, 1, 2);
				DrawLogicNodeLabel ("Direction", 0, 2);
				DrawVector2InputField (1, 1, 2);
				DrawLogicNodeLabel ("Distance", 0, 2);
				DrawFloatInputField (0, 1, 2);
				DrawLogicNodeLabel ("Layer Mask  (-1 for everything)");
				DrawIntInputField (0);
				intValues [0] = Mathf.Clamp (intValues [0], -1, 31);
				DrawLogicNodeLabel ("Min Depth", 0, 2);
				DrawFloatInputField (1, 1, 2);
				DrawLogicNodeLabel ("Max Depth", 0, 2);
				DrawFloatInputField (2, 1, 2);
				break;

			}
			DrawDoItButton();
		}
		void ComputeRay2D ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeRay2DType)
			{
			case ComputeRay2DType.Raycast:
				hit2D = Physics2D.Raycast (vector2Values [0], vector2Values [1],
					floatValues [0], intValues [0], floatValues [1], floatValues [2]);
				AssignRayCasthit_2D_Infos ();

				DebugRay (vector2Values [0], vector2Values [1], floatValues [0]);
				break;

			}
		}
		void ComputeRay2D_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeRay2DType)
			{
			case ComputeRay2DType.Raycast:
				DrawHit_2D_ResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Physics2D.Raycast.html", 
					"");
				break;

			}
		}


		void GoToState ()
		{
			string potentialStateToGoName = currentStateNames.ToString ();

			for (int i = 0; i < logic.node.graph.nodes.Count; i++)
			{
				if (logic.node.graph.nodes [i].nodeName == potentialStateToGoName)
				{
					logic.node.AddDestination (i);

					break;
				}
			}

			if (oldStateDestination.ToString () != potentialStateToGoName)
			{
				for (int i = 0; i < logic.node.graph.nodes.Count; i++)
				{
					if (logic.node.graph.nodes [i].nodeName == oldStateDestination.ToString ())
					{
						logic.node.RemoveDestination (i);

						break;
					}
				}
			}


			if (boolValues [0])
			{
				logic.node.stateToGoToNameValue = potentialStateToGoName;
			}
			else
			{
				logic.node.stateToGoToNameValue = "";
			}
		}


		void ApplyComputeTransform ()
		{
			ComputeTransform_InputFields ();
			if (logic.playing)ComputeTransform ();
			ComputeTransform_OutputFields ();
		}
		void ComputeTransform_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeTransformType = (ComputeTransformType)DrawEnumComputeType (computeTransformType, 
						ref computeTransformType_length, ref computeTransformType_last, 
						typeof (ComputeTransformType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				transform_ = gameObjectValues [0].GetComponent <Transform>();

				if (transform_ == null)
				{
					DrawInNodeInfo ("Add Transform To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						transform_ == null;

					return;
				}

			}

			computeTransformType = (ComputeTransformType)DrawEnumComputeType (computeTransformType, 
				ref computeTransformType_length, ref computeTransformType_last, 
				typeof (ComputeTransformType));

			switch (computeTransformType)
			{
			case ComputeTransformType.animationCurveLocalScale:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("End value");
				DrawVector3InputField (1);
				DrawLogicNodeLabel ("Duration", 0, 2);
				DrawFloatInputField (2, 1, 2);
				floatValues [2] = Mathf.Max (0.1f, floatValues [2]);

				break;

			case ComputeTransformType.animationCurveRotation:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value");
				DrawVector3InputField (0);				
				DrawLogicNodeLabel ("End value");
				DrawVector3InputField (1);				
				DrawLogicNodeLabel ("Duration", 0, 2);
				DrawFloatInputField (2, 1, 2);				
				floatValues [2] = Mathf.Max (0.1f, floatValues [2]);

				break;

			case ComputeTransformType.animationCurvePosition:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value");
				DrawVector3InputField (0);				
				DrawLogicNodeLabel ("End value");
				DrawVector3InputField (1);
				DrawLogicNodeLabel ("Duration", 0, 2);
				DrawFloatInputField (2, 1, 2);
				floatValues [2] = Mathf.Max (0.1f, floatValues [2]);

				break;

			case ComputeTransformType.keplerOrbit:
				DrawLogicNodeLabel ("Focus Point");
				DrawVector3InputField (0);				
				DrawLogicNodeLabel ("Orbit Normal");
				DrawVector3InputField (1);				
				DrawLogicNodeLabel ("Big Axis direction and Eccentricity value");
				DrawVector4InputField (0);				
				DrawLogicNodeLabel ("0.5 * Big Axis", 0, 2);
				DrawFloatInputField (0, 1, 2);				
				DrawLogicNodeLabel ("TriangleSpeed", 0, 2);
				DrawFloatInputField (1, 1, 2);
				break;

			case ComputeTransformType.parallaxScrollingEnhanced:
				DrawLogicNodeLabel ("Target", 0, 2);
				DrawGameObjectFieldInput (1, 1, 2);
				DrawLogicNodeLabel ("Distance", 0, 2);
				DrawFloatInputField (0, 1, 2);
				floatValues [0] = Mathf.Clamp (floatValues [0], 0f, 100f);
				DrawLogicNodeLabel ("Background's First Position");
				DrawVector3InputField (1);
				DrawLogicNodeLabel ("Target's First Position");
				DrawVector3InputField (0);
				DrawStringListMenuToString_0 ("Direction", new String [] {"x", "y", "z",}, 
					new String [] {"",}, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);

				break;

			case ComputeTransformType.parallaxScrolling:
				DrawLogicNodeLabel ("Scroll Speed", 0, 2);
				DrawFloatInputField (0, 1, 2);				
				DrawLogicNodeLabel ("Tile Size", 0, 2);
				DrawFloatInputField (1, 1, 2);
				floatValues [1] = MathM.NotZero (floatValues [1]);

				DrawLogicNodeLabel ("Start Position");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("Direction");
				DrawVector3InputField (1);
				break;

			case ComputeTransformType.SmoothDamp:
				DrawLogicNodeLabel ("Target Position");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("Smooth time", 0, 2);
				DrawFloatInputField (0, 1, 2);
				DrawLogicNodeLabel ("Max Speed", 0, 2);
				DrawFloatInputField (1, 1, 2);
				break;

			case ComputeTransformType.translate:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.TransformVector:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.TransformPoint:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.TransformDirection:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.setUp:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.SetSiblingIndex:
				DrawIntInputField (0);
				break;

			case ComputeTransformType.setRotationOnTransform:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.setRight:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.setPositionOnTransform:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.setLocalScaleOnTransform:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.setLocalRotationOnTransform:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.setLocalPositionOnTransform:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.setHasChanged:
				DrawBoolInputField (0);
				break;

			case ComputeTransformType.setForward:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.SetAsLastSibling:

				break;

			case ComputeTransformType.SetAsFirstSibling:

				break;

			case ComputeTransformType.RotateAround:
				DrawLogicNodeLabel ("Point");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("Axis");
				DrawVector3InputField (1);
				DrawLogicNodeLabel ("Angle", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case ComputeTransformType.rotate:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.makeMeChildOf:
				DrawGameObjectFieldInput (1);				if (gameObjectValues [1] == null)
				{
					DrawInNodeInfo ("Fill in GameObject field");

					return;
				}
				break;

			case ComputeTransformType.LookAt:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.InverseTransformVector:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.InverseTransformPoint:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.InverseTransformDirection:
				DrawVector3InputField (0);
				break;

			case ComputeTransformType.getParent:

				break;

			case ComputeTransformType.getWorldToLocalMatrix:

				break;

			case ComputeTransformType.getUp:

				break;

			case ComputeTransformType.GetSiblingIndex:

				break;

			case ComputeTransformType.getRotation:

				break;

			case ComputeTransformType.getRootParent:

				break;

			case ComputeTransformType.getRight:

				break;

			case ComputeTransformType.getPosition:

				break;

			case ComputeTransformType.getLocalToWorldMatrix:

				break;

			case ComputeTransformType.getLocalScale:

				break;

			case ComputeTransformType.getLocalRotation:

				break;

			case ComputeTransformType.getLocalPosition:

				break;

			case ComputeTransformType.getHasChanged:

				break;

			case ComputeTransformType.getForward:

				break;

			case ComputeTransformType.getChildCount:

				break;

			case ComputeTransformType.FindChildOfName:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeTransformType.FindChildOfIndex:
				DrawIntInputField (0);
				break;

			case ComputeTransformType.DetachChildren:

				break;

			case ComputeTransformType.AmIChildOf:
				DrawGameObjectFieldInput (1);				if (gameObjectValues [1] == null)
				{
					DrawInNodeInfo ("Fill in GameObject field");

					return;
				}
				break;

			}
			DrawDoItButton();
		}
		void ComputeTransform ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeTransformType)
			{
			case ComputeTransformType.animationCurveLocalScale:
				//forMeMezanix_5_Idle_G.forMeMezanix_5_Idle.forMeMezanix_5.StartCoroutine (RunAnimationCurve_transformRotation ());
				break;

			case ComputeTransformType.animationCurveRotation:
				//forMeMezanix_5_Idle_G.forMeMezanix_5_Idle.forMeMezanix_5.StartCoroutine (RunAnimationCurve_transformRotation ());
				break;

			case ComputeTransformType.animationCurvePosition:
				//forMeMezanix_5_Idle_G.forMeMezanix_5_Idle.forMeMezanix_5.StartCoroutine (RunAnimationCurve_transformPosition ());
				break;

			case ComputeTransformType.keplerOrbit:
				KeplerOrbit ();
				break;

			case ComputeTransformType.parallaxScrollingEnhanced:
				ParallaxScrollingEnhanced ();
				break;

			case ComputeTransformType.parallaxScrolling:
				ParallaxScrolling ();
				break;

			case ComputeTransformType.SmoothDamp:
				transform_.position = Vector3.SmoothDamp (transform_.position, vector3Values [0], ref vector3Value, floatValues [0], floatValues [1]);
				break;

			case ComputeTransformType.translate:
				transform_.Translate (vector3Values [0]);
				break;

			case ComputeTransformType.TransformVector:
				vector3Value = transform_.TransformVector (vector3Values [0]);
				break;

			case ComputeTransformType.TransformPoint:
				vector3Value = transform_.TransformPoint (vector3Values [0]);
				break;

			case ComputeTransformType.TransformDirection:
				vector3Value = transform_.TransformDirection (vector3Values [0]);
				break;

			case ComputeTransformType.setUp:
				transform_.up = vector3Values [0];
				break;

			case ComputeTransformType.SetSiblingIndex:
				transform_.SetSiblingIndex (intValues [0]);
				break;

			case ComputeTransformType.setRotationOnTransform:
				transform_.rotation = Quaternion.Euler (vector3Values [0]);
				break;

			case ComputeTransformType.setRight:
				transform_.right = vector3Values [0];
				break;

			case ComputeTransformType.setPositionOnTransform:
				transform_.position = vector3Values [0];
				break;

			case ComputeTransformType.setLocalScaleOnTransform:
				transform_.localScale = vector3Values [0];
				break;

			case ComputeTransformType.setLocalRotationOnTransform:
				transform_.localRotation = Quaternion.Euler (vector3Values [0]);
				break;

			case ComputeTransformType.setLocalPositionOnTransform:
				transform_.localPosition = vector3Values [0];
				break;

			case ComputeTransformType.setHasChanged:
				transform_.hasChanged = boolValues [0];
				break;

			case ComputeTransformType.setForward:
				transform_.forward = vector3Values [0];
				break;

			case ComputeTransformType.SetAsLastSibling:
				transform_.SetAsLastSibling ();
				break;

			case ComputeTransformType.SetAsFirstSibling:
				transform_.SetAsFirstSibling ();
				break;

			case ComputeTransformType.RotateAround:
				transform_.RotateAround (vector3Values [0], vector3Values [1], floatValues [0]);
				break;

			case ComputeTransformType.rotate:
				transform_.Rotate (vector3Values [0]);
				break;

			case ComputeTransformType.makeMeChildOf:
				if (gameObjectValues [1] != null)
				{
					transform_.parent = gameObjectValues [1].transform;
				}
				break;

			case ComputeTransformType.LookAt:
				transform_.LookAt (vector3Values [0]);
				break;

			case ComputeTransformType.InverseTransformVector:
				vector3Value = transform_.InverseTransformVector (vector3Values [0]);
				break;

			case ComputeTransformType.InverseTransformPoint:
				vector3Value = transform_.InverseTransformPoint (vector3Values [0]);
				break;

			case ComputeTransformType.InverseTransformDirection:
				vector3Value = transform_.InverseTransformDirection (vector3Values [0]);
				break;

			case ComputeTransformType.getParent:
				if (transform_.parent !=null)
				{
					gameObjectValue = transform_.parent.gameObject;
				}
				break;

			case ComputeTransformType.getWorldToLocalMatrix:
				m44Value_entier = transform_.worldToLocalMatrix;
				SetM44Value (m44Value_entier);
				break;

			case ComputeTransformType.getUp:
				vector3Value = transform_.up;
				break;

			case ComputeTransformType.GetSiblingIndex:
				intValue = transform_.GetSiblingIndex ();
				break;

			case ComputeTransformType.getRotation:
				vector3Value = transform_.rotation.eulerAngles;
				break;

			case ComputeTransformType.getRootParent:
				if (transform_.root != null)
				{
					gameObjectValue = transform_.root.gameObject;
				}
				break;

			case ComputeTransformType.getRight:
				vector3Value = transform_.right;
				break;

			case ComputeTransformType.getPosition:
				vector3Value = transform_.position;
				break;

			case ComputeTransformType.getLocalToWorldMatrix:
				m44Value_entier = transform_.localToWorldMatrix;
				SetM44Value (m44Value_entier);
				break;

			case ComputeTransformType.getLocalScale:
				vector3Value = transform_.localScale;
				break;

			case ComputeTransformType.getLocalRotation:
				vector3Value = transform_.localRotation.eulerAngles;
				break;

			case ComputeTransformType.getLocalPosition:
				vector3Value = transform_.localPosition;
				break;

			case ComputeTransformType.getHasChanged:
				boolValue = transform_.hasChanged;
				break;

			case ComputeTransformType.getForward:
				vector3Value = transform_.forward;
				break;

			case ComputeTransformType.getChildCount:
				intValue = transform_.childCount;
				break;

			case ComputeTransformType.FindChildOfName:
				if (transform_.Find (stringValues [0]) != null)
				{
					gameObjectValue = transform_.Find (stringValues [0]).gameObject;
				}
				break;

			case ComputeTransformType.FindChildOfIndex:
				if (transform_.childCount > 0)
				{
					intValues [0] = Mathf.Clamp (intValues [0], 0, transform_.childCount-1);

					if (transform_.GetChild (intValues [0]) != null)
					{
						gameObjectValue = transform_.GetChild (intValues [0]).gameObject;
					}
				}
				break;

			case ComputeTransformType.DetachChildren:
				transform_.DetachChildren ();
				break;

			case ComputeTransformType.AmIChildOf:
				if (gameObjectValues [1] != null)
				{
					if (transform_.parent == gameObjectValues [1].transform)
					{
						boolValue = true;
					}
					else
					{
						boolValue = false;
					}
				}
				break;

			}
		}
		void ComputeTransform_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeTransformType)
			{
			case ComputeTransformType.animationCurveLocalScale:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Animate a scale value on a curve,",
					"between the start and the end value.",
					"You have to define the animation time (duration).",
					"The time is the horizontal axis of the curve.",
					"The animated scale, the start and the end scales are on the",
					"vertical axis of the curve",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTransformType.animationCurveRotation:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Animate a rotation value on a curve,",
					"between the start and the end value.",
					"You have to define the animation time (duration).",
					"The time is the horizontal axis of the curve.",
					"The animated rotation, the start and the end rotations are on the",
					"vertical axis of the curve",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTransformType.animationCurvePosition:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Animate a position value on a curve,",
					"between the start and the end value.",
					"You have to define the animation time (duration).",
					"The time is the horizontal axis of the curve.",
					"The animated position, the start and the end positions are on the",
					"vertical axis of the curve",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTransformType.keplerOrbit:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Kepler Orbit",
					"",
					"About the 'Big Axis direction and Eccentricity value':",
					"x, y and, z are the big axis direction and w is the Eccentricity",
					"Eccentricity = 0 -> circle",
					"Eccentricity =>[0, 0.9] -> ellipse",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTransformType.parallaxScrollingEnhanced:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Parallax Scrolling is mostly used in 2D games.",
					"2D platformers and top down shooters usually.",
					"Parallax Scrolling move a background relative to the target (Player).",
					"It simulate the distance of the background.",
					"Far backgrounds follow the target, nearest ones don't.",
					"The distance is clamped between 0 and 100.",
					"0 for most nearest backgrounds that don't move.",
					"100 for most farest backgrounds that have the same movment of the target",
					"between 0 and 100 for backgrounds that move relativly to the target.",
					"greater is the distance, closer is the background's movment to the target's movment.",
					"",
					"Put your background in the first game object field.",
					"'Background's First Position' is the background first position, it's recommended that you fill it",
					"with the background initial position.",
					"Put your moving target (usually the player) in the second game object field.",
					"'Target's First Position' is the target first position, it's recommended that you fill it",
					"with the target initial position.",
					"",
					"'Scrolling Direction' is x, y or z, If another value is choosen,",
					"the default axe will be used i.e the x axe.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTransformType.parallaxScrolling:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Scroll the transform position in the direction, ",
					"you can define the scrolling speed and the tile size,the tile size is the repeating distance.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://unity3d.com/learn/tutorials/topics/2d-game-creation/2d-scrolling-backgrounds", 
					"");
				break;

			case ComputeTransformType.SmoothDamp:
				DrawLogicNodeLabel ("Current velocity", 0, 2);
				DrawVector3ResultField (true, 1, 2);

				documentationMessage = 
					new string[]
				{
					"",
					"Gradually changes a vector towards a desired goal over time.",
					"The vector is smoothed by some spring-damper like function,",
					"which will never overshoot. The most common use is for smoothing a follow camera.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Vector3.SmoothDamp.html", 
					"");
				break;

			case ComputeTransformType.translate:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Moves the transform in the direction and distance of translation.",
					"If relativeTo is left out or set to Space.Self the movement is applied relative",
					"to the transform's local axes.",
					"(the x, y and z axes shown when selecting the object inside the Scene View.)",
					"If relativeTo is Space.World the movement is applied relative to the world",
					"coordinate system.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.Translate.html", 
					"");
				break;

			case ComputeTransformType.TransformVector:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Transforms vector from local space to world space.",
					"This operation is not affected by position of the transform, but is is affected",
					"by scale. The returned vector may have a different length than vector.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.TransformVector.html", 
					"");
				break;

			case ComputeTransformType.TransformPoint:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Transforms position from local space to world space.",
					"Note that the returned position is affected by scale.",
					"Use Transform.TransformDirection if you are dealing with direction vectors.",
					"You can perform the opposite conversion, from world to local space using",
					"Transform.InverseTransformPoint.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.TransformPoint.html", 
					"");
				break;

			case ComputeTransformType.TransformDirection:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Transforms direction from local space to world space.",
					"This operation is not affected by scale or position of the transform.",
					"The returned vector has the same length as direction.",
					"You should use Transform.TransformPoint for the conversion if the vector represents",
					"a position rather than a directio",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html", 
					"");
				break;

			case ComputeTransformType.setUp:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The green axis of the transform in world space.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-up.html", 
					"");
				break;

			case ComputeTransformType.SetSiblingIndex:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Sets the sibling index.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.SetSiblingIndex.html", 
					"");
				break;

			case ComputeTransformType.setRotationOnTransform:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The rotation of the transform in world space stored as a Quaternion.",
					"Unity stores rotations as Quaternions internally. To rotate an object,",
					"use Transform.Rotate. Use Transform.eulerAngles for setting the rotation as",
					"euler angles.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-rotation.html", 
					"");
				break;

			case ComputeTransformType.setRight:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The red axis of the transform in world space.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-right.html", 
					"");
				break;

			case ComputeTransformType.setPositionOnTransform:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The position of the transform in world space.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-position.html", 
					"");
				break;

			case ComputeTransformType.setLocalScaleOnTransform:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The scale of the transform relative to the parent.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-localScale.html", 
					"");
				break;

			case ComputeTransformType.setLocalRotationOnTransform:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The rotation of the transform relative to the parent transform's rotation.",
					"Unity stores rotations as Quaternions internally.",
					"To rotate an object, use Transform.Rotate. Use Transform.localEulerAngles",
					"for modifying the rotation as euler angles.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-localRotation.html", 
					"");
				break;

			case ComputeTransformType.setLocalPositionOnTransform:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Position of the transform relative to the parent transform.",
					"If the transform has no parent, it is the same as Transform.position.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-localPosition.html", 
					"");
				break;

			case ComputeTransformType.setHasChanged:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Has the transform changed since the last time the flag was set to 'false'?",
					"A change to the transform can be anything that can cause its matrix to be",
					"recalculated: any adjustment to its position, rotation or scale. Note that",
					"operations which can change the transform will not actually check if the old",
					"and new value are different before setting this flag.",
					"So setting, for instance, transform.position will always set hasChanged on",
					"the transform, regardless of there being any actual change.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-hasChanged.html", 
					"");
				break;

			case ComputeTransformType.setForward:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The blue axis of the transform in world space.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-forward.html", 
					"");
				break;

			case ComputeTransformType.SetAsLastSibling:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Move the transform to the end of the local transform list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.SetAsLastSibling.html", 
					"");
				break;

			case ComputeTransformType.SetAsFirstSibling:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Move the transform to the start of the local transform list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.SetAsFirstSibling.html", 
					"");
				break;

			case ComputeTransformType.RotateAround:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Rotates the transform about axis passing through point in world coordinates by angle",
					"degrees.",
					"This modifies both the position and the rotation of the transform.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.RotateAround.html", 
					"");
				break;

			case ComputeTransformType.rotate:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Applies a rotation of eulerAngles.z degrees around the z axis,",
					"eulerAngles.x degrees around",
					"the x axis, and eulerAngles.y degrees around the y axis (in that order).",
					"If relativeTo is not specified or set to Space.Self the rotation is applied",
					"around the transform's local axes. If relativeTo is set to Space.World the",
					"rotation is applied around the world x, y, z axes.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.Rotate.html", 
					"");
				break;

			case ComputeTransformType.makeMeChildOf:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The parent of the transform.",
					"Changing the parent will modify the parent-relative position,",
					"scale and rotation but keep the world space position, rotation and scale the same.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-parent.html", 
					"");
				break;

			case ComputeTransformType.LookAt:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Rotates the transform so the forward vector points at /target/'s current position.",
					"Then it rotates the transform to point its up direction vector in the direction",
					"hinted at by the worldUp vector. If you leave out the worldUp parameter,",
					"the function will use the world y axis. worldUp is only a hint vector.",
					"The up vector of the rotation will only match the worldUp vector",
					"if the forward direction is perpendicular to worldUp.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.LookAt.html", 
					"");
				break;

			case ComputeTransformType.InverseTransformVector:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Transforms a vector from world space to local space.",
					"The opposite of Transform.TransformVector.",
					"This operation is affected by scale.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.InverseTransformVector.html", 
					"");
				break;

			case ComputeTransformType.InverseTransformPoint:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Transforms position from world space to local space.",
					"This function is essentially the opposite of Transform.TransformPoint,",
					"which is used to convert from local to world space.",
					"Note that the returned position is affected by scale.",
					"Use Transform.InverseTransformDirection if you are dealing with",
					"direction vectors rather than positions.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.InverseTransformPoint.html", 
					"");
				break;

			case ComputeTransformType.InverseTransformDirection:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Transforms a direction from world space to local space.",
					"The opposite of Transform.TransformDirection.",
					"This operation is unaffected by scale.",
					"You should use Transform.InverseTransformPoint if the vector represents a position",
					"in space rather than a direction.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.InverseTransformDirection.html", 
					"");
				break;

			case ComputeTransformType.getParent:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The parent of the transform.",
					"Changing the parent will modify the parent-relative position,",
					"scale and rotation but keep the world space position, rotation and scale the same.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-parent.html", 
					"");
				break;

			case ComputeTransformType.getWorldToLocalMatrix:
				DrawM44ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Matrix that transforms a point from world space into local space (Read Only).",
					"If you're not familiar with using matrices for coordinate transformations,",
					"use Transform.InverseTransformPoint instead.",
					"IMPORTANT: If you're setting shader parameters you MUST use",
					"Renderer.worldToLocalMatrix instead.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-worldToLocalMatrix.html", 
					"");
				break;

			case ComputeTransformType.getUp:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The green axis of the transform in world space.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-up.html", 
					"");
				break;

			case ComputeTransformType.GetSiblingIndex:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Gets the sibling index.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.GetSiblingIndex.html", 
					"");
				break;

			case ComputeTransformType.getRotation:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The rotation of the transform in world space stored as a Quaternion.",
					"Unity stores rotations as Quaternions internally. To rotate an object,",
					"use Transform.Rotate. Use Transform.eulerAngles for setting the rotation as",
					"euler angles.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-rotation.html", 
					"");
				break;

			case ComputeTransformType.getRootParent:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Returns the topmost transform in the hierarchy.",
					"(This never returns null, if this Transform doesn't have a parent it returns itself.)",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-root.html", 
					"");
				break;

			case ComputeTransformType.getRight:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The red axis of the transform in world space.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-right.html", 
					"");
				break;

			case ComputeTransformType.getPosition:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The position of the transform in world space.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-position.html", 
					"");
				break;

			case ComputeTransformType.getLocalToWorldMatrix:
				DrawM44ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Matrix that transforms a point from local space into world space (Read Only).",
					"If you're not familiar with using matrices for coordinate transformations,",
					"use Transform.TransformPoint instead.",
					"IMPORTANT: If you're setting shader",
					"parameters you MUST use Renderer.localToWorldMatrix instead.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-localToWorldMatrix.html", 
					"");
				break;

			case ComputeTransformType.getLocalScale:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The scale of the transform relative to the parent.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-localScale.html", 
					"");
				break;

			case ComputeTransformType.getLocalRotation:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The rotation of the transform relative to the parent transform's rotation.",
					"Unity stores rotations as Quaternions internally.",
					"To rotate an object, use Transform.Rotate. Use Transform.localEulerAngles",
					"for modifying the rotation as euler angles.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-localRotation.html", 
					"");
				break;

			case ComputeTransformType.getLocalPosition:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Position of the transform relative to the parent transform.",
					"If the transform has no parent, it is the same as Transform.position.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-localPosition.html", 
					"");
				break;

			case ComputeTransformType.getHasChanged:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Has the transform changed since the last time the flag was set to 'false'?",
					"A change to the transform can be anything that can cause its matrix to be",
					"recalculated: any adjustment to its position, rotation or scale. Note that",
					"operations which can change the transform will not actually check if the old",
					"and new value are different before setting this flag.",
					"So setting, for instance, transform.position will always set hasChanged on",
					"the transform, regardless of there being any actual change.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-hasChanged.html", 
					"");
				break;

			case ComputeTransformType.getForward:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The blue axis of the transform in world space.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-forward.html", 
					"");
				break;

			case ComputeTransformType.getChildCount:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The number of children the Transform has.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-childCount.html", 
					"");
				break;

			case ComputeTransformType.FindChildOfName:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Finds a child by name and returns it.",
					"If no child with name can be found, null is returned.",
					"If name contains a '/' character it will traverse the hierarchy like a path name.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.Find.html", 
					"");
				break;

			case ComputeTransformType.FindChildOfIndex:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Returns a transform child by index.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.GetChild.html", 
					"");
				break;

			case ComputeTransformType.DetachChildren:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Unparents all children.",
					"Useful if you want to destroy the root of a hierarchy without destroying",
					"the children.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform.DetachChildren.html", 
					"");
				break;

			case ComputeTransformType.AmIChildOf:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"The parent of the transform.",
					"Changing the parent will modify the parent-relative position,",
					"scale and rotation but keep the world space position, rotation and scale the same.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Transform-parent.html", 
					"");
				break;

			}
		}


		void ApplyComputeUiButton ()
		{
			ComputeUiButton_InputFields ();
			if (logic.playing)ComputeUiButton ();
			ComputeUiButton_OutputFields ();
		}
		void ComputeUiButton_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeUiButtonType = (ComputeUiButtonType)DrawEnumComputeType (computeUiButtonType,
						ref computeUiButtonType_length, ref computeUiButtonType_last, typeof(ComputeUiButtonType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				uiButton = gameObjectValues [0].GetComponent <UnityEngine.UI.Button>();

				if (uiButton == null)
				{
					DrawInNodeInfo ("Add UnityEngine.UI.Button To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						uiButton == null;

					return;
				}

			}
			computeUiButtonType = (ComputeUiButtonType)DrawEnumComputeType (computeUiButtonType,
				ref computeUiButtonType_length, ref computeUiButtonType_last, typeof(ComputeUiButtonType));

			switch (computeUiButtonType)
			{
			case ComputeUiButtonType.setEnabled:
				DrawBoolInputField (0);
				break;

			case ComputeUiButtonType.getIsActiveAndEnabled:

				break;

			case ComputeUiButtonType.getEnabled:

				break;

			case ComputeUiButtonType.onClick:
				DrawLogicNodeLabel ("Pulses number", 0, 2);
				DrawFloatInputField (0, 1, 2);
				floatValues [0] = Mathf.Max (0f, floatValues [0]);
				break;

			}
			DrawDoItButton();
		}
		void ComputeUiButton ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeUiButtonType)
			{
			case ComputeUiButtonType.setEnabled:
				uiButton.enabled = boolValues [0];
				break;

			case ComputeUiButtonType.getIsActiveAndEnabled:
				boolValue = uiButton.isActiveAndEnabled;
				break;

			case ComputeUiButtonType.getEnabled:
				boolValue = uiButton.enabled;
				break;

			case ComputeUiButtonType.onClick:
				uiButton.onClick.AddListener (TaskOnClick);

				if (boolValue)
				{
					downTimeCounterInt--;

					if (downTimeCounterInt < 0)
					{
						downTimeCounterInt = Mathf.CeilToInt (floatValues [0]);

						boolValue = false;
					}
				}

				break;

			}
		}
		void ComputeUiButton_OutputFields ()
		{
			
			string [] documentationMessage;

			switch (computeUiButtonType)
			{
			case ComputeUiButtonType.setEnabled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Enabled Behaviours are Updated, disabled Behaviours are not.",
					"This is shown as the small checkbox in the inspector of the behaviour.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUiButtonType.getIsActiveAndEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Has the Behaviour had enabled called.",
					"True while the behaviour is enabled, false when disabled.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-isActiveAndEnabled.html", 
					"");
				break;

			case ComputeUiButtonType.getEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Enabled Behaviours are Updated, disabled Behaviours are not.",
					"This is shown as the small checkbox in the inspector of the behaviour.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUiButtonType.onClick:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"UnityEvent that is triggered when the button is pressed.",
					"Note: Triggered on MouseUp after MouseDown on the same object.",
					"Every logicNode contains a function triggered when you click the button,",
					"this function put the bool output of your logicNode to true.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Button-onClick.html", 
					"");
				break;

			}
		}


		public int fillMethod_length = 0;
		public string fillMethod_last;

		void ApplyComputeUiImage ()
		{
			ComputeUiImage_InputFields ();
			if (logic.playing)ComputeUiImage ();
			ComputeUiImage_OutputFields ();
		}
		void ComputeUiImage_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeUiImageType = (ComputeUiImageType)DrawEnumComputeType (computeUiImageType,
						ref computeUiImageType_length, ref computeUiImageType_last, typeof(ComputeUiImageType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				uiImage = gameObjectValues [0].GetComponent <UnityEngine.UI.Image>();

				if (uiImage == null)
				{
					DrawInNodeInfo ("Add UnityEngine.UI.Image To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						uiImage == null;

					return;
				}

			}
			computeUiImageType = (ComputeUiImageType)DrawEnumComputeType (computeUiImageType,
				ref computeUiImageType_length, ref computeUiImageType_last, typeof(ComputeUiImageType));

			switch (computeUiImageType)
			{
			case ComputeUiImageType.setPreserveAspect:
				DrawBoolInputField (0);
				break;

			case ComputeUiImageType.SetNativeSize:

				break;

			case ComputeUiImageType.setMaterial:
				DrawMaterialFieldInput (0);
				break;

			case ComputeUiImageType.setFillMethod:
				fillMethod = (UnityEngine.UI.Image.FillMethod)DrawEnum (fillMethod,
					ref fillMethod_length, ref fillMethod_last, typeof(UnityEngine.UI.Image.FillMethod),
					"Fill Method", Skins.logicNodeLabel);
				break;

			case ComputeUiImageType.setFillClockwise:
				DrawBoolInputField (0);
				break;

			case ComputeUiImageType.setFillCenter:
				DrawBoolInputField (0);
				break;

			case ComputeUiImageType.setFillAmount:
				DrawFloatInputField (0);
				break;

			case ComputeUiImageType.setEnabled:
				DrawBoolInputField (0);
				break;

			case ComputeUiImageType.setColor:
				DrawColorInputField (0);
				break;

			case ComputeUiImageType.getSprite:
				DrawInNodeInfo ("Check true read/writeEnabled for the sprite");
				break;

			case ComputeUiImageType.getOverrideSprite:
				DrawInNodeInfo ("Check true read/writeEnabled for the sprite");
				break;

			case ComputeUiImageType.getPreserveAspect:

				break;

			case ComputeUiImageType.getPixelsPerUnit:

				break;

			case ComputeUiImageType.GetPixelAdjustedRect:

				break;

			case ComputeUiImageType.getMaterialForRendering:

				break;

			case ComputeUiImageType.getMaterial:

				break;

			case ComputeUiImageType.getMainTexture:

				break;

			case ComputeUiImageType.getHasBorder:

				break;

			case ComputeUiImageType.getFillClockwise:

				break;

			case ComputeUiImageType.getFillCenter:

				break;

			case ComputeUiImageType.getFillAmount:

				break;

			case ComputeUiImageType.getEnabled:
				
				break;

			case ComputeUiImageType.getDepth:

				break;

			case ComputeUiImageType.getDefaultMaterial:

				break;

			case ComputeUiImageType.getColor:

				break;

			}
			DrawDoItButton();
		}
		void ComputeUiImage ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeUiImageType)
			{
			case ComputeUiImageType.setPreserveAspect:
				uiImage.preserveAspect = boolValues [0];
				break;

			case ComputeUiImageType.SetNativeSize:
				uiImage.SetNativeSize ();
				break;

			case ComputeUiImageType.setMaterial:
				uiImage.material = materialValues [0];
				break;

			case ComputeUiImageType.setFillMethod:
				uiImage.fillMethod = fillMethod;
				break;

			case ComputeUiImageType.setFillClockwise:
				uiImage.fillClockwise = boolValues [0];
				break;

			case ComputeUiImageType.setFillCenter:
				uiImage.fillCenter = boolValues [0];
				break;

			case ComputeUiImageType.setFillAmount:
				uiImage.fillAmount = floatValues [0];
				break;

			case ComputeUiImageType.setEnabled:
				uiImage.enabled = boolValues [0];
				break;

			case ComputeUiImageType.setColor:
				uiImage.color = colorValues [0];
				break;

			case ComputeUiImageType.getSprite:
				texture2DValue = SpriteToTexture2D (uiImage.sprite);
				texture2DValue.name = uiImage.sprite.name;
				break;

			case ComputeUiImageType.getOverrideSprite:
				texture2DValue = SpriteToTexture2D (uiImage.overrideSprite);
				texture2DValue.name = uiImage.overrideSprite.name;
				break;

			case ComputeUiImageType.getPreserveAspect:
				boolValue = uiImage.preserveAspect;
				break;

			case ComputeUiImageType.getPixelsPerUnit:
				floatValue = uiImage.pixelsPerUnit;
				break;

			case ComputeUiImageType.GetPixelAdjustedRect:
				rectValue = uiImage.GetPixelAdjustedRect ();
				break;

			case ComputeUiImageType.getMaterialForRendering:
				materialValue = uiImage.materialForRendering;
				break;

			case ComputeUiImageType.getMaterial:
				materialValue = uiImage.material;
				break;

			case ComputeUiImageType.getMainTexture:
				texture2DValue = (Texture2D)uiImage.mainTexture;
				break;

			case ComputeUiImageType.getHasBorder:
				boolValue = uiImage.hasBorder;
				break;

			case ComputeUiImageType.getFillClockwise:
				boolValue = uiImage.fillClockwise;
				break;

			case ComputeUiImageType.getFillCenter:
				boolValue = uiImage.fillCenter;
				break;

			case ComputeUiImageType.getFillAmount:
				floatValue = uiImage.fillAmount;
				break;

			case ComputeUiImageType.getEnabled:
				boolValue = uiImage.enabled;
				break;

			case ComputeUiImageType.getDepth:
				intValue = uiImage.depth;
				break;

			case ComputeUiImageType.getDefaultMaterial:
				materialValue = uiImage.defaultMaterial;
				break;

			case ComputeUiImageType.getColor:
				colorValue = uiImage.color;
				break;

			}
		}
		void ComputeUiImage_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeUiImageType)
			{
			case ComputeUiImageType.setPreserveAspect:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-preserveAspect.html", 
					"");
				break;

			case ComputeUiImageType.SetNativeSize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image.SetNativeSize.html", 
					"");
				break;

			case ComputeUiImageType.setMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-material.html", 
					"");
				break;

			case ComputeUiImageType.setFillMethod:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillMethod.html", 
					"");
				break;

			case ComputeUiImageType.setFillClockwise:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillClockwise.html", 
					"");
				break;

			case ComputeUiImageType.setFillCenter:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillCenter.html", 
					"");
				break;

			case ComputeUiImageType.setFillAmount:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillAmount.html", 
					"");
				break;

			case ComputeUiImageType.setEnabled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUiImageType.setColor:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-color.html", 
					"");
				break;

			case ComputeUiImageType.getSprite:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-sprite.html", 
					"");
				break;

			case ComputeUiImageType.getOverrideSprite:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-sprite.html", 
					"");
				break;

			case ComputeUiImageType.getPreserveAspect:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-preserveAspect.html", 
					"");
				break;

			case ComputeUiImageType.getPixelsPerUnit:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Sprite-pixelsPerUnit.html", 
					"");
				break;

			case ComputeUiImageType.GetPixelAdjustedRect:
				DrawRectResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic.GetPixelAdjustedRect.html", 
					"");
				break;

			case ComputeUiImageType.getMaterialForRendering:
				DrawMaterialResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-materialForRendering.html", 
					"");
				break;

			case ComputeUiImageType.getMaterial:
				DrawMaterialResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-material.html", 
					"");
				break;

			case ComputeUiImageType.getMainTexture:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-mainTexture.html", 
					"");
				break;

			case ComputeUiImageType.getHasBorder:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-hasBorder.html", 
					"");
				break;

			case ComputeUiImageType.getFillClockwise:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillClockwise.html", 
					"");
				break;

			case ComputeUiImageType.getFillCenter:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillCenter.html", 
					"");
				break;

			case ComputeUiImageType.getFillAmount:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillAmount.html", 
					"");
				break;

			case ComputeUiImageType.getEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUiImageType.getDepth:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-depth.html", 
					"");
				break;

			case ComputeUiImageType.getDefaultMaterial:
				DrawMaterialResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-defaultMaterial.html", 
					"");
				break;

			case ComputeUiImageType.getColor:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-color.html", 
					"");
				break;

			}
		}

		public int textAnchor_length = 0;
		public string textAnchor_last;

		void ApplyComputeUnityText ()
		{
			ComputeUnityText_InputFields ();
			if (logic.playing)ComputeUnityText ();
			ComputeUnityText_OutputFields ();
		}
		void ComputeUnityText_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeUnityTextType = (ComputeUnityTextType)DrawEnumComputeType (computeUnityTextType,
						ref computeUnityTextType_length, ref computeUnityTextType_last,
						typeof (ComputeUnityTextType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				unityText = gameObjectValues [0].GetComponent <UnityEngine.UI.Text>();

				if (unityText == null)
				{
					DrawInNodeInfo ("Add UnityEngine.UI.Text To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						unityText == null;

					return;
				}

			}
			computeUnityTextType = (ComputeUnityTextType)DrawEnumComputeType (computeUnityTextType,
				ref computeUnityTextType_length, ref computeUnityTextType_last,
				typeof (ComputeUnityTextType));

			switch (computeUnityTextType)
			{
			case ComputeUnityTextType.setText:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeUnityTextType.setMaterial:
				DrawMaterialFieldInput (0);
				break;

			case ComputeUnityTextType.setLineSpacing:
				DrawFloatInputField (0);
				break;

			case ComputeUnityTextType.setFontSize:
				DrawIntInputField (0);
				break;

			case ComputeUnityTextType.setEnabled:
				DrawBoolInputField (0);
				break;

			case ComputeUnityTextType.setColor:
				DrawColorInputField (0);
				break;


			case ComputeUnityTextType.setAlignment:
				textAnchor = (TextAnchor)DrawEnum (textAnchor,
					ref textAnchor_length, ref textAnchor_last, typeof(TextAnchor),
					"Text Anchor", Skins.logicNodeLabel);
				break;

			case ComputeUnityTextType.getText:

				break;

			case ComputeUnityTextType.getPixelsPerUnit:

				break;

			case ComputeUnityTextType.GetPixelAdjustedRect:

				break;

			case ComputeUnityTextType.getMaterialForRendering:

				break;

			case ComputeUnityTextType.getMaterial:

				break;

			case ComputeUnityTextType.getMainTexture:

				break;

			case ComputeUnityTextType.getLineSpacing:

				break;

			case ComputeUnityTextType.getFontSize:

				break;

			case ComputeUnityTextType.getEnabled:

				break;

			case ComputeUnityTextType.getDepth:

				break;

			case ComputeUnityTextType.getColor:

				break;

			}
			DrawDoItButton();
		}
		void ComputeUnityText ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeUnityTextType)
			{
			case ComputeUnityTextType.setText:
				unityText.text = stringValues [0];
				break;

			case ComputeUnityTextType.setMaterial:
				unityText.material = materialValues [0];
				break;

			case ComputeUnityTextType.setLineSpacing:
				unityText.lineSpacing = floatValues [0];
				break;

			case ComputeUnityTextType.setFontSize:
				unityText.fontSize = intValues [0];
				break;

			case ComputeUnityTextType.setEnabled:
				unityText.enabled = boolValues [0];
				break;

			case ComputeUnityTextType.setColor:
				unityText.color = colorValues [0];
				break;

			case ComputeUnityTextType.setAlignment:
				unityText.alignment = textAnchor;
				break;

			case ComputeUnityTextType.getText:
				stringValue = unityText.text;
				break;

			case ComputeUnityTextType.getPixelsPerUnit:
				floatValue = unityText.pixelsPerUnit;
				break;

			case ComputeUnityTextType.GetPixelAdjustedRect:
				rectValue = unityText.GetPixelAdjustedRect ();
				break;

			case ComputeUnityTextType.getMaterialForRendering:
				materialValue = unityText.materialForRendering;
				break;

			case ComputeUnityTextType.getMaterial:
				materialValue = unityText.material;
				break;

			case ComputeUnityTextType.getMainTexture:
				texture2DValue = (Texture2D)unityText.mainTexture;
				break;

			case ComputeUnityTextType.getLineSpacing:
				floatValue = unityText.lineSpacing;
				break;

			case ComputeUnityTextType.getFontSize:
				intValue = unityText.fontSize;
				break;

			case ComputeUnityTextType.getEnabled:
				boolValue = unityText.enabled;
				break;

			case ComputeUnityTextType.getDepth:
				intValue = unityText.depth;
				break;

			case ComputeUnityTextType.getColor:
				colorValue = unityText.color;
				break;

			}
		}
		void ComputeUnityText_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeUnityTextType)
			{
			case ComputeUnityTextType.setText:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Text-text.html", 
					"");
				break;

			case ComputeUnityTextType.setMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-material.html", 
					"");
				break;

			case ComputeUnityTextType.setLineSpacing:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Text-lineSpacing.html", 
					"");
				break;

			case ComputeUnityTextType.setFontSize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Text-fontSize.html", 
					"");
				break;

			case ComputeUnityTextType.setEnabled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUnityTextType.setColor:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-color.html", 
					"");
				break;

			case ComputeUnityTextType.setAlignment:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Text-alignment.html", 
					"");
				break;

			case ComputeUnityTextType.getText:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Text-text.html", 
					"");
				break;

			case ComputeUnityTextType.getPixelsPerUnit:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Text-pixelsPerUnit.html", 
					"");
				break;

			case ComputeUnityTextType.GetPixelAdjustedRect:
				DrawRectResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic.GetPixelAdjustedRect.html", 
					"");
				break;

			case ComputeUnityTextType.getMaterialForRendering:
				DrawMaterialResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-materialForRendering.html", 
					"");
				break;

			case ComputeUnityTextType.getMaterial:
				DrawMaterialResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-material.html", 
					"");
				break;

			case ComputeUnityTextType.getMainTexture:
				DrawTexture2DResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Text-mainTexture.html", 
					"");
				break;

			case ComputeUnityTextType.getLineSpacing:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Text-lineSpacing.html", 
					"");
				break;

			case ComputeUnityTextType.getFontSize:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Text-fontSize.html", 
					"");
				break;

			case ComputeUnityTextType.getEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUnityTextType.getDepth:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-depth.html", 
					"");
				break;

			case ComputeUnityTextType.getColor:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-color.html", 
					"");
				break;

			}
		}

		void ApplyComputeRect ()
		{
			ComputeRect_InputFields ();
			if (logic.playing)ComputeRect ();
			ComputeRect_OutputFields ();
		}
		void ComputeRect_InputFields ()
		{
			computeRectType = (ComputeRectType)DrawEnumComputeType (computeRectType,
				ref computeRectType_length, ref computeRectType_last, typeof (ComputeRectType));

			switch (computeRectType)
			{
			case ComputeRectType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", MezanixDiamondRectNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawRectInputField (0, 1, 2);
				DrawLogicNodeLabel ("Consume the data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeRectType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawRectInputField (0, 1, 2);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeRectType.toString:
				DrawRectInputField (0);
				break;

			case ComputeRectType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_rect_DrawInputs ();
				break;

			case ComputeRectType.contains:
				DrawRectInputField (0);
				DrawLogicNodeLabel ("Is this point inside the rect?");
				DrawVector2InputField (0);
				break;

			}
			if (computeRectType == ComputeRectType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeRect ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeRectType)
			{
			case ComputeRectType.listenToTransferredData:
				rectValue = MezanixDiamondGetRect (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveRect (stringValues [0]);
				}
				break;

			case ComputeRectType.sendMeAsTransferredData:
				MezanixDiamondSetRect (stringValues [0]);

				break;

			case ComputeRectType.toString:
				stringValue = rectValues [0].ToString ();
				break;

			case ComputeRectType.get:
				ForGet_rect_Compute ();
				break;

			case ComputeRectType.contains:
				boolValue = rectValues [0].Contains (vector2Values [0]);
				break;

			}
		}
		void ComputeRect_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeRectType)
			{
			case ComputeRectType.listenToTransferredData:
				DrawRectResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeRectType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeRectType.toString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"To string",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeRectType.get:
				ForGet_rect_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeRectType.contains:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the x and y components of point is a point inside this rectangle.",
					"If allowInverse is present and true, the width and height of the Rect are allowed",
					"to take negative values (ie, the min value is greater than the max), and the test",
					"will still work.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rect.Contains.html", 
					"");
				break;

			}
		}


		void ApplyComputeVector4 ()
		{
			ComputeVector4_InputFields ();
			if (logic.playing)ComputeVector4 ();
			ComputeVector4_OutputFields ();
		}
		void ComputeVector4_InputFields ()
		{
			computeVector4Type = (ComputeVector4Type)DrawEnumComputeType (computeVector4Type,
				ref computeVector4Type_length, ref computeVector4Type_last, typeof (ComputeVector4Type));

			switch (computeVector4Type)
			{
			case ComputeVector4Type.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", MezanixDiamondVector4Names (), noTransferredDataFound,
				0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value");
				DrawVector4InputField (0);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeVector4Type.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer");
				DrawVector4InputField (0);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeVector4Type.animationCurvePickValue:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value");
				DrawVector4InputField (0);				DrawLogicNodeLabel ("End value");
				DrawVector4InputField (1);				
				DrawLogicNodeLabel ("Pick time", 0, 2);
				DrawFloatInputField (2, 1, 2);				
				floatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);

				break;

			case ComputeVector4Type.animationCurve:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value");
				DrawVector4InputField (0);				DrawLogicNodeLabel ("End value");
				DrawVector4InputField (1);			
				DrawLogicNodeLabel ("Duration", 0, 2);
				DrawFloatInputField (2, 1, 2);				
				floatValues [2] = Mathf.Max (0.1f, floatValues [2]);

				break;

			case ComputeVector4Type.Vector4ToColor:
				DrawVector4InputField (0);
				break;

			case ComputeVector4Type.vector3ToVector4:
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("To put in W", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case ComputeVector4Type.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_vector4_DrawInputs ();
				break;

			case ComputeVector4Type.toString:
				DrawVector4InputField (0);
				break;

			case ComputeVector4Type.Switch:
				DrawLogicNodeLabel ("Want this value?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawVector4InputField (0);
				DrawLogicNodeLabel ("Or this One?", 0, 2);
				DrawBoolInputField (1, 3, 4);
				DrawVector4InputField (1);
				break;

			case ComputeVector4Type.dot:
				DrawVector4InputField (0);
				DrawVector4InputField (1);
				break;

			case ComputeVector4Type.Add:
				DrawVector4InputField (0);
				DrawVector4InputField (1);
				break;

			case ComputeVector4Type.subtract:
				DrawVector4InputField (0);
				DrawVector4InputField (1);
				break;

			}
			if (computeVector4Type == ComputeVector4Type.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeVector4 ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeVector4Type)
			{
			case ComputeVector4Type.listenToTransferredData:
				vector4Value = MezanixDiamondGetVector4 (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveVector4 (stringValues [0]);
				}
				break;

			case ComputeVector4Type.sendMeAsTransferredData:
				MezanixDiamondSetVector4 (stringValues [0]);

				break;

			case ComputeVector4Type.animationCurvePickValue:
				vector4Value = Vector4.Lerp (vector4Values [0], vector4Values [1], animationCurve_.Evaluate (floatValues [2]));
				break;

			case ComputeVector4Type.animationCurve:
				//forMeMezanix_3_Idle_Ht.forMeMezanix_3_Idle.forMeMezanix_3.StartCoroutine (RunAnimationCurve_vector4 ());
				break;

			case ComputeVector4Type.Vector4ToColor:
				colorValue = new Color (Mathf.Clamp (vector4Values [0].x, 0f, 1f), Mathf.Clamp (vector4Values [0].y, 0f, 1f), Mathf.Clamp (vector4Values [0].z, 0f, 1f), Mathf.Clamp (vector4Values [0].w, 0f, 1f));
				break;

			case ComputeVector4Type.vector3ToVector4:
				vector4Value = new Vector4 (vector3Values [0].x, vector3Values [0].y, vector3Values [0].z, floatValues [0]);
				break;

			case ComputeVector4Type.get:
				ForGet_vector4_Compute ();
				break;

			case ComputeVector4Type.toString:
				stringValue = vector4Values [0].ToString ();
				break;

			case ComputeVector4Type.Switch:
				if (boolValues [0] && ! boolValues [1])
				{
					vector4Value = vector4Values [0];
				}
				if (boolValues [1] && ! boolValues [0])
				{
					vector4Value = vector4Values [1];
				}

				break;

			case ComputeVector4Type.dot:
				floatValue = Vector4.Dot (vector4Values [0], vector4Values [1]);
				break;

			case ComputeVector4Type.Add:
				vector4Value = vector4Values [0] + vector4Values [1];
				break;

			case ComputeVector4Type.subtract:
				vector4Value = vector4Values [0] - vector4Values [1];
				break;

			}
		}
		void ComputeVector4_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeVector4Type)
			{
			case ComputeVector4Type.listenToTransferredData:
				DrawVector4ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.animationCurvePickValue:
				DrawVector4ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Pick a vector value on a curve,",
					"between the start and the end value.",
					"You have to choose the time corresponding to your value",
					"The time is the horizontal axis of the curve.",
					"The picked vector, the start and the end vectors are on the",
					"vertical axis of the curve",
					"",
					"About the horizontal axis:",
					"This axis is commonly called time, but in the case of this node",
					"it is an axis having values from 0 to 1 (normalized),",
					"so this node is usful for drawing any curves shape and picking",
					"a vector value (vertical axis) on the curve corresponding of any",
					"position in the horizontal axis, 0 is the left of the horizontal axis,",
					"1 is its right and between them is a value on the axis.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.animationCurve:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawVector4ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Animate a vector value on a curve,",
					"between the start and the end value.",
					"You have to define the animation time (duration).",
					"The time is the horizontal axis of the curve.",
					"The animated vector, the start and the end vectors are on the",
					"vertical axis of the curve",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.Vector4ToColor:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Vector4 to Color. x to R",
					"y to G",
					"z to B",
					"w to A",
					"Vector4 values are clamped between 0f and 1f",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.vector3ToVector4:
				DrawVector4ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Compose a Vector4, put the input Vector3 in X, Y and Z, and the float in W",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.get:
				ForGet_vector4_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.toString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get a string (text) format of the value",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.Switch:
				DrawVector4ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the value corresponding of the checked box,",
					"if noth boxes have the same value, the node will not compute",
					"and it will conserve it's old output",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.dot:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Dot Product of two vectors.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Vector4.Dot.html", 
					"");
				break;

			case ComputeVector4Type.Add:
				DrawVector4ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Add two vector4",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4Type.subtract:
				DrawVector4ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Subtract two vector4",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeVector3 ()
		{
			ComputeVector3_InputFields ();
			if (logic.playing)ComputeVector3 ();
			ComputeVector3_OutputFields ();
		}
		void ComputeVector3_InputFields ()
		{
			computeVector3Type = (ComputeVector3Type)DrawEnumComputeType (computeVector3Type,
				ref computeVector3Type_length, ref computeVector3Type_last , typeof (ComputeVector3Type));

			switch (computeVector3Type)
			{
			case ComputeVector3Type.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", MezanixDiamondVector3Names (), noTransferredDataFound, 
				0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeVector3Type.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer");
				DrawVector3InputField (0);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeVector3Type.animationCurvePickValue:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("End value");
				DrawVector3InputField (1);
				DrawLogicNodeLabel ("Pick time", 0, 2);
				DrawFloatInputField (2, 1, 2);
				floatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);

				break;

			case ComputeVector3Type.animationCurve:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("End value");
				DrawVector3InputField (1);
				DrawLogicNodeLabel ("Duration", 0, 2);
				DrawFloatInputField (2, 1, 2);
				floatValues [2] = Mathf.Max (0.1f, floatValues [2]);

				break;

			case ComputeVector3Type.max:
				DrawVector3InputField (0);
				DrawVector3InputField (1);
				break;

			case ComputeVector3Type.min:
				DrawVector3InputField (0);
				DrawVector3InputField (1);
				break;

			case ComputeVector3Type.normalize:
				DrawVector3InputField (0);
				break;

			case ComputeVector3Type.ClampMagnitude:
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("Max Length", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case ComputeVector3Type.magnitude:
				DrawVector3InputField (0);
				break;

			case ComputeVector3Type.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_vector3_DrawInputs ();
				break;

			case ComputeVector3Type.toString:
				DrawVector3InputField (0);
				break;

			case ComputeVector3Type.Switch:
				DrawLogicNodeLabel ("Want this value?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("Or this One?", 0, 2);
				DrawBoolInputField (1, 3, 4);
				DrawVector3InputField (1);
				break;

			case ComputeVector3Type.toVector2:
				DrawVector3InputField (0);
				break;

			case ComputeVector3Type.subtract:
				DrawVector3InputField (0);
				DrawVector3InputField (1);
				break;

			case ComputeVector3Type.randomRotationUniform:

				break;

			case ComputeVector3Type.randomRotation:

				break;

			case ComputeVector3Type.putThisFloatInZ:
				DrawVector3InputField (0);
				DrawFloatInputField (0);
				break;

			case ComputeVector3Type.putThisFloatInYZ:
				DrawVector3InputField (0);
				DrawFloatInputField (0);
				break;

			case ComputeVector3Type.putThisFloatInY:
				DrawVector3InputField (0);
				DrawFloatInputField (0);
				break;

			case ComputeVector3Type.putThisFloatInXZ:
				DrawVector3InputField (0);
				DrawFloatInputField (0);
				break;

			case ComputeVector3Type.putThisFloatInXYZ:
				DrawVector3InputField (0);
				DrawFloatInputField (0);
				break;

			case ComputeVector3Type.putThisFloatInXY:
				DrawVector3InputField (0);
				DrawFloatInputField (0);
				break;

			case ComputeVector3Type.putThisFloatInX:
				DrawVector3InputField (0);
				DrawFloatInputField (0);
				break;

			case ComputeVector3Type.onUnitSphere:

				break;

			case ComputeVector3Type.multiply:
				DrawVector3InputField (0);
				DrawFloatInputField (0);
				break;

			case ComputeVector3Type.insideUnitSphere:

				break;

			case ComputeVector3Type.getFloatFromZ:
				DrawVector3InputField (0);
				break;

			case ComputeVector3Type.getFloatFromY:
				DrawVector3InputField (0);
				break;

			case ComputeVector3Type.getFloatFromX:
				DrawVector3InputField (0);
				break;

			case ComputeVector3Type.dot:
				DrawVector3InputField (0);
				DrawVector3InputField (1);
				break;

			case ComputeVector3Type.cross:
				DrawVector3InputField (0);
				DrawVector3InputField (1);
				break;

			case ComputeVector3Type.areParallel:
				DrawVector3InputField (0);
				DrawVector3InputField (1);
				break;

			case ComputeVector3Type.areOrthogonal:
				DrawVector3InputField (0);
				DrawVector3InputField (1);
				break;

			case ComputeVector3Type.areEqual:
				DrawVector3InputField (0);
				DrawVector3InputField (1);
				break;

			case ComputeVector3Type.Add:
				DrawVector3InputField (0);
				DrawVector3InputField (1);
				break;

			}
			if (computeVector3Type == ComputeVector3Type.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeVector3 ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeVector3Type)
			{
			case ComputeVector3Type.listenToTransferredData:
				vector3Value = MezanixDiamondGetVector3 (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveVector3 (stringValues [0]);
				}
				break;

			case ComputeVector3Type.sendMeAsTransferredData:
				MezanixDiamondSetVector3 (stringValues [0]);

				break;

			case ComputeVector3Type.animationCurvePickValue:
				vector3Value = Vector3.Lerp (vector3Values [0], vector3Values [1], animationCurve_.Evaluate (floatValues [2]));
				break;

			case ComputeVector3Type.animationCurve:
				//forMeMezanix_3_Idle_Ht.forMeMezanix_3_Idle.forMeMezanix_3.StartCoroutine (RunAnimationCurve_vector3 ());
				break;

			case ComputeVector3Type.max:
				vector3Value = new Vector3 (
					Mathf.Max (vector3Values [0].x, vector3Values [1].x),
					Mathf.Max (vector3Values [0].y, vector3Values [1].y),
					Mathf.Max (vector3Values [0].z, vector3Values [1].z));
				break;

			case ComputeVector3Type.min:
				vector3Value = new Vector3 (
					Mathf.Min (vector3Values [0].x, vector3Values [1].x),
					Mathf.Min (vector3Values [0].y, vector3Values [1].y),
					Mathf.Min (vector3Values [0].z, vector3Values [1].z));
				break;

			case ComputeVector3Type.normalize:
				vector3Value = vector3Values [0].normalized;
				break;

			case ComputeVector3Type.ClampMagnitude:
				vector3Value = Vector3.ClampMagnitude (vector3Values [0], floatValues [0]);
				break;

			case ComputeVector3Type.magnitude:
				floatValue = vector3Values [0].magnitude;
				break;

			case ComputeVector3Type.get:
				ForGet_vector3_Compute ();
				break;

			case ComputeVector3Type.toString:
				stringValue = vector3Values [0].ToString ();
				break;

			case ComputeVector3Type.Switch:
				if (boolValues [0] && ! boolValues [1])
				{
					vector3Value = vector3Values [0];
				}
				if (boolValues [1] && ! boolValues [0])
				{
					vector3Value = vector3Values [1];
				}

				break;

			case ComputeVector3Type.toVector2:
				vector2Value = new Vector2 (vector3Values [0].x, vector3Values [0].y);
				break;

			case ComputeVector3Type.subtract:
				vector3Value = vector3Values [0] - vector3Values [1];
				break;

			case ComputeVector3Type.randomRotationUniform:
				vector3Value = UnityEngine.Random.rotationUniform.eulerAngles;
				break;

			case ComputeVector3Type.randomRotation:
				vector3Value = UnityEngine.Random.rotation.eulerAngles;
				break;

			case ComputeVector3Type.putThisFloatInZ:
				vector3Value = new Vector3 (vector3Values [0].x, vector3Values [0].y, floatValues [0]);
				break;

			case ComputeVector3Type.putThisFloatInYZ:
				vector3Value = new Vector3 (vector3Values [0].x, floatValues [0], floatValues [0]);
				break;

			case ComputeVector3Type.putThisFloatInY:
				vector3Value = new Vector3 (vector3Values [0].x, floatValues [0], vector3Values [0].z);
				break;

			case ComputeVector3Type.putThisFloatInXZ:
				vector3Value = new Vector3 (floatValues [0], vector3Values [0].y, floatValues [0]);
				break;

			case ComputeVector3Type.putThisFloatInXYZ:
				vector3Value = new Vector3 (floatValues [0], floatValues [0], floatValues [0]);
				break;

			case ComputeVector3Type.putThisFloatInXY:
				vector3Value = new Vector3 (floatValues [0], floatValues [0], vector3Values [0].z);
				break;

			case ComputeVector3Type.putThisFloatInX:
				vector3Value = new Vector3 (floatValues [0], vector3Values [0].y, vector3Values [0].z);
				break;

			case ComputeVector3Type.onUnitSphere:
				vector3Value = UnityEngine.Random.onUnitSphere;
				break;

			case ComputeVector3Type.multiply:
				vector3Value = vector3Values [0] * floatValues [0];
				break;

			case ComputeVector3Type.insideUnitSphere:
				vector3Value = UnityEngine.Random.insideUnitSphere;
				break;

			case ComputeVector3Type.getFloatFromZ:
				floatValue = vector3Values [0].z;
				break;

			case ComputeVector3Type.getFloatFromY:
				floatValue = vector3Values [0].y;
				break;

			case ComputeVector3Type.getFloatFromX:
				floatValue = vector3Values [0].x;
				break;

			case ComputeVector3Type.dot:
				floatValue = Vector3.Dot (vector3Values [0], vector3Values [1]);
				break;

			case ComputeVector3Type.cross:
				vector3Value = Vector3.Cross (vector3Values [0], vector3Values [1]);
				break;

			case ComputeVector3Type.areParallel:
				boolValue = Vector3.Cross (vector3Values [0], vector3Values [1]).magnitude == 0f;
				break;

			case ComputeVector3Type.areOrthogonal:
				boolValue = Vector3.Dot (vector3Values [0], vector3Values [1]) == 0f;
				break;

			case ComputeVector3Type.areEqual:
				boolValue = vector3Values [0] == vector3Values [1];
				break;

			case ComputeVector3Type.Add:
				vector3Value = vector3Values [0] + vector3Values [1];
				break;

			}
		}
		void ComputeVector3_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeVector3Type)
			{
			case ComputeVector3Type.listenToTransferredData:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.animationCurvePickValue:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Pick a vector value on a curve,",
					"between the start and the end value.",
					"You have to choose the time corresponding to your value",
					"The time is the horizontal axis of the curve.",
					"The picked vector, the start and the end vectors are on the",
					"vertical axis of the curve",
					"",
					"About the horizontal axis:",
					"This axis is commonly called time, but in the case of this node",
					"it is an axis having values from 0 to 1 (normalized),",
					"so this node is usful for drawing any curves shape and picking",
					"a vector value (vertical axis) on the curve corresponding of any",
					"position in the horizontal axis, 0 is the left of the horizontal axis,",
					"1 is its right and between them is a value on the axis.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.animationCurve:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Animate a vector value on a curve,",
					"between the start and the end value.",
					"You have to define the animation time (duration).",
					"The time is the horizontal axis of the curve.",
					"The animated vector, the start and the end vectors are on the",
					"vertical axis of the curve",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.max:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the max value of the first and the second values",
					"Like the max for a float variable acting separately",
					"on both x, y, and z components of the vector",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.min:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the min value of the first and the second values",
					"Like the min for a float variable acting separately",
					"on both x, y, and z components of the vector",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.normalize:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns this vector with a magnitude of 1 (Read Only).",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Vector3-normalized.html", 
					"");
				break;

			case ComputeVector3Type.ClampMagnitude:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a copy of vector with its magnitude clamped to maxLength.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Vector3.ClampMagnitude.html", 
					"");
				break;

			case ComputeVector3Type.magnitude:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the magnitude (length) of the vector",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.get:
				ForGet_vector3_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.toString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get a string (text) format of the value",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.Switch:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the value corresponding of the checked box,",
					"if noth boxes have the same value, the node will not compute",
					"and it will conserve it's old output",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.toVector2:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Ignore Z, put X and Y in an output Vector2",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.subtract:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Subtract two vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.randomRotationUniform:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a random rotation with uniform distribution",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Random-rotationUniform.html", 
					"");
				break;

			case ComputeVector3Type.randomRotation:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a random rotation",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Random-rotation.html", 
					"");
				break;

			case ComputeVector3Type.putThisFloatInZ:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Modifie the Z value of the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.putThisFloatInYZ:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Put the same value on the Y and the Z of the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.putThisFloatInY:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Modifie the Y value of the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.putThisFloatInXZ:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Put the same value on the X and the Z of the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.putThisFloatInXYZ:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get a vector3 with same values on X, Y and Z",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.putThisFloatInXY:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Put the same value on the X and the Y of the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.putThisFloatInX:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Modifie the X value of the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.onUnitSphere:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a random point on the surface of a sphere with radius 1",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Random-onUnitSphere.html", 
					"");
				break;

			case ComputeVector3Type.multiply:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiply vector3 by a float (decimal) value.",
					"This cause a scaling of the vector2 without changing its direction",
					"If the float value is negative, it will flip the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.insideUnitSphere:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a random point inside a sphere with radius 1",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Random-insideUnitSphere.html", 
					"");
				break;

			case ComputeVector3Type.getFloatFromZ:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the Z value of the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.getFloatFromY:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the Y value of the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.getFloatFromX:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the X value of the vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.dot:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Dot Product of two vectors.",
					"The dot product is a float value equal to the magnitudes of the two vectors",
					"multiplied together and then multiplied by the cosine of the angle between them.",
					"For normalized vectors Dot returns 1 if they point in exactly the same direction,",
					"-1 if they point in completely opposite directions and zero if the vectors are",
					"perpendicular.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Vector3.Dot.html", 
					"");
				break;

			case ComputeVector3Type.cross:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Cross Product of two vectors.",
					"The cross product of two vectors results in a third vector which is perpendicular",
					"to the two input vectors. The result's magnitude is equal to the magnitudes of",
					"the two inputs multiplied together and then multiplied by the sine of the angle between",
					"the inputs.",
					"You can determine the direction of the result vector using the 'left hand rule'.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Vector3.Cross.html", 
					"");
				break;

			case ComputeVector3Type.areParallel:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Are these vector3 parallel?",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.areOrthogonal:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Are these vector3 orthogonal (perpendicular, angle of 90°)?",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.areEqual:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Are these vector3 equal?",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3Type.Add:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Add two vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}

		public int stringOperations_length = 0;
		public string stringOperations_last;

		void ApplyComputeString ()
		{			
			ComputeString_InputFields ();
			if (logic.playing)ComputeString ();
			ComputeString_OutputFields ();
		}
		void ComputeString_InputFields ()
		{
			computeStringType = (ComputeStringType)DrawEnumComputeType (computeStringType, 
				ref computeStringType_length, ref computeStringType_last, typeof (ComputeStringType));



			switch (computeStringType)
			{
			case ComputeStringType.stringOperations:
				DrawLogicNodeLabel ("Operations", 0, 2);
				stringOperations = (StringOperations)DrawEnum (stringOperations,
					ref stringOperations_length, ref stringOperations_last, typeof(StringOperations),
					FieldDrawType.label, 1, 2);

				StringOperations_Inputs ();

				break;

			case ComputeStringType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", MezanixDiamondStringNames (), noTransferredDataFound,
					0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawStringInputField (1, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeStringType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawStringInputField (1, stringInputFieldForWhat.general, 1, 2);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeStringType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_string_DrawInputs ();
				break;

			case ComputeStringType.Switch:
				DrawLogicNodeLabel ("Want this value?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawStringInputField (0, stringInputFieldForWhat.general);
				DrawLogicNodeLabel ("Or this One?", 0, 2);
				DrawBoolInputField (1, 3, 4);
				DrawStringInputField (1, stringInputFieldForWhat.general);
				break;

			case ComputeStringType.printToConsole:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeStringType.readItFromPlayerPrefs:

				DrawLogicNodeLabel ("With key", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case ComputeStringType.saveItInPlayerPrefs:
				DrawStringInputField (1, stringInputFieldForWhat.general);
				DrawLogicNodeLabel ("With key", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case ComputeStringType.isEqualToTag:
				DrawStringInputField (1, stringInputFieldForWhat.general);				DrawTagField (0);
				break;

			case ComputeStringType.isEqual:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				DrawStringInputField (1, stringInputFieldForWhat.general);
				break;

			case ComputeStringType.add:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				DrawStringInputField (1, stringInputFieldForWhat.general);
				break;

			}
			if (computeStringType == ComputeStringType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeString ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeStringType)
			{
			case ComputeStringType.stringOperations:
				StringOperations_Compute ();

				break;

			case ComputeStringType.listenToTransferredData:
				stringValue = MezanixDiamondGetString (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveString (stringValues [0]);
				}
				break;

			case ComputeStringType.sendMeAsTransferredData:
				MezanixDiamondSetString (stringValues [0]);

				break;

			case ComputeStringType.get:
				ForGet_string_Compute ();
				break;

			case ComputeStringType.Switch:
				if (boolValues [0] && ! boolValues [1])
				{
					stringValue = stringValues [0];
				}
				if (boolValues [1] && ! boolValues [0])
				{
					stringValue = stringValues [1];
				}

				break;

			case ComputeStringType.printToConsole:
				Debug.Log (stringValues [0]);
				break;

			case ComputeStringType.readItFromPlayerPrefs:
				stringValue = PlayerPrefs.GetString (stringValues [0]);
				break;

			case ComputeStringType.saveItInPlayerPrefs:
				PlayerPrefs.SetString (stringValues [0], stringValues [1]);
				PlayerPrefs.Save ();
				break;

			case ComputeStringType.isEqualToTag:
				boolValue = (stringValues [0] == stringValues [1])?true: false;
				break;

			case ComputeStringType.isEqual:
				boolValue = (stringValues [0] == stringValues [1])?true: false;
				break;

			case ComputeStringType.add:
				stringValue = "" + stringValues [0] + stringValues [1];
				break;

			}
		}
		void ComputeString_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeStringType)
			{
			case ComputeStringType.stringOperations:
				StringOperations_Outputs ();


				documentationMessage = 
					new string[]
				{
					"",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringType.listenToTransferredData:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringType.get:
				ForGet_string_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringType.Switch:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the value corresponding of the checked box,",
					"if noth boxes have the same value, the node will not compute",
					"and it will conserve it's old output",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringType.printToConsole:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Logs message to the Unity Console.",
					"When you select the message in the console a connection to the context object will be drawn.",
					"This can be useful for locating the object on which an error occurs.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Debug.Log.html", 
					"");
				break;

			case ComputeStringType.readItFromPlayerPrefs:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the value corresponding to key in the preference file if it exists.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.GetString.html", 
					"");
				break;

			case ComputeStringType.saveItInPlayerPrefs:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Sets the value of the preference identified by key.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.SetString.html", 
					"");
				break;

			case ComputeStringType.isEqualToTag:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if strings (phrases) are equal, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringType.isEqual:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if strings (phrases) are equal, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringType.add:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Add two string (phrase) values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeCollider2D ()
		{
			ComputeCollider2D_InputFields ();

			if (logic.playing)ComputeCollider2D ();

			ComputeCollider2D_OutputFields ();
		}
		public int computeCollider2DType_length = 0;
		public string computeCollider2DType_last;
		void ComputeCollider2D_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeCollider2DType = (ComputeCollider2DType)DrawEnumComputeType (computeCollider2DType, 
						ref computeCollider2DType_length, ref computeCollider2DType_last, typeof (ComputeCollider2DType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				collider2D = gameObjectValues [0].GetComponent <Collider2D>();

				if (collider2D == null)
				{
					DrawInNodeInfo ("Add Collider2D To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						collider2D == null;

					return;
				}

			}
			computeCollider2DType = (ComputeCollider2DType)DrawEnumComputeType (computeCollider2DType, 
				ref computeCollider2DType_length, ref computeCollider2DType_last, typeof (ComputeCollider2DType));
			

			switch (computeCollider2DType)
			{
			case ComputeCollider2DType.setUsedByEffector:
				DrawBoolInputField (0);
				break;

			case ComputeCollider2DType.setSharedPhysicMaterialFriction:
				DrawFloatInputField (0);
				break;

			case ComputeCollider2DType.setSharedPhysicMaterialBounciness:
				DrawFloatInputField (0);
				break;

			case ComputeCollider2DType.setOffset:
				DrawVector2InputField (0);
				break;

			case ComputeCollider2DType.setIsTrigger:
				DrawBoolInputField (0);
				break;

			case ComputeCollider2DType.setEnabled:
				DrawBoolInputField (0);
				break;

			case ComputeCollider2DType.setDensity:
				DrawFloatInputField (0);
				break;



			case ComputeCollider2DType.OverlapPoint:
				DrawVector3InputField (0);
				break;

			case ComputeCollider2DType.IsTouchingTheCollider2D:
				DrawGameObjectFieldInput (1);				if (gameObjectValues [1] == null)
				{
					DrawInNodeInfo ("Fill in GameObject field");

					return;
				}				collider2D_1 = gameObjectValues [1].GetComponent<Collider2D> ();

				if (collider2D_1 == null)
				{
					DrawInNodeInfo ("Add Collider2D To GameObject");

					return;
				}
				break;

			case ComputeCollider2DType.IsTouchingAnyColliderInThisLayerMask:
				DrawIntInputField (0);
				break;

			case ComputeCollider2DType.getUsedByEffector:

				break;

			case ComputeCollider2DType.getSharedPhysicMaterialFriction:

				break;

			case ComputeCollider2DType.getSharedPhysicMaterialBounciness:

				break;

			case ComputeCollider2DType.getShapeCount:

				break;

			case ComputeCollider2DType.getOffset:

				break;

			case ComputeCollider2DType.getIsTrigger:

				break;

			case ComputeCollider2DType.getEnabled:

				break;

			case ComputeCollider2DType.getDensity:

				break;



			case ComputeCollider2DType.getBounds:

				break;

			}
			DrawDoItButton();
		}
		void ComputeCollider2D ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeCollider2DType)
			{
			case ComputeCollider2DType.setUsedByEffector:
				collider2D.usedByEffector = boolValues [0];
				break;

			case ComputeCollider2DType.setSharedPhysicMaterialFriction:
				if (collider2D.sharedMaterial != null)
				{
					collider2D.sharedMaterial.friction = floatValues [0];
				}
				break;

			case ComputeCollider2DType.setSharedPhysicMaterialBounciness:
				if (collider2D.sharedMaterial != null)
				{
					collider2D.sharedMaterial.bounciness = floatValues [0];
				}
				break;

			case ComputeCollider2DType.setOffset:
				collider2D.offset = vector2Values [0];
				break;

			case ComputeCollider2DType.setIsTrigger:
				collider2D.isTrigger = boolValues [0];
				break;

			case ComputeCollider2DType.setEnabled:
				collider2D.enabled = boolValues [0];
				break;

			case ComputeCollider2DType.setDensity:
				collider2D.density = floatValues [0];
				break;



			case ComputeCollider2DType.OverlapPoint:
				boolValue = collider2D.OverlapPoint (vector3Values [0]);
				break;

			case ComputeCollider2DType.IsTouchingTheCollider2D:
				if (gameObjectValues [1] != null)
				{
					collider2D_1 = gameObjectValues [1].GetComponent<Collider2D>();

					if (collider2D_1 != null)
					{
						boolValue = collider2D.IsTouching (collider2D_1);
					}
				}
				break;

			case ComputeCollider2DType.IsTouchingAnyColliderInThisLayerMask:
				boolValue = collider2D.IsTouchingLayers (intValues [0]);
				break;

			case ComputeCollider2DType.getUsedByEffector:
				boolValue = collider2D.usedByEffector;
				break;

			case ComputeCollider2DType.getSharedPhysicMaterialFriction:
				if (collider2D.sharedMaterial != null)
				{
					floatValue = collider2D.sharedMaterial.friction;
				}
				break;

			case ComputeCollider2DType.getSharedPhysicMaterialBounciness:
				if (collider2D.sharedMaterial != null)
				{
					floatValue = collider2D.sharedMaterial.bounciness;
				}
				break;

			case ComputeCollider2DType.getShapeCount:
				intValue = collider2D.shapeCount;
				break;

			case ComputeCollider2DType.getOffset:
				vector2Value = collider2D.offset;
				break;

			case ComputeCollider2DType.getIsTrigger:
				boolValue = collider2D.isTrigger;
				break;

			case ComputeCollider2DType.getEnabled:
				boolValue = collider2D.enabled;
				break;

			case ComputeCollider2DType.getDensity:
				floatValue = collider2D.density;
				break;



			case ComputeCollider2DType.getBounds:
				boundsCenterValue = collider2D.bounds.center;

				boundsExtentsValue = collider2D.bounds.extents;

				boundsMaxValue = collider2D.bounds.max;

				boundsMinValue = collider2D.bounds.min;

				boundsSizeValue = collider2D.bounds.size;
				break;

			}
		}
		void ComputeCollider2D_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeCollider2DType)
			{
			case ComputeCollider2DType.setUsedByEffector:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-usedByEffector.html", 
					"");
				break;

			case ComputeCollider2DType.setSharedPhysicMaterialFriction:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicsMaterial2D-friction.html", 
					"");
				break;

			case ComputeCollider2DType.setSharedPhysicMaterialBounciness:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicsMaterial2D-bounciness.html", 
					"");
				break;

			case ComputeCollider2DType.setOffset:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-offset.html", 
					"");
				break;

			case ComputeCollider2DType.setIsTrigger:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-isTrigger.html", 
					"");
				break;

			case ComputeCollider2DType.setEnabled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeCollider2DType.setDensity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-density.html", 
					"");
				break;




			case ComputeCollider2DType.OverlapPoint:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D.OverlapPoint.html", 
					"");
				break;

			case ComputeCollider2DType.IsTouchingTheCollider2D:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D.IsTouching.html", 
					"");
				break;

			case ComputeCollider2DType.IsTouchingAnyColliderInThisLayerMask:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D.IsTouchingLayers.html", 
					"");
				break;

			case ComputeCollider2DType.getUsedByEffector:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-usedByEffector.html", 
					"");
				break;

			case ComputeCollider2DType.getSharedPhysicMaterialFriction:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicsMaterial2D-friction.html", 
					"");
				break;

			case ComputeCollider2DType.getSharedPhysicMaterialBounciness:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicsMaterial2D-bounciness.html", 
					"");
				break;

			case ComputeCollider2DType.getShapeCount:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-shapeCount.html", 
					"");
				break;

			case ComputeCollider2DType.getOffset:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-offset.html", 
					"");
				break;

			case ComputeCollider2DType.getIsTrigger:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-isTrigger.html", 
					"");
				break;

			case ComputeCollider2DType.getEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeCollider2DType.getDensity:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-density.html", 
					"");
				break;



			case ComputeCollider2DType.getBounds:
				DrawBoundsResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider2D-bounds.html", 
					"");
				break;

			}
		}

		void ApplyComputeCollider ()
		{
			ComputeCollider_InputFields ();

			if (logic.playing)ComputeCollider ();

			ComputeCollider_OutputFields ();
		}
		public int computeColliderType_length = 0;
		public string computeColliderType_last;
		void ComputeCollider_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;
			
			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeColliderType = (ComputeColliderType)DrawEnumComputeType (computeColliderType,
						ref computeColliderType_length, ref computeColliderType_last, typeof (ComputeColliderType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				collider = gameObjectValues [0].GetComponent <Collider>();

				if (collider == null)
				{
					DrawInNodeInfo ("Add Collider To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						collider == null;

					return;
				}

			}
			computeColliderType = (ComputeColliderType)DrawEnumComputeType (computeColliderType,
				ref computeColliderType_length, ref computeColliderType_last, typeof (ComputeColliderType));
			

			switch (computeColliderType)
			{
			case ComputeColliderType.setStaticFrictionOnSharedPhysicMaterial:
				DrawFloatInputField (0);
				break;

			case ComputeColliderType.setStaticFrictionOnPhysicMaterial:
				DrawFloatInputField (0);
				break;




			case ComputeColliderType.setIsTrigger:
				DrawBoolInputField (0);
				break;

			case ComputeColliderType.setFrictionCombineOnSharedPhysicMaterial:
				DrawPhysicMaterialCombineEnum ();
				break;

			case ComputeColliderType.setFrictionCombineOnPhysicMaterial:
				DrawPhysicMaterialCombineEnum ();
				break;

			case ComputeColliderType.setEnabled:
				DrawBoolInputField (0);
				break;

			case ComputeColliderType.setDynamicFrictionOnSharedPhysicMaterial:
				DrawFloatInputField (0);
				break;

			case ComputeColliderType.setDynamicFrictionOnPhysicMaterial:
				DrawFloatInputField (0);
				break;

			case ComputeColliderType.setContactOffset:
				DrawFloatInputField (0);
				break;




			case ComputeColliderType.setBouncinessOnSharedPhysicMaterial:
				DrawFloatInputField (0);
				break;

			case ComputeColliderType.setBouncinessOnPhysicMaterial:
				DrawFloatInputField (0);
				break;

			case ComputeColliderType.setBounceCombineOnSharedPhysicMaterial:
				DrawPhysicMaterialCombineEnum ();
				break;

			case ComputeColliderType.setBounceCombineOnPhysicMaterial:
				DrawPhysicMaterialCombineEnum ();
				break;

			case ComputeColliderType.getStaticFrictionFromPhysicMaterial:

				break;





			case ComputeColliderType.getIsTrigger:

				break;

			case ComputeColliderType.getEnabled:

				break;

			case ComputeColliderType.getDynamicFrictionFromPhysicMaterial:

				break;

			case ComputeColliderType.getContactOffset:

				break;




			case ComputeColliderType.getBouunds:

				break;

			case ComputeColliderType.getBouncinessFromPhysicMaterial:

				break;

			}
			DrawDoItButton();
		}
		void ComputeCollider ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeColliderType)
			{
			case ComputeColliderType.setStaticFrictionOnSharedPhysicMaterial:
				if (collider.sharedMaterial != null)
				{
					collider.sharedMaterial.staticFriction = floatValues [0];
				}
				break;

			case ComputeColliderType.setStaticFrictionOnPhysicMaterial:
				if (collider.material != null)
				{
					collider.material.staticFriction = floatValues [0];
				}
				break;





			case ComputeColliderType.setIsTrigger:
				collider.isTrigger = boolValues [0];
				break;

			case ComputeColliderType.setFrictionCombineOnSharedPhysicMaterial:
				if (collider.sharedMaterial != null)
				{
					collider.sharedMaterial.frictionCombine = physicMaterialCombine;
				}
				break;

			case ComputeColliderType.setFrictionCombineOnPhysicMaterial:
				if (collider.material != null)
				{
					collider.material.frictionCombine = physicMaterialCombine;
				}
				break;

			case ComputeColliderType.setEnabled:
				collider.enabled = boolValues [0];
				break;

			case ComputeColliderType.setDynamicFrictionOnSharedPhysicMaterial:
				if (collider.sharedMaterial != null)
				{
					collider.sharedMaterial.dynamicFriction = floatValues [0];
				}
				break;

			case ComputeColliderType.setDynamicFrictionOnPhysicMaterial:
				if (collider.material != null)
				{
					collider.material.dynamicFriction = floatValues [0];
				}
				break;

			case ComputeColliderType.setContactOffset:
				collider.contactOffset = floatValues [0];
				break;



			case ComputeColliderType.setBouncinessOnSharedPhysicMaterial:
				if (collider.sharedMaterial != null)
				{
					collider.sharedMaterial.bounciness = floatValues [0];
				}
				break;

			case ComputeColliderType.setBouncinessOnPhysicMaterial:
				if (collider.material != null)
				{
					collider.material.bounciness = floatValues [0];
				}
				break;

			case ComputeColliderType.setBounceCombineOnSharedPhysicMaterial:
				if (collider.sharedMaterial != null)
				{
					collider.sharedMaterial.bounceCombine = physicMaterialCombine;
				}
				break;

			case ComputeColliderType.setBounceCombineOnPhysicMaterial:
				if (collider.material != null)
				{
					collider.material.bounceCombine = physicMaterialCombine;
				}
				break;

			case ComputeColliderType.getStaticFrictionFromPhysicMaterial:
				if (collider.material != null)
				{
					floatValue = collider.material.staticFriction;
				}
				break;





			case ComputeColliderType.getIsTrigger:
				boolValue = collider.isTrigger;
				break;

			case ComputeColliderType.getEnabled:
				boolValue = collider.enabled;
				break;

			case ComputeColliderType.getDynamicFrictionFromPhysicMaterial:
				if (collider.material != null)
				{
					floatValue = collider.material.dynamicFriction;
				}
				break;

			case ComputeColliderType.getContactOffset:
				floatValue = collider.contactOffset;
				break;





			case ComputeColliderType.getBouunds:
				boundsCenterValue = collider.bounds.center;

				boundsExtentsValue = collider.bounds.extents;

				boundsMaxValue = collider.bounds.max;

				boundsMinValue = collider.bounds.min;

				boundsSizeValue = collider.bounds.size;
				break;

			case ComputeColliderType.getBouncinessFromPhysicMaterial:
				if (collider.material != null)
				{
					floatValue = collider.material.bounciness;
				}
				break;

			}
		}
		void ComputeCollider_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeColliderType)
			{
			case ComputeColliderType.setStaticFrictionOnSharedPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-staticFriction.html", 
					"");
				break;

			case ComputeColliderType.setStaticFrictionOnPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-staticFriction.html", 
					"");
				break;



			case ComputeColliderType.setIsTrigger:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider-isTrigger.html", 
					"");
				break;

			case ComputeColliderType.setFrictionCombineOnSharedPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-frictionCombine.html", 
					"");
				break;

			case ComputeColliderType.setFrictionCombineOnPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-frictionCombine.html", 
					"");
				break;

			case ComputeColliderType.setEnabled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider-enabled.html", 
					"");
				break;

			case ComputeColliderType.setDynamicFrictionOnSharedPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-dynamicFriction.html", 
					"");
				break;

			case ComputeColliderType.setDynamicFrictionOnPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-dynamicFriction.html", 
					"");
				break;

			case ComputeColliderType.setContactOffset:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider-contactOffset.html", 
					"");
				break;





			case ComputeColliderType.setBouncinessOnSharedPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounciness.html", 
					"");
				break;

			case ComputeColliderType.setBouncinessOnPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounciness.html", 
					"");
				break;

			case ComputeColliderType.setBounceCombineOnSharedPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounceCombine.html", 
					"");
				break;

			case ComputeColliderType.setBounceCombineOnPhysicMaterial:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounceCombine.html", 
					"");
				break;

			case ComputeColliderType.getStaticFrictionFromPhysicMaterial:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-staticFriction.html", 
					"");
				break;



			case ComputeColliderType.getIsTrigger:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider-isTrigger.html", 
					"");
				break;

			case ComputeColliderType.getEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider-enabled.html", 
					"");
				break;

			case ComputeColliderType.getDynamicFrictionFromPhysicMaterial:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-dynamicFriction.html", 
					"");
				break;

			case ComputeColliderType.getContactOffset:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider-contactOffset.html", 
					"");
				break;





			case ComputeColliderType.getBouunds:
				DrawBoundsResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Collider-bounds.html", 
					"");
				break;

			case ComputeColliderType.getBouncinessFromPhysicMaterial:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounciness.html", 
					"");
				break;

			}
		}

		void ApplyComputeLineRenderer ()
		{
			ComputeLineRenderer_InputFields ();
			if (logic.playing)ComputeLineRenderer ();
			ComputeLineRenderer_OutputFields ();
		}
		public int computeLineRendererType_length = 0;
		public string computeLineRendererType_last;
		void ComputeLineRenderer_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeLineRendererType = (ComputeLineRendererType)DrawEnumComputeType (computeLineRendererType,
						ref computeLineRendererType_length, ref computeLineRendererType_last, typeof (ComputeLineRendererType)
						);

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				lineRenderer = gameObjectValues [0].GetComponent <LineRenderer>();

				if (lineRenderer == null)
				{
					DrawInNodeInfo ("Add LineRenderer To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						lineRenderer == null;

					return;
				}

			}
			computeLineRendererType = (ComputeLineRendererType)DrawEnumComputeType (computeLineRendererType,
				ref computeLineRendererType_length, ref computeLineRendererType_last, typeof (ComputeLineRendererType)
			);

			switch (computeLineRendererType)
			{
			case ComputeLineRendererType.setLineRendererColors:
				DrawLogicNodeLabel ("Start color", 0, 2);
				DrawColorInputField (0, 1, 2);
				DrawLogicNodeLabel ("End Colors", 0, 2);
				DrawColorInputField (1, 1, 2);
				break;

			}
			DrawDoItButton();
		}
		void ComputeLineRenderer ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeLineRendererType)
			{
			case ComputeLineRendererType.setLineRendererColors:
				lineRenderer.startColor = colorValues [0];
				lineRenderer.endColor = colorValues [1];
				break;

			}
		}
		void ComputeLineRenderer_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeLineRendererType)
			{
			case ComputeLineRendererType.setLineRendererColors:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/LineRenderer-startColor.html", 
					"");
				break;

			}
		}

		void ApplyComputeSpriteRenderer ()
		{
			ComputeSpriteRenderer_InputFields ();
			if (logic.playing)ComputeSpriteRenderer ();
			ComputeSpriteRenderer_OutputFields ();
		}

		public int computeSpriteRendererType_length = 0;
		public string computeSpriteRendererType_last;

		public int spriteTileMode_length = 0;
		public string spriteTileMode_last;

		public int spriteDrawMode_length = 0;
		public string spriteDrawMode_last;

		void ComputeSpriteRenderer_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeSpriteRendererType = (ComputeSpriteRendererType)DrawEnumComputeType (
						computeSpriteRendererType, ref computeSpriteRendererType_length,
						ref computeSpriteRendererType_last, typeof (ComputeSpriteRendererType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				spriteRenderer = gameObjectValues [0].GetComponent <SpriteRenderer>();

				if (spriteRenderer == null)
				{
					DrawInNodeInfo ("Add SpriteRenderer To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						spriteRenderer == null;

					return;
				}

			}
			computeSpriteRendererType = (ComputeSpriteRendererType)DrawEnumComputeType (
				computeSpriteRendererType, ref computeSpriteRendererType_length,
				ref computeSpriteRendererType_last, typeof (ComputeSpriteRendererType));
			
			switch (computeSpriteRendererType)
			{
			case ComputeSpriteRendererType.tile:
				DrawSpriteRendererTileInputs ();
				break;

			case ComputeSpriteRendererType.getSize:

				break;

			case ComputeSpriteRendererType.setSize:
				DrawVector2InputField (0);
				break;

			case ComputeSpriteRendererType.getAdaptiveModeThreshold:

				break;

			case ComputeSpriteRendererType.setAdaptiveModeThreshold:
				DrawFloatInputField (0);
				break;



			case ComputeSpriteRendererType.setSpriteTileMode:
				spriteTileMode = (SpriteTileMode)DrawEnum (spriteTileMode,
					ref spriteTileMode_length, ref spriteTileMode_last, typeof(SpriteTileMode),
					"Sprite Tile Mode", Skins.logicNodeLabel);

				break;

			case ComputeSpriteRendererType.setSpriteDrawMode:
				spriteDrawMode = (SpriteDrawMode)DrawEnum (spriteDrawMode,
					ref spriteDrawMode_length, ref spriteDrawMode_last, typeof(SpriteDrawMode),
					"Sprite Draw Mode", Skins.logicNodeLabel);

				break;

			case ComputeSpriteRendererType.setSpriteRendererFlipY:
				DrawBoolInputField (0);
				break;

			case ComputeSpriteRendererType.setSpriteRendererFlipX:
				DrawBoolInputField (0);
				break;

			case ComputeSpriteRendererType.setSpriteRendererColor:
				DrawColorInputField (0);
				break;

			case ComputeSpriteRendererType.getSpriteRendererFlipY:

				break;

			case ComputeSpriteRendererType.getSpriteRendererFlipX:

				break;

			case ComputeSpriteRendererType.getSpriteRendererColor:

				break;

			}
			DrawDoItButton();
		}
		void ComputeSpriteRenderer ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeSpriteRendererType)
			{
			case ComputeSpriteRendererType.tile:
				TileSprite ();
				break;

			case ComputeSpriteRendererType.getSize:
				vector2Value = spriteRenderer.size;
				break;

			case ComputeSpriteRendererType.setSize:
				spriteRenderer.size = vector2Values [0];
				break;

			case ComputeSpriteRendererType.getAdaptiveModeThreshold:
				floatValue = spriteRenderer.adaptiveModeThreshold;
				break;

			case ComputeSpriteRendererType.setAdaptiveModeThreshold:
				spriteRenderer.adaptiveModeThreshold = floatValues [0];
				break;

			case ComputeSpriteRendererType.setSpriteTileMode:
				spriteRenderer.tileMode = spriteTileMode;
				break;

			case ComputeSpriteRendererType.setSpriteDrawMode:
				spriteRenderer.drawMode = spriteDrawMode;
				break;

			case ComputeSpriteRendererType.setSpriteRendererFlipY:
				spriteRenderer.flipY = boolValues [0];
				break;

			case ComputeSpriteRendererType.setSpriteRendererFlipX:
				spriteRenderer.flipX = boolValues [0];
				break;

			case ComputeSpriteRendererType.setSpriteRendererColor:
				spriteRenderer.color = colorValues [0];
				break;

			case ComputeSpriteRendererType.getSpriteRendererFlipY:
				boolValue = spriteRenderer.flipY;
				break;

			case ComputeSpriteRendererType.getSpriteRendererFlipX:
				boolValue = spriteRenderer.flipX;
				break;

			case ComputeSpriteRendererType.getSpriteRendererColor:
				colorValue = spriteRenderer.color;
				break;

			}
		}
		void ComputeSpriteRenderer_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeSpriteRendererType)
			{
			case ComputeSpriteRendererType.tile:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Tile a sprite horizontally and vertically.",
					"You can perform rotations over tiling, separatly on x and y or continusly.",
					"Your tiling can be fractional, 2.5 on x will give you 2 sprites and half tiled",
					"P.S. transform scale and sprite size are bothe taked into account to offer more control,",
					"so for simple adjacent tiling you can put one or both of sprite size and transform scale to 1,",
					"this will help you te see more clearly what is happening.",
					"IMPORTANT - 2 thinks to do before using the tile node:",
					"1. In the sprite import settings choose 'Full rect' for the Mesh Type",
					"2. Put the Sprite Renderer Draw Mode to Sliced in the sprite renderer inspector or via Diamond",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeSpriteRendererType.getSize:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-size.html", 
					"");
				break;

			case ComputeSpriteRendererType.setSize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-size.html", 
					"");
				break;

			case ComputeSpriteRendererType.getAdaptiveModeThreshold:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-adaptiveModeThreshold.html", 
					"");
				break;

			case ComputeSpriteRendererType.setAdaptiveModeThreshold:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-adaptiveModeThreshold.html", 
					"");
				break;

			case ComputeSpriteRendererType.setSpriteTileMode:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-tileMode.html", 
					"");
				break;

			case ComputeSpriteRendererType.setSpriteDrawMode:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-drawMode.html", 
					"");
				break;

			case ComputeSpriteRendererType.setSpriteRendererFlipY:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-flipY.html", 
					"");
				break;

			case ComputeSpriteRendererType.setSpriteRendererFlipX:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-flipX.html", 
					"");
				break;

			case ComputeSpriteRendererType.setSpriteRendererColor:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-color.html", 
					"");
				break;

			case ComputeSpriteRendererType.getSpriteRendererFlipY:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-flipY.html", 
					"");
				break;

			case ComputeSpriteRendererType.getSpriteRendererFlipX:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-flipX.html", 
					"");
				break;

			case ComputeSpriteRendererType.getSpriteRendererColor:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-color.html", 
					"");
				break;

			}
		}


		void ApplyComputeRigidBody ()
		{
			ComputeRigidbody_InputFields ();
			if (logic.playing)ComputeRigidbody ();
			ComputeRigidbody_OutputFields ();
		}
		public int computeRigidBodyType_length = 0;
		public string computeRigidBodyType_last;

		public int forceMode_length = 0;
		public string forceMode_last;

		void DrawEnumForceMode () 
		{
			forceMode = (ForceMode)DrawEnum (forceMode,
			ref forceMode_length, ref forceMode_last, typeof(ForceMode), FieldDrawType.label, 1, 2);
		}

		void ComputeRigidbody_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;
			
			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeRigidBodyType = (ComputeRigidBodyType)DrawEnumComputeType (computeRigidBodyType,
						ref computeRigidBodyType_length , ref computeRigidBodyType_last,
						typeof(ComputeRigidBodyType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				rigidBody = gameObjectValues [0].GetComponent <Rigidbody>();

				if (rigidBody == null)
				{
					DrawInNodeInfo ("Add Rigidbody To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						rigidBody == null;

					return;
				}

			}

			computeRigidBodyType = (ComputeRigidBodyType)DrawEnumComputeType (computeRigidBodyType,
				ref computeRigidBodyType_length , ref computeRigidBodyType_last,
				typeof(ComputeRigidBodyType));

			switch (computeRigidBodyType)
			{
			case ComputeRigidBodyType.WakeUp:

				break;

			case ComputeRigidBodyType.SweepTestAll:
				DrawFieldsForSweepTestAll ();


				break;

			case ComputeRigidBodyType.SweepTest:
				DrawFieldsForSweepTest ();
				break;

			case ComputeRigidBodyType.Sleep:

				break;

			case ComputeRigidBodyType.setVelocity:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.setUseGravity:
				DrawBoolInputField (0);
				break;

			case ComputeRigidBodyType.setSolverIterations:
				DrawIntInputField (0);
				break;

			case ComputeRigidBodyType.setSleepThreshold:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBodyType.setRotation:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.setPosition:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.setMaxDepenetrationVelocity:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBodyType.setMaxAngularVelocity:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBodyType.setMass:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBodyType.setIsKinemaic:
				DrawBoolInputField (0);
				break;

			case ComputeRigidBodyType.setInertiaTensorRotation:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.setInertiaTensor:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.setDrag:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBodyType.setDetectCollisions:
				DrawBoolInputField (0);
				break;

			case ComputeRigidBodyType.SetDensity:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBodyType.setCenterOfMass:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.setAngularVelocity:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.setAngularDrag:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBodyType.ResetInertiaTensor:

				break;

			case ComputeRigidBodyType.ResetCenterOfMass:

				break;

			case ComputeRigidBodyType.MoveRotation:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.MovePosition:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.IsSleeping:

				break;

			case ComputeRigidBodyType.getWorldCenterOfMass:

				break;

			case ComputeRigidBodyType.getVelocity:

				break;

			case ComputeRigidBodyType.getUseGravity:

				break;

			case ComputeRigidBodyType.getSolverIterations:

				break;

			case ComputeRigidBodyType.getSleepThreshold:

				break;

			case ComputeRigidBodyType.getRotation:

				break;

			case ComputeRigidBodyType.GetRelativePointVelocity:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.getPosition:

				break;

			case ComputeRigidBodyType.GetPointVelocity:
				DrawVector3InputField (0);
				break;

			case ComputeRigidBodyType.getMaxDepenetrationVelocity:

				break;

			case ComputeRigidBodyType.getMaxAngularVelocity:

				break;

			case ComputeRigidBodyType.getMass:

				break;

			case ComputeRigidBodyType.getIsKinemaic:

				break;

			case ComputeRigidBodyType.getInertiaTensorRotation:

				break;

			case ComputeRigidBodyType.getInertiaTensor:

				break;

			case ComputeRigidBodyType.getDrag:

				break;

			case ComputeRigidBodyType.getDetectCollisions:

				break;

			case ComputeRigidBodyType.getCenterOfMass:

				break;

			case ComputeRigidBodyType.getAngularVelocity:

				break;

			case ComputeRigidBodyType.getAngularDrag:

				break;

			case ComputeRigidBodyType.ClosestPointOnBounds:
				DrawLogicNodeLabel ("Position");
				DrawVector3InputField (0);
				break;


			case ComputeRigidBodyType.ApplyForce:
				DrawLogicNodeLabel ("Force");
				DrawVector3InputField (0);

				DrawLogicNodeLabel ("Force Mode", 0, 2);
				DrawEnumForceMode ();
				break;

			case ComputeRigidBodyType.AddTorque:
				DrawLogicNodeLabel ("Torque");
				DrawVector3InputField (0);

				DrawLogicNodeLabel ("Force Mode", 0, 2);
				DrawEnumForceMode ();
				break;

			case ComputeRigidBodyType.AddRelativeTorque:
				DrawLogicNodeLabel ("Torque");
				DrawVector3InputField (0);

				DrawLogicNodeLabel ("Force Mode", 0, 2);
				DrawEnumForceMode ();
				break;

			case ComputeRigidBodyType.AddRelativeForce:
				DrawLogicNodeLabel ("Force");
				DrawVector3InputField (0);

				DrawLogicNodeLabel ("Force Mode", 0, 2);
				DrawEnumForceMode ();
				break;

			case ComputeRigidBodyType.AddForceAtPosition:
				DrawLogicNodeLabel ("Force");
				DrawVector3InputField (0);

				DrawLogicNodeLabel ("Position");
				DrawVector3InputField (1);
				break;

			case ComputeRigidBodyType.AddExplosionForce:
				DrawLogicNodeLabel ("ExplosionForce", 0, 2);
				DrawFloatInputField (0, 1, 2);

				DrawLogicNodeLabel ("Explosion Position");
				DrawVector3InputField (0);

				DrawLogicNodeLabel ("Radius", 0, 2);
				DrawFloatInputField (1, 1, 2);

				DrawLogicNodeLabel ("UpwardModifier", 0, 2);
				DrawFloatInputField (2, 1, 2);

				DrawLogicNodeLabel ("Force Mode", 0, 2);
				DrawEnumForceMode ();
				break;

			}
			DrawDoItButton();
		}
		void ComputeRigidbody ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeRigidBodyType)
			{
			case ComputeRigidBodyType.WakeUp:
				rigidBody.WakeUp ();
				break;

			case ComputeRigidBodyType.SweepTestAll:
				hits = rigidBody.SweepTestAll (vector3Values [0], floatValues [0], queryTriggerInteraction);

				AssignRayCasthitInfos (intValues [0]);
				break;

			case ComputeRigidBodyType.SweepTest:
				boolValue = rigidBody.SweepTest (vector3Values [0], out hit, floatValues [0], queryTriggerInteraction);

				AssignRayCasthitInfos ();
				break;

			case ComputeRigidBodyType.Sleep:
				rigidBody.Sleep ();
				break;

			case ComputeRigidBodyType.setVelocity:
				rigidBody.velocity = vector3Values [0];
				break;

			case ComputeRigidBodyType.setUseGravity:
				rigidBody.useGravity = boolValues [0];
				break;

			case ComputeRigidBodyType.setSolverIterations:
				rigidBody.solverIterations = intValues [0];
				break;

			case ComputeRigidBodyType.setSleepThreshold:
				rigidBody.sleepThreshold = floatValues [0];
				break;

			case ComputeRigidBodyType.setRotation:
				rigidBody.rotation = Quaternion.Euler (vector3Values [0]);
				break;

			case ComputeRigidBodyType.setPosition:
				rigidBody.position = vector3Values [0];
				break;

			case ComputeRigidBodyType.setMaxDepenetrationVelocity:
				rigidBody.maxDepenetrationVelocity = floatValues [0];
				break;

			case ComputeRigidBodyType.setMaxAngularVelocity:
				rigidBody.maxAngularVelocity = floatValues [0];
				break;

			case ComputeRigidBodyType.setMass:
				rigidBody.mass = floatValues [0];
				break;

			case ComputeRigidBodyType.setIsKinemaic:
				rigidBody.isKinematic = boolValues [0];
				break;

			case ComputeRigidBodyType.setInertiaTensorRotation:
				rigidBody.inertiaTensorRotation = Quaternion.Euler (vector3Values [0]);
				break;

			case ComputeRigidBodyType.setInertiaTensor:
				rigidBody.inertiaTensor = vector3Values [0];
				break;

			case ComputeRigidBodyType.setDrag:
				rigidBody.drag = floatValues [0];
				break;

			case ComputeRigidBodyType.setDetectCollisions:
				rigidBody.detectCollisions = boolValues [0];
				break;

			case ComputeRigidBodyType.SetDensity:
				rigidBody.SetDensity (floatValues [0]);
				break;

			case ComputeRigidBodyType.setCenterOfMass:
				rigidBody.centerOfMass = vector3Values [0];
				break;

			case ComputeRigidBodyType.setAngularVelocity:
				rigidBody.angularVelocity = vector3Values [0];
				break;

			case ComputeRigidBodyType.setAngularDrag:
				rigidBody.angularDrag = floatValues [0];
				break;

			case ComputeRigidBodyType.ResetInertiaTensor:
				rigidBody.ResetInertiaTensor ();
				break;

			case ComputeRigidBodyType.ResetCenterOfMass:
				rigidBody.ResetCenterOfMass ();
				break;

			case ComputeRigidBodyType.MoveRotation:
				rigidBody.MoveRotation (Quaternion.Euler (vector3Values [0]));
				break;

			case ComputeRigidBodyType.MovePosition:
				rigidBody.MovePosition (vector3Values [0]);
				break;

			case ComputeRigidBodyType.IsSleeping:
				boolValue = rigidBody.IsSleeping ();
				break;

			case ComputeRigidBodyType.getWorldCenterOfMass:
				vector3Value = rigidBody.worldCenterOfMass;
				break;

			case ComputeRigidBodyType.getVelocity:
				vector3Value = rigidBody.velocity;
				break;

			case ComputeRigidBodyType.getUseGravity:
				boolValue = rigidBody.useGravity;
				break;

			case ComputeRigidBodyType.getSolverIterations:
				intValue = rigidBody.solverIterations;
				break;

			case ComputeRigidBodyType.getSleepThreshold:
				floatValue = rigidBody.sleepThreshold;
				break;

			case ComputeRigidBodyType.getRotation:
				vector3Value = rigidBody.rotation.eulerAngles;
				break;

			case ComputeRigidBodyType.GetRelativePointVelocity:
				vector3Value = rigidBody.GetRelativePointVelocity (vector3Values [0]);
				break;

			case ComputeRigidBodyType.getPosition:
				vector3Value = rigidBody.position;
				break;

			case ComputeRigidBodyType.GetPointVelocity:
				vector3Value = rigidBody.GetPointVelocity (vector3Values [0]);
				break;

			case ComputeRigidBodyType.getMaxDepenetrationVelocity:
				floatValue = rigidBody.maxDepenetrationVelocity;
				break;

			case ComputeRigidBodyType.getMaxAngularVelocity:
				floatValue = rigidBody.maxAngularVelocity;
				break;

			case ComputeRigidBodyType.getMass:
				floatValue = rigidBody.mass;
				break;

			case ComputeRigidBodyType.getIsKinemaic:
				boolValue = rigidBody.isKinematic;
				break;

			case ComputeRigidBodyType.getInertiaTensorRotation:
				vector3Value = rigidBody.inertiaTensorRotation.eulerAngles;
				break;

			case ComputeRigidBodyType.getInertiaTensor:
				vector3Value = rigidBody.inertiaTensor;
				break;

			case ComputeRigidBodyType.getDrag:
				floatValue = rigidBody.drag;
				break;

			case ComputeRigidBodyType.getDetectCollisions:
				boolValue = rigidBody.detectCollisions;
				break;

			case ComputeRigidBodyType.getCenterOfMass:
				vector3Value = rigidBody.centerOfMass;
				break;

			case ComputeRigidBodyType.getAngularVelocity:
				vector3Value = rigidBody.angularVelocity;
				break;

			case ComputeRigidBodyType.getAngularDrag:
				floatValue = rigidBody.angularDrag;
				break;

			case ComputeRigidBodyType.ClosestPointOnBounds:
				vector3Value = rigidBody.ClosestPointOnBounds (vector3Values [0]);
				break;

			case ComputeRigidBodyType.ApplyForce:
				rigidBody.AddForce (vector3Values [0], forceMode);
				break;

			case ComputeRigidBodyType.AddTorque:
				rigidBody.AddTorque (vector3Values [0], forceMode);
				break;

			case ComputeRigidBodyType.AddRelativeTorque:
				rigidBody.AddRelativeTorque (vector3Values [0], forceMode);
				break;

			case ComputeRigidBodyType.AddRelativeForce:
				rigidBody.AddRelativeForce (vector3Values [0], forceMode);
				break;

			case ComputeRigidBodyType.AddForceAtPosition:
				rigidBody.AddForceAtPosition (vector3Values [0], vector3Values [1]);
				break;

			case ComputeRigidBodyType.AddExplosionForce:
				rigidBody.AddExplosionForce (floatValues [0], vector3Values [0], floatValues [1], floatValues [2], forceMode);
				break;

			}
		}
		void ComputeRigidbody_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeRigidBodyType)
			{
			case ComputeRigidBodyType.WakeUp:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.WakeUp.html", 
					"");
				break;

			case ComputeRigidBodyType.SweepTestAll:
				DrawIntWhichHit ();
				DrawSweepTestResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.SweepTestAll.html", 
					"");
				break;

			case ComputeRigidBodyType.SweepTest:
				DrawSweepTestResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.SweepTest.html", 
					"");
				break;

			case ComputeRigidBodyType.Sleep:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.Sleep.html", 
					"");
				break;

			case ComputeRigidBodyType.setVelocity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-velocity.html", 
					"");
				break;

			case ComputeRigidBodyType.setUseGravity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-useGravity.html", 
					"");
				break;

			case ComputeRigidBodyType.setSolverIterations:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/530/Documentation/ScriptReference/Physics-solverIterationCount.html", 
					"");
				break;

			case ComputeRigidBodyType.setSleepThreshold:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-sleepThreshold.html", 
					"");
				break;

			case ComputeRigidBodyType.setRotation:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-rotation.html", 
					"");
				break;

			case ComputeRigidBodyType.setPosition:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-position.html", 
					"");
				break;

			case ComputeRigidBodyType.setMaxDepenetrationVelocity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-maxDepenetrationVelocity.html", 
					"");
				break;

			case ComputeRigidBodyType.setMaxAngularVelocity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-maxAngularVelocity.html", 
					"");
				break;

			case ComputeRigidBodyType.setMass:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-mass.html", 
					"");
				break;

			case ComputeRigidBodyType.setIsKinemaic:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-isKinematic.html", 
					"");
				break;

			case ComputeRigidBodyType.setInertiaTensorRotation:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-inertiaTensorRotation.html", 
					"");
				break;

			case ComputeRigidBodyType.setInertiaTensor:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-inertiaTensor.html", 
					"");
				break;

			case ComputeRigidBodyType.setDrag:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-drag.html", 
					"");
				break;

			case ComputeRigidBodyType.setDetectCollisions:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-detectCollisions.html", 
					"");
				break;

			case ComputeRigidBodyType.SetDensity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.SetDensity.html", 
					"");
				break;

			case ComputeRigidBodyType.setCenterOfMass:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-centerOfMass.html", 
					"");
				break;

			case ComputeRigidBodyType.setAngularVelocity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-angularVelocity.html", 
					"");
				break;

			case ComputeRigidBodyType.setAngularDrag:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-angularDrag.html", 
					"");
				break;

			case ComputeRigidBodyType.ResetInertiaTensor:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.ResetInertiaTensor.html", 
					"");
				break;

			case ComputeRigidBodyType.ResetCenterOfMass:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.ResetCenterOfMass.html", 
					"");
				break;

			case ComputeRigidBodyType.MoveRotation:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.MoveRotation.html", 
					"");
				break;

			case ComputeRigidBodyType.MovePosition:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.MovePosition.html", 
					"");
				break;

			case ComputeRigidBodyType.IsSleeping:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.IsSleeping.html", 
					"");
				break;

			case ComputeRigidBodyType.getWorldCenterOfMass:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-worldCenterOfMass.html", 
					"");
				break;

			case ComputeRigidBodyType.getVelocity:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-velocity.html", 
					"");
				break;

			case ComputeRigidBodyType.getUseGravity:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-useGravity.html", 
					"");
				break;

			case ComputeRigidBodyType.getSolverIterations:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/530/Documentation/ScriptReference/Physics-solverIterationCount.html", 
					"");
				break;

			case ComputeRigidBodyType.getSleepThreshold:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-sleepThreshold.html", 
					"");
				break;

			case ComputeRigidBodyType.getRotation:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-rotation.html", 
					"");
				break;

			case ComputeRigidBodyType.GetRelativePointVelocity:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.GetRelativePointVelocity.html", 
					"");
				break;

			case ComputeRigidBodyType.getPosition:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-position.html", 
					"");
				break;

			case ComputeRigidBodyType.GetPointVelocity:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.GetPointVelocity.html", 
					"");
				break;

			case ComputeRigidBodyType.getMaxDepenetrationVelocity:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-maxDepenetrationVelocity.html", 
					"");
				break;

			case ComputeRigidBodyType.getMaxAngularVelocity:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-maxAngularVelocity.html", 
					"");
				break;

			case ComputeRigidBodyType.getMass:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-mass.html", 
					"");
				break;

			case ComputeRigidBodyType.getIsKinemaic:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-isKinematic.html", 
					"");
				break;

			case ComputeRigidBodyType.getInertiaTensorRotation:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-inertiaTensorRotation.html", 
					"");
				break;

			case ComputeRigidBodyType.getInertiaTensor:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-inertiaTensor.html", 
					"");
				break;

			case ComputeRigidBodyType.getDrag:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-drag.html", 
					"");
				break;

			case ComputeRigidBodyType.getDetectCollisions:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-detectCollisions.html", 
					"");
				break;

			case ComputeRigidBodyType.getCenterOfMass:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-centerOfMass.html", 
					"");
				break;

			case ComputeRigidBodyType.getAngularVelocity:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-angularVelocity.html", 
					"");
				break;

			case ComputeRigidBodyType.getAngularDrag:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody-angularDrag.html", 
					"");
				break;

			case ComputeRigidBodyType.ClosestPointOnBounds:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.ClosestPointOnBounds.html", 
					"");
				break;

			case ComputeRigidBodyType.ApplyForce:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html", 
					"");
				break;

			case ComputeRigidBodyType.AddTorque:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddTorque.html", 
					"");
				break;

			case ComputeRigidBodyType.AddRelativeTorque:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddRelativeTorque.html", 
					"");
				break;

			case ComputeRigidBodyType.AddRelativeForce:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddRelativeForce.html", 
					"");
				break;

			case ComputeRigidBodyType.AddForceAtPosition:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddForceAtPosition.html", 
					"");
				break;

			case ComputeRigidBodyType.AddExplosionForce:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddExplosionForce.html", 
					"");
				break;

			}
		}

		void AdsActivationWarningMessage ()
		{
			DrawInNodeInfo ("Switch platform to Android or IOS");
			DrawInNodeInfo ("Activate Ads");
			DrawInNodeInfo ("If activating Ads is not sufficient");
			DrawInNodeInfo ("Import the unity asset store Ads Package");
		}
		void ApplyComputeAds ()
		{
			ComputeAds_InputFields ();
			if (logic.playing)ComputeAds ();
			ComputeAds_OutputFields ();
		}
		public int computeAdsType_length = 0;
		public string computeAdsType_last;
		void ComputeAds_InputFields ()
		{
			AdsActivationWarningMessage ();

			computeAdsType = (ComputeAdsType)DrawEnumComputeType (computeAdsType, ref computeAdsType_length,
				ref computeAdsType_last, typeof (ComputeAdsType));

			switch (computeAdsType)
			{
			case ComputeAdsType.WhatWasTheShowAdResult:
				DrawStringListMenuToString_0 (
					"Result Was", new String []{"Finished", "Failed", "Skipped"}, new String [] {"",},
				0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);

				break;

			case ComputeAdsType.Show:
				DrawLogicNodeLabel ("Rewarded?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				break;

			case ComputeAdsType.setDebugMode:
				DrawBoolInputField (0);
				break;

			case ComputeAdsType.isSupported:

				break;

			case ComputeAdsType.isShowing:

				break;

			case ComputeAdsType.IsReady:

				break;

			case ComputeAdsType.isInitialized:

				break;

			case ComputeAdsType.Initialize:
				DrawLogicNodeLabel ("Game ID", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Test Mode?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				break;

			case ComputeAdsType.getVersion:

				break;

			case ComputeAdsType.GetPlacementState:
				DrawStringListMenuToString_0 (
					"Placement ID", new String [] {"video", "rewardedVideo"}, new String [] {"",},
				0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);

				break;

			//case ComputeAdsType.getIsTestMode:
			//
			//	break;
			//
			//case ComputeAdsType.getGameId:
			//
			//	break;

			case ComputeAdsType.getDebugMode:

				break;

			}
			DrawDoItButton();
		}
		void ComputeAds ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeAdsType)
			{
			case ComputeAdsType.WhatWasTheShowAdResult:
				WhatWasTheShowAdResult ();
				break;

			case ComputeAdsType.Show:
				if ( ! Application.isPlaying)
				{
					return;
				}
				ShowAd ();
				break;

			case ComputeAdsType.setDebugMode:
				if ( ! Application.isPlaying)
				{
					return;
				}
				#if UNITY_IOS || UNITY_ANDROID
				UnityEngine.Advertisements.Advertisement.debugMode = boolValues [0];
				#endif
				break;

			case ComputeAdsType.isSupported:
				if ( ! Application.isPlaying)
				{
					return;
				}
				#if UNITY_IOS || UNITY_ANDROID
				boolValue = UnityEngine.Advertisements.Advertisement.isSupported;
				#endif
				break;

			case ComputeAdsType.isShowing:
				if ( ! Application.isPlaying)
				{
					return;
				}
				#if UNITY_IOS || UNITY_ANDROID
				boolValue = UnityEngine.Advertisements.Advertisement.isShowing;
				#endif
				break;

			case ComputeAdsType.IsReady:
				if ( ! Application.isPlaying)
				{
					return;
				}
				#if UNITY_IOS || UNITY_ANDROID
				boolValue = UnityEngine.Advertisements.Advertisement.IsReady ();
				#endif
				break;

			case ComputeAdsType.isInitialized:
				if ( ! Application.isPlaying)
				{
					return;
				}
				#if UNITY_IOS || UNITY_ANDROID
				boolValue = UnityEngine.Advertisements.Advertisement.isInitialized;
				#endif
				break;

			case ComputeAdsType.Initialize:
				if ( ! Application.isPlaying)
				{
					return;
				}
				#if UNITY_IOS || UNITY_ANDROID
				UnityEngine.Advertisements.Advertisement.Initialize (stringValues [0], boolValues [0]);
				#endif
				break;

			case ComputeAdsType.getVersion:
				if ( ! Application.isPlaying)
				{
					return;
				}
				#if UNITY_IOS || UNITY_ANDROID
				stringValue = UnityEngine.Advertisements.Advertisement.version;
				#endif
				break;

			case ComputeAdsType.GetPlacementState:
				if ( ! Application.isPlaying)
				{
					return;
				}
				#if UNITY_IOS || UNITY_ANDROID
				stringValue = UnityEngine.Advertisements.Advertisement.GetPlacementState (stringValues [0]).ToString ();
				#endif
				break;

			//case ComputeAdsType.getIsTestMode:
			//	if ( ! Application.isPlaying)
			//	{
			//		return;
			//	}
			//	#if UNITY_IOS || UNITY_ANDROID
			//	boolValue = UnityEngine.Advertisements.Advertisement.testMode;
			//	#endif
			//	break;
			//
			//case ComputeAdsType.getGameId:
			//	if ( ! Application.isPlaying)
			//	{
			//		return;
			//	}
			//	#if UNITY_IOS || UNITY_ANDROID
			//	stringValue = UnityEngine.Advertisements.Advertisement.gameId;
			//	#endif
			//	break;

			case ComputeAdsType.getDebugMode:
				if ( ! Application.isPlaying)
				{
					return;
				}
				#if UNITY_IOS || UNITY_ANDROID
				boolValue = UnityEngine.Advertisements.Advertisement.debugMode;
				#endif
				break;

			}
		}
		void ComputeAds_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeAdsType)
			{
			case ComputeAdsType.WhatWasTheShowAdResult:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"This logic node indicates by true/false if the Ad had one of the following results:",
					"Finished -> Indicates that the advertisement completed successfully. Or",
					"Failed -> Indicates that the advertisement failed to complete. Or",
					"Skipped -> Indicates that the advertisement was skipped.",
					"",
					"Click the button 'Is The Ad Result Was' to choose one from the above list",
					"",
					"This logic node is usually used with the Do It button set to Always Do It,",
					"So you are always checking the Ads results",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			case ComputeAdsType.Show:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Show an advertisement in your project.",
					"If you choose 'Rewarded', tha ad result can be:",
					"Finished -> Indicates that the advertisement completed successfully. Or",
					"Failed -> Indicates that the advertisement failed to complete. Or",
					"Skipped -> Indicates that the advertisement was skipped.",
					"",
					"To know the Ads result use the logic node 'What Was The Show Ad Result',",
					"this node returns a bool that tells information about the Ads result,",
					"so you can use this bool to Invoke actions.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement.Show.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			case ComputeAdsType.setDebugMode:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Controls the amount of logging output from the advertisement system.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-debugMode.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			case ComputeAdsType.isSupported:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns if the current platform is supported by the advertisement system.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-isSupported.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			case ComputeAdsType.isShowing:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns whether an advertisement is currently being shown.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-isShowing.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			case ComputeAdsType.IsReady:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns whether an advertisement is ready to be shown. ",
					"Placements are configured per",
					" game in the UnityAds admin site, ",
					"where you can also set your default placement.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement.IsReady.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			case ComputeAdsType.isInitialized:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns whether the advertisement system is initialized successfully.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-isInitialized.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			case ComputeAdsType.Initialize:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Manually initializes the advertisement system. ",
					"Normally this is done from editor, and you should only ",
					"call this method if you are using UnityAds with automatic initialization disabled.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement.Initialize.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			case ComputeAdsType.getVersion:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the current Unity Ads version.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-version.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			case ComputeAdsType.GetPlacementState:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the placement state.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement.GetPlacementState.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			//case ComputeAdsType.getIsTestMode:
			//	DrawBoolResultField ();
			//
			//	documentationMessage = 
			//		new string[]
			//	{
			//		"",
			//		"",
			//		"Returns whether the testing mode is enabled.",
			//	};
			//
			//	DrawDocumentationBoxUpRight (documentationMessage);
			//	DrawDocumentationUrlButtons (documentationMessage, 
			//		"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-testMode.html", 
			//		"");
			//	break;
			//
			//case ComputeAdsType.getGameId:
			//	DrawStringResultField (true);
			//
			//	documentationMessage = 
			//		new string[]
			//	{
			//		"",
			//		"",
			//		"Returns the game identifier for the current platform.",
			//	};
			//
			//	DrawDocumentationBoxUpRight (documentationMessage);
			//	DrawDocumentationUrlButtons (documentationMessage, 
			//		"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-gameId.html", 
			//		"");
			//	break;

			case ComputeAdsType.getDebugMode:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Controls the amount of logging output from the advertisement system.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-debugMode.html", 
					"http://mezanix.com/portfolio/diamond-1-1-7f3-documentation-ads/");
				break;

			}
		}


		void ApplyComputeMouseInput ()
		{
			ComputeMouseInput_InputFields ();
			if (logic.playing)ComputeMouseInput ();
			ComputeMouseInput_OutputFields ();
		}
		public int computeMouseInputType_length = 0;
		public string computeMouseInputType_last;
		void ComputeMouseInput_InputFields ()
		{


			computeMouseInputType = (ComputeMouseInputType)DrawEnumComputeType (computeMouseInputType,
				ref computeMouseInputType_length, ref computeMouseInputType_last, typeof(ComputeMouseInputType));

			switch (computeMouseInputType)
			{
			case ComputeMouseInputType.getMouseScrollDelta:

				break;

			case ComputeMouseInputType.getMousePresent:

				break;

			case ComputeMouseInputType.getMousePosition:
				DrawInNodeInfo ("First Person Cameras may lock the cursor");
				DrawInNodeInfo ("Get position after freeing the Cursor");
				break;

			}
		}
		void ComputeMouseInput ()
		{
			switch (computeMouseInputType)
			{
			case ComputeMouseInputType.getMouseScrollDelta:
				vector2Value = Input.mouseScrollDelta;
				break;

			case ComputeMouseInputType.getMousePresent:
				boolValue = Input.mousePresent;
				break;

			case ComputeMouseInputType.getMousePosition:
				Cursor.lockState = CursorLockMode.None;
				vector3Value = Input.mousePosition;
				break;

			}
		}
		void ComputeMouseInput_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeMouseInputType)
			{
			case ComputeMouseInputType.getMouseScrollDelta:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-mouseScrollDelta.html", 
					"");
				break;

			case ComputeMouseInputType.getMousePresent:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-mousePresent.html", 
					"");
				break;

			case ComputeMouseInputType.getMousePosition:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"In the Logic Type: 'Unity Input Class and Cross Platform'",
					"you can also get the 'Mouse Position'",
					"but without freeing the cursor.",
					"Here you get the mouse position after freeing the cursor.",
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-mousePosition.html", 
					"");
				break;

			}
		}

		void ApplyComputeRay ()
		{
			ResetRayCastHitInfos ();

			ComputeRay_InputFields ();
			if (logic.playing)ComputeRay ();
			ComputeRay_OutputFields ();
		}
		public int computeRayType_length = 0;
		public string computeRayType_last;
		void ComputeRay_InputFields ()
		{
			//bool linkedOrAttachedTo = IsGameObject_0_InputLinked () || IsGameObject_0_AttachedTo ();

		

			computeRayType = (ComputeRayType)DrawEnumComputeType (computeRayType, ref computeRayType_length,
				ref computeRayType_last, typeof(ComputeRayType));

			switch (computeRayType)
			{
			case ComputeRayType.Raycast:
				DrawLogicNodeLabel ("Origine");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("Direction");
				DrawVector3InputField (1);
				DrawLogicNodeLabel ("Distance", 0, 2);
				DrawFloatInputField (0, 1, 2);
				DrawLogicNodeLabel ("Layer Mask (-1 for everything)");
				DrawIntInputField (0);
				intValues [0] = Mathf.Clamp (intValues [0], -1, 31);
				DrawLogicNodeLabel ("Query Trigger Interaction");
				DrawQueryTriggerInteractionEnum ();
				break;

			}
			DrawDoItButton();
		}
		void ComputeRay ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeRayType)
			{
			case ComputeRayType.Raycast:
				boolValue = Physics.Raycast (vector3Values [0], vector3Values [1],
					out hit, floatValues [0], intValues [0], queryTriggerInteraction);

				AssignRayCasthitInfos ();

				DebugRay (vector3Values [0], vector3Values [1], floatValues [0]);
				break;

			}
		}
		void ComputeRay_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeRayType)
			{
			case ComputeRayType.Raycast:
				DrawSweepTestResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Physics.Raycast.html", 
					"");
				break;

			}
		}

		void ApplyComputeRigidBody2D ()
		{
			ComputeRigidbody2D_InputFields();
			ComputeRigidbody2D();
			ComputeRigidbody2D_OutputFields ();
		}
		public int computeRigidBody2DType_length = 0;
		public string computeRigidBody2DType_last;

		public int forceMode2D_length = 0;
		public string forceMode2D_last;

		void DrawEnumForceMode2D () 
		{
			forceMode2D = (ForceMode2D)DrawEnum (forceMode2D,
			ref forceMode2D_length, ref forceMode2D_last, typeof(ForceMode2D), FieldDrawType.label, 1, 2);
		}

		void ComputeRigidbody2D_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeRigidBody2DType = (ComputeRigidBody2DType)DrawEnumComputeType (computeRigidBody2DType,
						ref computeRigidBody2DType_length, ref computeRigidBody2DType_last, typeof(ComputeRigidBody2DType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				rigidBody2D = gameObjectValues [0].GetComponent <Rigidbody2D>();

				if (rigidBody2D == null)
				{
					DrawInNodeInfo ("Add Rigidbody2D To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						rigidBody2D == null;

					return;
				}

			}
			computeRigidBody2DType = (ComputeRigidBody2DType)DrawEnumComputeType (computeRigidBody2DType,
				ref computeRigidBody2DType_length, ref computeRigidBody2DType_last, typeof(ComputeRigidBody2DType));
			

			switch (computeRigidBody2DType)
			{
			case ComputeRigidBody2DType.WakeUp:

				break;

			case ComputeRigidBody2DType.Sleep:

				break;

			case ComputeRigidBody2DType.setVelocity:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.setUseAutoMass:
				DrawBoolInputField (0);
				break;

			case ComputeRigidBody2DType.setSimulated:
				DrawBoolInputField (0);
				break;

			case ComputeRigidBody2DType.setRotation:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBody2DType.setPosition:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.setMass:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBody2DType.setIsKinematic:
				DrawBoolInputField (0);
				break;

			case ComputeRigidBody2DType.setInertia:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBody2DType.setGravityScale:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBody2DType.setFreezeRotation:
				DrawBoolInputField (0);
				break;

			case ComputeRigidBody2DType.setDrag:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBody2DType.setCenterOfMass:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.setAngularVelocity:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBody2DType.setAngularDrag:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBody2DType.MoveRotation:
				DrawFloatInputField (0);
				break;

			case ComputeRigidBody2DType.MovePosition:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.IsTouchingLayers:
				DrawIntInputField (0);
				break;

			case ComputeRigidBody2DType.IsTouching:
				DrawGameObjectFieldInput (1);				if (gameObjectValues [1] == null)
				{
					DrawInNodeInfo ("Fill in GameObject field");

					return;
				}				collider2D_1 = gameObjectValues [1].GetComponent<Collider2D> ();

				if (collider2D_1 == null)
				{
					DrawInNodeInfo ("Add Collider2D To GameObject");

					return;
				}
				break;

			case ComputeRigidBody2DType.IsSleeping:

				break;

			case ComputeRigidBody2DType.IsAwake:

				break;

			case ComputeRigidBody2DType.getWorldCenterOfMass:

				break;

			case ComputeRigidBody2DType.getVelocity:

				break;

			case ComputeRigidBody2DType.GetVector:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.getUseAutoMass:

				break;

			case ComputeRigidBody2DType.getSimulated:

				break;

			case ComputeRigidBody2DType.getRotation:

				break;

			case ComputeRigidBody2DType.GetRelativeVector:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.GetRelativePointVelocity:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.GetRelativePoint:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.getPosition:

				break;

			case ComputeRigidBody2DType.GetPointVelocity:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.GetPoint:
				DrawVector2InputField (0);
				break;

			case ComputeRigidBody2DType.getMass:

				break;

			case ComputeRigidBody2DType.getIsKinematic:

				break;

			case ComputeRigidBody2DType.getInertia:

				break;

			case ComputeRigidBody2DType.getGravityScale:

				break;

			case ComputeRigidBody2DType.getFreezeRotation:

				break;

			case ComputeRigidBody2DType.getDrag:

				break;

			case ComputeRigidBody2DType.getCenterOfMass:

				break;

			case ComputeRigidBody2DType.getAngularVelocity:

				break;

			case ComputeRigidBody2DType.getAngularDrag:

				break;



			case ComputeRigidBody2DType.ApplyForce:
				DrawLogicNodeLabel ("Force", 0, 2);
				DrawVector2InputField (0, 1, 2);

				DrawLogicNodeLabel ("Force Mode", 0, 2);
				DrawEnumForceMode2D ();
				break;

			case ComputeRigidBody2DType.AddTorque:
				DrawLogicNodeLabel ("Torque", 0, 2);
				DrawFloatInputField (0, 1, 2);
			
				DrawLogicNodeLabel ("Force Mode", 0, 2);
				DrawEnumForceMode2D ();
				break;

			case ComputeRigidBody2DType.AddRelativeForce:
				DrawLogicNodeLabel ("Relarive Force", 0, 2);
				DrawVector2InputField (0, 1, 2);

				DrawLogicNodeLabel ("Force Mode", 0, 2);
				DrawEnumForceMode2D ();
				break;

			case ComputeRigidBody2DType.AddForceAtPosition:
				DrawLogicNodeLabel ("Force", 0, 2);
				DrawVector2InputField (0, 1, 2);
				DrawLogicNodeLabel ("Position", 0, 2);
				DrawVector2InputField (1, 1, 2);

				break;

			}
			DrawDoItButton();
		}
		void ComputeRigidbody2D ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeRigidBody2DType)
			{
			case ComputeRigidBody2DType.WakeUp:
				rigidBody2D.WakeUp ();
				break;

			case ComputeRigidBody2DType.Sleep:
				rigidBody2D.Sleep ();
				break;

			case ComputeRigidBody2DType.setVelocity:
				rigidBody2D.velocity = vector2Values [0];
				break;

			case ComputeRigidBody2DType.setUseAutoMass:
				rigidBody2D.useAutoMass = boolValues [0];
				break;

			case ComputeRigidBody2DType.setSimulated:
				rigidBody2D.simulated = boolValues [0];
				break;

			case ComputeRigidBody2DType.setRotation:
				rigidBody2D.rotation = floatValues [0];
				break;

			case ComputeRigidBody2DType.setPosition:
				rigidBody2D.position = vector2Values [0];
				break;

			case ComputeRigidBody2DType.setMass:
				rigidBody2D.mass = floatValues [0];
				break;

			case ComputeRigidBody2DType.setIsKinematic:
				rigidBody2D.isKinematic = boolValues [0];
				break;

			case ComputeRigidBody2DType.setInertia:
				rigidBody2D.inertia = floatValues [0];
				break;

			case ComputeRigidBody2DType.setGravityScale:
				rigidBody2D.gravityScale = floatValues [0];
				break;

			case ComputeRigidBody2DType.setFreezeRotation:
				rigidBody2D.freezeRotation = boolValues [0];
				break;

			case ComputeRigidBody2DType.setDrag:
				rigidBody2D.drag = floatValues [0];
				break;

			case ComputeRigidBody2DType.setCenterOfMass:
				rigidBody2D.centerOfMass = vector2Values [0];
				break;

			case ComputeRigidBody2DType.setAngularVelocity:
				rigidBody2D.angularVelocity = floatValues [0];
				break;

			case ComputeRigidBody2DType.setAngularDrag:
				rigidBody2D.angularDrag = floatValues [0];
				break;

			case ComputeRigidBody2DType.MoveRotation:
				rigidBody2D.MoveRotation (floatValues [0]);
				break;

			case ComputeRigidBody2DType.MovePosition:
				rigidBody2D.MovePosition (vector2Values [0]);
				break;

			case ComputeRigidBody2DType.IsTouchingLayers:
				boolValue = rigidBody2D.IsTouchingLayers (intValues [0]);
				break;

			case ComputeRigidBody2DType.IsTouching:
				if (gameObjectValues [1] != null)
				{
					collider2D_1 = gameObjectValues [1].GetComponent<Collider2D>();

					if (collider2D_1 != null)
					{
						boolValue = rigidBody2D.IsTouching (collider2D_1);
					}
				}
				break;

			case ComputeRigidBody2DType.IsSleeping:
				boolValue = rigidBody2D.IsSleeping ();
				break;

			case ComputeRigidBody2DType.IsAwake:
				boolValue = rigidBody2D.IsAwake ();
				break;

			case ComputeRigidBody2DType.getWorldCenterOfMass:
				vector2Value = rigidBody2D.worldCenterOfMass;
				break;

			case ComputeRigidBody2DType.getVelocity:
				vector2Value = rigidBody2D.velocity;
				break;

			case ComputeRigidBody2DType.GetVector:
				vector2Value = rigidBody2D.GetVector (vector2Values [0]);
				break;

			case ComputeRigidBody2DType.getUseAutoMass:
				boolValue = rigidBody2D.useAutoMass;
				break;

			case ComputeRigidBody2DType.getSimulated:
				boolValue = rigidBody2D.simulated;
				break;

			case ComputeRigidBody2DType.getRotation:
				floatValue = rigidBody2D.rotation;
				break;

			case ComputeRigidBody2DType.GetRelativeVector:
				vector2Value = rigidBody2D.GetRelativeVector (vector2Values [0]);
				break;

			case ComputeRigidBody2DType.GetRelativePointVelocity:
				vector2Value = rigidBody2D.GetRelativePointVelocity (vector2Values [0]);
				break;

			case ComputeRigidBody2DType.GetRelativePoint:
				vector2Value = rigidBody2D.GetRelativePoint (vector2Values [0]);
				break;

			case ComputeRigidBody2DType.getPosition:
				vector2Value = rigidBody2D.position;
				break;

			case ComputeRigidBody2DType.GetPointVelocity:
				vector2Value = rigidBody2D.GetPointVelocity (vector2Values [0]);
				break;

			case ComputeRigidBody2DType.GetPoint:
				vector2Value = rigidBody2D.GetPoint (vector2Values [0]);
				break;

			case ComputeRigidBody2DType.getMass:
				floatValue = rigidBody2D.mass;
				break;

			case ComputeRigidBody2DType.getIsKinematic:
				boolValue = rigidBody2D.isKinematic;
				break;

			case ComputeRigidBody2DType.getInertia:
				floatValue = rigidBody2D.inertia;
				break;

			case ComputeRigidBody2DType.getGravityScale:
				floatValue = rigidBody2D.gravityScale;
				break;

			case ComputeRigidBody2DType.getFreezeRotation:
				boolValue = rigidBody2D.freezeRotation;
				break;

			case ComputeRigidBody2DType.getDrag:
				floatValue = rigidBody2D.drag;
				break;

			case ComputeRigidBody2DType.getCenterOfMass:
				vector2Value = rigidBody2D.centerOfMass;
				break;

			case ComputeRigidBody2DType.getAngularVelocity:
				floatValue = rigidBody2D.angularVelocity;
				break;

			case ComputeRigidBody2DType.getAngularDrag:
				floatValue = rigidBody2D.angularDrag;
				break;

			case ComputeRigidBody2DType.ApplyForce:
				rigidBody2D.AddForce (vector2Values [0], forceMode2D);
				break;

			case ComputeRigidBody2DType.AddTorque:
				rigidBody2D.AddTorque (floatValues [0], forceMode2D);
				break;

			case ComputeRigidBody2DType.AddRelativeForce:
				rigidBody2D.AddRelativeForce (vector2Values [0], forceMode2D);
				break;

			case ComputeRigidBody2DType.AddForceAtPosition:
				rigidBody2D.AddForceAtPosition (vector2Values [0], vector2Values [1]);
				break;

			}
		}
		void ComputeRigidbody2D_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeRigidBody2DType)
			{
			case ComputeRigidBody2DType.WakeUp:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.WakeUp.html", 
					"");
				break;

			case ComputeRigidBody2DType.Sleep:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.Sleep.html", 
					"");
				break;

			case ComputeRigidBody2DType.setVelocity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html", 
					"");
				break;

			case ComputeRigidBody2DType.setUseAutoMass:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-useAutoMass.html", 
					"");
				break;

			case ComputeRigidBody2DType.setSimulated:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-simulated.html", 
					"");
				break;

			case ComputeRigidBody2DType.setRotation:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-rotation.html", 
					"");
				break;

			case ComputeRigidBody2DType.setPosition:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-position.html", 
					"");
				break;

			case ComputeRigidBody2DType.setMass:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-mass.html", 
					"");
				break;

			case ComputeRigidBody2DType.setIsKinematic:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-isKinematic.html", 
					"");
				break;

			case ComputeRigidBody2DType.setInertia:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-inertia.html", 
					"");
				break;

			case ComputeRigidBody2DType.setGravityScale:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-gravityScale.html", 
					"");
				break;

			case ComputeRigidBody2DType.setFreezeRotation:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-freezeRotation.html", 
					"");
				break;

			case ComputeRigidBody2DType.setDrag:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-drag.html", 
					"");
				break;

			case ComputeRigidBody2DType.setCenterOfMass:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-centerOfMass.html", 
					"");
				break;

			case ComputeRigidBody2DType.setAngularVelocity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-angularVelocity.html", 
					"");
				break;

			case ComputeRigidBody2DType.setAngularDrag:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-angularDrag.html", 
					"");
				break;

			case ComputeRigidBody2DType.MoveRotation:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.MoveRotation.html", 
					"");
				break;

			case ComputeRigidBody2DType.MovePosition:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.MovePosition.html", 
					"");
				break;

			case ComputeRigidBody2DType.IsTouchingLayers:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.IsTouchingLayers.html", 
					"");
				break;

			case ComputeRigidBody2DType.IsTouching:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.IsTouching.html", 
					"");
				break;

			case ComputeRigidBody2DType.IsSleeping:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.IsSleeping.html", 
					"");
				break;

			case ComputeRigidBody2DType.IsAwake:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.IsAwake.html", 
					"");
				break;

			case ComputeRigidBody2DType.getWorldCenterOfMass:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-worldCenterOfMass.html", 
					"");
				break;

			case ComputeRigidBody2DType.getVelocity:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html", 
					"");
				break;

			case ComputeRigidBody2DType.GetVector:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetVector.html", 
					"");
				break;

			case ComputeRigidBody2DType.getUseAutoMass:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-useAutoMass.html", 
					"");
				break;

			case ComputeRigidBody2DType.getSimulated:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-simulated.html", 
					"");
				break;

			case ComputeRigidBody2DType.getRotation:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-rotation.html", 
					"");
				break;

			case ComputeRigidBody2DType.GetRelativeVector:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetRelativeVector.html", 
					"");
				break;

			case ComputeRigidBody2DType.GetRelativePointVelocity:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetRelativePointVelocity.html", 
					"");
				break;

			case ComputeRigidBody2DType.GetRelativePoint:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetRelativePoint.html", 
					"");
				break;

			case ComputeRigidBody2DType.getPosition:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-position.html", 
					"");
				break;

			case ComputeRigidBody2DType.GetPointVelocity:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetPointVelocity.html", 
					"");
				break;

			case ComputeRigidBody2DType.GetPoint:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetPoint.html", 
					"");
				break;

			case ComputeRigidBody2DType.getMass:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-mass.html", 
					"");
				break;

			case ComputeRigidBody2DType.getIsKinematic:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-isKinematic.html", 
					"");
				break;

			case ComputeRigidBody2DType.getInertia:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-inertia.html", 
					"");
				break;

			case ComputeRigidBody2DType.getGravityScale:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-gravityScale.html", 
					"");
				break;

			case ComputeRigidBody2DType.getFreezeRotation:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-freezeRotation.html", 
					"");
				break;

			case ComputeRigidBody2DType.getDrag:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-drag.html", 
					"");
				break;

			case ComputeRigidBody2DType.getCenterOfMass:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-centerOfMass.html", 
					"");
				break;

			case ComputeRigidBody2DType.getAngularVelocity:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-angularVelocity.html", 
					"");
				break;

			case ComputeRigidBody2DType.getAngularDrag:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-angularDrag.html", 
					"");
				break;

			case ComputeRigidBody2DType.ApplyForce:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.AddForce.html", 
					"");
				break;

			case ComputeRigidBody2DType.AddTorque:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.AddTorque.html", 
					"");
				break;

			case ComputeRigidBody2DType.AddRelativeForce:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.AddRelativeForce.html", 
					"");
				break;

			case ComputeRigidBody2DType.AddForceAtPosition:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.AddForceAtPosition.html", 
					"");
				break;

			}
		}

		static int intStatic;

		void ApplyComputeInt ()
		{
			ComputeInt_InputFields ();
			if (logic.playing)ComputeInt ();
			ComputeInt_OutputFields ();
		}public int computeIntType_length = 0;
		public string computeIntType_last;
		void ComputeInt_InputFields ()
		{
			

			computeIntType = (ComputeIntType)DrawEnumComputeType (computeIntType,
				ref computeIntType_length, ref computeIntType_last, typeof(ComputeIntType));

			switch (computeIntType)
			{
			case ComputeIntType.listenToTransferredData:
				DrawStringListMenuToString_0 (
					"Data Name", MezanixDiamondIntNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawIntInputField (0, 1, 2);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeIntType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawIntInputField (0, 1, 2);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeIntType.loop:
				DrawLogicNodeLabel ("From", 0, 2);
				DrawIntInputField (0, 1, 2);				
				DrawLogicNodeLabel ("To (excluded)", 0, 2);
				DrawIntInputField (1, 1, 2);
				break;

			case ComputeIntType.MultiplicativeInverse:
				DrawIntInputField (0);
				break;

			case ComputeIntType.modulo:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.multiplyWithVector4:
				DrawIntInputField (0);
				//DrawLogicNodeLabel ("Vector4 Value");
				DrawVector4InputField (0);
				break;

			case ComputeIntType.multiplyWithVector3:
				DrawIntInputField (0);
				//DrawLogicNodeLabel ("Vector3 Value");
				DrawVector3InputField (0);
				break;

			case ComputeIntType.multiplyWithVector2:
				DrawIntInputField (0);				
				//DrawLogicNodeLabel ("Vector2 Value");
				DrawVector2InputField (0);
				break;

			case ComputeIntType.multiplyWithFloatOutInt:
				DrawIntInputField (0);				
				DrawLogicNodeLabel ("Float Value", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case ComputeIntType.multiplyWithFloatOutFloat:
				DrawIntInputField (0);
				DrawLogicNodeLabel ("Float Value", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case ComputeIntType.max:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.min:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.incrementStaticWithInit:
				DrawLogicNodeLabel ("Init?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawLogicNodeLabel ("Initial value", 0, 2);
				DrawIntInputField (1, 1, 2);
				DrawLogicNodeLabel ("Increment value", 0, 2);
				DrawIntInputField (0, 1, 2);
				break;

			case ComputeIntType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_int_DrawInputs ();
				break;

			case ComputeIntType.or:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.shiftOperatorOfOne:
				DrawLogicNodeLabel ("Shifting value", 0, 2);
				DrawIntInputField (0, 1, 2);
				DrawLogicNodeLabel ("Inverse it", 0, 2);
				DrawBoolInputField (0, 3, 4);
				break;

			case ComputeIntType.incrementStatic:
				DrawIntInputField (0);
				break;

			case ComputeIntType.increment:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.Switch:
				DrawLogicNodeLabel ("Want this value?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawIntInputField (0);
				DrawLogicNodeLabel ("Or this One?", 0, 2);
				DrawBoolInputField (1, 3, 4);
				DrawIntInputField (1);
				break;

			case ComputeIntType.readItFromPlayerPrefs:

				DrawLogicNodeLabel ("With key", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case ComputeIntType.saveItInPlayerPrefs:
				DrawIntInputField (0);
				DrawLogicNodeLabel ("With key", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case ComputeIntType.isEqualTo:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.isNotEqualTo:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.isGreaterThan:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.isGreaterOrEqualThan:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.isSmallerOrEqualThan:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.isSmallerThan:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.toString:
				DrawIntInputField (0);
				break;

			case ComputeIntType.subtract:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.random:
				DrawLogicNodeLabel ("Seed", 0, 2);
				DrawIntInputField (2, 1, 2);
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.multiply:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.divide:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			case ComputeIntType.clamp:
				DrawIntInputField (0);
				DrawIntInputField (1);
				DrawIntInputField (2);
				break;

			case ComputeIntType.add:
				DrawIntInputField (0);
				DrawIntInputField (1);
				break;

			}
			if (computeIntType == ComputeIntType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeInt ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeIntType)
			{
			case ComputeIntType.listenToTransferredData:
				intValue = MezanixDiamondGetInt (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveInt(stringValues [0]);
				}
				break;

			case ComputeIntType.sendMeAsTransferredData:
				MezanixDiamondSetInt (stringValues [0]);

				break;

			case ComputeIntType.loop:
				Loop ();
				break;

			case ComputeIntType.MultiplicativeInverse:
				if (intValues [0] != 0)
				{
					floatValue = 1f / (float)intValues [0];
				}
				else
				{
					floatValue = (float)intValues [0];
				}
				break;

			case ComputeIntType.modulo:
				if (intValues [1] != 0)
				{
					intValue = intValues [0] % intValues [1];
				}
				else
				{
					intValue = intValues [0];
				}
				break;

			case ComputeIntType.multiplyWithVector4:
				vector4Value = (float)intValues [0] * vector4Values [0];
				break;

			case ComputeIntType.multiplyWithVector3:
				vector3Value = (float)intValues [0] * vector3Values [0];
				break;

			case ComputeIntType.multiplyWithVector2:
				vector2Value = (float)intValues [0] * vector2Values [0];
				break;

			case ComputeIntType.multiplyWithFloatOutInt:
				intValue = (int)((float)intValues [0] * floatValues [0]);
				break;

			case ComputeIntType.multiplyWithFloatOutFloat:
				floatValue = (float)intValues [0] * floatValues [0];
				break;

			case ComputeIntType.max:
				intValue = Mathf.Max (intValues [0], intValues [1]);
				break;

			case ComputeIntType.min:
				intValue = Mathf.Min (intValues [0], intValues [1]);
				break;

			case ComputeIntType.incrementStaticWithInit:
				if (boolValues [0])
				{
					intStatic = intValues [1];
				}
				intStatic += intValues [0];
				intValue = intStatic;
				break;

			case ComputeIntType.get:
				ForGet_int_Compute ();
				break;

			case ComputeIntType.or:
				intValue = intValues [0] | intValues [1];
				break;

			case ComputeIntType.shiftOperatorOfOne:
				if ( ! boolValues [0])
				{
					intValue = 1 << intValues [0];
				}
				else
				{
					intValue = ~(1 << intValues [0]);
				}
				break;

			case ComputeIntType.incrementStatic:
				intStatic += intValues [0];
				intValue = intStatic;
				break;

			case ComputeIntType.increment:
				intValue = intValues [0] + intValues [1];
				intValues [0] = intValue;
				break;

			case ComputeIntType.Switch:
				if (boolValues [0] && ! boolValues [1])
				{
					intValue = intValues [0];
				}
				if (boolValues [1] && ! boolValues [0])
				{
					intValue = intValues [1];
				}

				break;

			case ComputeIntType.readItFromPlayerPrefs:
				intValue = PlayerPrefs.GetInt (stringValues [0]);
				break;

			case ComputeIntType.saveItInPlayerPrefs:
				PlayerPrefs.SetInt (stringValues [0], intValues [0]);
				PlayerPrefs.Save ();
				break;

			case ComputeIntType.isEqualTo:
				boolValue = intValues [0] == intValues [1];
				break;

			case ComputeIntType.isNotEqualTo:
				boolValue = intValues [0] != intValues [1];
				break;

			case ComputeIntType.isGreaterThan:
				boolValue = intValues [0] > intValues [1];
				break;

			case ComputeIntType.isGreaterOrEqualThan:
				boolValue = intValues [0] >= intValues [1];
				break;

			case ComputeIntType.isSmallerOrEqualThan:
				boolValue = intValues [0] <= intValues [1];
				break;

			case ComputeIntType.isSmallerThan:
				boolValue = intValues [0] < intValues [1];
				break;

			case ComputeIntType.toString:
				stringValue = intValues [0].ToString ();
				break;

			case ComputeIntType.subtract:
				intValue = intValues [0] - intValues [1];
				break;

			case ComputeIntType.random:
				intValue = UnityEngine.Random.Range (intValues [0], intValues [1]);
				break;

			case ComputeIntType.multiply:
				intValue = intValues [0] * intValues [1];
				break;

			case ComputeIntType.divide:
				if (intValues [1] == 0)
				{
					intValue = intValues [0];
				}
				else
				{
					intValue = intValues [0] / intValues [1];
				}
				break;

			case ComputeIntType.clamp:
				intValue = Mathf.Clamp (intValues [0], intValues [1], intValues [2]);
				break;

			case ComputeIntType.add:
				intValue = intValues [0] + intValues [1];
				break;

			}
		}
		void ComputeInt_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeIntType)
			{
			case ComputeIntType.listenToTransferredData:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.loop:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Loop from the first to the second value.",
					"No matter if 'from' is greater or smaller than 'to',",
					"the loop can go in 2 directions",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.MultiplicativeInverse:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiplicative Inverse (One over) of the int value.",
					"The result type is float.",
					"If the int value is zero, ",
					"the result will be a zero of type float.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.modulo:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Compute the remainder after dividing the first int by the second one.",
					"If the second one is zero, the first int will be the result.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.multiplyWithVector4:
				DrawVector4ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiply an integere with an Vector4 and have result of type Vector4",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.multiplyWithVector3:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiply an integere with an Vector3 and have result of type Vector3",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.multiplyWithVector2:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiply an integere with an Vector2 and have result of type Vector2",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.multiplyWithFloatOutInt:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiply an integere with a float and have result of type int",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.multiplyWithFloatOutFloat:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiply an integere with a float and have result of type float",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.max:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the largest of two values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Mathf.Max.html", 
					"");
				break;

			case ComputeIntType.min:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the smallest of two values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Mathf.Min.html", 
					"");
				break;

			case ComputeIntType.incrementStaticWithInit:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"If DoIT enabled, increment the result value by the increment amount",
					"If the Init field is true, the result value will be reset to the initial value",
					"This is a static version of the increment node, you use it when you want",
					"To prevent your incremented value from being intitialized,",
					"because in the dynamic version of the incriment node, your incremented value",
					"could be initialized if the game object holding the generated script is destroyed",
					"or if an another object having tha same script on it is spawned in the scene.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.get:
				ForGet_int_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.or:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Perform or operator on two integer",
					"It is useful for combining layermasks",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.shiftOperatorOfOne:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the corresponding integer of a 1 shifted in binary, you can get also its binary inverse",
					"This is useful to use for defining layermasks",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.incrementStatic:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"If DoIT enabled, increment the result value by the amount of the first one.",
					"This is the static version of the increment node, you use it when you want",
					"To prevent your incremented value from being intitialized,",
					"because in the dynamic version of the incriment node, your incremented value",
					"could be initialized if the game object holding the generated script is destroyed",
					"or if an another object having tha same script on it is spawned in the scene.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.increment:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"If DoIT enabled, increment the first value by the amount of the second one.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.Switch:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the value corresponding of the checked box,",
					"if noth boxes have the same value, the node will not compute",
					"and it will conserve it's old output",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.readItFromPlayerPrefs:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the value corresponding to key in the preference file if it exists.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.GetInt.html", 
					"");
				break;

			case ComputeIntType.saveItInPlayerPrefs:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Sets the value of the preference identified by key.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.SetInt.html", 
					"");
				break;

			case ComputeIntType.isEqualTo:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is equal to the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.isNotEqualTo:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is not equal to the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.isGreaterThan:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is greater than the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.isGreaterOrEqualThan:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is greater or equal than the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.isSmallerOrEqualThan:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is smaller or equal than the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.isSmallerThan:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is smaller than the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.toString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get a string (phrase) version of the number",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.subtract:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Subtract two integer values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.random:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Returns a random integer number between min [inclusive] and",
					"max [exclusive] (Read Only).",
					"Note that max is exclusive, so using Random.Range( 0, 10 )",
					"will return values between 0 and 9. If max equals min, min will",
					"be returned.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Random.Range.html", 
					"");
				break;

			case ComputeIntType.multiply:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiply two integere values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.divide:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Divide the first integere by the second",
					"If the second integer is zero, the node returns the first value",
					"Note that divide with integeres gives rounded values.",
					"To obtain decimale precision use divide on float variable type",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.clamp:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Clamp the first value by the second and the third values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntType.add:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Add two integer values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeFloat ()
		{
			ComputeFloat_InputFields ();
			if (logic.playing)ComputeFloat ();
			ComputeFloat_OutputFields ();
		}
		public int computeFloatType_length= 0;
		public string computeFloatType_last;
		void ComputeFloat_InputFields ()
		{

			computeFloatType = (ComputeFloatType)DrawEnumComputeType (computeFloatType,
				ref computeFloatType_length, ref computeFloatType_last, typeof(ComputeFloatType));

			switch (computeFloatType)
			{
			case ComputeFloatType.listenToTransferredData:
				DrawStringListMenuToString_0 (
					"Data Name", MezanixDiamondFloatNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawFloatInputField (0, 1, 2);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeFloatType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawFloatInputField (0, 1, 2);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeFloatType.animationCurvePickValue:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value", 0, 2);
				DrawFloatInputField (0, 1, 2);
				DrawLogicNodeLabel ("End value", 0, 2);
				DrawFloatInputField (1, 1, 2);
				DrawLogicNodeLabel ("Pick time", 0, 2);
				DrawFloatInputField (2, 1, 2);
				floatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);

				break;

			case ComputeFloatType.animationCurve:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value", 0, 2);
				DrawFloatInputField (0, 1, 2);
				DrawLogicNodeLabel ("End value", 0, 2);
				DrawFloatInputField (1, 1, 2);
				DrawLogicNodeLabel ("Duration", 0, 2);
				DrawFloatInputField (2, 1, 2);
				floatValues [2] = Mathf.Max (0.1f, floatValues [2]);

				break;

			case ComputeFloatType.MultiplicativeInverse:
				DrawFloatInputField (0);
				break;

			case ComputeFloatType.modulo:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.max:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.min:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_float_DrawInputs ();
				break;

			case ComputeFloatType.Switch:
				DrawLogicNodeLabel ("Want this value?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawFloatInputField (0);
				DrawLogicNodeLabel ("Or this One?", 0, 2);
				DrawBoolInputField (1, 3, 4);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.readItFromPlayerPrefs:

				DrawLogicNodeLabel ("With key", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case ComputeFloatType.saveItInPlayerPrefs:
				DrawFloatInputField (0);
				DrawLogicNodeLabel ("With key", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case ComputeFloatType.isEqualTo:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.isNotEqualTo:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.isGreaterThan:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.isGreaterOrEqualThan:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.isSmallerOrEqualThan:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.isSmallerThan:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.toString:
				DrawFloatInputField (0);
				break;

			case ComputeFloatType.repeat:
				DrawLogicNodeLabel ("Value to Repeat", 0, 2);
				DrawFloatInputField (0, 1, 2);
				DrawLogicNodeLabel ("Length", 0, 2);
				DrawFloatInputField (1, 1, 2);
				break;

			case ComputeFloatType.sigmoid:
				DrawLogicNodeLabel ("Map me to 0, 1", 0, 2);
				DrawFloatInputField (0, 1, 2);
				DrawLogicNodeLabel ("Sigmoid speed", 0, 2);
				DrawFloatInputField (1, 1, 2);
				floatValues [1] = Mathf.Max (floatValues [1], 0f);

				break;

			case ComputeFloatType.subtract:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.random:
				DrawLogicNodeLabel ("Seed", 0, 2);
				DrawIntInputField (2, 1, 2);
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.multiply:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.divide:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			case ComputeFloatType.clamp:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				DrawFloatInputField (2);
				break;

			case ComputeFloatType.add:
				DrawFloatInputField (0);
				DrawFloatInputField (1);
				break;

			}
			if (computeFloatType == ComputeFloatType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeFloat ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeFloatType)
			{
			case ComputeFloatType.listenToTransferredData:
				floatValue = MezanixDiamondGetFloat (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveFloat(stringValues [0]);
				}
				break;

			case ComputeFloatType.sendMeAsTransferredData:
				MezanixDiamondSetFloat (stringValues [0]);

				break;

			case ComputeFloatType.animationCurvePickValue:
				floatValue = Mathf.Lerp (floatValues [0], floatValues [1], animationCurve_.Evaluate (floatValues [2]));
				break;

			case ComputeFloatType.animationCurve:
				//forMeMezanix_3_Idle_Ht.forMeMezanix_3_Idle.forMeMezanix_3.StartCoroutine (RunAnimationCurve_float ());
				break;

			case ComputeFloatType.MultiplicativeInverse:
				if (floatValues [0] != 0f)
				{
					floatValue = 1f / floatValues [0];
				}
				else
				{
					floatValue = floatValues [0];
				}
				break;

			case ComputeFloatType.modulo:
				if (floatValues [1] != 0f)
				{
					floatValue = floatValues [0] % floatValues [1];
				}
				else
				{
					floatValue = floatValues [0];
				}
				break;

			case ComputeFloatType.max:
				floatValue = Mathf.Max (floatValues [0], floatValues [1]);
				break;

			case ComputeFloatType.min:
				floatValue = Mathf.Min (floatValues [0], floatValues [1]);
				break;

			case ComputeFloatType.get:
				ForGet_float_Compute ();
				break;

			case ComputeFloatType.Switch:
				if (boolValues [0] && ! boolValues [1])
				{
					floatValue = floatValues [0];
				}
				if (boolValues [1] && ! boolValues [0])
				{
					floatValue = floatValues [1];
				}

				break;

			case ComputeFloatType.readItFromPlayerPrefs:
				floatValue = PlayerPrefs.GetFloat (stringValues [0]);
				break;

			case ComputeFloatType.saveItInPlayerPrefs:
				PlayerPrefs.SetFloat (stringValues [0], floatValues [0]);
				PlayerPrefs.Save ();
				break;

			case ComputeFloatType.isEqualTo:
				boolValue = floatValues [0] == floatValues [1];
				break;

			case ComputeFloatType.isNotEqualTo:
				boolValue = floatValues [0] != floatValues [1];
				break;

			case ComputeFloatType.isGreaterThan:
				boolValue = floatValues [0] > floatValues [1];
				break;

			case ComputeFloatType.isGreaterOrEqualThan:
				boolValue = floatValues [0] >= floatValues [1];
				break;

			case ComputeFloatType.isSmallerOrEqualThan:
				boolValue = floatValues [0] <= floatValues [1];
				break;

			case ComputeFloatType.isSmallerThan:
				boolValue = floatValues [0] < floatValues [1];
				break;

			case ComputeFloatType.toString:
				stringValue = floatValues [0].ToString ();
				break;

			case ComputeFloatType.repeat:
				floatValue = Mathf.Repeat (floatValues [0], floatValues [1]);
				break;

			case ComputeFloatType.sigmoid:
				floatValue = 1f / (1f + Mathf.Exp ((-1f)*floatValues[0]*floatValues[1]));
				break;

			case ComputeFloatType.subtract:
				floatValue = floatValues [0] - floatValues [1];
				break;

			case ComputeFloatType.random:
				floatValue = UnityEngine.Random.Range (floatValues [0], floatValues [1]);
				break;

			case ComputeFloatType.multiply:
				floatValue = floatValues [0] * floatValues [1];
				break;

			case ComputeFloatType.divide:
				if (floatValues [1] == 0f)
				{
					floatValue = floatValues [0];
				}
				else
				{
					floatValue = floatValues [0] / floatValues [1];
				}
				break;

			case ComputeFloatType.clamp:
				floatValue = Mathf.Clamp (floatValues [0], floatValues [1], floatValues [2]);
				break;

			case ComputeFloatType.add:
				floatValue = floatValues [0] + floatValues [1];
				break;

			}
		}
		void ComputeFloat_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeFloatType)
			{
			case ComputeFloatType.listenToTransferredData:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.animationCurvePickValue:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Pick a float value on a curve,",
					"between the start and the end value.",
					"You have to choose the time corresponding to your value",
					"The time is the horizontal axis of the curve.",
					"The picked float, the start and the end floats are on the",
					"vertical axis of the curve",
					"",
					"About the horizontal axis:",
					"This axis is commonly called time, but in the case of this node",
					"it is an axis having values from 0 to 1 (normalized),",
					"so this node is usful for drawing any curves shape and picking",
					"a float value (vertical axis) on the curve corresponding of any",
					"position in the horizontal axis, 0 is the left of the horizontal axis,",
					"1 is its right and between them is a value on the axis.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.animationCurve:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Animate a float value on a curve,",
					"between the start and the end value.",
					"You have to define the animation time (duration).",
					"The time is the horizontal axis of the curve.",
					"The animated float, the start and the end floats are on the",
					"vertical axis of the curve",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.MultiplicativeInverse:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiplicative Inverse (One over) of the float value.",
					"The result type is float.",
					"If the float value is zero, ",
					"the result will be a zero of type float.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.modulo:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Compute the remainder after dividing the first float by the second one.",
					"If the second one is zero, the first float will be the result.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.max:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the largest of two values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Mathf.Max.html", 
					"");
				break;

			case ComputeFloatType.min:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the smallest of two values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Mathf.Min.html", 
					"");
				break;

			case ComputeFloatType.get:
				ForGet_float_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.Switch:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the value corresponding of the checked box,",
					"if noth boxes have the same value, the node will not compute",
					"and it will conserve it's old output",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.readItFromPlayerPrefs:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the value corresponding to key in the preference file if it exists.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.GetFloat.html", 
					"");
				break;

			case ComputeFloatType.saveItInPlayerPrefs:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Sets the value of the preference identified by key.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.SetFloat.html", 
					"");
				break;

			case ComputeFloatType.isEqualTo:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is equal to the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.isNotEqualTo:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is not equal to the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.isGreaterThan:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is greater than the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.isGreaterOrEqualThan:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is greater or equal than the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.isSmallerOrEqualThan:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is smaller or equal than the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.isSmallerThan:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first value is smaller than the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.toString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get a string (phrase) version of the number",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.repeat:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Loops the value t, so that it is never larger than length and never smaller than 0.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Mathf.Repeat.html", 
					"");
				break;

			case ComputeFloatType.sigmoid:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Every 'decimal' value is mapped to the zero : one interval.",
					"negative infinity mapped to zero, infinity mapped to One,",
					"and zero is mapped to 0.5",
					"Putting the Sigmoid speed to 0 will always return 0.5",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"http://mezanix.com/portfolio/sigmoid/");
				break;

			case ComputeFloatType.subtract:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Subtract two decimal values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.random:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Returns a random float number between and min [inclusive] and max [inclusive]",
					"(Read Only).",
					"Note that max is inclusive, so using Random.Range( 0.0f, 1.0f )",
					"could return 1.0 as a value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Random.Range.html", 
					"");
				break;

			case ComputeFloatType.multiply:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiply two decimal values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.divide:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Divide the first decimal by the second",
					"If the second decimal is zero, the node returns the first value",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.clamp:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Clamp the first value by the second and the third values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatType.add:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Add two decimal values",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeVector2 ()
		{
			ComputeVector2_InputFields ();
			if (logic.playing)ComputeVector2 ();
			ComputeVector2_OutputFields ();
		}
		public int computeVector2Type_length = 0;
		public string computeVector2Type_last;
		void ComputeVector2_InputFields ()
		{
			
			computeVector2Type = (ComputeVector2Type)DrawEnumComputeType (computeVector2Type,
				ref computeVector2Type_length, ref computeVector2Type_last, typeof(ComputeVector2Type));

			switch (computeVector2Type)
			{
			case ComputeVector2Type.listenToTransferredData:
				DrawStringListMenuToString_0 (
					"Data Name", MezanixDiamondVector2Names (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawVector2InputField (0, 1, 2);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeVector2Type.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawVector2InputField (0, 1, 2);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeVector2Type.animationCurvePickValue:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value", 0, 2);
				DrawVector2InputField (0, 1, 2);
				DrawLogicNodeLabel ("End value", 0, 2);
				DrawVector2InputField (1, 1, 2);
				DrawLogicNodeLabel ("Pick time", 0, 2);
				DrawFloatInputField (2, 1, 2);
				floatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);

				break;

			case ComputeVector2Type.animationCurve:
				DrawAnimationCurveInputField ();
				DrawLogicNodeLabel ("Start value", 0, 2);
				DrawVector2InputField (0, 1, 2);
				DrawLogicNodeLabel ("End value", 0, 2);
				DrawVector2InputField (1, 1, 2);
				DrawLogicNodeLabel ("Duration", 0, 2);
				DrawFloatInputField (2, 1, 2);
				floatValues [2] = Mathf.Max (0.1f, floatValues [2]);

				break;

			case ComputeVector2Type.max:
				DrawVector2InputField (0);
				DrawVector2InputField (1);
				break;

			case ComputeVector2Type.min:
				DrawVector2InputField (0);
				DrawVector2InputField (1);
				break;

			case ComputeVector2Type.normalize:
				DrawVector2InputField (0);
				break;

			case ComputeVector2Type.ClampMagnitude:
				DrawVector2InputField (0);
				DrawLogicNodeLabel ("Max Length", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case ComputeVector2Type.magnitude:
				DrawVector2InputField (0);
				break;

			case ComputeVector2Type.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 1, 2);
				ForGet_vector2_DrawInputs ();
				break;

			case ComputeVector2Type.toRect:
				DrawVector2InputField (0);
				DrawVector2InputField (1);
				break;

			case ComputeVector2Type.toString:
				DrawVector2InputField (0);
				break;

			case ComputeVector2Type.Switch:
				DrawLogicNodeLabel ("Want this value?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				DrawVector2InputField (0);
				DrawLogicNodeLabel ("Or this One?", 0, 2);
				DrawBoolInputField (1, 3, 4);
				DrawVector2InputField (1);
				break;

			case ComputeVector2Type.subtract:
				DrawVector2InputField (0);
				DrawVector2InputField (1);
				break;

			case ComputeVector2Type.putThisFloatInY:
				DrawVector2InputField (0);				DrawFloatInputField (0);
				break;

			case ComputeVector2Type.putThisFloatInXY:
				DrawVector2InputField (0);				DrawFloatInputField (0);
				break;

			case ComputeVector2Type.putThisFloatInX:
				DrawVector2InputField (0);				DrawFloatInputField (0);
				break;

			case ComputeVector2Type.onUnitCircle:

				break;

			case ComputeVector2Type.multiply:
				DrawFloatInputField (0);
				DrawVector2InputField (0);
				break;

			case ComputeVector2Type.areParallel:
				DrawVector2InputField (0);
				DrawVector2InputField (1);
				break;

			case ComputeVector2Type.areOrthogonal:
				DrawVector2InputField (0);
				DrawVector2InputField (1);
				break;

			case ComputeVector2Type.areEqual:
				DrawVector2InputField (0);
				DrawVector2InputField (1);
				break;

			case ComputeVector2Type.insideUnitCircle:

				break;

			case ComputeVector2Type.getFloatFromY:
				DrawVector2InputField (0);
				break;

			case ComputeVector2Type.getFloatFromX:
				DrawVector2InputField (0);
				break;

			case ComputeVector2Type.dot:
				DrawVector2InputField (0);
				DrawVector2InputField (1);
				break;

			case ComputeVector2Type.Add:
				DrawVector2InputField (0);
				DrawVector2InputField (1);
				break;

			}
			if (computeVector2Type == ComputeVector2Type.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeVector2 ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeVector2Type)
			{
			case ComputeVector2Type.listenToTransferredData:
				vector2Value = MezanixDiamondGetVector2 (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveVector2 (stringValues [0]);
				}
				break;

			case ComputeVector2Type.sendMeAsTransferredData:
				MezanixDiamondSetVector2 (stringValues [0]);

				break;

			case ComputeVector2Type.animationCurvePickValue:
				vector2Value = Vector2.Lerp (vector2Values [0], vector2Values [1], animationCurve_.Evaluate (floatValues [2]));
				break;

			case ComputeVector2Type.animationCurve:
				//forMeMezanix_3_Idle_Ht.forMeMezanix_3_Idle.forMeMezanix_3.StartCoroutine (RunAnimationCurve_vector2 ());
				break;

			case ComputeVector2Type.max:
				vector2Value = new Vector2 (
					Mathf.Max (vector2Values [0].x, vector2Values [1].x),
					Mathf.Max (vector2Values [0].y, vector2Values [1].y));
				break;

			case ComputeVector2Type.min:
				vector2Value = new Vector2 (
					Mathf.Min (vector2Values [0].x, vector2Values [1].x),
					Mathf.Min (vector2Values [0].y, vector2Values [1].y));
				break;

			case ComputeVector2Type.normalize:
				vector2Value = vector2Values [0].normalized;
				break;

			case ComputeVector2Type.ClampMagnitude:
				vector2Value = Vector2.ClampMagnitude (vector2Values [0], floatValues [0]);
				break;

			case ComputeVector2Type.magnitude:
				floatValue = vector2Values [0].magnitude;
				break;

			case ComputeVector2Type.get:
				ForGet_vector2_Compute ();
				break;

			case ComputeVector2Type.toRect:
				rectValue = new Rect (vector2Values [0], vector2Values [1]);
				break;

			case ComputeVector2Type.toString:
				stringValue = vector2Values [0].ToString ();
				break;

			case ComputeVector2Type.Switch:
				if (boolValues [0] && ! boolValues [1])
				{
					vector2Value = vector2Values [0];
				}
				if (boolValues [1] && ! boolValues [0])
				{
					vector2Value = vector2Values [1];
				}

				break;

			case ComputeVector2Type.subtract:
				vector2Value = vector2Values [0] - vector2Values [1];
				break;

			case ComputeVector2Type.putThisFloatInY:
				vector2Value = new Vector2 (vector2Values [0].x, floatValues [0]);
				break;

			case ComputeVector2Type.putThisFloatInXY:
				vector2Value = new Vector2 (floatValues [0], floatValues [0]);
				break;

			case ComputeVector2Type.putThisFloatInX:
				vector2Value = new Vector2 (floatValues [0], vector2Values [0].y);
				break;

			case ComputeVector2Type.onUnitCircle:
				Vector3 v3 = UnityEngine.Random.onUnitSphere;
				vector2Value = new Vector2 (v3.x, v3.z).normalized;
				break;

			case ComputeVector2Type.multiply:
				vector2Value = vector2Values [0] * floatValues [0];
				break;

			case ComputeVector2Type.areParallel:
				boolValue = Vector3.Cross (
					new Vector3(vector2Values [0].x, vector2Values [0].y, 0f), 
					new Vector3(vector2Values [1].x, vector2Values [1].y, 0f)).magnitude == 0f;
				break;

			case ComputeVector2Type.areOrthogonal:
				boolValue = Vector2.Dot (vector2Values [0], vector2Values [1]) == 0f;
				break;

			case ComputeVector2Type.areEqual:
				boolValue = vector2Values [0] == vector2Values [1];
				break;

			case ComputeVector2Type.insideUnitCircle:
				vector2Value = UnityEngine.Random.insideUnitCircle;
				break;

			case ComputeVector2Type.getFloatFromY:
				floatValue = vector2Values [0].y;
				break;

			case ComputeVector2Type.getFloatFromX:
				floatValue = vector2Values [0].x;
				break;

			case ComputeVector2Type.dot:
				floatValue = Vector2.Dot (vector2Values [0], vector2Values [1]);
				break;

			case ComputeVector2Type.Add:
				vector2Value = vector2Values [0] + vector2Values [1];
				break;

			}
		}
		void ComputeVector2_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeVector2Type)
			{
			case ComputeVector2Type.listenToTransferredData:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.animationCurvePickValue:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Pick a vector value on a curve,",
					"between the start and the end value.",
					"You have to choose the time corresponding to your value",
					"The time is the horizontal axis of the curve.",
					"The picked vector, the start and the end vectors are on the",
					"vertical axis of the curve",
					"",
					"About the horizontal axis:",
					"This axis is commonly called time, but in the case of this node",
					"it is an axis having values from 0 to 1 (normalized),",
					"so this node is usful for drawing any curves shape and picking",
					"a vector value (vertical axis) on the curve corresponding of any",
					"position in the horizontal axis, 0 is the left of the horizontal axis,",
					"1 is its right and between them is a value on the axis.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.animationCurve:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Animate a vector value on a curve,",
					"between the start and the end value.",
					"You have to define the animation time (duration).",
					"The time is the horizontal axis of the curve.",
					"The animated vector, the start and the end vectors are on the",
					"vertical axis of the curve",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.max:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the max value of the first and the second values",
					"Like the max for a float variable acting separately",
					"on both x and y components of the vector",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.min:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the min value of the first and the second values",
					"Like the min for a float variable acting separately",
					"on both x and y components of the vector",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.normalize:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns this vector with a magnitude of 1 (Read Only).",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Vector2-normalized.html", 
					"");
				break;

			case ComputeVector2Type.ClampMagnitude:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a copy of vector with its magnitude clamped to maxLength.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Vector2.ClampMagnitude.html", 
					"");
				break;

			case ComputeVector2Type.magnitude:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the magnitude (length) of the vector",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.get:
				ForGet_vector2_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.toRect:
				DrawRectResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Use two vector2 to get a rect, ",
					"the first vector is for the Rect position and the second one is for the it's size",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.toString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get a string (text) format of the value",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.Switch:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the value corresponding of the checked box,",
					"if noth boxes have the same value, the node will not compute",
					"and it will conserve it's old output",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.subtract:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Subtract two vector2",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.putThisFloatInY:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Modifies the Y value of the vector2",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.putThisFloatInXY:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get a vector2 with same values on X and Y",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.putThisFloatInX:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Modifie the X value of the vector2",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.onUnitCircle:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a random point on a circle with radius 1",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.multiply:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Multiply vector2 by a float (decimal) value.",
					"This cause a scaling of the vector2 without changing its direction",
					"If the float value is negative, it will flip the vector2",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.areParallel:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Are these vector2 parallel?",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.areOrthogonal:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Are these vector2 orthogonal (perpendicular, angle of 90°)?",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.areEqual:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Are these vector2 equal?",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.insideUnitCircle:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns a random point inside a circle with radius 1",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Random-insideUnitCircle.html", 
					"");
				break;

			case ComputeVector2Type.getFloatFromY:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the Y value of the vector2",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.getFloatFromX:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get the X value of the vector2",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2Type.dot:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"Dot Product of two vectors.",
					"For normalized vectors Dot returns 1 if they point in exactly the same direction;",
					"-1 if they point in completely opposite directions; and a number in between for other cases",
					"(e.g. Dot returns zero if vectors are perpendicular).",
					"For vectors of arbitrary length the Dot return values are similar:",
					"they get larger when the angle between vectors decreases.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Vector2.Dot.html", 
					"");
				break;

			case ComputeVector2Type.Add:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Add two vector2",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeUIInputField ()
		{
			ComputeUiInputField_InputFields ();
			if (logic.playing)ComputeUiInputField ();
			ComputeUiInputField_OutputFields ();
		}
		public int computeUiInputFieldType_length = 0;
		public string computeUiInputFieldType_last;
		void ComputeUiInputField_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeUiInputFieldType = (ComputeUiInputFieldType)DrawEnumComputeType (computeUiInputFieldType,
						ref computeUiInputFieldType_length, ref computeUiInputFieldType_last, typeof(ComputeUiInputFieldType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				uiInputField = gameObjectValues [0].GetComponent <UnityEngine.UI.InputField>();

				if (uiInputField == null)
				{
					DrawInNodeInfo ("Add UnityEngine.UI.InputField To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						uiInputField == null;

					return;
				}

			}
			computeUiInputFieldType = (ComputeUiInputFieldType)DrawEnumComputeType (computeUiInputFieldType,
				ref computeUiInputFieldType_length, ref computeUiInputFieldType_last, typeof(ComputeUiInputFieldType));
			

			switch (computeUiInputFieldType)
			{
			case ComputeUiInputFieldType.setEnabled:
				DrawBoolInputField (0);
				break;

			case ComputeUiInputFieldType.getIsActiveAndEnabled:

				break;

			case ComputeUiInputFieldType.getEnabled:

				break;

			case ComputeUiInputFieldType.setText:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeUiInputFieldType.getText:

				break;


			case ComputeUiInputFieldType.setKeyboardType:
				touchScreenKeyboardType = (TouchScreenKeyboardType)DrawEnum (touchScreenKeyboardType,
					ref touchScreenKeyboardType_length, ref touchScreenKeyboardType_last, 
					typeof(TouchScreenKeyboardType),
					"Touch Screen Keyboard Type", Skins.logicNodeLabel);

				break;

			}
			DrawDoItButton();
		}

		public int touchScreenKeyboardType_length = 0;
		public string touchScreenKeyboardType_last;

		void ComputeUiInputField ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeUiInputFieldType)
			{
			case ComputeUiInputFieldType.setEnabled:
				uiInputField.enabled = boolValues [0];
				break;

			case ComputeUiInputFieldType.getIsActiveAndEnabled:
				boolValue = uiInputField.isActiveAndEnabled;
				break;

			case ComputeUiInputFieldType.getEnabled:
				boolValue = uiInputField.enabled;
				break;

			case ComputeUiInputFieldType.setText:
				uiInputField.text = stringValues [0];

				break;

			case ComputeUiInputFieldType.getText:
				stringValue = uiInputField.text;

				break;

			case ComputeUiInputFieldType.setKeyboardType:
				uiInputField.keyboardType = touchScreenKeyboardType;

				break;

			}
		}
		void ComputeUiInputField_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeUiInputFieldType)
			{
			case ComputeUiInputFieldType.setEnabled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Enabled Behaviours are Updated, disabled Behaviours are not.",
					"This is shown as the small checkbox in the inspector of the behaviour.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUiInputFieldType.getIsActiveAndEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Has the Behaviour had enabled called.",
					"True while the behaviour is enabled, false when disabled.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-isActiveAndEnabled.html", 
					"");
				break;

			case ComputeUiInputFieldType.getEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Enabled Behaviours are Updated, disabled Behaviours are not.",
					"This is shown as the small checkbox in the inspector of the behaviour.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUiInputFieldType.setText:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The current value of the input field.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.InputField-text.html", 
					"");
				break;

			case ComputeUiInputFieldType.getText:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The current value of the input field.",
					"Note that null is invalid value for InputField.text.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.InputField-text.html", 
					"");
				break;

			case ComputeUiInputFieldType.setKeyboardType:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Describes the type of keyboard.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/TouchScreenKeyboardType.html", 
					"");
				break;

			}
		}


		void ApplyComputeLight ()
		{
			ComputeLight_InputFields ();
			if (logic.playing)ComputeLight ();
			ComputeLight_OutputFields ();
		}
		public int computeLightType_length = 0;
		public string computeLightType_last;
		void ComputeLight_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();


					computeLightType = (ComputeLightType)DrawEnumComputeType (computeLightType,
						ref computeLightType_length, ref computeLightType_last, typeof(ComputeLightType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				lightComp = gameObjectValues [0].GetComponent <Light>();

				if (lightComp == null)
				{
					DrawInNodeInfo ("Add Light To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						lightComp == null;

					return;
				}

			}
			computeLightType = (ComputeLightType)DrawEnumComputeType (computeLightType,
				ref computeLightType_length, ref computeLightType_last, typeof(ComputeLightType));

			switch (computeLightType)
			{
			case ComputeLightType.getSpotAngle:

				break;

			case ComputeLightType.setSpotAngle:
				DrawFloatInputField (0);
				break;

			case ComputeLightType.getShadowStrength:

				break;

			case ComputeLightType.setShadowStrength:
				DrawFloatInputField (0);
				break;

			case ComputeLightType.getShadowNormalBias:

				break;

			case ComputeLightType.setShadowNormalBias:
				DrawFloatInputField (0);
				break;

			case ComputeLightType.getShadowNearPlane:

				break;

			case ComputeLightType.setShadowNearPlane:
				DrawFloatInputField (0);
				break;

			case ComputeLightType.getShadowCustomResolution:

				break;

			case ComputeLightType.setShadowCustomResolution:
				DrawIntInputField (0);
				break;

			case ComputeLightType.getShadowBias:

				break;

			case ComputeLightType.setShadowBias:
				DrawFloatInputField (0);
				break;

			case ComputeLightType.getRange:

				break;

			case ComputeLightType.setRange:
				DrawFloatInputField (0);
				break;

			case ComputeLightType.getIsBaked:

				break;

			case ComputeLightType.getIntensity:

				break;

			case ComputeLightType.setIntensity:
				DrawFloatInputField (0);
				break;

			case ComputeLightType.getCullingMask:

				break;

			case ComputeLightType.setCullingMask:
				DrawIntInputField (0);
				break;

			case ComputeLightType.getCookieSize:

				break;

			case ComputeLightType.setCookieSize:
				DrawFloatInputField (0);
				break;

			case ComputeLightType.getColor:

				break;

			case ComputeLightType.setColor:
				DrawColorInputField (0);
				break;

			case ComputeLightType.getBounceIntensity:

				break;

			case ComputeLightType.setBounceIntensity:
				DrawFloatInputField (0);
				break;

			case ComputeLightType.getAreaSize:

				break;

			case ComputeLightType.setAreaSize:
				DrawVector2InputField (0);
				break;

			case ComputeLightType.setAlreadyLightmapped:
				DrawBoolInputField (0);
				break;

			case ComputeLightType.getAlreadyLightmapped:

				break;

			case ComputeLightType.setEnabled:
				DrawBoolInputField (0);
				break;

			case ComputeLightType.getIsActiveAndEnabled:

				break;

			case ComputeLightType.getEnabled:

				break;

			}
			DrawDoItButton();
		}
		void ComputeLight ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeLightType)
			{
			case ComputeLightType.getSpotAngle:
				floatValue = lightComp.spotAngle;
				break;

			case ComputeLightType.setSpotAngle:
				lightComp.spotAngle = floatValues [0];
				break;

			case ComputeLightType.getShadowStrength:
				floatValue = lightComp.shadowStrength;
				break;

			case ComputeLightType.setShadowStrength:
				lightComp.shadowStrength = floatValues [0];
				break;

			case ComputeLightType.getShadowNormalBias:
				floatValue = lightComp.shadowNormalBias;
				break;

			case ComputeLightType.setShadowNormalBias:
				lightComp.shadowNormalBias = floatValues [0];
				break;

			case ComputeLightType.getShadowNearPlane:
				floatValue = lightComp.shadowNearPlane;
				break;

			case ComputeLightType.setShadowNearPlane:
				lightComp.shadowNearPlane = floatValues [0];
				break;

			case ComputeLightType.getShadowCustomResolution:
				intValue = lightComp.shadowCustomResolution;
				break;

			case ComputeLightType.setShadowCustomResolution:
				lightComp.shadowCustomResolution = intValues [0];
				break;

			case ComputeLightType.getShadowBias:
				floatValue = lightComp.shadowBias;
				break;

			case ComputeLightType.setShadowBias:
				lightComp.shadowBias = floatValues [0];
				break;

			case ComputeLightType.getRange:
				floatValue = lightComp.range;
				break;

			case ComputeLightType.setRange:
				lightComp.range = floatValues [0];
				break;

			case ComputeLightType.getIsBaked:
				boolValue = lightComp.isBaked;
				break;

			case ComputeLightType.getIntensity:
				floatValue = lightComp.intensity;
				break;

			case ComputeLightType.setIntensity:
				lightComp.intensity = floatValues [0];
				break;

			case ComputeLightType.getCullingMask:
				intValue = lightComp.cullingMask;
				break;

			case ComputeLightType.setCullingMask:
				lightComp.cullingMask = intValues [0];
				break;

			case ComputeLightType.getCookieSize:
				floatValue = lightComp.cookieSize;
				break;

			case ComputeLightType.setCookieSize:
				lightComp.cookieSize = floatValues [0];
				break;

			case ComputeLightType.getColor:
				colorValue = lightComp.color;
				break;

			case ComputeLightType.setColor:
				lightComp.color = colorValues [0];
				break;

			case ComputeLightType.getBounceIntensity:
				floatValue = lightComp.bounceIntensity;
				break;

			case ComputeLightType.setBounceIntensity:
				lightComp.bounceIntensity = floatValues [0];
				break;

			case ComputeLightType.getAreaSize:
				vector2Value = lightComp.areaSize;
				break;

			case ComputeLightType.setAreaSize:
				lightComp.areaSize = vector2Values [0];
				break;

			case ComputeLightType.setAlreadyLightmapped:
				lightComp.alreadyLightmapped = boolValues [0];
				break;

			case ComputeLightType.getAlreadyLightmapped:
				boolValue = lightComp.alreadyLightmapped;
				break;

			case ComputeLightType.setEnabled:
				lightComp.enabled = boolValues [0];
				break;

			case ComputeLightType.getIsActiveAndEnabled:
				boolValue = lightComp.isActiveAndEnabled;
				break;

			case ComputeLightType.getEnabled:
				boolValue = lightComp.enabled;
				break;

			}
		}
		void ComputeLight_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeLightType)
			{
			case ComputeLightType.getSpotAngle:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The angle of the light's spotlight cone in degrees.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-spotAngle.html", 
					"");
				break;

			case ComputeLightType.setSpotAngle:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The angle of the light's spotlight cone in degrees.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-spotAngle.html", 
					"");
				break;

			case ComputeLightType.getShadowStrength:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Strength of light's shadows.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowStrength.html", 
					"");
				break;

			case ComputeLightType.setShadowStrength:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Strength of light's shadows.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowStrength.html", 
					"");
				break;

			case ComputeLightType.getShadowNormalBias:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Shadow mapping normal-based bias.",
					"Shadow caster surfaces are pushed inwards along their normals by this amount,",
					"to help prevent self-shadowing ('shadow acne') artifacts. Units of normal-based bias",
					"are expressed in terms of shadowmap texel size; typically values between 0.3-0.7 work well.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowNormalBias.html", 
					"");
				break;

			case ComputeLightType.setShadowNormalBias:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Shadow mapping normal-based bias.",
					"Shadow caster surfaces are pushed inwards along their normals by this amount,",
					"to help prevent self-shadowing ('shadow acne') artifacts. Units of normal-based bias",
					"are expressed in terms of shadowmap texel size; typically values between 0.3-0.7 work well.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowNormalBias.html", 
					"");
				break;

			case ComputeLightType.getShadowNearPlane:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Near plane value to use for shadow frustums.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowNearPlane.html", 
					"");
				break;

			case ComputeLightType.setShadowNearPlane:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Near plane value to use for shadow frustums.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowNearPlane.html", 
					"");
				break;

			case ComputeLightType.getShadowCustomResolution:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The custom resolution of the shadow map.",
					"By default, shadow map resolution is computed from its importance on screen.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowCustomResolution.html", 
					"");
				break;

			case ComputeLightType.setShadowCustomResolution:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The custom resolution of the shadow map.",
					"By default, shadow map resolution is computed from its importance on screen.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowCustomResolution.html", 
					"");
				break;

			case ComputeLightType.getShadowBias:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Shadow mapping constant bias.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowBias.html", 
					"");
				break;

			case ComputeLightType.setShadowBias:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Shadow mapping constant bias.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-shadowBias.html", 
					"");
				break;

			case ComputeLightType.getRange:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The range of the light.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-range.html", 
					"");
				break;

			case ComputeLightType.setRange:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The range of the light.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-range.html", 
					"");
				break;

			case ComputeLightType.getIsBaked:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Is the light contribution already stored in lightmaps and/or lightprobes.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-isBaked.html", 
					"");
				break;

			case ComputeLightType.getIntensity:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The Intensity of a light is multiplied with the Light color.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-intensity.html", 
					"");
				break;

			case ComputeLightType.setIntensity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The Intensity of a light is multiplied with the Light color.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-intensity.html", 
					"");
				break;

			case ComputeLightType.getCullingMask:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"This is used to light certain objects in the scene selectively.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-cullingMask.html", 
					"");
				break;

			case ComputeLightType.setCullingMask:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"This is used to light certain objects in the scene selectively.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-cullingMask.html", 
					"");
				break;

			case ComputeLightType.getCookieSize:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The size of a directional light's cookie.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-cookieSize.html", 
					"");
				break;

			case ComputeLightType.setCookieSize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The size of a directional light's cookie.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-cookieSize.html", 
					"");
				break;

			case ComputeLightType.getColor:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The color of the light.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-color.html", 
					"");
				break;

			case ComputeLightType.setColor:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The color of the light.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-color.html", 
					"");
				break;

			case ComputeLightType.getBounceIntensity:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The multiplier that defines the strength of the bounce lighting.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-bounceIntensity.html", 
					"");
				break;

			case ComputeLightType.setBounceIntensity:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The multiplier that defines the strength of the bounce lighting.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-bounceIntensity.html", 
					"");
				break;

			case ComputeLightType.getAreaSize:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The size of the area light.",
					"This property is only exposed to Editor scripts.",
					"It is not exposed during Play mode.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-areaSize.html", 
					"");
				break;

			case ComputeLightType.setAreaSize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"The size of the area light.",
					"This property is only exposed to Editor scripts.",
					"It is not exposed during Play mode.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Light-areaSize.html", 
					"");
				break;

			case ComputeLightType.setAlreadyLightmapped:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Has the light already been lightmapped.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/530/Documentation/ScriptReference/Light-alreadyLightmapped.html", 
					"");
				break;

			case ComputeLightType.getAlreadyLightmapped:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Has the light already been lightmapped.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/530/Documentation/ScriptReference/Light-alreadyLightmapped.html", 
					"");
				break;

			case ComputeLightType.setEnabled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Enabled Behaviours are Updated, disabled Behaviours are not.",
					"This is shown as the small checkbox in the inspector of the behaviour.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeLightType.getIsActiveAndEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Has the Behaviour had enabled called.",
					"True while the behaviour is enabled, false when disabled.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-isActiveAndEnabled.html", 
					"");
				break;

			case ComputeLightType.getEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Enabled Behaviours are Updated, disabled Behaviours are not.",
					"This is shown as the small checkbox in the inspector of the behaviour.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			}
		}


		void ApplyComputeUIToggle ()
		{
			ComputeUiToggle_InputFields ();
			if (logic.playing)ComputeUiToggle ();
			ComputeUiToggle_OutputFields ();
		}
		public int computeUiToggleType_length = 0;
		public string computeUiToggleType_last;
		void ComputeUiToggle_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();



					computeUiToggleType = (ComputeUiToggleType)DrawEnumComputeType (computeUiToggleType,
						ref computeUiToggleType_length, ref computeUiToggleType_last, typeof(ComputeUiToggleType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				uiToggle = gameObjectValues [0].GetComponent <UnityEngine.UI.Toggle>();

				if (uiToggle == null)
				{
					DrawInNodeInfo ("Add UnityEngine.UI.Toggle To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						uiToggle == null;

					return;
				}

			}
			computeUiToggleType = (ComputeUiToggleType)DrawEnumComputeType (computeUiToggleType,
				ref computeUiToggleType_length, ref computeUiToggleType_last, typeof(ComputeUiToggleType));

			switch (computeUiToggleType)
			{
			case ComputeUiToggleType.setEnabled:
				DrawBoolInputField (0);
				break;

			case ComputeUiToggleType.getIsActiveAndEnabled:

				break;

			case ComputeUiToggleType.getEnabled:

				break;

			case ComputeUiToggleType.isOn:

				break;

			}
			DrawDoItButton();
		}
		void ComputeUiToggle ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeUiToggleType)
			{
			case ComputeUiToggleType.setEnabled:
				uiToggle.enabled = boolValues [0];
				break;

			case ComputeUiToggleType.getIsActiveAndEnabled:
				boolValue = uiToggle.isActiveAndEnabled;
				break;

			case ComputeUiToggleType.getEnabled:
				boolValue = uiToggle.enabled;
				break;

			case ComputeUiToggleType.isOn:
				boolValue = uiToggle.isOn;

				break;

			}
		}
		void ComputeUiToggle_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeUiToggleType)
			{
			case ComputeUiToggleType.setEnabled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Enabled Behaviours are Updated, disabled Behaviours are not.",
					"This is shown as the small checkbox in the inspector of the behaviour.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUiToggleType.getIsActiveAndEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Has the Behaviour had enabled called.",
					"True while the behaviour is enabled, false when disabled.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-isActiveAndEnabled.html", 
					"");
				break;

			case ComputeUiToggleType.getEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Enabled Behaviours are Updated, disabled Behaviours are not.",
					"This is shown as the small checkbox in the inspector of the behaviour.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeUiToggleType.isOn:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Is the toggle on.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/UI.Toggle-isOn.html", 
					"");
				break;

			}
		}


		void ApplyComputeCircleCollider2D ()
		{
			ComputeCircleCollider2D_InputFields ();
			if (logic.playing)ComputeCircleCollider2D ();
			ComputeCircleCollider2D_OutputFields ();
		}
		public int computeCircleCollider2DType_length = 0;
		public string computeCircleCollider2DType_last;
		void ComputeCircleCollider2D_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();


					computeCircleCollider2DType = (ComputeCircleCollider2DType)DrawEnumComputeType (
						computeCircleCollider2DType, ref computeCircleCollider2DType_length,
						ref computeCircleCollider2DType_last, typeof(ComputeCircleCollider2DType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				circleCollider2D = gameObjectValues [0].GetComponent <CircleCollider2D>();

				if (circleCollider2D == null)
				{
					DrawInNodeInfo ("Add CircleCollider2D To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						circleCollider2D == null;

					return;
				}

			}
			computeCircleCollider2DType = (ComputeCircleCollider2DType)DrawEnumComputeType (
				computeCircleCollider2DType, ref computeCircleCollider2DType_length,
				ref computeCircleCollider2DType_last, typeof(ComputeCircleCollider2DType));
			
			switch (computeCircleCollider2DType)
			{
			case ComputeCircleCollider2DType.getCircleCollider2DRadius:

				break;

			case ComputeCircleCollider2DType.setCircleCollider2DRadius:
				circleCollider2D = gameObjectValues [0].GetComponent<CircleCollider2D> ();

				if (circleCollider2D == null)
				{
					DrawInNodeInfo ("Add CircleCollider2D To GameObject");

					return;
				}

				DrawFloatInputField (0);
				break;

			}
			DrawDoItButton();
		}
		void ComputeCircleCollider2D ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeCircleCollider2DType)
			{
			case ComputeCircleCollider2DType.getCircleCollider2DRadius:
				floatValue = circleCollider2D.radius;
				break;

			case ComputeCircleCollider2DType.setCircleCollider2DRadius:
				circleCollider2D.radius = floatValues [0];
				break;

			}
		}
		void ComputeCircleCollider2D_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeCircleCollider2DType)
			{
			case ComputeCircleCollider2DType.getCircleCollider2DRadius:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CircleCollider2D-radius.html", 
					"");
				break;

			case ComputeCircleCollider2DType.setCircleCollider2DRadius:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CircleCollider2D-radius.html", 
					"");
				break;

			}
		}

		void ApplyComputeBoxCollider2D ()
		{
			ComputeBoxCollider2D_InputFields ();
			if (logic.playing)ComputeBoxCollider2D ();
			ComputeBoxCollider2D_OutputFields ();
		}
		public int computeBoxCollider2DType_length = 0;
		public string computeBoxCollider2DType_last;
		void ComputeBoxCollider2D_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();



					computeBoxCollider2DType = (ComputeBoxCollider2DType)DrawEnumComputeType (
						computeBoxCollider2DType, ref computeBoxCollider2DType_length,
						ref computeBoxCollider2DType_last, typeof(ComputeBoxCollider2DType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				boxCollider2D = gameObjectValues [0].GetComponent <BoxCollider2D>();

				if (boxCollider2D == null)
				{
					DrawInNodeInfo ("Add BoxCollider2D To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						boxCollider2D == null;

					return;
				}

			}

			computeBoxCollider2DType = (ComputeBoxCollider2DType)DrawEnumComputeType (
				computeBoxCollider2DType, ref computeBoxCollider2DType_length,
				ref computeBoxCollider2DType_last, typeof(ComputeBoxCollider2DType));


			switch (computeBoxCollider2DType)
			{
			case ComputeBoxCollider2DType.getBoxCollider2DSize:

				break;

			case ComputeBoxCollider2DType.setBoxCollider2DSize:
				boxCollider2D = gameObjectValues [0].GetComponent<BoxCollider2D> ();

				if (boxCollider2D == null)
				{
					DrawInNodeInfo ("Add BoxCollider2D To GameObject");

					return;
				}

				DrawVector2InputField (0);
				break;

			}
			DrawDoItButton();
		}
		void ComputeBoxCollider2D ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeBoxCollider2DType)
			{
			case ComputeBoxCollider2DType.getBoxCollider2DSize:
				vector2Value = boxCollider2D.size;
				break;

			case ComputeBoxCollider2DType.setBoxCollider2DSize:
				boxCollider2D.size = vector2Values [0];
				break;

			}
		}
		void ComputeBoxCollider2D_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeBoxCollider2DType)
			{
			case ComputeBoxCollider2DType.getBoxCollider2DSize:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/BoxCollider2D-size.html", 
					"");
				break;

			case ComputeBoxCollider2DType.setBoxCollider2DSize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/BoxCollider2D-size.html", 
					"");
				break;

			}
		}

		void ApplyComputeMeshCollider ()
		{
			ComputeMeshCollider_InputFields ();
			if (logic.playing)ComputeMeshCollider ();
			ComputeMeshCollider_OutputFields ();
		}
		public int computeMeshColliderType_length = 0;
		public string computeMeshColliderType_last;
		void ComputeMeshCollider_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();



					computeMeshColliderType = (ComputeMeshColliderType)DrawEnumComputeType (
						computeMeshColliderType, ref computeMeshColliderType_length,
						ref computeMeshColliderType_last, typeof(ComputeMeshColliderType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				meshCollider = gameObjectValues [0].GetComponent <MeshCollider>();

				if (meshCollider == null)
				{
					DrawInNodeInfo ("Add MeshCollider To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						meshCollider == null;

					return;
				}

			}
			computeMeshColliderType = (ComputeMeshColliderType)DrawEnumComputeType (
				computeMeshColliderType, ref computeMeshColliderType_length,
				ref computeMeshColliderType_last, typeof(ComputeMeshColliderType));

			switch (computeMeshColliderType)
			{
			case ComputeMeshColliderType.SetMeshColliderConvex:
				DrawBoolInputField (0);
				break;

			case ComputeMeshColliderType.GetMeshColliderConvex:

				break;

			}
			DrawDoItButton();
		}
		void ComputeMeshCollider ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeMeshColliderType)
			{
			case ComputeMeshColliderType.SetMeshColliderConvex:
				meshCollider.convex = boolValues [0];
				break;

			case ComputeMeshColliderType.GetMeshColliderConvex:
				boolValue = meshCollider.convex;
				break;

			}
		}
		void ComputeMeshCollider_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeMeshColliderType)
			{
			case ComputeMeshColliderType.SetMeshColliderConvex:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/MeshCollider-convex.html", 
					"");
				break;

			case ComputeMeshColliderType.GetMeshColliderConvex:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/MeshCollider-convex.html", 
					"");
				break;

			}
		}

		void ApplyComputeCapsuleCollider ()
		{
			ComputeCapsuleCollider_InputFields ();
			if (logic.playing)ComputeCapsuleCollider ();
			ComputeCapsuleCollider_OutputFields ();
		}
		public int computeCapsuleColliderType_length = 0;
		public string computeCapsuleColliderType_last;
		void ComputeCapsuleCollider_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();



					computeCapsuleColliderType = (ComputeCapsuleColliderType)DrawEnumComputeType (
						computeCapsuleColliderType, ref computeCapsuleColliderType_length,
						ref computeCapsuleColliderType_last, typeof(ComputeCapsuleColliderType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				capsuleCollider = gameObjectValues [0].GetComponent <CapsuleCollider>();

				if (capsuleCollider == null)
				{
					DrawInNodeInfo ("Add CapsuleCollider To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						capsuleCollider == null;

					return;
				}

			}
			computeCapsuleColliderType = (ComputeCapsuleColliderType)DrawEnumComputeType (
				computeCapsuleColliderType, ref computeCapsuleColliderType_length,
				ref computeCapsuleColliderType_last, typeof(ComputeCapsuleColliderType));
			
			switch (computeCapsuleColliderType)
			{
			case ComputeCapsuleColliderType.SetCapsuleColliderRadius:
				DrawFloatInputField (0);
				break;

			case ComputeCapsuleColliderType.SetCapsuleColliderHeight:
				DrawFloatInputField (0);
				break;

			case ComputeCapsuleColliderType.SetCapsuleColliderDirection:
				DrawLabelFields (new string []
					{
						"Direction",
						"0" + StringTreatment.rArrow + "x",
						"1" + StringTreatment.rArrow + "y",
						"2" + StringTreatment.rArrow + "z",
					});
				DrawIntInputField (0);
				intValues [0] = Mathf.Clamp (intValues [0], 0, 2);
				break;

			case ComputeCapsuleColliderType.SetCapsuleColliderCenter:
				DrawVector3InputField (0);
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderRadius:

				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderHeight:

				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderDirection:
				DrawLabelFields (new string []
					{
						"Direction",
						"0" + StringTreatment.rArrow + "x",
						"1" + StringTreatment.rArrow + "y",
						"2" + StringTreatment.rArrow + "z",
					});
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderCenter:

				break;

			}
			DrawDoItButton();
		}
		void ComputeCapsuleCollider ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeCapsuleColliderType)
			{
			case ComputeCapsuleColliderType.SetCapsuleColliderRadius:
				capsuleCollider.radius = floatValues [0];
				break;

			case ComputeCapsuleColliderType.SetCapsuleColliderHeight:
				capsuleCollider.height = floatValues [0];
				break;

			case ComputeCapsuleColliderType.SetCapsuleColliderDirection:
				capsuleCollider.direction = intValues [0];
				break;

			case ComputeCapsuleColliderType.SetCapsuleColliderCenter:
				capsuleCollider.center = vector3Values [0];
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderRadius:
				floatValue = capsuleCollider.radius;
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderHeight:
				floatValue = capsuleCollider.height;
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderDirection:
				intValue = capsuleCollider.direction;
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderCenter:
				vector3Value = capsuleCollider.center;
				break;

			}
		}
		void ComputeCapsuleCollider_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeCapsuleColliderType)
			{
			case ComputeCapsuleColliderType.SetCapsuleColliderRadius:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-radius.html", 
					"");
				break;

			case ComputeCapsuleColliderType.SetCapsuleColliderHeight:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-height.html", 
					"");
				break;

			case ComputeCapsuleColliderType.SetCapsuleColliderDirection:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-direction.html", 
					"");
				break;

			case ComputeCapsuleColliderType.SetCapsuleColliderCenter:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-center.html", 
					"");
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderRadius:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-radius.html", 
					"");
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderHeight:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-height.html", 
					"");
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderDirection:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-direction.html", 
					"");
				break;

			case ComputeCapsuleColliderType.GetCapsuleColliderCenter:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-center.html", 
					"");
				break;

			}
		}

		void ApplyComputeSphereCollider ()
		{
			ComputeSphereCollider_InputFields ();
			if (logic.playing)ComputeSphereCollider ();
			ComputeSphereCollider_OutputFields ();
		}
		public int computeSphereColliderType_length = 0;
		public string computeSphereColliderType_last;
		void ComputeSphereCollider_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();



					computeSphereColliderType = (ComputeSphereColliderType)DrawEnumComputeType (
						computeSphereColliderType, ref computeSphereColliderType_length, 
						ref computeSphereColliderType_last, typeof(ComputeSphereColliderType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				sphereCollider = gameObjectValues [0].GetComponent <SphereCollider>();

				if (sphereCollider == null)
				{
					DrawInNodeInfo ("Add SphereCollider To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						sphereCollider == null;

					return;
				}

			}
			computeSphereColliderType = (ComputeSphereColliderType)DrawEnumComputeType (
				computeSphereColliderType, ref computeSphereColliderType_length, 
				ref computeSphereColliderType_last, typeof(ComputeSphereColliderType));
			
			switch (computeSphereColliderType)
			{
			case ComputeSphereColliderType.SetSphereColliderRadius:
				DrawFloatInputField (0);
				break;

			case ComputeSphereColliderType.SetSphereColliderCenter:
				DrawVector3InputField (0);
				break;

			case ComputeSphereColliderType.GetSphereColliderRadius:

				break;

			case ComputeSphereColliderType.GetSphereColliderCenter:

				break;

			}
			DrawDoItButton();
		}
		void ComputeSphereCollider ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeSphereColliderType)
			{
			case ComputeSphereColliderType.SetSphereColliderRadius:
				sphereCollider.radius = floatValues [0];
				break;

			case ComputeSphereColliderType.SetSphereColliderCenter:
				sphereCollider.center = vector3Values [0];
				break;

			case ComputeSphereColliderType.GetSphereColliderRadius:
				floatValue = sphereCollider.radius;
				break;

			case ComputeSphereColliderType.GetSphereColliderCenter:
				vector3Value = sphereCollider.center;
				break;

			}
		}
		void ComputeSphereCollider_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeSphereColliderType)
			{
			case ComputeSphereColliderType.SetSphereColliderRadius:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SphereCollider-radius.html", 
					"");
				break;

			case ComputeSphereColliderType.SetSphereColliderCenter:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SphereCollider-center.html", 
					"");
				break;

			case ComputeSphereColliderType.GetSphereColliderRadius:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SphereCollider-radius.html", 
					"");
				break;

			case ComputeSphereColliderType.GetSphereColliderCenter:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/SphereCollider-center.html", 
					"");
				break;

			}
		}

		void ApplyComputeBoxCollider ()
		{
			computeBoxCollider_InputFields ();
			if (logic.playing)computeBoxCollider ();
			computeBoxCollider_OutputFields ();
		}
		public int computeBoxColliderType_length= 0;
		public string computeBoxColliderType_last;
		void computeBoxCollider_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();



					computeBoxColliderType = (ComputeBoxColliderType)DrawEnumComputeType (computeBoxColliderType,
						ref computeBoxColliderType_length, ref computeBoxColliderType_last, 
						typeof(ComputeBoxColliderType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				boxCollider = gameObjectValues [0].GetComponent <BoxCollider>();

				if (boxCollider == null)
				{
					DrawInNodeInfo ("Add BoxCollider To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						boxCollider == null;

					return;
				}

			}

			computeBoxColliderType = (ComputeBoxColliderType)DrawEnumComputeType (computeBoxColliderType,
				ref computeBoxColliderType_length, ref computeBoxColliderType_last, 
				typeof(ComputeBoxColliderType));

			switch (computeBoxColliderType)
			{
			case ComputeBoxColliderType.SetBoxColliderSize:
				DrawVector3InputField (0);
				break;

			case ComputeBoxColliderType.SetBoxColliderCenter:
				DrawVector3InputField (0);
				break;

			case ComputeBoxColliderType.GetBoxColliderSize:

				break;

			case ComputeBoxColliderType.GetBoxColliderCenter:
				
				break;

			}
			DrawDoItButton();
		}
		void computeBoxCollider ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeBoxColliderType)
			{
			case ComputeBoxColliderType.SetBoxColliderSize:
				boxCollider.size = vector3Values [0];
				break;

			case ComputeBoxColliderType.SetBoxColliderCenter:
				boxCollider.center = vector3Values [0];
				break;

			case ComputeBoxColliderType.GetBoxColliderSize:
				vector3Value = boxCollider.size;
				break;

			case ComputeBoxColliderType.GetBoxColliderCenter:
				vector3Value = boxCollider.center;
				break;

			}
		}
		void computeBoxCollider_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeBoxColliderType)
			{
			case ComputeBoxColliderType.SetBoxColliderSize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/BoxCollider-size.html", 
					"");
				break;

			case ComputeBoxColliderType.SetBoxColliderCenter:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/BoxCollider-center.html", 
					"");
				break;

			case ComputeBoxColliderType.GetBoxColliderSize:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/BoxCollider-size.html", 
					"");
				break;

			case ComputeBoxColliderType.GetBoxColliderCenter:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/BoxCollider-center.html", 
					"");
				break;

			}
		}


		void ApplyComputeAudioSource ()
		{
			ComputeAudioSource_InputFields ();
			if (logic.playing)ComputeAudioSource ();
			ComputeAudioSource_OutputFields ();
		}
		public int computeAudioSourceType_length = 0;
		public string computeAudioSourceType_last;
		void ComputeAudioSource_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeAudioSourceType = (ComputeAudioSourceType)DrawEnumComputeType (computeAudioSourceType,
						ref computeAudioSourceType_length, ref computeAudioSourceType_last, typeof(ComputeAudioSourceType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				audioSource_ = gameObjectValues [0].GetComponent <AudioSource>();

				if (audioSource_ == null)
				{
					DrawInNodeInfo ("Add AudioSource To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						audioSource_ == null;

					return;
				}

			}
			computeAudioSourceType = (ComputeAudioSourceType)DrawEnumComputeType (computeAudioSourceType,
				ref computeAudioSourceType_length, ref computeAudioSourceType_last, typeof(ComputeAudioSourceType));
			
			switch (computeAudioSourceType)
			{
			case ComputeAudioSourceType.UnPause:

				break;

			case ComputeAudioSourceType.stop:

				break;

			case ComputeAudioSourceType.setVolume:
				DrawFloatInputField (0);
				break;

			case ComputeAudioSourceType.setTime:
				DrawFloatInputField (0);
				break;

			case ComputeAudioSourceType.setSpatialize:
				DrawBoolInputField (0);
				break;

			case ComputeAudioSourceType.setSpatialBlend:
				DrawFloatInputField (0);
				break;

			case ComputeAudioSourceType.setPriority:
				DrawIntInputField (0);
				break;

			case ComputeAudioSourceType.setPitch:
				DrawFloatInputField (0);
				break;

			case ComputeAudioSourceType.setPanStereo:
				DrawFloatInputField (0);
				break;

			case ComputeAudioSourceType.setMute:
				DrawBoolInputField (0);
				break;

			case ComputeAudioSourceType.setMinDistance:
				DrawFloatInputField (0);
				break;

			case ComputeAudioSourceType.setMaxDistance:
				DrawFloatInputField (0);
				break;

			case ComputeAudioSourceType.setLoop:
				DrawBoolInputField (0);
				break;

			case ComputeAudioSourceType.PlayScheduled:
				DrawDoubleInputField ();
				break;

			case ComputeAudioSourceType.playOneShot:
				DrawAudioClipFieldInput_Local ();
				DrawLogicNodeLabel ("Volume Scale", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case ComputeAudioSourceType.PlayDelayed:
				DrawFloatInputField (0);
				break;

			case ComputeAudioSourceType.play:

				break;

			case ComputeAudioSourceType.pause:

				break;

			case ComputeAudioSourceType.getVolume:

				break;

			case ComputeAudioSourceType.getTime:

				break;

			case ComputeAudioSourceType.getSpatialize:

				break;

			case ComputeAudioSourceType.getSpatialBlend:

				break;

			case ComputeAudioSourceType.getPriority:

				break;

			case ComputeAudioSourceType.getPitch:

				break;

			case ComputeAudioSourceType.getPanStereo:

				break;

			case ComputeAudioSourceType.getMute:

				break;

			case ComputeAudioSourceType.getMinDistance:

				break;

			case ComputeAudioSourceType.getMaxDistance:

				break;

			case ComputeAudioSourceType.getLoop:

				break;

			case ComputeAudioSourceType.getIsPlaying:

				break;

			}
			DrawDoItButton();
		}
		void ComputeAudioSource ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeAudioSourceType)
			{
			case ComputeAudioSourceType.UnPause:
				audioSource_.UnPause ();
				break;

			case ComputeAudioSourceType.stop:
				audioSource_.Stop ();
				break;

			case ComputeAudioSourceType.setVolume:
				audioSource_.volume = floatValues [0];
				break;

			case ComputeAudioSourceType.setTime:
				audioSource_.time = floatValues [0];
				break;

			case ComputeAudioSourceType.setSpatialize:
				audioSource_.spatialize = boolValues [0];
				break;

			case ComputeAudioSourceType.setSpatialBlend:
				audioSource_.spatialBlend = floatValues [0];
				break;

			case ComputeAudioSourceType.setPriority:
				audioSource_.priority = intValues [0];
				break;

			case ComputeAudioSourceType.setPitch:
				audioSource_.pitch = floatValues [0];
				break;

			case ComputeAudioSourceType.setPanStereo:
				audioSource_.panStereo = floatValues [0];
				break;

			case ComputeAudioSourceType.setMute:
				audioSource_.mute = boolValues [0];
				break;

			case ComputeAudioSourceType.setMinDistance:
				audioSource_.minDistance = floatValues [0];
				break;

			case ComputeAudioSourceType.setMaxDistance:
				audioSource_.maxDistance = floatValues [0];
				break;

			case ComputeAudioSourceType.setLoop:
				audioSource_.loop = boolValues [0];
				break;

			case ComputeAudioSourceType.PlayScheduled:
				audioSource_.PlayScheduled (doubleValue);
				break;

			case ComputeAudioSourceType.playOneShot:
				if (audioClipValue_Local != null)
					audioSource_.PlayOneShot (audioClipValue_Local, floatValues [0]);
				break;

			case ComputeAudioSourceType.PlayDelayed:
				audioSource_.PlayDelayed (floatValues [0]);
				break;

			case ComputeAudioSourceType.play:
				audioSource_.Play ();
				break;

			case ComputeAudioSourceType.pause:
				audioSource_.Pause ();
				break;

			case ComputeAudioSourceType.getVolume:
				floatValue = audioSource_.volume;
				break;

			case ComputeAudioSourceType.getTime:
				floatValue = audioSource_.time;
				break;

			case ComputeAudioSourceType.getSpatialize:
				boolValue = audioSource_.spatialize;
				break;

			case ComputeAudioSourceType.getSpatialBlend:
				floatValue = audioSource_.spatialBlend;
				break;

			case ComputeAudioSourceType.getPriority:
				intValue = audioSource_.priority;
				break;

			case ComputeAudioSourceType.getPitch:
				floatValue = audioSource_.pitch;
				break;

			case ComputeAudioSourceType.getPanStereo:
				floatValue = audioSource_.panStereo;
				break;

			case ComputeAudioSourceType.getMute:
				boolValue = audioSource_.mute;
				break;

			case ComputeAudioSourceType.getMinDistance:
				floatValue = audioSource_.minDistance;
				break;

			case ComputeAudioSourceType.getMaxDistance:
				floatValue = audioSource_.maxDistance;
				break;

			case ComputeAudioSourceType.getLoop:
				boolValue = audioSource_.loop;
				break;

			case ComputeAudioSourceType.getIsPlaying:
				boolValue = audioSource_.isPlaying;
				break;

			}
		}
		void ComputeAudioSource_OutputFields ()
		{
			
			string [] documentationMessage;

			switch (computeAudioSourceType)
			{
			case ComputeAudioSourceType.UnPause:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource.UnPause.html", 
					"");
				break;

			case ComputeAudioSourceType.stop:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource.Stop.html", 
					"");
				break;

			case ComputeAudioSourceType.setVolume:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-volume.html", 
					"");
				break;

			case ComputeAudioSourceType.setTime:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-time.html", 
					"");
				break;

			case ComputeAudioSourceType.setSpatialize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-spatialize.html", 
					"");
				break;

			case ComputeAudioSourceType.setSpatialBlend:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-spatialBlend.html", 
					"");
				break;

			case ComputeAudioSourceType.setPriority:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-priority.html", 
					"");
				break;

			case ComputeAudioSourceType.setPitch:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-pitch.html", 
					"");
				break;

			case ComputeAudioSourceType.setPanStereo:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-panStereo.html", 
					"");
				break;

			case ComputeAudioSourceType.setMute:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-mute.html", 
					"");
				break;

			case ComputeAudioSourceType.setMinDistance:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-minDistance.html", 
					"");
				break;

			case ComputeAudioSourceType.setMaxDistance:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-maxDistance.html", 
					"");
				break;

			case ComputeAudioSourceType.setLoop:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-loop.html", 
					"");
				break;

			case ComputeAudioSourceType.PlayScheduled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html", 
					"");
				break;

			case ComputeAudioSourceType.playOneShot:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html", 
					"");
				break;

			case ComputeAudioSourceType.PlayDelayed:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource.PlayDelayed.html", 
					"");
				break;

			case ComputeAudioSourceType.play:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource.Play.html", 
					"");
				break;

			case ComputeAudioSourceType.pause:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource.Pause.html", 
					"");
				break;

			case ComputeAudioSourceType.getVolume:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-volume.html", 
					"");
				break;

			case ComputeAudioSourceType.getTime:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-time.html", 
					"");
				break;

			case ComputeAudioSourceType.getSpatialize:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-spatialize.html", 
					"");
				break;

			case ComputeAudioSourceType.getSpatialBlend:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-spatialBlend.html", 
					"");
				break;

			case ComputeAudioSourceType.getPriority:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-priority.html", 
					"");
				break;

			case ComputeAudioSourceType.getPitch:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-pitch.html", 
					"");
				break;

			case ComputeAudioSourceType.getPanStereo:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-panStereo.html", 
					"");
				break;

			case ComputeAudioSourceType.getMute:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-mute.html", 
					"");
				break;

			case ComputeAudioSourceType.getMinDistance:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-minDistance.html", 
					"");
				break;

			case ComputeAudioSourceType.getMaxDistance:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-maxDistance.html", 
					"");
				break;

			case ComputeAudioSourceType.getLoop:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-loop.html", 
					"");
				break;

			case ComputeAudioSourceType.getIsPlaying:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/AudioSource-isPlaying.html", 
					"");
				break;

			}
		}


		void ApplyTimeOperation ()
		{
			switch (timeType)
			{
			case TimeType.deltaTime:
				floatValue = Time.deltaTime;
				break;

			case TimeType.fixedDeltaTime:
				floatValue = Time.fixedDeltaTime;
				break;

			case TimeType.fps:
				floatValue = 1f / Time.deltaTime;
				break;

			case TimeType.framesSinceLevelLoad:
				DrawLogicNodeLabel ("Moduled by", 0, 2);
				DrawFloatInputField (0, 1, 2);

				floatValues [0] = Mathf.Max (floatValues [0], 1f); 
				break;

			case TimeType.timeSinceLevelLoad:
				DrawLogicNodeLabel ("Moduled by", 0, 2);
				DrawFloatInputField (0, 1, 2);

				floatValues [0] = Mathf.Max (floatValues [0], 1f); 
				break;

			case TimeType.tictacOnTime:
				DrawLogicNodeLabel ("With Period", 0, 2);
				DrawFloatInputField (0, 1, 2);

				floatValues [0] = Mathf.Max (floatValues [0], 0f); 
				break;

			case TimeType.tictacOnFrames:
				DrawLogicNodeLabel ("With Period", 0, 2);
				DrawFloatInputField (0, 1, 2);

				floatValues [0] = Mathf.Max (floatValues [0], 0f); 
				break;
			}
		}
		void TimeOperation_OutputField ()
		{
			switch (timeType)
			{
			case TimeType.deltaTime:
				DrawFloatResultField (true);
				break;

			case TimeType.fixedDeltaTime:
				DrawFloatResultField (true);
				break;

			case TimeType.fps:
				DrawFloatResultField (true);
				break;

			case TimeType.framesSinceLevelLoad:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawFloatResultField (true);
				break;

			case TimeType.timeSinceLevelLoad:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawFloatResultField (true);
				break;

			case TimeType.tictacOnTime:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawBoolResultField ();
				break;

			case TimeType.tictacOnFrames:
				DrawInNodeInfo (workOnlyOnGeneratedScripts);
				DrawBoolResultField ();
				break;
			}
		}

		void ApplyUnityInputClassAndCrossPlatform ()
		{
			axisNameIsSetup = true;

			ComputeUnityInputClassAndCrossPlatform_InputFields ();

			if (logic.playing) 
			{
				if (axisNameIsSetup)
				{
					ComputeUnityInputClassAndCrossPlatform ();
				}
			}

			ComputeUnityInputClassAndCrossPlatform_OutputFields ();
		}
		public int computeUnityInputClassAndCrossPlatformType_length = 0;
		public string computeUnityInputClassAndCrossPlatformType_last;

		public int iMECompositionMode_length = 0;
		public string iMECompositionMode_last;

		void ComputeUnityInputClassAndCrossPlatform_InputFields ()
		{
			

			computeUnityInputClassAndCrossPlatformType = (ComputeUnityInputClassAndCrossPlatformType)DrawEnumComputeType (
				computeUnityInputClassAndCrossPlatformType, 
				ref computeUnityInputClassAndCrossPlatformType_length,
				ref computeUnityInputClassAndCrossPlatformType_last, 
				typeof(ComputeUnityInputClassAndCrossPlatformType));

			switch (computeUnityInputClassAndCrossPlatformType)
			{
			case ComputeUnityInputClassAndCrossPlatformType.touchSupported:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.touchPressureSupported:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.touchCount:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.stylusTouchSupported:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.stopLocationService:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.startLocationService:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.setSimulateMouseWithTouches:
				DrawBoolInputField (0);
				break;


			case ComputeUnityInputClassAndCrossPlatformType.setImeCompositionMode:
				iMECompositionMode = (IMECompositionMode)DrawEnum (iMECompositionMode,
					ref iMECompositionMode_length, ref iMECompositionMode_last, typeof(IMECompositionMode),
					"IME Composition Mode", Skins.logicNodeLabel);
				//DrawLogicNodeLabel ("IME Composition Mode", 0, 2);
				//iMECompositionMode = (IMECompositionMode)DrawEnum (iMECompositionMode, FieldDrawType.label, 1, 2);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setCompositionCursorPos:
				DrawVector2InputField (0);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setCompensateSensors:
				DrawBoolInputField (0);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setBackButtonLeavesApp:
				DrawBoolInputField (0);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.ResetInputAxes:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.multiTouchEnabled:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.mouseScrollDelta:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.mousePresent:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.mousePosition:
				//DrawInNodeInfo (crossPlatformRunOnlyInRunTime);
				DrawInNodeInfo (makeSureCrossPlatformImported);

				break;

			case ComputeUnityInputClassAndCrossPlatformType.mousePositionNoCrossPlatform:

				break;



			case ComputeUnityInputClassAndCrossPlatformType.locationServiceGetStatus:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.locationServiceGetLastData:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.locationServiceIsEnabledByUser:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.IsJoystickPreconfigured:
				//DrawLogicNodeLabel ("Joystick Name");
				//DrawStringInputField (0, stringInputFieldForWhat.general);

				DrawLogicNodeLabel ("Joystick Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.inputString:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.imeIsSelected:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.getImeCompositionMode:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.gyro:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetTouch:
				DrawIntInputField (0);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.getSimulateMouseWithTouches:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetMouseButtonUp:
				DrawIntInputField (0);
				intValues [0] = Mathf.Clamp (intValues [0], 0, 6);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetMouseButtonDown:				
				DrawIntInputField (0);
				intValues [0] = Mathf.Clamp (intValues [0], 0, 6);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetMouseButton:				
				DrawIntInputField (0);
				intValues [0] = Mathf.Clamp (intValues [0], 0, 6);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetKeyUp:
				DrawKeyCodeEnum ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetKeyDown:
				DrawKeyCodeEnum ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetKey:
				DrawKeyCodeEnum ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetJoystickNames:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.getCompositionCursorPos:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.getCompensateSensors:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonUp:
				//DrawInNodeInfo (crossPlatformRunOnlyInRunTime);
				DrawInNodeInfo (makeSureCrossPlatformImported);

				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonUpNoCrossPlatform:
				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonDown:
				//DrawInNodeInfo (crossPlatformRunOnlyInRunTime);
				DrawInNodeInfo (makeSureCrossPlatformImported);

				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonDownNoCrossPlatform:
				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButton:
				//DrawInNodeInfo (crossPlatformRunOnlyInRunTime);
				DrawInNodeInfo (makeSureCrossPlatformImported);

				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonNoCrossPlatform:
				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.getBackButtonLeavesApp:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxisRaw:
				//DrawInNodeInfo (crossPlatformRunOnlyInRunTime);
				DrawInNodeInfo (makeSureCrossPlatformImported);

				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxisRawNoCrossPlatform:
				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxis:
				//DrawInNodeInfo (crossPlatformRunOnlyInRunTime);
				DrawInNodeInfo (makeSureCrossPlatformImported);

				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxisNoCrossPlatform:
				DrawLogicNodeLabel ("Axis Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				CheckAxisNameSetup ();

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAccelerationEventDeltaTime:
				DrawIntInputField (0);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAccelerationEventAcceleration:
				DrawIntInputField (0);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.deviceOrientation:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.compositionString:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.compass:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.anyKeyDown:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.anyKey:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.accelerationEventsDeltaTimes:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.accelerationEventsAccelerations:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.accelerationEventCount:

				break;

			case ComputeUnityInputClassAndCrossPlatformType.acceleration:

				break;

			}
		}
		void ComputeUnityInputClassAndCrossPlatform ()
		{
			switch (computeUnityInputClassAndCrossPlatformType)
			{
			case ComputeUnityInputClassAndCrossPlatformType.touchSupported:
				boolValue = Input.touchSupported;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.touchPressureSupported:
				boolValue = Input.touchPressureSupported;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.touchCount:
				intValue = Input.touchCount;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.stylusTouchSupported:
				boolValue = Input.stylusTouchSupported;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.stopLocationService:
				Input.location.Stop ();
				break;

			case ComputeUnityInputClassAndCrossPlatformType.startLocationService:
				Input.location.Start ();
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setSimulateMouseWithTouches:
				Input.simulateMouseWithTouches = boolValues [0];
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setImeCompositionMode:
				Input.imeCompositionMode = iMECompositionMode;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setCompositionCursorPos:
				Input.compositionCursorPos = vector2Values [0];
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setCompensateSensors:
				Input.compensateSensors = boolValues [0];
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setBackButtonLeavesApp:
				Input.backButtonLeavesApp = boolValues [0];
				break;

			case ComputeUnityInputClassAndCrossPlatformType.ResetInputAxes:
				Input.ResetInputAxes ();
				break;

			case ComputeUnityInputClassAndCrossPlatformType.multiTouchEnabled:
				boolValue = Input.multiTouchEnabled;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.mouseScrollDelta:
				vector2Value = Input.mouseScrollDelta;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.mousePresent:
				boolValue = Input.mousePresent;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.mousePosition:
#if CROSS_PLATFORM_INPUT
					vector3Value = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.mousePosition;
#else
					vector3Value = Input.mousePosition;
#endif
					break;

			case ComputeUnityInputClassAndCrossPlatformType.mousePositionNoCrossPlatform:
				vector3Value = Input.mousePosition;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.locationServiceGetStatus:
				stringValue = Input.location.status.ToString ();
				break;

			case ComputeUnityInputClassAndCrossPlatformType.locationServiceGetLastData:
				stringValue = Input.location.lastData.ToString ();
				break;

			case ComputeUnityInputClassAndCrossPlatformType.locationServiceIsEnabledByUser:
				boolValue = Input.location.isEnabledByUser;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.IsJoystickPreconfigured:
				boolValue = Input.IsJoystickPreconfigured (stringValues [0]);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.inputString:
				stringValue = Input.inputString;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.imeIsSelected:
				boolValue = Input.imeIsSelected;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.getImeCompositionMode:
				stringValue = Input.imeCompositionMode.ToString ();
				break;

			case ComputeUnityInputClassAndCrossPlatformType.gyro:
				Gyroscope gyro = Input.gyro;


				boolValue = gyro.enabled;

				vector3Value = gyro.gravity;

				floatValue = gyro.updateInterval;



				m44Value [0] = gyro.attitude.x;

				m44Value [1] = gyro.attitude.y;

				m44Value [2] = gyro.attitude.z;

				m44Value [3] = gyro.attitude.w;



				m44Value [4] = gyro.rotationRate.x;

				m44Value [5] = gyro.rotationRate.y;

				m44Value [6] = gyro.rotationRate.z;

				m44Value [7] = 1f;


				m44Value [8] = gyro.userAcceleration.x;

				m44Value [9] = gyro.userAcceleration.y;

				m44Value [10] = gyro.userAcceleration.z;

				m44Value [11] = 1f;


				m44Value [12] = gyro.rotationRateUnbiased.x;

				m44Value [13] = gyro.rotationRateUnbiased.y;

				m44Value [14] = gyro.rotationRateUnbiased.z;

				m44Value [15] = 1f;

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetTouch:
				intValues [0] = Mathf.Clamp  (intValues [0], 0, Input.touchCount);

				if (Input.touchCount > 0) 
				{
					Touch touch = Input.GetTouch (intValues [0]);


					touch_altitudeAngle = touch.altitudeAngle; 

					touch_azimuthAngle = touch.azimuthAngle;

					touch_deltaPosition = touch.deltaPosition;

					touch_deltaTime = touch.deltaTime;



					touch_fingerId = touch.fingerId;

					touch_maximumPossiblePressure = touch.maximumPossiblePressure;

					touch_phase = touch.phase.ToString ();

					touch_position = touch.position;

					touch_pressure = touch.pressure;



					touch_radius = touch.radius;

					touch_radiusVariance = touch.radiusVariance;

					touch_rawPosition = touch.rawPosition;

					touch_tapCount = touch.tapCount;

					touch_type = touch.type.ToString ();
				}

				break;

			case ComputeUnityInputClassAndCrossPlatformType.getSimulateMouseWithTouches:
				boolValue = Input.simulateMouseWithTouches;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetMouseButtonUp:
				boolValue = Input.GetMouseButtonUp (intValues [0]);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetMouseButtonDown:
				boolValue = Input.GetMouseButtonDown (intValues [0]);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetMouseButton:
				boolValue = Input.GetMouseButton (intValues [0]);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetKeyUp:
				boolValue = Input.GetKeyUp (keyCode);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetKeyDown:
				boolValue = Input.GetKeyDown (keyCode);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetKey:
				boolValue = Input.GetKey (keyCode);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetJoystickNames:
				stringsListValue = new List<string>();
				for (int i = 0; i < Input.GetJoystickNames ().Length; i++)
				{
					stringsListValue.Add (Input.GetJoystickNames ()[i]);
				}


				break;

			case ComputeUnityInputClassAndCrossPlatformType.getCompositionCursorPos:
				vector2Value = Input.compositionCursorPos;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.getCompensateSensors:
				boolValue = Input.compensateSensors;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonUp:
#if CROSS_PLATFORM_INPUT
					boolValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetButtonUp (stringValues [0]);
#else
					boolValue = Input.GetButtonUp (stringValues [0]);
#endif
					break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonUpNoCrossPlatform:
				boolValue = Input.GetButtonUp (stringValues [0]);

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonDown:
#if CROSS_PLATFORM_INPUT
					boolValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetButtonDown (stringValues [0]);
#else
					boolValue = Input.GetButtonDown (stringValues [0]);
#endif
					break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonDownNoCrossPlatform:
				boolValue = Input.GetButtonDown (stringValues [0]);
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButton:
#if CROSS_PLATFORM_INPUT
					boolValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetButton (stringValues [0]);
#else
					boolValue = Input.GetButton (stringValues [0]);
#endif
					break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonNoCrossPlatform:
				boolValue = Input.GetButton (stringValues [0]);

				break;

			case ComputeUnityInputClassAndCrossPlatformType.getBackButtonLeavesApp:
				boolValue = Input.backButtonLeavesApp;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxisRaw:
#if CROSS_PLATFORM_INPUT
					floatValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetAxisRaw (stringValues [0]);
#else
					floatValue = Input.GetAxisRaw (stringValues [0]);
#endif
					break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxisRawNoCrossPlatform:
				floatValue = Input.GetAxisRaw (stringValues [0]);

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxis:
#if CROSS_PLATFORM_INPUT
					floatValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetAxis (stringValues [0]);
#else
					floatValue = Input.GetAxis (stringValues [0]);
#endif
					break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxisNoCrossPlatform:
				floatValue = Input.GetAxis (stringValues [0]);

				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAccelerationEventDeltaTime:
				floatValue = Input.GetAccelerationEvent (intValues [0]).deltaTime;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAccelerationEventAcceleration:
				vector3Value = Input.GetAccelerationEvent (intValues [0]).acceleration;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.deviceOrientation:
				stringValue = Input.deviceOrientation.ToString ();
				break;

			case ComputeUnityInputClassAndCrossPlatformType.compositionString:
				stringValue = Input.compositionString;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.compass:
				boolValue = Input.compass.enabled;

				vector4Value = new Vector4 (
					Input.compass.headingAccuracy,
					Input.compass.magneticHeading,
					Input.compass.trueHeading,
					(float)Input.compass.timestamp);

				vector3Value = Input.compass.rawVector;

				break;

			case ComputeUnityInputClassAndCrossPlatformType.anyKeyDown:
				boolValue = Input.anyKeyDown;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.anyKey:
				boolValue = Input.anyKey;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.accelerationEventsDeltaTimes:
				accelerationEvents = Input.accelerationEvents;

				floatsListValue = new List<float> ();

				for (int i = 0; i < accelerationEvents.Length; i++)
				{
					floatsListValue.Add (accelerationEvents [i].deltaTime);
				}

				break;

			case ComputeUnityInputClassAndCrossPlatformType.accelerationEventsAccelerations:
				accelerationEvents = Input.accelerationEvents;

				vector3ListValue = new List<Vector3> ();

				for (int i = 0; i < accelerationEvents.Length; i++)
				{
					vector3ListValue.Add (accelerationEvents [i].acceleration);
				}

				break;

			case ComputeUnityInputClassAndCrossPlatformType.accelerationEventCount:
				intValue = Input.accelerationEventCount;
				break;

			case ComputeUnityInputClassAndCrossPlatformType.acceleration:
				vector3Value = Input.acceleration;
				break;

			}
		}
		void ComputeUnityInputClassAndCrossPlatform_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeUnityInputClassAndCrossPlatformType)
			{
			case ComputeUnityInputClassAndCrossPlatformType.touchSupported:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-touchSupported.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.touchPressureSupported:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-touchPressureSupported.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.touchCount:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-touchCount.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.stylusTouchSupported:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-stylusTouchSupported.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.stopLocationService:


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/LocationService.Stop.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.startLocationService:


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/LocationService.Start.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setSimulateMouseWithTouches:


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-simulateMouseWithTouches.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setImeCompositionMode:


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/IMECompositionMode.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setCompositionCursorPos:


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-compositionCursorPos.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setCompensateSensors:


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-compensateSensors.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.setBackButtonLeavesApp:


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-backButtonLeavesApp.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.ResetInputAxes:


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.ResetInputAxes.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.multiTouchEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-multiTouchEnabled.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.mouseScrollDelta:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-mouseScrollDelta.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.mousePresent:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-mousePresent.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.mousePosition:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-mousePosition.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.mousePositionNoCrossPlatform:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-mousePosition.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.locationServiceGetStatus:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/LocationServiceStatus.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.locationServiceGetLastData:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/LocationInfo.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.locationServiceIsEnabledByUser:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/LocationService-isEnabledByUser.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.IsJoystickPreconfigured:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.IsJoystickPreconfigured.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.inputString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-inputString.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.imeIsSelected:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-imeIsSelected.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.getImeCompositionMode:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/IMECompositionMode.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.gyro:
				DrawM44ResultField (new string []
					{
						"gyro.attitude.x",
						"gyro.attitude.y",
						"gyro.attitude.z",
						"gyro.attitude.w",

						"gyro.rotationRate.x",
						"gyro.rotationRate.y",
						"gyro.rotationRate.z",
						"none",

						"gyro.userAcceleration.x",
						"gyro.userAcceleration.y",
						"gyro.userAcceleration.z",
						"none",

						"gyro.rotationRateUnbiased.x",
						"gyro.rotationRateUnbiased.y",
						"gyro.rotationRateUnbiased.z",
						"none",
					});


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Gyroscope.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetTouch:
				DrawTouchOutputField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetTouch.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.getSimulateMouseWithTouches:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-simulateMouseWithTouches.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetMouseButtonUp:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetMouseButtonUp.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetMouseButtonDown:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetMouseButtonDown.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetMouseButton:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetKeyUp:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetKeyUp.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetKeyDown:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetKeyDown.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetKey:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetKey.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetJoystickNames:
				DrawStringsListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetJoystickNames.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.getCompositionCursorPos:
				DrawVector2ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-compositionCursorPos.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.getCompensateSensors:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-compensateSensors.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonUp:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetButtonUp.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonUpNoCrossPlatform:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetButtonUp.html", 
					"");
				break;


			case ComputeUnityInputClassAndCrossPlatformType.GetButtonDown:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetButtonDown.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonDownNoCrossPlatform:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetButtonDown.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButton:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetButton.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetButtonNoCrossPlatform:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetButton.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.getBackButtonLeavesApp:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-backButtonLeavesApp.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxisRaw:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetAxisRaw.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxisRawNoCrossPlatform:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetAxisRaw.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxis:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetAxis.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAxisNoCrossPlatform:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetAxis.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAccelerationEventDeltaTime:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetAccelerationEvent.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.GetAccelerationEventAcceleration:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input.GetAccelerationEvent.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.deviceOrientation:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/DeviceOrientation.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.compositionString:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-compositionString.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.compass:
				DrawLogicNodeLabel ("Enabled", 0, 2);
				DrawBoolResultField (1, 2);				
				DrawLogicNodeLabel ("headingAccuracy -> x");
				DrawLogicNodeLabel ("magneticHeading -> y");
				DrawLogicNodeLabel ("trueHeading -> z");
				DrawLogicNodeLabel ("(float)timestamp -> w");
				DrawVector4ResultField (true);				
				DrawLogicNodeLabel ("rawVector", 0, 2);
				DrawVector3ResultField (true, 1, 2);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Compass.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.anyKeyDown:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-anyKeyDown.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.anyKey:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-anyKey.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.accelerationEventsDeltaTimes:
				DrawFloatListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-accelerationEvents.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.accelerationEventsAccelerations:
				DrawVector3ListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-accelerationEvents.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.accelerationEventCount:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-accelerationEventCount.html", 
					"");
				break;

			case ComputeUnityInputClassAndCrossPlatformType.acceleration:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Input-acceleration.html", 
					"");
				break;

			}
		}

		void ApplyComputeCamera ()
		{
			ComputeCamera_InputFields ();
			if (logic.playing)ComputeCamera ();
			ComputeCamera_OutputFields ();
		}
		public int computeCameraType_length = 0;
		public string computeCameraType_last;
	
		public int transparencySortMode_length = 0;
		public string transparencySortMode_last;

		public int camera_StereoscopicEye_length = 0;
		public string camera_StereoscopicEye_last;

		void DrawEnumCamera_StereoscopicEye ()
		{
			camera_StereoscopicEye = (Camera.StereoscopicEye)DrawEnum (camera_StereoscopicEye,
				ref camera_StereoscopicEye_length,
				ref camera_StereoscopicEye_last, typeof(Camera.StereoscopicEye),
				"Stereoscopic Eye", Skins.logicNodeLabel);
		}

		public int renderingPath_length = 0;
		public string renderingPath_last;

		public int opaqueSortMode_length = 0;
		public string opaqueSortMode_last;

		public int depthTextureMode_length = 0;
		public string depthTextureMode_last;

		void ComputeCamera_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			DrawGameObjectFieldInput (0);

			if ( ! linkedOrAttachedTo)
			{
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();

					computeCameraType = (ComputeCameraType)DrawEnumComputeType (computeCameraType, 
						ref computeCameraType_length, ref computeCameraType_last, typeof(ComputeCameraType));

					return;
				}
			}
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			if ( ! linkedOrAttachedTo)
			{
				cam = gameObjectValues [0].GetComponent <Camera>();

				if (cam == null)
				{
					DrawInNodeInfo ("Add Camera To GameObject");

					linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
						IsGameObject_0_AttachedTo () || 
						gameObjectValues [0] == null ||
						cam == null;

					return;
				}

			}
			computeCameraType = (ComputeCameraType)DrawEnumComputeType (computeCameraType, 
				ref computeCameraType_length, ref computeCameraType_last, typeof(ComputeCameraType));

			switch (computeCameraType)
			{
			case ComputeCameraType.WorldToViewportPoint:
				DrawLabelFields (new string[] {"World Point",});
				DrawVector3InputField (0);

				break;

			case ComputeCameraType.WorldToScreenPoint:
				DrawLabelFields (new string[] {"World Point",});
				DrawVector3InputField (0);

				break;

			case ComputeCameraType.ViewportToWorldPoint:
				DrawLabelFields (new string[] {"Viewport Point (normalized)",});
				DrawVector3InputField (0);

				break;

			case ComputeCameraType.ViewportToScreenPoint:
				DrawLabelFields (new string[] {"Viewport Point (normalized)",});
				DrawVector3InputField (0);

				break;

			case ComputeCameraType.ViewportPointToRay:
				DrawLabelFields (new string[] {"Viewport Point (normalized), z ignored",});
				DrawVector3InputField (0);

				break;

			case ComputeCameraType.setUseOcclusionCulling:
				DrawBoolInputField (0);
				break;



			case ComputeCameraType.setTransparencySortMode:
				transparencySortMode = (TransparencySortMode)DrawEnum (
					transparencySortMode,
					ref transparencySortMode_length, ref transparencySortMode_last, typeof(TransparencySortMode),
					"Transparency Sort Mode", Skins.logicNodeLabel);
				break;

			case ComputeCameraType.setTargetDisplay:
				DrawIntInputField (0);
				break;




			case ComputeCameraType.SetStereoViewMatrices:
				DrawEnumCamera_StereoscopicEye ();

				DrawLabelFields (new string[]{"Matrix"});
				DrawM44EntierInputField (0);


				break;

			case ComputeCameraType.setStereoSeparation:
				DrawFloatInputField (0);
				break;

			case ComputeCameraType.getNonJitteredProjectionMatrix:

				break;

			case ComputeCameraType.setNonJitteredProjectionMatrix:
				DrawLabelFields (new string[]{"Matrix"});
				DrawM44EntierInputField (0);


				break;

			case ComputeCameraType.SetStereoProjectionMatrices:
				DrawEnumCamera_StereoscopicEye ();

				DrawLabelFields (new string[]{"Matrix"});
				DrawM44EntierInputField (0);


				break;

			case ComputeCameraType.setStereoConvergence:
				DrawFloatInputField (0);
				break;

			case ComputeCameraType.SetReplacementShader:
				DrawShaderFieldInput (0);

				DrawLabelFields (new string[] {"Replacement Tag",});
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;



			case ComputeCameraType.setRenderingPath:
				renderingPath = (RenderingPath)DrawEnum (
					renderingPath,
					ref  renderingPath_length, ref renderingPath_last, typeof(RenderingPath),
					"RenderingPath", Skins.logicNodeLabel);
				break;

			case ComputeCameraType.setRectNormalizedToTheScreen:
				DrawRectInputField (0);
				break;

			case ComputeCameraType.setProjectionMatrix:
				DrawM44EntierInputField (0);
				break;

			case ComputeCameraType.setPixelRect:
				DrawRectInputField (0);
				break;

			case ComputeCameraType.setOrthographicSize:
				DrawFloatInputField (0);
				break;

			case ComputeCameraType.setOrthographic:
				DrawBoolInputField (0);
				break;

			case ComputeCameraType.setOpaqueSortMode:
				opaqueSortMode = (OpaqueSortMode)DrawEnum (
					opaqueSortMode,
					ref opaqueSortMode_length, ref opaqueSortMode_last, typeof(OpaqueSortMode),
					"Opaque Sort Mode", Skins.logicNodeLabel);

				break;

			case ComputeCameraType.setNearClipPlane:
				DrawFloatInputField (0);
				break;

			case ComputeCameraType.setIsStereoMirrorMode:
				DrawBoolInputField (0);
				#if UNITY_2017_2_OR_NEWER
				DrawInNodeInfo ("stereoMirrorMode is obsolete, use:");
				DrawInNodeInfo ("single pass stereo rendering instead");
				if (GUI.Button (GetSuitableRect (FieldDrawType.variable), "More Info"))
				{
				Application.OpenURL ("https://docs.unity3d.com/Manual/SinglePassStereoRendering.html");
				}
				#endif
				break;

			case ComputeCameraType.setAllowHdr:
				DrawBoolInputField (0);
				break;

			case ComputeCameraType.setFieldOfView:
				DrawFloatInputField (0);
				break;

			case ComputeCameraType.setFarClipPlane:
				DrawFloatInputField (0);
				break;

			case ComputeCameraType.setEventMask:
				DrawIntInputField (0);
				break;

			case ComputeCameraType.setEnabled:
				DrawBoolInputField (0);
				break;


			case ComputeCameraType.setDepthTextureMode:
				depthTextureMode = (DepthTextureMode)DrawEnum (
					depthTextureMode, ref depthTextureMode_length, ref depthTextureMode_last, typeof(DepthTextureMode),
					"Depth Texture Mode", Skins.logicNodeLabel);
				break;

			case ComputeCameraType.setDepth:
				DrawFloatInputField (0);
				break;

			case ComputeCameraType.setCullingMask:

				DrawLabelFields (new string[]
					{
						"-1" + StringTreatment.rArrow + "everything",
						"0" + StringTreatment.rArrow + "nothing",
						"1" + StringTreatment.rArrow + "default",
						"2" + StringTreatment.rArrow + "transparentFx",
						"3" + StringTreatment.rArrow + "default + transparentFx",
						"4" + StringTreatment.rArrow + "ignore raycast",
						"5" + StringTreatment.rArrow + "default + ignore raycast",
						"6" + StringTreatment.rArrow + "transparentFx + ignore raycast",
						"7" + StringTreatment.rArrow + "default + transparentFx + ignore raycast",
						"16" + StringTreatment.rArrow + "water",
						"32" + StringTreatment.rArrow + "UI",
						"48" + StringTreatment.rArrow + "water + UI",
					});

				DrawIntInputField (0);
				break;

			case ComputeCameraType.setBackgroundColor:
				DrawColorInputField (0);
				break;

			case ComputeCameraType.setAspectRatio:
				DrawFloatInputField (0);
				floatValues [0] = Mathf.Max (0.2f, floatValues [0]);
				break;

			case ComputeCameraType.ScreenToWorldPoint:
				DrawLabelFields (new string[] {"Screen Point (pixels)",});
				DrawVector3InputField (0);
				break;

			case ComputeCameraType.ScreenToViewportPoint:
				DrawLabelFields (new string[] {"Screen Point (pixels)",});
				DrawVector3InputField (0);
				break;

			case ComputeCameraType.ScreenPointToRay:
				DrawLabelFields (new string[] {"Screen Point (pixels), z ignored",});
				DrawVector3InputField (0);
				break;

			case ComputeCameraType.ResetWorldToCameraMatrix:

				break;

			case ComputeCameraType.ResetStereoViewMatrices:

				break;

			case ComputeCameraType.ResetStereoProjectionMatrices:

				break;

			case ComputeCameraType.ResetReplacementShader:

				break;

			case ComputeCameraType.ResetProjectionMatrix:

				break;

			case ComputeCameraType.ResetFieldOfView:

				break;

			case ComputeCameraType.ResetAspect:

				break;

			case ComputeCameraType.RenderWithShader:
				DrawShaderFieldInput (0);

				DrawLabelFields (new string[] {"Replacement Tag",});
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeCameraType.RenderManually:

				break;

			case ComputeCameraType.getWorldToCameraMatrix:

				break;

			case ComputeCameraType.getVelocity:

				break;

			case ComputeCameraType.getUseOcclusionCulling:

				break;

			case ComputeCameraType.getTransparencySortMode:

				break;

			case ComputeCameraType.getTargetDisplay:

				break;

			case ComputeCameraType.getStereoSeparation:

				break;

			case ComputeCameraType.getStereoEnabled:

				break;

			case ComputeCameraType.getStereoConvergence:

				break;

			case ComputeCameraType.getRenderingPath:

				break;

			case ComputeCameraType.getRectNormalizedToTheScreen:

				break;

			case ComputeCameraType.getProjectionMatrix:

				break;

			case ComputeCameraType.getPixelWidth:

				break;

			case ComputeCameraType.getPixelRect:

				break;

			case ComputeCameraType.getPixelHeight:

				break;

			case ComputeCameraType.getOrthographicSize:

				break;

			case ComputeCameraType.getOrthographic:

				break;

			case ComputeCameraType.getOpaqueSortMode:

				break;

			case ComputeCameraType.getNearClipPlane:

				break;

			case ComputeCameraType.getIsStereoMirrorMode:
				#if UNITY_2017_2_OR_NEWER
				DrawInNodeInfo ("stereoMirrorMode is obsolete, use:");
				DrawInNodeInfo ("single pass stereo rendering instead");
				if (GUI.Button (GetSuitableRect (FieldDrawType.variable), "More Info"))
				{
				Application.OpenURL ("https://docs.unity3d.com/Manual/SinglePassStereoRendering.html");
				}
				#endif
				break;

			case ComputeCameraType.getAllowHdr:

				break;

			case ComputeCameraType.getFieldOfView:

				break;

			case ComputeCameraType.getFarClipPlane:

				break;

			case ComputeCameraType.getEventMask:

				break;

			case ComputeCameraType.getEnabled:

				break;

			case ComputeCameraType.getDepthTextureMode:

				break;

			case ComputeCameraType.getDepth:

				break;

			case ComputeCameraType.getCullingMask:

				break;

			case ComputeCameraType.getCameraToWorldMatrix:

				break;

			case ComputeCameraType.getBackgroundColor:

				break;

			case ComputeCameraType.getAspectRatio:

				break;

			case ComputeCameraType.getActualRenderingPath:

				break;

			case ComputeCameraType.CopySettingsToTheCamera:
				DrawLabelFields (new string[] {"from this gameObject's Camera",});

				DrawGameObjectFieldInput (1);

				if (gameObjectValues [1] == null)
				{
					DrawGameObject_0_isNullInfo ();

					return;
				}
				cam_1 = gameObjectValues [1].GetComponent <Camera> ();
				if (cam_1 == null)
				{
					DrawInNodeInfo ("Add Camera To GameObject");

					return;
				}
				break;

			case ComputeCameraType.CalculateObliqueMatrix:
				DrawLabelFields (new string[] {"projection matrix for this near-plane",});
				DrawVector4InputField (0);
				break;

			}
			DrawDoItButton();
		}
		void ComputeCamera ()
		{
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeCameraType)
			{
			case ComputeCameraType.WorldToViewportPoint:
				vector3Value = cam.WorldToViewportPoint (vector3Values [0]);
				break;

			case ComputeCameraType.WorldToScreenPoint:
				vector3Value = cam.WorldToScreenPoint (vector3Values [0]);
				break;

			case ComputeCameraType.ViewportToWorldPoint:
				vector3Value = cam.ViewportToWorldPoint (vector3Values [0]);
				break;

			case ComputeCameraType.ViewportToScreenPoint:
				vector3Value = cam.ViewportToScreenPoint (vector3Values [0]);
				break;

			case ComputeCameraType.ViewportPointToRay:
				rayValue = cam.ViewportPointToRay (vector3Values [0]);

				SetRayValueOrigine (rayValue.origin);
				SetRayDirectionValue (rayValue.direction);
				break;

			case ComputeCameraType.setUseOcclusionCulling:
				cam.useOcclusionCulling = boolValues [0];
				break;

			case ComputeCameraType.setTransparencySortMode:
				cam.transparencySortMode = transparencySortMode;
				break;

			case ComputeCameraType.setTargetDisplay:
				cam.targetDisplay = intValues [0];
				break;

			case ComputeCameraType.SetStereoViewMatrices:
				cam.SetStereoViewMatrix (camera_StereoscopicEye, m44Value_Input_entier [0]);
				break;

			case ComputeCameraType.setStereoSeparation:
				cam.stereoSeparation = floatValues [0];
				break;

			case ComputeCameraType.getNonJitteredProjectionMatrix:
				m44Value_entier = cam.nonJitteredProjectionMatrix;
				SetM44Value (m44Value_entier);
				break;

			case ComputeCameraType.setNonJitteredProjectionMatrix:
				cam.nonJitteredProjectionMatrix = m44Value_Input_entier [0];
				break;

			case ComputeCameraType.SetStereoProjectionMatrices:
				cam.SetStereoProjectionMatrix (camera_StereoscopicEye, m44Value_Input_entier [0]);
				break;

			case ComputeCameraType.setStereoConvergence:
				cam.stereoConvergence = floatValues [0];
				break;

			case ComputeCameraType.SetReplacementShader:
				if (shaderValues [0] != null)
				{
					cam.SetReplacementShader (shaderValues [0], stringValues [0]);
				}

				break;

			case ComputeCameraType.setRenderingPath:
				cam.renderingPath = renderingPath;
				break;

			case ComputeCameraType.setRectNormalizedToTheScreen:
				cam.rect = rectValues [0];
				break;

			case ComputeCameraType.setProjectionMatrix:
				cam.projectionMatrix = m44Value_Input_entier [0];
				break;

			case ComputeCameraType.setPixelRect:
				cam.pixelRect = rectValues [0];
				break;

			case ComputeCameraType.setOrthographicSize:
				cam.orthographicSize = floatValues [0];
				break;

			case ComputeCameraType.setOrthographic:
				cam.orthographic = boolValues [0];
				break;

			case ComputeCameraType.setOpaqueSortMode:
				cam.opaqueSortMode = opaqueSortMode;
				break;

			case ComputeCameraType.setNearClipPlane:
				cam.nearClipPlane = floatValues [0];
				break;

			case ComputeCameraType.setIsStereoMirrorMode:
				#if UNITY_5_6 || UNITY_2017_1
				cam.stereoMirrorMode = boolValues [0];
				#endif
				break;

			case ComputeCameraType.setAllowHdr:
				cam.allowHDR = boolValues [0];
				break;

			case ComputeCameraType.setFieldOfView:
				cam.fieldOfView = floatValues [0];
				break;

			case ComputeCameraType.setFarClipPlane:
				cam.farClipPlane = floatValues [0];
				break;

			case ComputeCameraType.setEventMask:
				cam.eventMask = intValues [0];
				break;

			case ComputeCameraType.setEnabled:
				cam.enabled = boolValues [0];
				break;

			case ComputeCameraType.setDepthTextureMode:
				cam.depthTextureMode = depthTextureMode;
				break;

			case ComputeCameraType.setDepth:
				cam.depth = floatValues [0];
				break;

			case ComputeCameraType.setCullingMask:
				cam.cullingMask = intValues [0];
				break;

			case ComputeCameraType.setBackgroundColor:
				cam.backgroundColor = colorValues [0];
				break;

			case ComputeCameraType.setAspectRatio:
				cam.aspect = floatValues [0];
				break;

			case ComputeCameraType.ScreenToWorldPoint:
				vector3Value = cam.ScreenToWorldPoint (vector3Values [0]);
				break;

			case ComputeCameraType.ScreenToViewportPoint:
				vector3Value = cam.ScreenToViewportPoint (vector3Values [0]);
				break;

			case ComputeCameraType.ScreenPointToRay:
				rayValue = cam.ScreenPointToRay (vector3Values [0]);

				SetRayValueOrigine (rayValue.origin);

				SetRayDirectionValue (rayValue.direction);
				break;

			case ComputeCameraType.ResetWorldToCameraMatrix:
				cam.ResetWorldToCameraMatrix ();
				break;

			case ComputeCameraType.ResetStereoViewMatrices:
				cam.ResetStereoViewMatrices ();
				break;

			case ComputeCameraType.ResetStereoProjectionMatrices:
				cam.ResetStereoProjectionMatrices ();
				break;

			case ComputeCameraType.ResetReplacementShader:
				cam.ResetReplacementShader ();
				break;

			case ComputeCameraType.ResetProjectionMatrix:
				cam.ResetProjectionMatrix ();
				break;

			case ComputeCameraType.ResetFieldOfView:
				cam.fieldOfView = 60f;
				break;

			case ComputeCameraType.ResetAspect:
				cam.ResetAspect ();
				break;

			case ComputeCameraType.RenderWithShader:
				if (shaderValues [0] != null)
				{
					cam.RenderWithShader (shaderValues [0], stringValues [0]);
				}

				break;

			case ComputeCameraType.RenderManually:
				cam.Render ();
				break;

			case ComputeCameraType.getWorldToCameraMatrix:
				m44Value_entier = cam.worldToCameraMatrix;
				SetM44Value (m44Value_entier);
				break;

			case ComputeCameraType.getVelocity:
				vector3Value = cam.velocity;
				break;

			case ComputeCameraType.getUseOcclusionCulling:
				boolValue = cam.useOcclusionCulling;
				break;

			case ComputeCameraType.getTransparencySortMode:
				stringValue = cam.transparencySortMode.ToString ();
				break;

			case ComputeCameraType.getTargetDisplay:
				intValue = cam.targetDisplay;
				break;

			case ComputeCameraType.getStereoSeparation:
				floatValue = cam.stereoSeparation;
				break;

			case ComputeCameraType.getStereoEnabled:
				boolValue = cam.stereoEnabled;
				break;

			case ComputeCameraType.getStereoConvergence:
				floatValue = cam.stereoConvergence;
				break;

			case ComputeCameraType.getRenderingPath:
				stringValue = cam.renderingPath.ToString ();
				break;

			case ComputeCameraType.getRectNormalizedToTheScreen:
				rectValue = cam.rect;
				break;

			case ComputeCameraType.getProjectionMatrix:
				m44Value_entier = cam.projectionMatrix;
				SetM44Value (m44Value_entier);
				break;

			case ComputeCameraType.getPixelWidth:
				intValue = cam.pixelWidth;
				break;

			case ComputeCameraType.getPixelRect:
				rectValue = cam.pixelRect;
				break;

			case ComputeCameraType.getPixelHeight:
				intValue = cam.pixelHeight;
				break;

			case ComputeCameraType.getOrthographicSize:
				floatValue = cam.orthographicSize;
				break;

			case ComputeCameraType.getOrthographic:
				boolValue = cam.orthographic;
				break;

			case ComputeCameraType.getOpaqueSortMode:
				stringValue = cam.opaqueSortMode.ToString ();
				break;

			case ComputeCameraType.getNearClipPlane:
				floatValue = cam.nearClipPlane;
				break;

			case ComputeCameraType.getIsStereoMirrorMode:
				#if UNITY_5_6 || UNITY_2017_1
				boolValue = cam.stereoMirrorMode;
				#endif
				break;

			case ComputeCameraType.getAllowHdr:
				boolValue = cam.allowHDR;
				break;

			case ComputeCameraType.getFieldOfView:
				floatValue = cam.fieldOfView;
				break;

			case ComputeCameraType.getFarClipPlane:
				floatValue = cam.farClipPlane;
				break;

			case ComputeCameraType.getEventMask:
				intValue = cam.eventMask;
				break;

			case ComputeCameraType.getEnabled:
				boolValue = cam.enabled;
				break;

			case ComputeCameraType.getDepthTextureMode:
				stringValue = cam.depthTextureMode.ToString ();
				break;

			case ComputeCameraType.getDepth:
				floatValue = cam.depth;
				break;

			case ComputeCameraType.getCullingMask:
				intValue = cam.cullingMask;
				break;

			case ComputeCameraType.getCameraToWorldMatrix:
				m44Value_entier = cam.cameraToWorldMatrix;
				SetM44Value (m44Value_entier);
				break;

			case ComputeCameraType.getBackgroundColor:
				colorValue = cam.backgroundColor;
				break;

			case ComputeCameraType.getAspectRatio:
				floatValue = cam.aspect;
				break;

			case ComputeCameraType.getActualRenderingPath:
				stringValue = cam.actualRenderingPath.ToString ();
				break;

			case ComputeCameraType.CopySettingsToTheCamera:
				if (cam_1 != null)
				{
					cam.CopyFrom (cam_1);
				}

				break;

			case ComputeCameraType.CalculateObliqueMatrix:
				m44Value_entier = cam.CalculateObliqueMatrix (vector4Values [0]);
				SetM44Value (m44Value_entier);
				break;

			}
		}
		void ComputeCamera_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeCameraType)
			{
			case ComputeCameraType.WorldToViewportPoint:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.WorldToViewportPoint.html", 
					"");
				break;

			case ComputeCameraType.WorldToScreenPoint:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.WorldToScreenPoint.html", 
					"");
				break;

			case ComputeCameraType.ViewportToWorldPoint:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ViewportToWorldPoint.html", 
					"");
				break;

			case ComputeCameraType.ViewportToScreenPoint:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ViewportToScreenPoint.html", 
					"");
				break;

			case ComputeCameraType.ViewportPointToRay:
				DrawRayResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ViewportPointToRay.html", 
					"");
				break;

			case ComputeCameraType.setUseOcclusionCulling:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-useOcclusionCulling.html", 
					"");
				break;

			case ComputeCameraType.setTransparencySortMode:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/TransparencySortMode.html", 
					"");
				break;

			case ComputeCameraType.setTargetDisplay:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-targetDisplay.html", 
					"");
				break;

			case ComputeCameraType.SetStereoViewMatrices:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.SetStereoViewMatrix.html", 
					"");
				break;

			case ComputeCameraType.setStereoSeparation:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-stereoSeparation.html", 
					"");
				break;

			case ComputeCameraType.getNonJitteredProjectionMatrix:
				DrawM44ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-nonJitteredProjectionMatrix.html", 
					"");
				break;

			case ComputeCameraType.setNonJitteredProjectionMatrix:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-nonJitteredProjectionMatrix.html", 
					"");
				break;

			case ComputeCameraType.SetStereoProjectionMatrices:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.SetStereoProjectionMatrix.html", 
					"");
				break;

			case ComputeCameraType.setStereoConvergence:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-stereoConvergence.html", 
					"");
				break;

			case ComputeCameraType.SetReplacementShader:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.SetReplacementShader.html", 
					"");
				break;

			case ComputeCameraType.setRenderingPath:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/RenderingPath.html", 
					"");
				break;

			case ComputeCameraType.setRectNormalizedToTheScreen:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-rect.html", 
					"");
				break;

			case ComputeCameraType.setProjectionMatrix:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-projectionMatrix.html", 
					"");
				break;

			case ComputeCameraType.setPixelRect:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-pixelRect.html", 
					"");
				break;

			case ComputeCameraType.setOrthographicSize:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-orthographicSize.html", 
					"");
				break;

			case ComputeCameraType.setOrthographic:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-orthographic.html", 
					"");
				break;

			case ComputeCameraType.setOpaqueSortMode:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rendering.OpaqueSortMode.html", 
					"");
				break;

			case ComputeCameraType.setNearClipPlane:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-nearClipPlane.html", 
					"");
				break;

			case ComputeCameraType.setIsStereoMirrorMode:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-stereoMirrorMode.html", 
					"");
				break;

			case ComputeCameraType.setAllowHdr:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-allowHDR.html", 
					"");
				break;

			case ComputeCameraType.setFieldOfView:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html", 
					"");
				break;

			case ComputeCameraType.setFarClipPlane:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-farClipPlane.html", 
					"");
				break;

			case ComputeCameraType.setEventMask:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-eventMask.html", 
					"");
				break;

			case ComputeCameraType.setEnabled:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeCameraType.setDepthTextureMode:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/DepthTextureMode.html", 
					"");
				break;

			case ComputeCameraType.setDepth:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-depth.html", 
					"");
				break;

			case ComputeCameraType.setCullingMask:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-cullingMask.html", 
					"");
				break;

			case ComputeCameraType.setBackgroundColor:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-backgroundColor.html", 
					"");
				break;

			case ComputeCameraType.setAspectRatio:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-aspect.html", 
					"");
				break;

			case ComputeCameraType.ScreenToWorldPoint:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html", 
					"");
				break;

			case ComputeCameraType.ScreenToViewportPoint:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ScreenToViewportPoint.html", 
					"");
				break;

			case ComputeCameraType.ScreenPointToRay:
				DrawRayResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ScreenPointToRay.html", 
					"");
				break;

			case ComputeCameraType.ResetWorldToCameraMatrix:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ResetWorldToCameraMatrix.html", 
					"");
				break;

			case ComputeCameraType.ResetStereoViewMatrices:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ResetStereoViewMatrices.html", 
					"");
				break;

			case ComputeCameraType.ResetStereoProjectionMatrices:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ResetStereoProjectionMatrices.html", 
					"");
				break;

			case ComputeCameraType.ResetReplacementShader:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ResetReplacementShader.html", 
					"");
				break;

			case ComputeCameraType.ResetProjectionMatrix:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ResetProjectionMatrix.html", 
					"");
				break;

			case ComputeCameraType.ResetFieldOfView:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ResetFieldOfView.html", 
					"");
				break;

			case ComputeCameraType.ResetAspect:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.ResetAspect.html", 
					"");
				break;

			case ComputeCameraType.RenderWithShader:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.RenderWithShader.html", 
					"");
				break;

			case ComputeCameraType.RenderManually:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.Render.html", 
					"");
				break;

			case ComputeCameraType.getWorldToCameraMatrix:
				DrawM44ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-worldToCameraMatrix.html", 
					"");
				break;

			case ComputeCameraType.getVelocity:
				DrawVector3ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-velocity.html", 
					"");
				break;

			case ComputeCameraType.getUseOcclusionCulling:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-useOcclusionCulling.html", 
					"");
				break;

			case ComputeCameraType.getTransparencySortMode:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/TransparencySortMode.html", 
					"");
				break;

			case ComputeCameraType.getTargetDisplay:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-targetDisplay.html", 
					"");
				break;

			case ComputeCameraType.getStereoSeparation:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-stereoSeparation.html", 
					"");
				break;

			case ComputeCameraType.getStereoEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-stereoEnabled.html", 
					"");
				break;

			case ComputeCameraType.getStereoConvergence:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-stereoConvergence.html", 
					"");
				break;

			case ComputeCameraType.getRenderingPath:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/RenderingPath.html", 
					"");
				break;

			case ComputeCameraType.getRectNormalizedToTheScreen:
				DrawRectResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-rect.html", 
					"");
				break;

			case ComputeCameraType.getProjectionMatrix:
				DrawM44ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-projectionMatrix.html", 
					"");
				break;

			case ComputeCameraType.getPixelWidth:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-pixelWidth.html", 
					"");
				break;

			case ComputeCameraType.getPixelRect:
				DrawRectResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-pixelRect.html", 
					"");
				break;

			case ComputeCameraType.getPixelHeight:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-pixelHeight.html", 
					"");
				break;

			case ComputeCameraType.getOrthographicSize:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-orthographicSize.html", 
					"");
				break;

			case ComputeCameraType.getOrthographic:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-orthographic.html", 
					"");
				break;

			case ComputeCameraType.getOpaqueSortMode:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Rendering.OpaqueSortMode.html", 
					"");
				break;

			case ComputeCameraType.getNearClipPlane:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-nearClipPlane.html", 
					"");
				break;

			case ComputeCameraType.getIsStereoMirrorMode:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-stereoMirrorMode.html", 
					"");
				break;

			case ComputeCameraType.getAllowHdr:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-allowHDR.html", 
					"");
				break;

			case ComputeCameraType.getFieldOfView:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html", 
					"");
				break;

			case ComputeCameraType.getFarClipPlane:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-farClipPlane.html", 
					"");
				break;

			case ComputeCameraType.getEventMask:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-eventMask.html", 
					"");
				break;

			case ComputeCameraType.getEnabled:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html", 
					"");
				break;

			case ComputeCameraType.getDepthTextureMode:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/DepthTextureMode.html", 
					"");
				break;

			case ComputeCameraType.getDepth:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-depth.html", 
					"");
				break;

			case ComputeCameraType.getCullingMask:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-cullingMask.html", 
					"");
				break;

			case ComputeCameraType.getCameraToWorldMatrix:
				DrawM44ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-cameraToWorldMatrix.html", 
					"");
				break;

			case ComputeCameraType.getBackgroundColor:
				DrawColorResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-backgroundColor.html", 
					"");
				break;

			case ComputeCameraType.getAspectRatio:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-aspect.html", 
					"");
				break;

			case ComputeCameraType.getActualRenderingPath:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera-actualRenderingPath.html", 
					"");
				break;

			case ComputeCameraType.CopySettingsToTheCamera:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.CopyFrom.html", 
					"");
				break;

			case ComputeCameraType.CalculateObliqueMatrix:
				DrawM44ResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					goToTheUnityDocumentation,
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Camera.CalculateObliqueMatrix.html", 
					"");
				break;

			}
		}

		void ApplyComputeGameObject ()
		{
			ComputeGameObject_InputFields (); 
			if (logic.playing)ComputeGameObject ();
			ComputeGameObject_OutputFields ();
		}
		public int computeGameObjectType_length = 0;
		public string computeGameObjectType_last;
		void ComputeGameObject_InputFields ()
		{
			linkedOrAttachedTo = (IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || 
				IsGameObject_0_AttachedTo () || 
				gameObjectValues [0] == null;

			if (computeGameObjectType != ComputeGameObjectType.get)
				DrawGameObjectFieldInput (0);

			if (computeGameObjectType != ComputeGameObjectType.get)
			if ( ! linkedOrAttachedTo)
			{
				if (computeGameObjectType != ComputeGameObjectType.get)
				if (gameObjectValues [0] == null)
				{
					DrawGameObject_0_isNullInfo ();


					computeGameObjectType = (ComputeGameObjectType)DrawEnumComputeType (computeGameObjectType,
						ref computeGameObjectType_length, ref computeGameObjectType_last, 
						typeof(ComputeGameObjectType));

					return;
				}
			}
			if (computeGameObjectType != ComputeGameObjectType.get)
			if (linkedOrAttachedTo)
			{
				DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);
			}
			computeGameObjectType = (ComputeGameObjectType)DrawEnumComputeType (computeGameObjectType,
				ref computeGameObjectType_length, ref computeGameObjectType_last, 
				typeof(ComputeGameObjectType));

			switch (computeGameObjectType)
			{
			case ComputeGameObjectType.listenToTransferredData:
				DrawInNodeInfo ("Default value: in the above gameObject field");
				DrawStringListMenuToString_0 ("Data Name",
					MezanixDiamondGameObjectNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);
				break;

			case ComputeGameObjectType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeGameObjectType.SpawnMeInAGrid:
				DrawLogicNodeLabel ("Grid Origine");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("How many on X, Y, and Z");
				DrawIntInputField (0, 0, 3);
				DrawIntInputField (1, 1, 3);
				DrawIntInputField (2, 2, 3);
				DrawLogicNodeLabel ("How much spacing on X, Y, and Z");
				DrawVector3InputField (1);
				break;

			case ComputeGameObjectType.otherGameObjectFoundOnMyWayAtDistance_2D:
				OtherGameObjectFoundOnMyWayAtDistance_InputFields_2D ();
				break;

			case ComputeGameObjectType.otherGameObjectFoundAtRadius_2D:
				OtherGameObjectFoundAtRadius_InputFields_2D ();
				break;

			case ComputeGameObjectType.otherGameObjectFoundOnMyWayAtDistance:
				OtherGameObjectFoundOnMyWayAtDistance_InputFields ();
				break;

			case ComputeGameObjectType.otherGameObjectFoundAtRadius:
				OtherGameObjectFoundAtRadius_InputFields ();
				break;

			case ComputeGameObjectType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_gameObject_DrawInputs ();
				break;

			case ComputeGameObjectType.hasThisTag:
				DrawTagField (0);
				break;

			case ComputeGameObjectType.isChildOf:
				DrawGameObjectFieldInput (1);
				break;

			case ComputeGameObjectType.isEqualTo:
				DrawGameObjectFieldInput (1);
				break;

			case ComputeGameObjectType.setTag:
				DrawTagField (0);
				break;

			case ComputeGameObjectType.setName:
				DrawStringInputField (0, stringInputFieldForWhat.general);
				break;

			case ComputeGameObjectType.setLayer:
				DrawIntInputField (0);
				break;

			case ComputeGameObjectType.instantiateAndChooseUp:
				DrawLogicNodeLabel ("At this position");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("Instatiated with this Up");
				DrawVector3InputField (1);
				break;

			case ComputeGameObjectType.instantiate:
				DrawLogicNodeLabel ("At this position");
				DrawVector3InputField (0);
				DrawLogicNodeLabel ("With this rotation");
				DrawVector3InputField (1);
				break;

			case ComputeGameObjectType.getTag:

				break;

			case ComputeGameObjectType.getName:

				break;

			case ComputeGameObjectType.getLayer:

				break;

			case ComputeGameObjectType.getActiveSelf:

				break;

			case ComputeGameObjectType.getActiveInHierarchy:

				break;

			case ComputeGameObjectType.destroy:
				DrawLogicNodeLabel ("Delay", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case ComputeGameObjectType.deactivate:

				break;

			case ComputeGameObjectType.CompareTag:
				DrawTagField (0);
				break;

			case ComputeGameObjectType.activate:

				break;

			}
			if (computeGameObjectType == ComputeGameObjectType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeGameObject ()
		{
			bool notDataTransfer = ! (computeGameObjectType == ComputeGameObjectType.sendMeAsTransferredData ||
				computeGameObjectType == ComputeGameObjectType.listenToTransferredData);
			if (notDataTransfer)
			if (linkedOrAttachedTo)
				return;			if ( ! doIT)
			{
				return;
			}
			if (notDataTransfer)
			if (IsGameObject_0_AttachedTo ())
			{
				return;
			}
			AssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);

			switch (computeGameObjectType)
			{
			case ComputeGameObjectType.listenToTransferredData:
				gameObjectValue = MezanixDiamondGetGameObject (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveGameObject (stringValues [0]);
				}
				break;

			case ComputeGameObjectType.sendMeAsTransferredData:
				MezanixDiamondSetGameObject (stringValues [0]);

				break;

			case ComputeGameObjectType.SpawnMeInAGrid:
				SpawnOnGrid ();
				break;

			case ComputeGameObjectType.otherGameObjectFoundOnMyWayAtDistance_2D:
				OtherGameObjectFoundOnMyWayAtDistance_Compute_2D ();
				break;

			case ComputeGameObjectType.otherGameObjectFoundAtRadius_2D:
				OtherGameObjectFoundAtRadius_Compute_2D ();
				break;

			case ComputeGameObjectType.otherGameObjectFoundOnMyWayAtDistance:
				OtherGameObjectFoundOnMyWayAtDistance_Compute ();
				break;

			case ComputeGameObjectType.otherGameObjectFoundAtRadius:
				OtherGameObjectFoundAtRadius_Compute ();
				break;

			case ComputeGameObjectType.get:
				ForGet_gameObject_Compute ();
				break;

			case ComputeGameObjectType.hasThisTag:
				boolValue = gameObjectValue.tag == stringValues [0];
				break;

			case ComputeGameObjectType.isChildOf:
				boolValue = gameObjectValues[0].transform.parent == gameObjectValues[1].transform;
				break;

			case ComputeGameObjectType.isEqualTo:
				boolValue = gameObjectValues[0] == gameObjectValues[1];
				break;

			case ComputeGameObjectType.setTag:
				gameObjectValues[0].tag = stringValues [0];
				break;

			case ComputeGameObjectType.setName:
				gameObjectValues[0].name = stringValues [0];
				break;

			case ComputeGameObjectType.setLayer:
				intValues [0] = Mathf.Clamp (intValues [0], 0, 31);

				gameObjectValues[0].layer = intValues [0];
				break;

			case ComputeGameObjectType.instantiateAndChooseUp:
				gameObjectValue = MonoBehaviour.Instantiate (gameObjectValues [0], vector3Values [0], 
					Quaternion.identity) as GameObject;
				gameObjectValue.transform.up = vector3Values [1];

				break;

			case ComputeGameObjectType.instantiate:
				gameObjectValue = MonoBehaviour.Instantiate (gameObjectValues [0], vector3Values [0], 
					Quaternion.Euler (vector3Values [1])) as GameObject;

				break;

			case ComputeGameObjectType.getTag:
				stringValue = gameObjectValues [0].tag;
				break;

			case ComputeGameObjectType.getName:
				stringValue = gameObjectValues [0].name;
				break;

			case ComputeGameObjectType.getLayer:
				intValue = gameObjectValues [0].layer;
				break;

			case ComputeGameObjectType.getActiveSelf:
				boolValue = gameObjectValues [0].activeSelf;
				break;

			case ComputeGameObjectType.getActiveInHierarchy:
				boolValue = gameObjectValues [0].activeInHierarchy;
				break;

			case ComputeGameObjectType.destroy:
				floatValues [0] = Mathf.Max (floatValues [0], 0f);

				MonoBehaviour.Destroy (gameObjectValues [0], floatValues [0]);


				break;

			case ComputeGameObjectType.deactivate:
				gameObjectValues [0].SetActive (false);
				break;

			case ComputeGameObjectType.CompareTag:
				boolValue = gameObjectValues [0].CompareTag (stringValues [0]);
				break;

			case ComputeGameObjectType.activate:
				gameObjectValues [0].SetActive (true);
				break;

			}
		}
		void ComputeGameObject_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeGameObjectType)
			{
			case ComputeGameObjectType.listenToTransferredData:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.SpawnMeInAGrid:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Duplicate your gamobject on a 3D grid.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.otherGameObjectFoundOnMyWayAtDistance_2D:
				OtherGameObjectFoundOnMyWayAtDistance_OutputFields_2D ();

				documentationMessage = 
					new string[]
				{
					"",
					"Need a Rigidbody component",
					"While moving, find if another game object is on the way of your game object ",
					"by a defined distance.",
					"Only one game object can be detected by frame.",
					"If your game object has a collider on it, the search zone will begin outside",
					"the collider bounds, if not, the search zone begin at your object's transform position",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.otherGameObjectFoundAtRadius_2D:
				OtherGameObjectFoundAtRadius_OutputFields_2D ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Find if another game object is near of your game object by a defined radius.",
					"Only one game object can be detected by frame.",
					"If your game object has a collider on it, the search zone will begin outside",
					"the collider bounds, if not, the search zone begin at your object's transform position",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.otherGameObjectFoundOnMyWayAtDistance:
				OtherGameObjectFoundOnMyWayAtDistance_OutputFields ();

				documentationMessage = 
					new string[]
				{
					"",
					"Need a Rigidbody component",
					"While moving, find if another game object is on the way of your game object ",
					"by a defined distance.",
					"Only one game object can be detected by frame.",
					"If your game object has a collider on it, the search zone will begin outside",
					"the collider bounds, if not, the search zone begin at your object's transform position",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.otherGameObjectFoundAtRadius:
				OtherGameObjectFoundAtRadius_OutputFields ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Find if another game object is near of your game object by a defined radius.",
					"Only one game object can be detected by frame.",
					"If your game object has a collider on it, the search zone will begin outside",
					"the collider bounds, if not, the search zone begin at your object's transform position",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.get:
				ForGet_gameObject_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.hasThisTag:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the game object has this tag, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.isChildOf:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if the first game object is a child of the second one, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.isEqualTo:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns true if game objects are equal, false otherwise",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectType.setTag:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The tag of this game object.",
					"A tag can be used to identify a game object. Tags must be declared in the Tags",
					"and Layers manager before using them.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/GameObject-tag.html", 
					"");
				break;

			case ComputeGameObjectType.setName:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The name of the object.",
					"Components share the same name with the game object and all attached components.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Object-name.html", 
					"");
				break;

			case ComputeGameObjectType.setLayer:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"The layer the game object is in. A layer is in the range [0...31].",
					"Layers can be used for selective rendering from cameras or ignoring raycasts.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/GameObject-layer.html", 
					"");
				break;

			case ComputeGameObjectType.instantiateAndChooseUp:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Like the original Unity standard instantiation methode.",
					"In this one you can additionaly set the Up (y axis, green arrow on transfrom gizmos).",
					"of the intantiated gameobject.",
					"For example this is useful when you want to simulate the effect on a wall after",
					"a bullet shot, so you can intantiate a particle system oriented as same as the wall's normal.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Object.Instantiate.html", 
					"");
				break;

			case ComputeGameObjectType.instantiate:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Clones the object original and returns the clone.",
					"This function makes a copy of an object in a similar way to the Duplicate",
					"command in the editor. If you are cloning a GameObject then you can also",
					"optionally specify its position and rotation (these default to the original",
					"GameObject's position and rotation otherwise).",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Object.Instantiate.html", 
					"");
				break;

			case ComputeGameObjectType.getTag:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The tag of this game object.",
					"A tag can be used to identify a game object. Tags must be declared in the Tags",
					"and Layers manager before using them.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/GameObject-tag.html", 
					"");
				break;

			case ComputeGameObjectType.getName:
				DrawStringResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The name of the object.",
					"Components share the same name with the game object and all attached components.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Object-name.html", 
					"");
				break;

			case ComputeGameObjectType.getLayer:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"The layer the game object is in. A layer is in the range [0...31].",
					"Layers can be used for selective rendering from cameras or ignoring raycasts.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/GameObject-layer.html", 
					"");
				break;

			case ComputeGameObjectType.getActiveSelf:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"The local active state of this GameObject. (Read Only)",
					"This returns the local active state of this GameObject,",
					"which is set using GameObject.SetActive. Note that a GameObject may be inactive",
					"because a parent is not active, even if this returns true.",
					"This state will then be used once all parents are active.",
					"Use GameObject.activeInHierarchy if you want to check if the GameObject",
					"is actually treated as active in the scene.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/GameObject-activeSelf.html", 
					"");
				break;

			case ComputeGameObjectType.getActiveInHierarchy:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Is the GameObject active in the scene?",
					"This lets you know if a gameObject is active in the game.",
					"That is the case if its GameObject.activeSelf property is enabled,",
					"as well as that of all it's parents.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/GameObject-activeInHierarchy.html", 
					"");
				break;

			case ComputeGameObjectType.destroy:


				documentationMessage = 
					new string[]
				{
					"",
					"Removes a gameobject, component or asset.",
					"The object obj will be destroyed now or if a time is specified t seconds from now.",
					"If obj is a Component it will remove the component from the GameObject and destroy",
					"it. If obj is a GameObject it will destroy the GameObject, all its components and",
					"all transform children of the GameObject.",
					"Actual object destruction is always delayed until after the current Update loop,",
					"but will always be done before rendering.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Object.Destroy.html", 
					"");
				break;

			case ComputeGameObjectType.deactivate:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Activates/Deactivates the GameObject.",
					"Note that a GameObject may be inactive because a parent is not active.",
					"In that case, calling SetActive() will not activate it, but only set the local",
					"state of the GameObject, which can be checked using GameObject.activeSelf.",
					"This state will then be used once all parents are active.",
					"Making a GameObject inactive will disable every component, turning off any",
					"attached renderers, colliders, rigidbodies, scripts, etc...",
					"Any scripts that you have attached to the GameObject will no longer have",
					"Update() called, for example.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/GameObject.SetActive.html", 
					"");
				break;

			case ComputeGameObjectType.CompareTag:
				DrawBoolResultField ();

				documentationMessage = 
					new string[]
				{
					"",
					"Is this game object tagged with tag ?",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/GameObject.CompareTag.html", 
					"");
				break;

			case ComputeGameObjectType.activate:
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName);

				documentationMessage = 
					new string[]
				{
					"",
					"Activates/Deactivates the GameObject.",
					"Note that a GameObject may be inactive because a parent is not active.",
					"In that case, calling SetActive() will not activate it, but only set the local",
					"state of the GameObject, which can be checked using GameObject.activeSelf.",
					"This state will then be used once all parents are active.",
					"Making a GameObject inactive will disable every component, turning off any",
					"attached renderers, colliders, rigidbodies, scripts, etc...",
					"Any scripts that you have attached to the GameObject will no longer have",
					"Update() called, for example.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/GameObject.SetActive.html", 
					"");
				break;

			}
		}


		void ApplyComputeGameObjectList ()
		{
			ComputeGameObjectList_InputFields();
			ComputeGameObjectList();
			ComputeGameObjectList_OutputFields();
		}
		public int computeGameObjectListType_length = 0;
		public string computeGameObjectListType_last;

		public int inventoryListAction_length = 0;
		public string inventoryListAction_last;

		void DrawEnumInventoryListAction ()
		{
			inventoryListAction = (InventoryListAction)DrawEnum (inventoryListAction, 
				ref inventoryListAction_length, ref inventoryListAction_last, typeof(InventoryListAction),
				"Inventory List Action", Skins.logicNodeLabel);
		}

		void ComputeGameObjectList_InputFields ()
		{		

			computeGameObjectListType = (ComputeGameObjectListType)DrawEnumComputeType (computeGameObjectListType,
				ref computeGameObjectListType_length, ref computeGameObjectListType_last, typeof(ComputeGameObjectListType));

			switch (computeGameObjectListType)
			{
			case ComputeGameObjectListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", 
					MezanixDiamondGameObjectListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawGameObjectListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume the data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeGameObjectListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawGameObjectListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;



			case ComputeGameObjectListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_gameobject_DrawInputs ();

				break;

			case ComputeGameObjectListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_gameObjectList_DrawInputs ();
				break;

			case ComputeGameObjectListType.MergeWith:
				DrawGameObjectListFieldInput (0);


				DrawGameObjectListFieldInput (1);


				break;

			}
			if (computeGameObjectListType == ComputeGameObjectListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeGameObjectList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeGameObjectListType)
			{
			case ComputeGameObjectListType.listenToTransferredData:
				gameObjectsListValue = MezanixDiamondGetGameObjectList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveGameObjectList (stringValues [0]);
				}
				break;

			case ComputeGameObjectListType.sendMeAsTransferredData:
				MezanixDiamondSetGameObjectList (stringValues [0]);

				break;

			case ComputeGameObjectListType.inventoryList:
				InventoryListAction_gameobject_Compute ();
				break;

			case ComputeGameObjectListType.get:
				ForGet_gameObjectList_Compute ();
				break;

			case ComputeGameObjectListType.MergeWith:
				ListOperations.Merge (ref gameObjectsListValue, gameObjectsListValues [0], gameObjectsListValues [1]);
				intValue = gameObjectsListValue.Count;
				break;

			}
		}
		void ComputeGameObjectList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeGameObjectListType)
			{
			case ComputeGameObjectListType.listenToTransferredData:
				DrawGameObjectListResultField (false, false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectListType.inventoryList:
				InventoryListAction_gameobject_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"In the game object list case, The 'MakeObject Of Following Index Ready',",
					"can be used for example to let a player switch between different weapons ",
					"and activate one of them",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectListType.get:
				ForGet_gameObjectList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeGameObjectListType.MergeWith:
				DrawGameObjectListResultField (false, false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeShaderList ()
		{
			ComputeShaderList_InputFields();
			ComputeShaderList();
			ComputeShaderList_OutputFields();
		}
		public int computeShaderListType_length = 0;
		public string computeShaderListType_last;
		void ComputeShaderList_InputFields ()
		{
			
			computeShaderListType = (ComputeShaderListType)DrawEnumComputeType (computeShaderListType,
				ref computeShaderListType_length, ref computeShaderListType_last, typeof(ComputeShaderListType));

			switch (computeShaderListType)
			{
			case ComputeShaderListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", 
					MezanixDiamondShaderListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawShaderListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeShaderListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawShaderListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeShaderListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_shader_DrawInputs ();

				break;

			case ComputeShaderListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_shaderList_DrawInputs ();
				break;

			case ComputeShaderListType.MergeWith:
				DrawShaderListFieldInput (0);


				DrawShaderListFieldInput (1);


				break;

			}
			if (computeShaderListType == ComputeShaderListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeShaderList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeShaderListType)
			{
			case ComputeShaderListType.listenToTransferredData:
				shaderListValue = MezanixDiamondGetShaderList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveShaderList (stringValues [0]);
				}
				break;

			case ComputeShaderListType.sendMeAsTransferredData:
				MezanixDiamondSetShaderList (stringValues [0]);

				break;

			case ComputeShaderListType.inventoryList:
				InventoryListAction_shader_Compute ();
				break;

			case ComputeShaderListType.get:
				ForGet_shaderList_Compute ();
				break;

			case ComputeShaderListType.MergeWith:
				ListOperations.Merge (ref shaderListValue, shaderListValues [0], shaderListValues [1]);

				break;

			}
		}
		void ComputeShaderList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeShaderListType)
			{
			case ComputeShaderListType.listenToTransferredData:
				DrawShaderListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeShaderListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeShaderListType.inventoryList:
				InventoryListAction_shader_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"In the game object list case, The 'MakeObject Of Following Index Ready',",
					"can be used for example to let a player switch between different weapons ",
					"and activate one of them",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeShaderListType.get:
				ForGet_shaderList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeShaderListType.MergeWith:
				DrawShaderListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeTexture2DList ()
		{
			ComputeTexture2DList_InputFields();
			ComputeTexture2DList();
			ComputeTexture2DList_OutputFields();
		}
		public int computeTexture2DListType_length = 0;
		public string computeTexture2DListType_last;
		void ComputeTexture2DList_InputFields ()
		{
			

			computeTexture2DListType = (ComputeTexture2DListType)DrawEnumComputeType (computeTexture2DListType,
				ref computeTexture2DListType_length, ref computeTexture2DListType_last, typeof(ComputeTexture2DListType));

			switch (computeTexture2DListType)
			{
			case ComputeTexture2DListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name",
					MezanixDiamondTexture2DListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawTexture2DListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume the data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeTexture2DListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawTexture2DListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeTexture2DListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_texture2D_DrawInputs ();

				break;

			case ComputeTexture2DListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_texture2DList_DrawInputs ();
				break;

			case ComputeTexture2DListType.MergeWith:
				DrawTexture2DListFieldInput (0);


				DrawTexture2DListFieldInput (1);


				break;

			}
			if (computeTexture2DListType == ComputeTexture2DListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeTexture2DList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeTexture2DListType)
			{
			case ComputeTexture2DListType.listenToTransferredData:
				texture2DListValue = MezanixDiamondGetTexture2DList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveTexture2DList (stringValues [0]);
				}
				break;

			case ComputeTexture2DListType.sendMeAsTransferredData:
				MezanixDiamondSetTexture2DList (stringValues [0]);

				break;

			case ComputeTexture2DListType.inventoryList:
				InventoryListAction_texture2D_Compute ();
				break;

			case ComputeTexture2DListType.get:
				ForGet_texture2DList_Compute ();
				break;

			case ComputeTexture2DListType.MergeWith:
				ListOperations.Merge (ref texture2DListValue, texture2DListValues [0], texture2DListValues [1]);

				break;

			}
		}
		void ComputeTexture2DList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeTexture2DListType)
			{
			case ComputeTexture2DListType.listenToTransferredData:
				DrawTexture2DListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DListType.inventoryList:
				InventoryListAction_texture2D_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"In the game object list case, The 'MakeObject Of Following Index Ready',",
					"can be used for example to let a player switch between different weapons ",
					"and activate one of them",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DListType.get:
				ForGet_texture2DList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeTexture2DListType.MergeWith:
				DrawTexture2DListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeMaterialList ()
		{
			ComputeMaterialList_InputFields();
			ComputeMaterialList();
			ComputeMaterialList_OutputFields();
		}
		public int computeMaterialListType_length = 0;
		public string computeMaterialListType_last;
		void ComputeMaterialList_InputFields ()
		{
			
			computeMaterialListType = (ComputeMaterialListType)DrawEnumComputeType (computeMaterialListType, 
				ref computeMaterialListType_length, ref computeMaterialListType_last, typeof(ComputeMaterialListType));

			switch (computeMaterialListType)
			{
			case ComputeMaterialListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", 
					MezanixDiamondMaterialListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawMaterialListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume the data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeMaterialListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0 , 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawMaterialListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeMaterialListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_material_DrawInputs ();

				break;

			case ComputeMaterialListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_materialList_DrawInputs ();
				break;

			case ComputeMaterialListType.MergeWith:
				DrawMaterialListFieldInput (0);


				DrawMaterialListFieldInput (1);


				break;

			}
			if (computeMaterialListType == ComputeMaterialListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeMaterialList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeMaterialListType)
			{
			case ComputeMaterialListType.listenToTransferredData:
				materialsListValue = MezanixDiamondGetMaterialList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveMaterialList (stringValues [0]);
				}
				break;

			case ComputeMaterialListType.sendMeAsTransferredData:
				MezanixDiamondSetMaterialList (stringValues [0]);

				break;

			case ComputeMaterialListType.inventoryList:
				InventoryListAction_material_Compute ();
				break;

			case ComputeMaterialListType.get:
				ForGet_materialList_Compute ();
				break;

			case ComputeMaterialListType.MergeWith:
				ListOperations.Merge (ref materialsListValue, materialsListValues [0], materialsListValues [1]);

				break;

			}
		}
		void ComputeMaterialList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeMaterialListType)
			{
			case ComputeMaterialListType.listenToTransferredData:
				DrawMaterialListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeMaterialListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeMaterialListType.inventoryList:
				InventoryListAction_material_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"In the game object list case, The 'MakeObject Of Following Index Ready',",
					"can be used for example to let a player switch between different weapons ",
					"and activate one of them",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeMaterialListType.get:
				ForGet_materialList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeMaterialListType.MergeWith:
				DrawMaterialListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeRectList ()
		{
			ComputeRectList_InputFields ();
			if (logic.playing)ComputeRectList ();
			ComputeRectList_OutputFields ();
		}
		public int computeRectListType_length = 0;
		public string computeRectListType_last;
		void ComputeRectList_InputFields ()
		{
			

			computeRectListType = (ComputeRectListType)DrawEnumComputeType (computeRectListType,
				ref computeRectListType_length, ref computeRectListType_last, typeof(ComputeRectListType));

			switch (computeRectListType)
			{
			case ComputeRectListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name",
					MezanixDiamondRectListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawRectListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume the data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeRectListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawRectListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeRectListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_rect_DrawInputs ();

				break;

			case ComputeRectListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_rectList_DrawInputs ();
				break;

			case ComputeRectListType.MergeWith:
				DrawRectListFieldInput (0);


				DrawRectListFieldInput (1);


				break;

			}
			if (computeRectListType == ComputeRectListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeRectList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeRectListType)
			{
			case ComputeRectListType.listenToTransferredData:
				rectListValue = MezanixDiamondGetRectList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveRectList (stringValues [0]);
				}
				break;

			case ComputeRectListType.sendMeAsTransferredData:
				MezanixDiamondSetRectList (stringValues [0]);

				break;

			case ComputeRectListType.inventoryList:
				InventoryListAction_rect_Compute ();
				break;

			case ComputeRectListType.get:
				ForGet_RectList_Compute ();
				break;

			case ComputeRectListType.MergeWith:
				ListOperations.Merge (ref rectListValue, rectListValues [0], rectListValues [1]);

				break;

			}
		}
		void ComputeRectList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeRectListType)
			{
			case ComputeRectListType.listenToTransferredData:
				DrawRectListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeRectListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeRectListType.inventoryList:
				InventoryListAction_rect_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeRectListType.get:
				ForGet_rectList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeRectListType.MergeWith:
				DrawRectListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeVector4List ()
		{
			ComputeVector4List_InputFields ();
			if (logic.playing)ComputeVector4List ();
			ComputeVector4List_OutputFields ();
		} 
		public int computeVector4ListType_length = 0;
		public string computeVector4ListType_last;
		void ComputeVector4List_InputFields ()
		{
			

			computeVector4ListType = (ComputeVector4ListType)DrawEnumComputeType (computeVector4ListType,
				ref computeVector4ListType_length, ref computeVector4ListType_last, typeof(ComputeVector4ListType));

			switch (computeVector4ListType)
			{
			case ComputeVector4ListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", 
					MezanixDiamondVector4ListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawVector4ListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume the data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeVector4ListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawVector4ListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeVector4ListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_vector4_DrawInputs ();

				break;

			case ComputeVector4ListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_vector4List_DrawInputs ();
				break;

			case ComputeVector4ListType.MergeWith:
				DrawVector4ListFieldInput (0);


				DrawVector4ListFieldInput (1);


				break;

			}
			if (computeVector4ListType == ComputeVector4ListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeVector4List ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeVector4ListType)
			{
			case ComputeVector4ListType.listenToTransferredData:
				vector4ListValue = MezanixDiamondGetVector4List (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveVector4List (stringValues [0]);
				}
				break;

			case ComputeVector4ListType.sendMeAsTransferredData:
				MezanixDiamondSetVector4List (stringValues [0]);

				break;

			case ComputeVector4ListType.inventoryList:
				InventoryListAction_vector4_Compute ();
				break;

			case ComputeVector4ListType.get:
				ForGet_vector4List_Compute ();
				break;

			case ComputeVector4ListType.MergeWith:
				ListOperations.Merge (ref vector4ListValue, vector4ListValues [0], vector4ListValues [1]);

				break;

			}
		}
		void ComputeVector4List_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeVector4ListType)
			{
			case ComputeVector4ListType.listenToTransferredData:
				DrawVector4ListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4ListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4ListType.inventoryList:
				InventoryListAction_vector4_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4ListType.get:
				ForGet_vector4List_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector4ListType.MergeWith:
				DrawVector4ListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeVector3List ()
		{
			ComputeVector3List_InputFields ();
			if (logic.playing)ComputeVector3List ();
			ComputeVector3List_OutputFields ();
		}
		public int computeVector3ListType_length =0;
		public string computeVector3ListType_last;
		void ComputeVector3List_InputFields ()
		{
			
			computeVector3ListType = (ComputeVector3ListType)DrawEnumComputeType (computeVector3ListType,
				ref computeVector3ListType_length, ref computeVector3ListType_last, typeof(ComputeVector3ListType));

			switch (computeVector3ListType)
			{
			case ComputeVector3ListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", 
					MezanixDiamondVector3ListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawVector3ListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume the data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeVector3ListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawVector3ListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeVector3ListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_vector3_DrawInputs ();

				break;

			case ComputeVector3ListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_vector3List_DrawInputs ();
				break;

			case ComputeVector3ListType.MergeWith:
				DrawVector3ListFieldInput (0);


				DrawVector3ListFieldInput (1);


				break;

			}
			if (computeVector3ListType == ComputeVector3ListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeVector3List ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeVector3ListType)
			{
			case ComputeVector3ListType.listenToTransferredData:
				vector3ListValue = MezanixDiamondGetVector3List (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveVector3List (stringValues [0]);
				}
				break;

			case ComputeVector3ListType.sendMeAsTransferredData:
				MezanixDiamondSetVector3List (stringValues [0]);

				break;

			case ComputeVector3ListType.inventoryList:
				InventoryListAction_vector3_Compute ();
				break;

			case ComputeVector3ListType.get:
				ForGet_vector3List_Compute ();
				break;

			case ComputeVector3ListType.MergeWith:
				ListOperations.Merge (ref vector3ListValue, vector3ListValues [0], vector3ListValues [1]);

				break;

			}
		}
		void ComputeVector3List_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeVector3ListType)
			{
			case ComputeVector3ListType.listenToTransferredData:
				DrawVector3ListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3ListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3ListType.inventoryList:
				InventoryListAction_vector3_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3ListType.get:
				ForGet_vector3List_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector3ListType.MergeWith:
				DrawVector3ListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeVector2List ()
		{
			ComputeVector2List_InputFields();
			ComputeVector2List ();
			ComputeVector2List_OutputFields ();
		}
		public int computeVector2ListType_length = 0;
		public string computeVector2ListType_last;
		void ComputeVector2List_InputFields ()
		{
			

			computeVector2ListType = (ComputeVector2ListType)DrawEnumComputeType (computeVector2ListType,
				ref computeVector2ListType_length, ref computeVector2ListType_last, typeof(ComputeVector2ListType));

			switch (computeVector2ListType)
			{
			case ComputeVector2ListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name",
					MezanixDiamondVector2ListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawVector2ListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeVector2ListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawVector2ListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeVector2ListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_vector2_DrawInputs ();

				break;

			case ComputeVector2ListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_vector2List_DrawInputs ();
				break;

			case ComputeVector2ListType.MergeWith:
				DrawVector2ListFieldInput (0);


				DrawVector2ListFieldInput (1);


				break;

			}
			if (computeVector2ListType == ComputeVector2ListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeVector2List ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeVector2ListType)
			{
			case ComputeVector2ListType.listenToTransferredData:
				vector2ListValue = MezanixDiamondGetVector2List (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveVector2List (stringValues [0]);
				}
				break;

			case ComputeVector2ListType.sendMeAsTransferredData:
				MezanixDiamondSetVector2List (stringValues [0]);

				break;

			case ComputeVector2ListType.inventoryList:
				InventoryListAction_vector2_Compute ();
				break;

			case ComputeVector2ListType.get:
				ForGet_vector2List_Compute ();
				break;

			case ComputeVector2ListType.MergeWith:
				ListOperations.Merge (ref vector2ListValue, vector2ListValues [0], vector2ListValues [1]);

				break;

			}
		}
		void ComputeVector2List_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeVector2ListType)
			{
			case ComputeVector2ListType.listenToTransferredData:
				DrawVector2ListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2ListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2ListType.inventoryList:
				InventoryListAction_vector2_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2ListType.get:
				ForGet_vector2List_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeVector2ListType.MergeWith:
				DrawVector2ListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}



		void ApplyComputeStringList ()
		{
			ComputeStringList_InputFields ();
			if (logic.playing)ComputeStringList ();
			ComputeStringList_OutputFields ();
		}
		public int computeStringsListType_length = 0;
		public string computeStringsListType_last;
		void ComputeStringList_InputFields ()
		{
			

			computeStringsListType = (ComputeStringsListType)DrawEnumComputeType (computeStringsListType,
				ref computeStringsListType_length, ref computeStringsListType_last, typeof(ComputeStringsListType));

			switch (computeStringsListType)
			{
			case ComputeStringsListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", 
					MezanixDiamondStringListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawStringsListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeStringsListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawStringsListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeStringsListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_string_DrawInputs ();

				break;

			case ComputeStringsListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_stringList_DrawInputs ();
				break;

			case ComputeStringsListType.MergeWith:
				DrawStringsListFieldInput (0);


				DrawStringsListFieldInput (1);


				break;

			}
			if (computeStringsListType == ComputeStringsListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeStringList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeStringsListType)
			{
			case ComputeStringsListType.listenToTransferredData:
				stringsListValue = MezanixDiamondGetStringList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveStringList(stringValues [0]);
				}
				break;

			case ComputeStringsListType.sendMeAsTransferredData:
				MezanixDiamondSetStringList (stringValues [0]);

				break;

			case ComputeStringsListType.inventoryList:
				InventoryListAction_string_Compute ();
				break;

			case ComputeStringsListType.get:
				ForGet_stringList_Compute ();
				break;

			case ComputeStringsListType.MergeWith:
				ListOperations.Merge (ref stringsListValue, stringsListValues [0], stringsListValues [1]);

				break;

			}
		}
		void ComputeStringList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeStringsListType)
			{
			case ComputeStringsListType.listenToTransferredData:
				DrawStringsListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringsListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringsListType.inventoryList:
				InventoryListAction_string_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringsListType.get:
				ForGet_stringList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeStringsListType.MergeWith:
				DrawStringsListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeIntList ()
		{
			ComputeIntList_InputFields();
			ComputeIntList ();
			ComputeIntList_OutputFields ();
		}
		public int computeIntListType_length = 0;
		public string computeIntListType_last;
		void ComputeIntList_InputFields ()
		{
			

			computeIntListType = (ComputeIntsListType)DrawEnumComputeType (computeIntListType,
				ref computeIntListType_length, ref computeIntListType_last, typeof(ComputeIntsListType));

			switch (computeIntListType)
			{
			case ComputeIntsListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name",
					MezanixDiamondIntListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawIntListFieldInput (0, 1 ,2);


				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeIntsListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawIntListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeIntsListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_int_DrawInputs ();

				break;

			case ComputeIntsListType.max:
				DrawIntListFieldInput (0);


				break;

			case ComputeIntsListType.min:
				DrawIntListFieldInput (0);


				break;

			case ComputeIntsListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_intList_DrawInputs ();
				break;

			case ComputeIntsListType.MergeWith:
				DrawIntListFieldInput (0);


				DrawIntListFieldInput (1);


				break;

			}
			if (computeIntListType == ComputeIntsListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeIntList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeIntListType)
			{
			case ComputeIntsListType.listenToTransferredData:
				intsListValue = MezanixDiamondGetIntList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveIntList(stringValues [0]);
				}
				break;

			case ComputeIntsListType.sendMeAsTransferredData:
				MezanixDiamondSetIntList (stringValues [0]);

				break;

			case ComputeIntsListType.inventoryList:
				InventoryListAction_int_Compute ();
				break;

			case ComputeIntsListType.max:
				intValue = Mathf.Max (intsListValues [0].ToArray ());
				break;

			case ComputeIntsListType.min:
				intValue = Mathf.Min (intsListValues [0].ToArray ());
				break;

			case ComputeIntsListType.get:
				ForGet_intList_Compute ();
				break;

			case ComputeIntsListType.MergeWith:
				ListOperations.Merge (ref intsListValue, intsListValues [0], intsListValues [1]);

				break;

			}
		}
		void ComputeIntList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeIntListType)
			{
			case ComputeIntsListType.listenToTransferredData:
				DrawIntListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntsListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntsListType.inventoryList:
				InventoryListAction_int_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntsListType.max:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the max value of the list",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Mathf.Max.html", 
					"");
				break;

			case ComputeIntsListType.min:
				DrawIntResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the min value of the list",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Mathf.Min.html", 
					"");
				break;

			case ComputeIntsListType.get:
				ForGet_intList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeIntsListType.MergeWith:
				DrawIntListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeFloatList ()
		{
			ComputeFloatsList_InputFields ();
			if (logic.playing)ComputeFloatsList ();
			ComputeFloatsList_OutputFields ();
		}
		public int computeFloatsListType_length = 0;
		public string computeFloatsListType_last;
		void ComputeFloatsList_InputFields ()
		{
			

			computeFloatsListType = (ComputeFloatsListType)DrawEnumComputeType (computeFloatsListType,
				ref computeFloatsListType_length, ref computeFloatsListType_last, typeof(ComputeFloatsListType));

			switch (computeFloatsListType)
			{
			case ComputeFloatsListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", 
					MezanixDiamondFloatListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawFloatListFieldInput (0, 1, 2);


				DrawLogicNodeLabel ("Consume the data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeFloatsListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawFloatListFieldInput (0, 1, 2);


				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeFloatsListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_float_DrawInputs ();

				break;

			case ComputeFloatsListType.max:
				DrawFloatListFieldInput (0);


				break;

			case ComputeFloatsListType.min:
				DrawFloatListFieldInput (0);


				break;

			case ComputeFloatsListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_floatList_DrawInputs ();
				break;

			case ComputeFloatsListType.MergeWith:
				DrawFloatListFieldInput (0);


				DrawFloatListFieldInput (1);


				break;

			}
			if (computeFloatsListType == ComputeFloatsListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeFloatsList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeFloatsListType)
			{
			case ComputeFloatsListType.listenToTransferredData:
				floatsListValue = MezanixDiamondGetFloatList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveFloatList (stringValues [0]);
				}
				break;

			case ComputeFloatsListType.sendMeAsTransferredData:
				MezanixDiamondSetFloatList (stringValues [0]);

				break;

			case ComputeFloatsListType.inventoryList:
				InventoryListAction_float_Compute ();
				break;

			case ComputeFloatsListType.max:
				floatValue = Mathf.Max (floatsListValues [0].ToArray ());
				break;

			case ComputeFloatsListType.min:
				floatValue = Mathf.Min (floatsListValues [0].ToArray ());
				break;

			case ComputeFloatsListType.get:
				ForGet_floatList_Compute ();
				break;

			case ComputeFloatsListType.MergeWith:
				ListOperations.Merge (ref floatsListValue, floatsListValues [0], floatsListValues [1]);

				break;

			}
		}
		void ComputeFloatsList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeFloatsListType)
			{
			case ComputeFloatsListType.listenToTransferredData:
				DrawFloatListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatsListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatsListType.inventoryList:
				InventoryListAction_float_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatsListType.max:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the max value of the list",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Mathf.Max.html", 
					"");
				break;

			case ComputeFloatsListType.min:
				DrawFloatResultField (true);

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Returns the min value of the list",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"https://docs.unity3d.com/ScriptReference/Mathf.Min.html", 
					"");
				break;

			case ComputeFloatsListType.get:
				ForGet_floatList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeFloatsListType.MergeWith:
				DrawFloatListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeBoolList ()
		{
			ComputeBoolList_InputFields ();
			if (logic.playing)ComputeBoolList ();
			ComputeBoolList_OutputFields ();
		}
		public int computeBoolListType_length = 0;
		public string computeBoolListType_last;
		void ComputeBoolList_InputFields ()
		{
			

			computeBoolListType = (ComputeBoolListType)DrawEnumComputeType (computeBoolListType,
				ref computeBoolListType_length, ref computeBoolListType_last, typeof(ComputeBoolListType));

			switch (computeBoolListType)
			{
			case ComputeBoolListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_bool_DrawInputs ();

				break;

			case ComputeBoolListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", 
					MezanixDiamondBoolListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawBoolListFieldInput (0, 1 , 2);

				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeBoolListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Data Value to transfer", 0, 2);
				DrawBoolListFieldInput (0, 1, 2);

				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeBoolListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_boolList_DrawInputs ();
				break;

			case ComputeBoolListType.mergeWith:
				DrawBoolListFieldInput (0);

				DrawBoolListFieldInput (1);

				break;

			}
			if (computeBoolListType == ComputeBoolListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeBoolList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeBoolListType)
			{
			case ComputeBoolListType.inventoryList:
				InventoryListAction_bool_Compute ();
				break;

			case ComputeBoolListType.listenToTransferredData:
				boolsListValue = MezanixDiamondGetBoolList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveBoolList (stringValues [0]);
				}

				break;

			case ComputeBoolListType.sendMeAsTransferredData:
				MezanixDiamondSetBoolList (stringValues [0]);

				break;

			case ComputeBoolListType.get:
				ForGet_boolList_Compute ();
				break;

			case ComputeBoolListType.mergeWith:
				ListOperations.Merge (ref boolsListValue, boolsListValues [0], boolsListValues [1]);
				intValue = boolsListValue.Count;

				break;

			}
		}
		void ComputeBoolList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeBoolListType)
			{
			case ComputeBoolListType.inventoryList:
				InventoryListAction_bool_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolListType.listenToTransferredData:
				DrawBoolListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolListType.get:
				ForGet_boolList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeBoolListType.mergeWith:
				DrawBoolListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void ApplyComputeColorList ()
		{
			ComputeColorList_InputFields ();
			if (logic.playing) ComputeColorList ();
			ComputeColorList_OutputFields ();
		}
		public int computeColorListType_length = 0;
		public string computeColorListType_last;
		void ComputeColorList_InputFields ()
		{
			
			computeColorListType = (ComputeColorListType)DrawEnumComputeType (computeColorListType,
				ref computeColorListType_length, ref computeColorListType_last, typeof(ComputeColorListType));

			switch (computeColorListType)
			{
			case ComputeColorListType.listenToTransferredData:
				DrawStringListMenuToString_0 ("Data Name", 
					MezanixDiamondColorListNames (), noTransferredDataFound, 0, 2);
				DrawLogicNodeLabel (stringValues [0], 1, 2);
				DrawLogicNodeLabel ("Default value", 0, 2);
				DrawColorListFieldInput (0, 1, 2);

				DrawLogicNodeLabel ("Consume data?", 0, 2);
				DrawBoolInputField (0, 3, 4);

				break;

			case ComputeColorListType.sendMeAsTransferredData:
				DrawLogicNodeLabel ("Data Name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				DrawLogicNodeLabel ("Value to transfer", 0, 2);
				DrawColorListFieldInput (0, 1 ,2);

				DrawInNodeInfo ("Play logic, name data, click doIT");

				break;

			case ComputeColorListType.inventoryList:
				DrawEnumInventoryListAction ();

				InventoryListAction_color_DrawInputs ();

				break;

			case ComputeColorListType.get:
				DrawLogicNodeLabel ("Get from input", 0, 2);
				DrawBoolInputField (0, 3, 4);
				ForGet_colorList_DrawInputs ();
				break;

			case ComputeColorListType.mergeWith:
				DrawColorListFieldInput (0);
				DrawColorListFieldInput (1);

				break;

			}
			if (computeColorListType == ComputeColorListType.get)
			{
				doIT = true;
			}
			else
			{
				DrawDoItButton();
			}
		}
		void ComputeColorList ()
		{
			if ( ! doIT)
			{
				return;
			}
			switch (computeColorListType)
			{
			case ComputeColorListType.listenToTransferredData:
				colorsListValue = MezanixDiamondGetColorList (stringValues [0]);
				if (boolValues [0])
				{
					MezanixDiamondRemoveColorList (stringValues [0]);
				}
				break;

			case ComputeColorListType.sendMeAsTransferredData:
				MezanixDiamondSetColorList (stringValues [0]);

				break;

			case ComputeColorListType.inventoryList:
				InventoryListAction_color_Compute ();
				break;

			case ComputeColorListType.get:
				ForGet_colorList_Compute ();
				break;

			case ComputeColorListType.mergeWith:
				ListOperations.Merge (ref colorsListValue, colorsListValues [0], colorsListValues [1]);
				intValue = colorsListValue.Count;

				break;

			}
		}
		void ComputeColorList_OutputFields ()
		{

			string [] documentationMessage;

			switch (computeColorListType)
			{
			case ComputeColorListType.listenToTransferredData:
				DrawColorListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Listen to (read) a value by its name.",
					"If you want to read this value at this moment",
					"and no need to read it later, it's recommended",
					"to consume it.",
					"",
					"If the transferred data is not found,",
					"the default value will be used",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorListType.sendMeAsTransferredData:


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Send a value by its name. The name can be used",
					"by another graph (script) to listen to (read) this value.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorListType.inventoryList:
				InventoryListAction_color_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"Perform actions to manage an inventory list.",
					"",
					"If you check the box 'Act on the input list?', actions will be applied",
					"to the input list and put the result in the output list,",
					"this help to act on a list comming from another node.",
					"",
					"If the box 'Act on the input list?' is not checked, the node will act directly",
					"on its output list.",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorListType.get:
				ForGet_colorList_DrawOutputs ();

				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Get this",
					"",
					"If you choose 'Get from input'",
					"you can get from the input list that",
					"is turnable to public, so it can appear",
					"in the inspector of the game object holding",
					"the genrated script",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			case ComputeColorListType.mergeWith:
				DrawColorListResultField (false);


				documentationMessage = 
					new string[]
				{
					"",
					"",
					"Merge the two lists",
				};

				DrawDocumentationBoxUpRight (documentationMessage);
				DrawDocumentationUrlButtons (documentationMessage, 
					"", 
					"");
				break;

			}
		}


		void CheckAxisNameSetup ()
		{
			try
			{
				Input.GetAxis(stringValues [0]);

				axisNameIsSetup = true;
			}
			catch
			{
				DrawInNodeInfo (thisAxisNameIsNotSetup);

				axisNameIsSetup = false;
			}
		}

		void ApplyInput ()
		{
			boolValue = false;

			if (keyCode == KeyCode.Mouse0 ||
				keyCode == KeyCode.Mouse1 ||
				keyCode == KeyCode.Mouse2 ||
				keyCode == KeyCode.Mouse3 ||
				keyCode == KeyCode.Mouse4 ||
				keyCode == KeyCode.Mouse5 ||
				keyCode == KeyCode.Mouse6)
			{
				switch (mouseInputTriggerWhen)
				{
				case MouseInputTriggerWhen.down:
					if (Input.GetKeyDown (keyCode))
					{
						boolValue = true;

						////Debug.Log (boolValue);
					}
					break;

				case MouseInputTriggerWhen.drag:
					if (Input.GetKey (keyCode))
					{
						if (MouseMoved ())
						{
							boolValue = true;

							////Debug.Log (boolValue);
						}
					}
					break;

				case MouseInputTriggerWhen.hold:
					if (Input.GetKey (keyCode))
					{
						boolValue = true;

						////Debug.Log (boolValue);
					}
					break;

				case MouseInputTriggerWhen.up:
					if (Input.GetKeyUp (keyCode))
					{
						boolValue = true;

						////Debug.Log (boolValue);
					}
					break;
				}
			}
			else
			{
				switch (keyCodeTriggerWhen)
				{
				case KeyCodeTriggerWhen.down:
					if (Input.GetKeyDown (keyCode))
					{
						boolValue = true;

						////Debug.Log (boolValue);
					}
					break;

				case KeyCodeTriggerWhen.hold:
					if (Input.GetKey (keyCode))
					{
						boolValue = true;

						////Debug.Log (boolValue);
					}
					break;

				case KeyCodeTriggerWhen.up:
					if (Input.GetKeyUp (keyCode))
					{
						boolValue = true;

						//Debug.Log (boolValue);
					}
					break;
				}
			}

			//DrawResult ();
		}

		void ApplyUnityInputAxes ()
		{
			if (axeName != AxeName.horizontalAndOrVertical)
			{
				floatValue = 0f;

				floatValue = Input.GetAxis (AxeNameToString ());
			}
			else if (axeName == AxeName.horizontalAndOrVertical)
			{
				vector2Value = new Vector2 ();

				vector2Value = new Vector2 (Input.GetAxis ("Horizontal"), Input.GetAxis ("Vertical"));
			}
		}

		string AxeNameToString ()
		{
			string retVal = "";

			switch (axeName)
			{
			case AxeName.cancel:
				retVal = "Cancel";
				break;

			case AxeName.fire1:
				retVal = "Fire1";
				break;

			case AxeName.fire2:
				retVal = "Fire2";
				break;

			case AxeName.fire3:
				retVal = "Fire3";
				break;

			case AxeName.horizontal:
				retVal = "Horizontal";
				break;

			case AxeName.horizontalAndOrVertical:
				break;

			case AxeName.jump:
				retVal = "Jump";
				break;

			case AxeName.mouseScrollWheel:
				retVal = "Mouse ScrollWheel";
				break;

			case AxeName.mouseX:
				retVal = "Mouse X";
				break;

			case AxeName.mouseY:
				retVal = "Mouse Y";
				break;

			case AxeName.submit:
				retVal = "Submit";
				break;

			case AxeName.vertical:
				retVal = "Vertical";
				break;
			}

			return retVal;
		}

		bool MouseMoved ()
		{
			bool retVal = false;

			if (Input.mousePosition != mousePosition)
			{
				retVal = true;

				mousePosition = Input.mousePosition;
			}

			return retVal;
		}


		void SetM44Value (Matrix4x4 m44)
		{
			m44Value_entier = m44;


			m44ValueDeterminant = m44.determinant;

			m44ValueIsIdentity = m44.isIdentity;

			m44ValueInvertible = (m44.determinant == 0f)? false: true;


			m44Value [0] = m44.m00;
			m44Value [1] = m44.m01;
			m44Value [2] = m44.m02;
			m44Value [3] = m44.m03;

			m44Value [4] = m44.m10;
			m44Value [5] = m44.m11;
			m44Value [6] = m44.m12;
			m44Value [7] = m44.m13;

			m44Value [8] = m44.m20;
			m44Value [9] = m44.m21;
			m44Value [10] = m44.m22;
			m44Value [11] = m44.m23;

			m44Value [12] = m44.m30;
			m44Value [13] = m44.m31;
			m44Value [14] = m44.m32;
			m44Value [15] = m44.m33;
		}

		float [] SetM44ValueToArray (Matrix4x4 m44)
		{
			float [] r = new float[16];


			r [0] =  m44.m00;
			r [1] =  m44.m01;
			r [2] =  m44.m02;
			r [3] =  m44.m03;

			r [4] =  m44.m10;
			r [5] =  m44.m11;
			r [6] =  m44.m12;
			r [7] =  m44.m13;

			r [8] =  m44.m20;
			r [9] =  m44.m21;
			r [10] = m44.m22;
			r [11] = m44.m23;

			r [12] = m44.m30;
			r [13] = m44.m31;
			r [14] = m44.m32;
			r [15] = m44.m33;

			return r;
		}
		Matrix4x4 GetM44 (float [] m44Vs)
		{
			Matrix4x4 r = new Matrix4x4 ();

			r.m00 = m44Vs [0];
			r.m01 = m44Vs [1];
			r.m02 = m44Vs [2];
			r.m03 = m44Vs [3];

			r.m10 = m44Vs [4];
			r.m11 = m44Vs [5];
			r.m12 = m44Vs [6];
			r.m13 = m44Vs [7];

			r.m20 = m44Vs [8];
			r.m21 = m44Vs [9];
			r.m22 = m44Vs [10];
			r.m23 = m44Vs [11];

			r.m30 = m44Vs [12];
			r.m31 = m44Vs [13];
			r.m32 = m44Vs [14];
			r.m33 = m44Vs [15];

			return r;
		}

		void AssignRayCasthitInfos (int wantedHit)
		{
			if (hits.Length == 0)
			{
				ResetRayCastHitInfos ();

				return;
			}


			if (wantedHit < 0 || wantedHit > hits.Length-1)
			{
				ResetRayCastHitInfos ();

				return;
			}


			boolValue = true;

			raycastHitGameObject = hits [wantedHit].transform.gameObject;

			if (raycastHitGameObject == null)
				raycastHitGameObject = hits [wantedHit].collider.gameObject;

			if (raycastHitGameObject == null)
				raycastHitGameObject = hits [wantedHit].rigidbody.gameObject;



			raycastHitBarycentricCoordinate = hits [wantedHit].barycentricCoordinate;

			raycastHitTriangleIndex = hits [wantedHit].triangleIndex;


			raycastHitPoint = hits [wantedHit].point;

			raycastHitNormal = hits [wantedHit].normal;

			raycastHitDistance = hits [wantedHit].distance;


			raycastHitLightmapCoord = hits [wantedHit].lightmapCoord;

			raycastHittextureCoord = hits [wantedHit].textureCoord;

			raycastHittextureCoord2 =  hits [wantedHit].textureCoord2;
		}

		void AssignRayCasthitInfos ()
		{
			if ( ! boolValue)
			{
				ResetRayCastHitInfos ();

				return;
			}

			raycastHitGameObject = hit.transform.gameObject;

			if (raycastHitGameObject == null)
				raycastHitGameObject = hit.collider.gameObject;

			if (raycastHitGameObject == null)
				raycastHitGameObject = hit.rigidbody.gameObject;



			raycastHitBarycentricCoordinate = hit.barycentricCoordinate;

			raycastHitTriangleIndex = hit.triangleIndex;


			raycastHitPoint = hit.point;

			raycastHitNormal = hit.normal;

			raycastHitDistance = hit.distance;


			raycastHitLightmapCoord = hit.lightmapCoord;

			raycastHittextureCoord = hit.textureCoord;

			raycastHittextureCoord2 =  hit.textureCoord2;
		}

		void ResetRayCastHitInfos ()
		{
			boolValue = false;

			raycastHitGameObject = null;



			raycastHitBarycentricCoordinate = new Vector3 ();

			raycastHitTriangleIndex = -1;


			raycastHitPoint = new Vector3 ();

			raycastHitNormal = new Vector3 ();

			raycastHitDistance = 0f;


			raycastHitLightmapCoord = new Vector2 ();

			raycastHittextureCoord = new Vector2 ();

			raycastHittextureCoord2 =  new Vector2 ();
		}


		void ParallaxScrolling ()
		{
			float newScrolling = Mathf.Repeat(Time.time * (-1f)*floatValues [0], floatValues [1]);

			transform_.position = vector3Values [0] + vector3Values [1].normalized * newScrolling;
		}


		void BoundsExtractValues (Bounds b)
		{
			boundsCenterValue = b.center;

			boundsExtentsValue = b.extents;

			boundsMaxValue = b.max;

			boundsMinValue = b.min;

			boundsSizeValue = b.size;
		}

		void ExtractNavMeshHitValues ()
		{
			NavMeshHit_distance = navMeshHit.distance;

			NavMeshHit_hit = navMeshHit.hit;

			NavMeshHit_mask = navMeshHit.mask;

			NavMeshHit_normal = navMeshHit.normal;

			NavMeshHit_position = navMeshHit.position;
		}



		void Texture2D_0_ComputeNormalMap ()
		{
			if (texture2DValues [0] != null)
			{
				Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);


				//Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
				//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

				int intensity = (int)normalMapComputeIntensity + 1;

				float amplifier = (float)intensity*10f;

				tex.SetPixels (TextureComputer.NormalColors (texture2DValues [0], boolValues [0], channel,
					amplifier));

				tex.name = "Normal";

				tex.Apply ();

				texture2DValue = tex;

				tex = null;
			}
		}

		void Texture2D_0_Mirror ()
		{
			if (texture2DValues [0] != null)
			{
				Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

				if (mirrorTexture2D_Direction == TextureComputer.MirrorTexture2D_Direction.rotate90 ||
					mirrorTexture2D_Direction == TextureComputer.MirrorTexture2D_Direction.rotateMinus90 ||
					mirrorTexture2D_Direction == TextureComputer.MirrorTexture2D_Direction.mirrorXAndY)
				{
					tex = new Texture2D (texture2DValues [0].height, texture2DValues [0].width);
				}

				//Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
				//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

				tex.SetPixels (TextureComputer.MirrorAndRotate (texture2DValues [0], mirrorTexture2D_Direction));

				tex.name = texture2DValues [0].name + "_" + mirrorTexture2D_Direction.ToString ();

				tex.Apply ();

				texture2DValue = tex;

				tex = null;
			}
		}

		void Texture2D_0_SwitchColors ()
		{
			if (texture2DValues [0] != null)
			{
				Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

				//Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
				//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

				tex.SetPixels (TextureComputer.SwitchColors (texture2DValues [0], switchColorsType));

				tex.name = texture2DValues [0].name + "_" + switchColorsType.ToString ();

				tex.Apply ();

				texture2DValue = tex;

				tex = null;
			}

		}

		void Texture2D_0_SetChannelsComingFromTexture ()
		{
			if (texture2DValues [0] != null)
			{
				if (texture2DValues [1] != null)
				{
					if (texture2DValues [0].width == texture2DValues [1].width)
					{
						if (texture2DValues [0].height == texture2DValues [1].height)
						{
							Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

							//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
							//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

							tex.SetPixels (TextureComputer.SetChannel (texture2DValues [0], channel, texture2DValues [1]));

							tex.name = "modifiedTexture";

							tex.Apply ();

							texture2DValue = tex;

							tex = null;
						}
					}
				}
			}

		}

		void Texture2D_0_SetPixelAccordingToAChannelValue ()
		{
			if (texture2DValues [0] != null)
			{
				if (texture2DValues [1] != null)
				{
					Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

					//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
					//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

					tex.SetPixels (TextureComputer.SetPixelAccordingToAChannelValue (channels [1], 
						intValues [1], intValues [2], texture2DValues [1],	texture2DValues [0]));

					tex.name = "modifiedTexture";

					tex.Apply ();

					texture2DValue = tex;

					tex = null;
				}
			}

		}

		void Texture2D_0_SetColorAccordingToAChannelValue ()
		{
			if (texture2DValues [0] != null)
			{
				Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

				//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
				//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

				tex.SetPixels (TextureComputer.SetColorAccordingToAChannelValue (channels [1], 
					intValues [1], intValues [2], colorValues [0],	texture2DValues [0]));

				tex.name = "modifiedTexture";

				tex.Apply ();

				texture2DValue = tex;

				tex = null;
			}

		}

		void Texture2D_0_SetChannelAccordingToAnotherChannelValue ()
		{
			if (texture2DValues [0] != null)
			{
				Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

				//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
				//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

				tex.SetPixels (TextureComputer.SetChannelAccordingToAnotherChannelValue
					(channels [0], channels [1], intValues [1], intValues [2], intValues [0],
						texture2DValues [0], boolValues [0], boolValues [1]));

				tex.name = "modifiedTexture";

				tex.Apply ();

				texture2DValue = tex;

				tex = null;
			}

		}

		void Texture2D_0_SetChannels ()
		{
			if (texture2DValues [0] != null)
			{
				Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

				//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
				//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

				tex.SetPixels (TextureComputer.SetChannel (texture2DValues [0], channel, intValues [0]));

				tex.name = "modifiedTexture";

				tex.Apply ();

				texture2DValue = tex;

				tex = null;
			}

		}

		void Texture2D_0_ExtractChannels ()
		{
			if (texture2DValues [0] != null)
			{
				Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);

				//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,
				//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);

				tex.SetPixels (TextureComputer.ExtractChannel (texture2DValues [0], channel, extractResultType));

				tex.name = "modifiedTexture";

				tex.Apply ();

				texture2DValue = tex;

				tex = null;
			}

		}

		void Texture2D_AuthorANewUniColorTexture ()
		{
			int bW = Mathf.CeilToInt (vector2Values[0].x);
		
			int bH = Mathf.CeilToInt (vector2Values[0].y);
		
			Texture2D tex = new Texture2D (bW, bH);
		
			Color[] colors = new Color [bW*bH];
		
			for (int i = 0; i < colors.Length; i++)
				colors [i] = colorValues [0];
		
			tex.SetPixels (colors);
		
		
		
			tex.Apply ();
		
			texture2DValue = tex;
		
			texture2DValue.name = "AuthoredTexture";

			tex = null;
		}



		void SetTexture2D_0_SetPixel ()
		{
			if (texture2DValues [0] != null)
			{
				intValues [0] = Mathf.Clamp (intValues [0], 0, texture2DValues [0].width);

				intValues [1] = Mathf.Clamp (intValues [1], 0, texture2DValues [0].height);

				texture2DValues [0].SetPixel (intValues [0], intValues [1], colorValues [0]);

				texture2DValue = texture2DValues [0];
			}
		}

		void SetTexture2D_0_WrapMode ()
		{
			if (texture2DValues [0] != null)
			{
				texture2DValues [0].wrapMode = textureWrapMode;

				texture2DValue = texture2DValues [0];
			}
		}

		void SetTexture2D_0_FilterMode ()
		{
			if (texture2DValues [0] != null)
			{
				texture2DValues [0].filterMode = filterMode;

				texture2DValue = texture2DValues [0];
			}
		}

		void SetTexture2D_0_AnisoLevel ()
		{
			if (texture2DValues [0] != null)
			{
				texture2DValues [0].anisoLevel = intValues [0];

				texture2DValue = texture2DValues [0];
			}
		}

		void SetTexture2D_0_MipMapBias ()
		{
			if (texture2DValues [0] != null)
			{
				texture2DValues [0].mipMapBias = floatValues [0];

				texture2DValue = texture2DValues [0];
			}
		}

		void GetTexture2D_0_MipMapBias ()
		{
			if (texture2DValues [0] != null)
			{
				floatValue = texture2DValues [0].mipMapBias;
			}
		}

		void Texture2D_0_Compress ()
		{
			if (texture2DValues [0] != null)
			{
				texture2DValues [0].Compress (boolValues [0]);

				texture2DValue = texture2DValues [0];
			}
		}

		void Texture2D_CaptureGameViewScreenshot ()
		{
			if (string.IsNullOrEmpty (stringValues [0]))
				stringValues [0] = "Game View Screenshot";

			string path = TextureWriter.CreateNewFolder (TextureWriter.screenshotsFolderName)
				+ "/" + stringValues [0] + ".png";



			#if UNITY_2017_1_OR_NEWER
			if (intValues [0] > 0)
				ScreenCapture.CaptureScreenshot (path, intValues [0]);
			else
				ScreenCapture.CaptureScreenshot (path);
			#else
			if (intValues [0] > 0)
				Application.CaptureScreenshot (path, intValues [0]);
			else
				Application.CaptureScreenshot (path);
			#endif


			texture2DValue = (Texture2D)AssetDatabase.LoadAssetAtPath (path, typeof (Texture2D));

			Auxiliaries.SaveAndRefreshAssetsForced ();
		}

		void GetTexture2D_0_PixelBilinear ()
		{
			if (texture2DValues [0] != null)
			{
				floatValues [0] = Mathf.Clamp (floatValues [0], 0f, 1f);

				floatValues [1] = Mathf.Clamp (floatValues [1], 0f, 1f);

				colorValue = texture2DValues [0].GetPixelBilinear (floatValues [0], floatValues [1]);
			}
		}

		void GetTexture2D_0_Pixel ()
		{
			if (texture2DValues [0] != null)
			{
				intValues [0] = Mathf.Clamp (intValues [0], 0, texture2DValues [0].width);

				intValues [1] = Mathf.Clamp (intValues [1], 0, texture2DValues [0].height);

				colorValue = texture2DValues [0].GetPixel (intValues [0], intValues [1]);
			}
		}

		void GetTexture2D_0_MipMapCount ()
		{
			if (texture2DValues [0] != null)
			{
				intValue = texture2DValues [0].mipmapCount;
			}
		}

		void GetTexture2D_0_Width ()
		{
			if (texture2DValues [0] != null)
			{
				intValue = texture2DValues [0].width;
			}
		}

		void GetTexture2D_0_Height ()
		{
			if (texture2DValues [0] != null)
			{
				intValue = texture2DValues [0].height;
			}
		}

		void GetTexture2D_0_AnisoLevel ()
		{
			if (texture2DValues [0] != null)
			{
				intValue = texture2DValues [0].anisoLevel;
			}
		}


		void TaskOnClick()
		{
			boolValue = true;

			uiButton.Invoke ("BoolValueToFalse", Time.deltaTime * floatValues [0]);
		}

		void BoolValueToFalse ()
		{
			boolValue = false;
		}


		void InventoryListAction_gameobject_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawGameObjectListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawGameObjectFieldInput (0, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawGameObjectFieldInput (0, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_gameobject_Compute ()
		{
			if (boolValues [0])
			{
				gameObjectsListValue = gameObjectsListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				gameObjectsListValue.Add (gameObjectValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (gameObjectsListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > gameObjectsListValue.Count -1)
					return;

				gameObjectValue = gameObjectsListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				gameObjectsListValue.Remove (gameObjectValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > gameObjectsListValue.Count -1)
					return;
				
				gameObjectsListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = gameObjectsListValue.Count;
		}
		void InventoryListAction_gameobject_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawGameObjectListResultField (false, false);
				//if (gameObjectsListValue.Count > 0) 
				//	gameObjectsListValue [gameObjectsListValue.Count-1] = gameObjectValues [0];
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawGameObjectResultField (ObjectResultDrawChoice.itsName, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawGameObjectListResultField (false, false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawGameObjectListResultField (false, false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawGameObjectListResultField (false, false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1 ,2);
				DrawGameObjectListResultField (false, false);
				break;
			}
		}

		void ForGet_gameObjectList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawGameObjectListFieldInput (0);
			}
		}
		void ForGet_gameObjectList_Compute ()
		{
			if (boolValues [0])
			{
				gameObjectsListValue = gameObjectsListValues [0];
			}

			intValue = gameObjectsListValue.Count;
		}
		void ForGet_gameObjectList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawGameObjectListResultField (false, false);
			}
			else if ( ! boolValues [0])
			{
				DrawGameObjectListResultField (true, true);
			}
		}


		void InventoryListAction_material_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawMaterialListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawMaterialFieldInput (0, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawMaterialFieldInput (0, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_material_Compute ()
		{
			if (boolValues [0])
			{
				materialsListValue = materialsListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				materialsListValue.Add (materialValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (materialsListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > materialsListValue.Count -1)
					return;

				materialValue = materialsListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				materialsListValue.Remove (materialValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > materialsListValue.Count -1)
					return;

				materialsListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = materialsListValue.Count;
		}
		void InventoryListAction_material_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawMaterialListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawMaterialResultField (true, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawMaterialListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawMaterialListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawMaterialListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawMaterialListResultField (false);
				break;
			}
		}

		void ForGet_materialList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawMaterialListFieldInput (0);
			}
		}
		void ForGet_materialList_Compute ()
		{
			if (boolValues [0])
			{
				materialsListValue = materialsListValues [0];
			}

			intValue = materialsListValue.Count;
		}
		void ForGet_materialList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawMaterialListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawMaterialListResultField (true);
			}
		}


		void InventoryListAction_shader_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawShaderListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawShaderFieldInput (0, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawShaderFieldInput (0, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_shader_Compute ()
		{
			if (boolValues [0])
			{
				shaderListValue = shaderListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				shaderListValue.Add (shaderValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (shaderListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > shaderListValue.Count -1)
					return;

				shaderValue = shaderListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				shaderListValue.Remove (shaderValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > shaderListValue.Count -1)
					return;

				shaderListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = shaderListValue.Count;
		}
		void InventoryListAction_shader_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawShaderListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawShaderResultField (true, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawShaderListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawShaderListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawShaderListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawShaderListResultField (false);
				break;
			}
		}

		void ForGet_shaderList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawShaderListFieldInput (0);
			}
		}
		void ForGet_shaderList_Compute ()
		{
			if (boolValues [0])
			{
				shaderListValue = shaderListValues [0];
			}

			intValue = shaderListValue.Count;
		}
		void ForGet_shaderList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawShaderListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawShaderListResultField (true);
			}
		}



		void InventoryListAction_texture2D_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawTexture2DListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawTexture2DFieldInput (0, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawTexture2DFieldInput (0, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_texture2D_Compute ()
		{
			if (boolValues [0])
			{
				texture2DListValue = texture2DListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				texture2DListValue.Add (texture2DValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (texture2DListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > texture2DListValue.Count -1)
					return;

				texture2DValue = texture2DListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				texture2DListValue.Remove (texture2DValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > texture2DListValue.Count -1)
					return;

				texture2DListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = texture2DListValue.Count;
		}
		void InventoryListAction_texture2D_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawTexture2DListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawTexture2DResultField (true, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawTexture2DListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1 , 2);
				DrawTexture2DListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawTexture2DListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawTexture2DListResultField (false);
				break;
			}
		}

		void ForGet_texture2DList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawTexture2DListFieldInput (0);
			}
		}
		void ForGet_texture2DList_Compute ()
		{
			if (boolValues [0])
			{
				texture2DListValue = texture2DListValues [0];
			}

			intValue = texture2DListValue.Count;
		}
		void ForGet_texture2DList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawTexture2DListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawTexture2DListResultField (true);
			}
		}



		void InventoryListAction_bool_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawBoolListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (1, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawBoolInputField (0, 3, 4);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawBoolInputField (0, 3, 4);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_bool_Compute ()
		{
			if (boolValues [1])
			{
				boolsListValue = boolsListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				boolsListValue.Add (boolValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (boolsListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > boolsListValue.Count -1)
					return;

				boolValue = boolsListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				boolsListValue.Remove (boolValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > boolsListValue.Count -1)
					return;

				boolsListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = boolsListValue.Count;
		}
		void InventoryListAction_bool_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawBoolListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawBoolResultField (1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawBoolListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawBoolListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1 ,2);
				DrawBoolListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawBoolListResultField (false);
				break;
			}
		}

		void ForGet_boolList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawBoolListFieldInput (0);
			}
		}
		void ForGet_boolList_Compute ()
		{
			if (boolValues [0])
			{
				boolsListValue = boolsListValues [0];
			}

			intValue = boolsListValue.Count;
		}
		void ForGet_boolList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawBoolListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawBoolListResultField (true);
			}
		}

		void ForGet_bool_DrawInputs ()
		{
			if (boolValues [1])
			{
				DrawLogicNodeLabel ("The input", 0, 2);
				DrawBoolInputField (0, 3, 4);
			}
		}
		void ForGet_bool_Compute ()
		{
			if (boolValues [1])
			{
				boolValue = boolValues [0];
			}
		}
		void ForGet_bool_DrawOutputs ()
		{
			DrawLogicNodeLabel ("The result", 0, 2);

			DrawBoolResultField (Enums.boolValue_ID, 3, 4);
		}


		void InventoryListAction_color_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawColorListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawColorInputField (0, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawColorInputField (0, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_color_Compute ()
		{
			if (boolValues [0])
			{
				colorsListValue = colorsListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				colorsListValue.Add (colorValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (colorsListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > colorsListValue.Count -1)
					return;

				colorValue = colorsListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				colorsListValue.Remove (colorValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > colorsListValue.Count -1)
					return;

				colorsListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = colorsListValue.Count;
		}
		void InventoryListAction_color_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawColorListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawColorResultField (1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawColorListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawColorListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawColorListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawColorListResultField (false);
				break;
			}
		}

		void ForGet_colorList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawColorListFieldInput (0);
			}
		}
		void ForGet_colorList_Compute ()
		{
			if (boolValues [0])
			{
				colorsListValue = colorsListValues [0];
			}

			intValue = colorsListValue.Count;
		}
		void ForGet_colorList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawColorListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawColorListResultField (true);
			}
		}


		void InventoryListAction_float_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawFloatListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawFloatInputField (0, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_float_Compute ()
		{
			if (boolValues [0])
			{
				floatsListValue = floatsListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				floatsListValue.Add (floatValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (floatsListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > floatsListValue.Count -1)
					return;

				floatValue = floatsListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				floatsListValue.Remove (floatValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > floatsListValue.Count -1)
					return;

				floatsListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = floatsListValue.Count;
		}
		void InventoryListAction_float_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawFloatListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawFloatResultField (true, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawFloatListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawFloatListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawFloatListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawFloatListResultField (false);
				break;
			}
		}

		void ForGet_floatList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawFloatListFieldInput (0);
			}
		}
		void ForGet_floatList_Compute ()
		{
			if (boolValues [0])
			{
				floatsListValue = floatsListValues [0];
			}

			intValue = floatsListValue.Count;
		}
		void ForGet_floatList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawFloatListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawFloatListResultField (true);
			}
		}



		void InventoryListAction_rect_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawRectListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawRectInputField (0, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawRectInputField (0, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_rect_Compute ()
		{
			if (boolValues [0])
			{
				rectListValue = rectListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				rectListValue.Add (rectValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (rectListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > rectListValue.Count -1)
					return;

				rectValue = rectListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				rectListValue.Remove (rectValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > rectListValue.Count -1)
					return;

				rectListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = rectListValue.Count;
		}
		void InventoryListAction_rect_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawRectListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawRectResultField (true, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawRectListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawRectListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawRectListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawRectListResultField (false);
				break;
			}
		}


		void InventoryListAction_vector4_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawVector4ListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list");
				DrawVector4InputField (0);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list");
				DrawVector4InputField (0);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_vector4_Compute ()
		{
			if (boolValues [0])
			{
				vector4ListValue = vector4ListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				vector4ListValue.Add (vector4Values [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (vector4ListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > vector4ListValue.Count -1)
					return;

				vector4Value = vector4ListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				vector4ListValue.Remove (vector4Values [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > vector4ListValue.Count -1)
					return;

				vector4ListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = vector4ListValue.Count;
		}
		void InventoryListAction_vector4_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector4ListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawVector4ResultField (true, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector4ListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector4ListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector4ListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector4ListResultField (false);
				break;
			}
		}


		void InventoryListAction_vector3_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawVector3ListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list");
				DrawVector3InputField (0);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list");
				DrawVector3InputField (0);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_vector3_Compute ()
		{
			if (boolValues [0])
			{
				vector3ListValue = vector3ListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				vector3ListValue.Add (vector3Values [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (vector3ListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > vector3ListValue.Count -1)
					return;

				vector3Value = vector3ListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				vector3ListValue.Remove (vector3Values [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > vector3ListValue.Count -1)
					return;

				vector3ListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = vector3ListValue.Count;
		}
		void InventoryListAction_vector3_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector3ListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawVector3ResultField (true, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector3ListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector3ListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector3ListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector3ListResultField (false);
				break;
			}
		}



		void InventoryListAction_int_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawIntListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawIntInputField (0, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawIntInputField (0, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_int_Compute ()
		{
			if (boolValues [0])
			{
				intsListValue = intsListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				intsListValue.Add (intValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (intsListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > intsListValue.Count -1)
					return;

				intValue = intsListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				intsListValue.Remove (intValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > intsListValue.Count -1)
					return;

				intsListValue.RemoveAt (intValues [0]);
				break;
			}

			if (inventoryListAction != InventoryListAction.makeObjectOfFollowingIndexReady)
				intValue = intsListValue.Count;
		}
		void InventoryListAction_int_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawIntListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawIntResultField (true, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawIntListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawIntListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawIntListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawIntListResultField (false);
				break;
			}
		}

		void ForGet_intList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawIntListFieldInput (0);
			}
		}
		void ForGet_intList_Compute ()
		{
			if (boolValues [0])
			{
				intsListValue = intsListValues [0];
			}

			intValue = intsListValue.Count;
		}
		void ForGet_intList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawIntListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawIntListResultField (true);
			}
		}


		void InventoryListAction_string_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawStringsListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_string_Compute ()
		{
			if (boolValues [0])
			{
				stringsListValue = stringsListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				stringsListValue.Add (stringValues [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (stringsListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > stringsListValue.Count -1)
					return;

				stringValue = stringsListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				stringsListValue.Remove (stringValues [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > stringsListValue.Count -1)
					return;

				stringsListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = stringsListValue.Count;
		}
		void InventoryListAction_string_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawStringsListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawStringResultField (true, 1, 2);

				//DrawLogicNodeLabel ("List's name", 0, 2);
				//DrawStringResultField (true, 1, 2);
				DrawStringsListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawStringsListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawStringsListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawStringsListResultField (false);
				break;
			}
		}

		void ForGet_stringList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawStringsListFieldInput (0);
			}
		}
		void ForGet_stringList_Compute ()
		{
			if (boolValues [0])
			{
				stringsListValue = stringsListValues [0];
			}

			intValue = stringsListValue.Count;
		}
		void ForGet_stringList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawStringsListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawStringsListResultField (true);
			}
		}


		void InventoryListAction_vector2_DrawInputs ()
		{
			DrawLogicNodeLabel ("Input list", 0, 2);
			DrawVector2ListFieldInput (0, 1, 2);

			DrawLogicNodeLabel ("Act on input list?", 0, 2);
			DrawBoolInputField (0, 3, 4);

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("Add to list", 0, 2);
				DrawVector2InputField (0, 1, 2);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("With this name", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("Remove from list", 0, 2);
				DrawVector2InputField (0, 1, 2);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawIntInputField (0);
				//intValues [0] = Mathf.Clamp (intValues [0], 0, gameObjectsListValue.Count-1);
				break;
			}
		}
		void InventoryListAction_vector2_Compute ()
		{
			if (boolValues [0])
			{
				vector2ListValue = vector2ListValues [0];
			}

			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				vector2ListValue.Add (vector2Values [0]);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				if (vector2ListValue.Count == 0)
					return;

				if (intValues [0] < 0 || intValues [0] > vector2ListValue.Count -1)
					return;

				vector2Value = vector2ListValue [intValues [0]];
				break;

			case InventoryListAction.nameEntireList:
				stringValue = stringValues [0];
				break;

			case InventoryListAction.Remove:
				vector2ListValue.Remove (vector2Values [0]);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				if (intValues [0] < 0 || intValues [0] > vector2ListValue.Count -1)
					return;

				vector2ListValue.RemoveAt (intValues [0]);
				break;
			}

			intValue = vector2ListValue.Count;
		}
		void InventoryListAction_vector2_DrawOutputs ()
		{
			switch (inventoryListAction)
			{
			case InventoryListAction.Add:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector2ListResultField (false);
				break;

			case InventoryListAction.makeObjectOfFollowingIndexReady:
				DrawLogicNodeLabel ("Ready Object", 0, 2);
				DrawVector2ResultField (true, 1, 2);

				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector2ListResultField (false);
				break;

			case InventoryListAction.nameEntireList:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector2ListResultField (false);
				break;

			case InventoryListAction.Remove:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector2ListResultField (false);
				break;

			case InventoryListAction.RemoveAtThisIndex:
				DrawLogicNodeLabel ("List's name", 0, 2);
				DrawStringResultField (true, 1, 2);
				DrawVector2ListResultField (false);
				break;
			}
		}

		void ForGet_vector2List_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawVector2ListFieldInput (0);
			}
		}
		void ForGet_vector2List_Compute ()
		{
			if (boolValues [0])
			{
				vector2ListValue = vector2ListValues[0];
			}

			intValue = vector2ListValue.Count;
		}
		void ForGet_vector2List_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawVector2ListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawVector2ListResultField (true);
			}
		}

		void ForGet_vector3List_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawVector3ListFieldInput (0);
			}
		}
		void ForGet_vector3List_Compute ()
		{
			if (boolValues [0])
			{
				vector3ListValue = vector3ListValues[0];
			}

			intValue = vector3ListValue.Count;
		}
		void ForGet_vector3List_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawVector3ListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawVector3ListResultField (true);
			}
		}

		void ForGet_vector4List_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawVector4ListFieldInput (0);
			}
		}
		void ForGet_vector4List_Compute ()
		{
			if (boolValues [0])
			{
				vector4ListValue = vector4ListValues[0];
			}

			intValue = vector4ListValue.Count;
		}
		void ForGet_vector4List_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawVector4ListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawVector4ListResultField (true);
			}
		}

		void ForGet_rectList_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawRectListFieldInput (0);
			}
		}
		void ForGet_RectList_Compute ()
		{
			if (boolValues [0])
			{
				rectListValue = rectListValues[0];
			}

			intValue = rectListValue.Count;
		}
		void ForGet_rectList_DrawOutputs ()
		{
			if (boolValues [0])
			{
				DrawRectListResultField (false);
			}
			else if ( ! boolValues [0])
			{
				DrawRectListResultField (true);
			}
		}


		void ForGet_color_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawColorInputField (0);
			}
		}
		void ForGet_color_Compute ()
		{
			if (boolValues [0])
			{
				colorValue = colorValues [0];
			}
		}
		void ForGet_color_DrawOutputs ()
		{
			DrawColorResultField ();
		}


		void ForGet_float_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawFloatInputField (0);
			}
		}
		void ForGet_float_Compute ()
		{
			if (boolValues [0])
			{
				floatValue = floatValues [0];
			}
		}
		void ForGet_float_DrawOutputs ()
		{
			DrawFloatResultField (false);
		}


		void ForGet_int_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawIntInputField (0);
			}
		}
		void ForGet_int_Compute ()
		{
			if (boolValues [0])
			{
				intValue = intValues [0];
			}
		}
		void ForGet_int_DrawOutputs ()
		{
			DrawIntResultField (false);
		}


		void ForGet_vector2_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawVector2InputField (0);
			}
		}
		void ForGet_vector2_Compute ()
		{
			if (boolValues [0])
			{
				vector2Value = vector2Values [0];
			}
		}
		void ForGet_vector2_DrawOutputs ()
		{
			DrawVector2ResultField (false);
		}


		void ForGet_vector3_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawVector3InputField (0);
			}
		}
		void ForGet_vector3_Compute ()
		{
			if (boolValues [0])
			{
				vector3Value = vector3Values [0];
			}
		}
		void ForGet_vector3_DrawOutputs ()
		{
			DrawVector3ResultField (false);
		}


		void ForGet_vector4_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawVector4InputField (0);
			}
		}
		void ForGet_vector4_Compute ()
		{
			if (boolValues [0])
			{
				vector4Value = vector4Values [0];
			}
		}
		void ForGet_vector4_DrawOutputs ()
		{
			DrawVector4ResultField (false);
		}


		void ForGet_rect_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawRectInputField (0);
			}
		}
		void ForGet_rect_Compute ()
		{
			if (boolValues [0])
			{
				rectValue = rectValues [0];
			}
		}
		void ForGet_rect_DrawOutputs ()
		{
			DrawRectResultField (false);
		}


		void ForGet_string_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawStringInputField (0, stringInputFieldForWhat.general);
			}
		}
		void ForGet_string_Compute ()
		{
			if (boolValues [0])
			{
				stringValue = stringValues [0];
			}
		}
		void ForGet_string_DrawOutputs ()
		{
			DrawStringResultField (false);
		}


		void ForGet_gameObject_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawGameObjectFieldInput (0);
			}
		}
		void ForGet_gameObject_Compute ()
		{
			if (boolValues [0])
			{
				gameObjectValue = gameObjectValues [0];
			}
		}
		void ForGet_gameObject_DrawOutputs ()
		{
			DrawGameObjectResultField (ObjectResultDrawChoice.itself);
		}


		void ForGet_material_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawMaterialFieldInput (0);
			}
		}
		void ForGet_material_Compute ()
		{
			if (boolValues [0])
			{
				materialValue = materialValues [0];
			}
		}
		void ForGet_material_DrawOutputs ()
		{
			DrawMaterialResultField (false);
		}


		void ForGet_texture2D_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawTexture2DFieldInput (0);
			}
		}
		void ForGet_texture2D_Compute ()
		{
			if (boolValues [0])
			{
				texture2DValue = texture2DValues [0];
			}
		}
		void ForGet_texture2D_DrawOutputs ()
		{
			DrawTexture2DResultField (false);
		}


		void ForGet_shader_DrawInputs ()
		{
			if (boolValues [0])
			{
				DrawShaderFieldInput (0);
			}
		}
		void ForGet_shader_Compute ()
		{
			if (boolValues [0])
			{
				shaderValue = shaderValues [0];
			}
		}
		void ForGet_shader_DrawOutputs ()
		{
			DrawShaderResultField (false);
		}


		void DoNotCheckTexture2D_0 ()
		{
			doNotCheckTexture2D_0 = 
				computeTexture2DType == 
				ComputeTexture2DType.AuthorANewUniColorTexture ||
				computeTexture2DType ==
				ComputeTexture2DType.CaptureGameViewScreenshot;


			//doIT_ComputeShader = doNotCheckShader_0;
		}

		void DoNotCheckShader_0 ()
		{
			doNotCheckShader_0 = computeShaderType == 
				ComputeShaderType.FindAShaderByName ||
				computeShaderType == 
				ComputeShaderType.forAllShadersDisableKeyword ||
				computeShaderType == 
				ComputeShaderType.forAllShadersEnableKeyword ||
				computeShaderType == 
				ComputeShaderType.forAllShadersGetGlobalMaximumLOD ||
				computeShaderType == 
				ComputeShaderType.forAllShadersIsKeywordEnabled ||
				computeShaderType == 
				ComputeShaderType.forAllShadersPropertyToID ||
				computeShaderType == 
				ComputeShaderType.forAllShadersSetGlobalColor ||
				computeShaderType == 
				ComputeShaderType.forAllShadersSetGlobalFloat ||
				computeShaderType == 
				ComputeShaderType.forAllShadersSetGlobalInt ||
				computeShaderType == 
				ComputeShaderType.forAllShadersSetGlobalMaximumLOD ||
				computeShaderType == 
				ComputeShaderType.forAllShadersSetGlobalTexture ||
				computeShaderType == 
				ComputeShaderType.forAllShadersSetGlobalVector4 ||
				computeShaderType == 
				ComputeShaderType.WarmupAllShaders;

			//doIT_ComputeShader = doNotCheckShader_0;
		}


		void AssignRayCasthit_2D_Infos ()
		{
			if (hit2D.collider == null)
			{
				ResetRayCasthit_2D_Infos ();

				return;
			}



			hit2D_gameObject = hit2D.transform.gameObject;

			if (hit2D_gameObject == null)
				hit2D_gameObject = hit2D.collider.gameObject;

			if (hit2D_gameObject == null)
				hit2D_gameObject = hit2D.rigidbody.gameObject;



			boolValue = true;

			hit2D_centroid = hit2D.centroid;

			hit2D_fraction = hit2D.fraction;


			hit2D_point = hit2D.point;

			hit2D_normal = hit2D.normal;

			hit2D_distance = hit2D.distance;
		}

		void ResetRayCasthit_2D_Infos ()
		{
			boolValue = false;

			hit2D_gameObject = null;



			hit2D_centroid = new Vector2 ();

			hit2D_fraction = 0f;


			hit2D_point = new Vector2 ();

			hit2D_normal = new Vector2 ();

			hit2D_distance = 0f;
		}

		void OtherGameObjectFoundAtRadius_InputFields ()
		{
			DrawLogicNodeLabel ("Radius", 0, 2);
			DrawFloatInputField (0, 1, 2);
			floatValues [0] = Mathf.Max (0.01f, floatValues [0]);


			DrawLogicNodeLabel ("Layer Mask (-1 for everything)");
			DrawIntInputField (0);
			intValues [0] = Mathf.Max (-1, intValues [0]);
		}

		void OtherGameObjectFoundAtRadius_Compute ()
		{
			Vector3 ori = gameObjectValues [0].transform.position;
			Vector3 dori = UnityEngine.Random.onUnitSphere;
			float gap = 0.03f;

			Collider colli = gameObjectValues [0].GetComponent <Collider> ();

			bool noColli = colli == null;

			if ( ! noColli)
			{
				Bounds boundi = colli.bounds;				

				float semiDiag = (boundi.max - boundi.center).magnitude + gap;
				ori = boundi.center + dori*semiDiag;
			}



			RaycastHit hiti;

			boolValue = false;

			boolValue = Physics.Raycast (ori, dori, out hiti, floatValues [0], intValues [0]);

			//Debug.DrawLine (ori, ori + dori*floatValues [0], Color.cyan, 0.2f);

			gameObjectValue = null;
			stringValue = "";
			if (boolValue)
			{
				if (gameObjectValue == gameObjectValues [0])
				{
					gameObjectValue = null;
				}

				gameObjectValue = hiti.transform.gameObject;

				stringValue = gameObjectValue.tag;
				return;
			}
		}

		void OtherGameObjectFoundAtRadius_OutputFields ()
		{
			DrawLogicNodeLabel ("Something Found", 0, 2);
			DrawBoolResultField (1, 2);

			DrawLogicNodeLabel ("Found GameObject", 0, 2);
			DrawGameObjectResultField (ObjectResultDrawChoice.itsName, 1, 2);

			DrawLogicNodeLabel ("its Tag", 0, 2);
			DrawStringResultField (true, 1, 2);
		}


		void OtherGameObjectFoundOnMyWayAtDistance_InputFields ()
		{
			DrawLogicNodeLabel ("Distance", 0, 2);
			DrawFloatInputField (0, 1, 2);
			floatValues [0] = Mathf.Max (0.01f, floatValues [0]);


			DrawLogicNodeLabel ("Layer Mask (-1 for everything)");
			DrawIntInputField (0);
			intValues [0] = Mathf.Max (-1, intValues [0]);
		}

		void OtherGameObjectFoundOnMyWayAtDistance_Compute ()
		{
			Vector3 dori = Vector3.zero;

			Rigidbody rigi = gameObjectValues [0].GetComponent <Rigidbody> ();

			bool noRigi = rigi == null;

			if (noRigi)
				return;

			dori = rigi.velocity.normalized;

			if (Vector3.Dot (dori, dori) == 0f)
				return;

			Vector3 ori = gameObjectValues [0].transform.position;

			float gap = 0.03f;

			Collider colli = gameObjectValues [0].GetComponent <Collider> ();

			bool noColli = colli == null;
			if ( ! noColli)
			{
				Bounds boundi = colli.bounds;				

				float semiDiag = (boundi.max - boundi.center).magnitude + gap;
				ori = boundi.center + dori*semiDiag;
			}


			RaycastHit hiti;

			boolValue = false;
			boolValue = Physics.Raycast (ori, dori, out hiti, floatValues [0], intValues [0]);

			//Debug.DrawLine (ori, ori + dori*floatValues [0], Color.cyan, 0.2f);

			gameObjectValue = null;
			stringValue = "";
			if (boolValue)
			{
				if (gameObjectValue == gameObjectValues [0])
				{
					gameObjectValue = null;
				}

				gameObjectValue = hiti.transform.gameObject;

				stringValue = gameObjectValue.tag;
				return;
			}
		}

		void OtherGameObjectFoundOnMyWayAtDistance_OutputFields ()
		{
			DrawLogicNodeLabel ("Something Found", 0, 2);
			DrawBoolResultField (1, 2);

			DrawLogicNodeLabel ("Found GameObject", 0, 2);
			DrawGameObjectResultField (ObjectResultDrawChoice.itsName, 1, 2);

			DrawLogicNodeLabel ("its Tag", 0, 2);
			DrawStringResultField (true, 1, 2);
		}



		void OtherGameObjectFoundAtRadius_InputFields_2D ()
		{
			DrawLogicNodeLabel ("Radius", 0, 2);
			DrawFloatInputField (0, 1, 2);
			floatValues [0] = Mathf.Max (0.01f, floatValues [0]);


			DrawLogicNodeLabel ("Layer Mask (-1 for everything)");
			DrawIntInputField (0);
			intValues [0] = Mathf.Max (-1, intValues [0]);
		}

		void OtherGameObjectFoundAtRadius_Compute_2D ()
		{
			Vector2 ori = new Vector2 (gameObjectValues [0].transform.position.x, gameObjectValues [0].transform.position.y);
			Vector2 dori = UnityEngine.Random.insideUnitCircle.normalized;
			float gap = 0.03f;

			Collider2D colli = gameObjectValues [0].GetComponent <Collider2D> ();

			bool noColli = colli == null;

			if ( ! noColli)
			{
				Bounds boundi = colli.bounds;				

				float semiDiag = (boundi.max - boundi.center).magnitude + gap;
				ori = new Vector2 (boundi.center.x, boundi.center.y) + dori*semiDiag;
			}



			RaycastHit2D hiti;

			boolValue = false;

			hiti = Physics2D.Raycast (ori, dori, floatValues [0], intValues [0]);

			boolValue = hiti.transform != null;


			gameObjectValue = null;
			stringValue = "";
			if (boolValue)
			{
				if (gameObjectValue == gameObjectValues [0])
				{
					gameObjectValue = null;
				}

				gameObjectValue = hiti.transform.gameObject;

				stringValue = gameObjectValue.tag;
				return;
			}
		}

		void OtherGameObjectFoundAtRadius_OutputFields_2D ()
		{
			DrawLogicNodeLabel ("Something Found", 0, 2);
			DrawBoolResultField (1, 2);

			DrawLogicNodeLabel ("Found GameObject", 0, 2);
			DrawGameObjectResultField (ObjectResultDrawChoice.itsName, 1, 2);

			DrawLogicNodeLabel ("its Tag", 0, 2);
			DrawStringResultField (true, 1, 2);
		}


		void OtherGameObjectFoundOnMyWayAtDistance_InputFields_2D ()
		{
			DrawLogicNodeLabel ("Distance", 0, 2);
			DrawFloatInputField (0, 1, 2);
			floatValues [0] = Mathf.Max (0.01f, floatValues [0]);


			DrawLogicNodeLabel ("Layer Mask (-1 for everything)");
			DrawIntInputField (0);
			intValues [0] = Mathf.Max (-1, intValues [0]);
		}

		void OtherGameObjectFoundOnMyWayAtDistance_Compute_2D ()
		{
			Vector2 dori = Vector2.zero;

			Rigidbody2D rigi = gameObjectValues [0].GetComponent <Rigidbody2D> ();

			bool noRigi = rigi == null;

			if (noRigi)
				return;

			dori = rigi.velocity.normalized;

			if (Vector2.Dot (dori, dori) == 0f)
				return;

			Vector2 ori = new Vector2 (gameObjectValues [0].transform.position.x, gameObjectValues [0].transform.position.y);

			float gap = 0.03f;

			Collider2D colli = gameObjectValues [0].GetComponent <Collider2D> ();

			bool noColli = colli == null;
			if ( ! noColli)
			{
				Bounds boundi = colli.bounds;				

				float semiDiag = (boundi.max - boundi.center).magnitude + gap;
				ori = new Vector2 (boundi.center.x, boundi.center.y) + dori*semiDiag;
			}


			RaycastHit2D hiti;

			boolValue = false;

			hiti = Physics2D.Raycast (ori, dori, floatValues [0], intValues [0]);

			boolValue = hiti.transform != null;

			gameObjectValue = null;
			stringValue = "";
			if (boolValue)
			{
				if (gameObjectValue == gameObjectValues [0])
				{
					gameObjectValue = null;
				}

				gameObjectValue = hiti.transform.gameObject;

				stringValue = gameObjectValue.tag;
				return;
			}
		}

		void OtherGameObjectFoundOnMyWayAtDistance_OutputFields_2D ()
		{
			DrawLogicNodeLabel ("Something Found", 0, 2);
			DrawBoolResultField (1, 2);

			DrawLogicNodeLabel ("Found GameObject", 0, 2);
			DrawGameObjectResultField (ObjectResultDrawChoice.itsName, 1, 2);

			DrawLogicNodeLabel ("its Tag", 0, 2);
			DrawStringResultField (true, 1, 2);
		}


		void ParticleSystemCheck ()
		{
			if ( ! doIT)
			{
				return;
			}

			particleSystem = gameObjectValues [0].GetComponent <ParticleSystem> ();

			if (particleSystem == null)
			{
				doIT = false;
			}
		}

		void RendererCheck ()
		{
			if ( ! doIT)
			{
				return;
			}

			spriteRenderer = gameObjectValues [0].GetComponent <SpriteRenderer> ();

			if (spriteRenderer == null)
			{
				doIT = false; 
			}
		}


		void TileSprite ()
		{
			Vector3 startPosition = vector3Values [0];

			float startRotation = floatValues [0];


			Vector2 rotationOverTiling_v2 = vector2Values [1];

			float rotationOverTiling = floatValues [1];


			Vector3 tilePosition = Vector3.zero;

			float tileRotation = 0f;


			Vector2 finalSpriteSize = new Vector2 (
				Mathf.Abs (spriteRenderer.size.x*spriteRenderer.transform.localScale.x), 
				Mathf.Abs (spriteRenderer.size.y*spriteRenderer.transform.localScale.y));

			Vector2 finalSpriteSizeNotNull = new Vector2 (
				finalSpriteSize.x != 0f? finalSpriteSize.x: 1f,
				finalSpriteSize.y != 0f? finalSpriteSize.y: 1f);	

			Vector2 totalSizeNotNull = new Vector2 (Mathf.Abs (vector2Values [0].x), Mathf.Abs (vector2Values [0].y));

			int tile_x = Mathf.FloorToInt (totalSizeNotNull.x / finalSpriteSizeNotNull.x);

			int tile_y = Mathf.FloorToInt (totalSizeNotNull.y / finalSpriteSizeNotNull.y);

			Vector2 resid = new Vector2 (
				Mathf.Abs (totalSizeNotNull.x - (float)tile_x*finalSpriteSizeNotNull.x),
				Mathf.Abs (totalSizeNotNull.y - (float)tile_y*finalSpriteSizeNotNull.y));


			GameObject spritesParent = new GameObject ("SpriteTiles");
			spritesParent.transform.position = startPosition;
			spritesParent.transform.rotation = Quaternion.Euler (Vector3.zero);
			spritesParent.transform.localScale = Vector3.one;
			GameObject newSprite = null;
			for (int j = 0; j < tile_y; j++)
			{
				for (int i = 0; i < tile_x; i++)
				{
					tilePosition = startPosition + new Vector3 (finalSpriteSizeNotNull.x*(float)i, 
						finalSpriteSizeNotNull.y*(float)j);

					tileRotation = startRotation;

					TileRotation (ref tileRotation, startRotation, rotationOverTiling, rotationOverTiling_v2,
						tile_x, i, j);

					newSprite = MonoBehaviour.Instantiate (spriteRenderer.gameObject, tilePosition,
						Quaternion.Euler (new Vector3 (0f, 0f, tileRotation)), spritesParent.transform);

					newSprite.name = spriteRenderer.name + "_" + i.ToString () + "_x_" + j.ToString ();

					if (i == tile_x-1 && resid.x > 0f)
					{
						tilePosition = startPosition + new Vector3 (
							finalSpriteSizeNotNull.x*(float)i+0.5f*(1f+resid.x)*finalSpriteSizeNotNull.x, 
							finalSpriteSizeNotNull.y*(float)j);

						TileRotation (ref tileRotation, startRotation, rotationOverTiling, rotationOverTiling_v2,
							tile_x, i, j);

						newSprite = MonoBehaviour.Instantiate (spriteRenderer.gameObject, tilePosition,
							Quaternion.Euler (new Vector3 (0f, 0f, tileRotation)), spritesParent.transform);

						newSprite.transform.localScale = new Vector3 (spriteRenderer.transform.localScale.x*resid.x,
							spriteRenderer.transform.localScale.y, spriteRenderer.transform.localScale.z);

						newSprite.name = spriteRenderer.name + "_" + "residual" + "_x_" + j.ToString ();
					}
				}


				if (j == tile_y-1 && resid.y > 0f)
				{
					for (int i = 0; i < tile_x; i++)
					{
						tilePosition = startPosition + new Vector3 (finalSpriteSizeNotNull.x*(float)i, 
							finalSpriteSizeNotNull.y*(float)j+0.5f*(1f+resid.y)*finalSpriteSizeNotNull.y);

						tileRotation = startRotation;

						TileRotation (ref tileRotation, startRotation, rotationOverTiling, rotationOverTiling_v2,
							tile_x, i, j);

						newSprite = MonoBehaviour.Instantiate (spriteRenderer.gameObject, tilePosition,
							Quaternion.Euler (new Vector3 (0f, 0f, tileRotation)), spritesParent.transform);

						newSprite.transform.localScale = new Vector3 (spriteRenderer.transform.localScale.x,
							spriteRenderer.transform.localScale.y*resid.y, spriteRenderer.transform.localScale.z);

						newSprite.name = spriteRenderer.name + "_" + i.ToString () + "_x_" + "residual";

						if (i == tile_x-1 && resid.x > 0f)
						{
							tilePosition = startPosition + new Vector3 (
								finalSpriteSizeNotNull.x*(float)i+0.5f*(1f+resid.x)*finalSpriteSizeNotNull.x, 
								finalSpriteSizeNotNull.y*(float)j+0.5f*(1f+resid.y)*finalSpriteSizeNotNull.y);

							TileRotation (ref tileRotation, startRotation, rotationOverTiling, rotationOverTiling_v2,
								tile_x, i, j);

							newSprite = MonoBehaviour.Instantiate (spriteRenderer.gameObject, tilePosition,
								Quaternion.Euler (new Vector3 (0f, 0f, tileRotation)), spritesParent.transform);

							newSprite.transform.localScale = new Vector3 (spriteRenderer.transform.localScale.x*resid.x,
								spriteRenderer.transform.localScale.y*resid.y, spriteRenderer.transform.localScale.z);

							newSprite.name = spriteRenderer.name + "_" + "residual" + "_x_" + "residual";
						}
					}
				}
			}

			gameObjectValue = spritesParent;
		}

		void TileRotation (ref float tileRotation, float startRotation, float rotationOverTiling, Vector2 rotationOverTiling_v2,
			int tile_x, int i, int j)
		{
			if ( ! boolValues [0])
			{
				if (boolValues [1])
				{
					tileRotation = startRotation + (float)i*rotationOverTiling_v2.x + (float)j*rotationOverTiling_v2.y;
				}
				else if ( ! boolValues [1])
				{
					tileRotation = startRotation + (float)(i+j*tile_x)*rotationOverTiling;
				}
			}
			else if (boolValues [0])
			{
				tileRotation = UnityEngine.Random.Range (0f, 359.9f);
			}
		}


		void Collider2DCheck ()
		{
			if ( ! doIT)
			{
				return;
			}

			circleCollider2D = gameObjectValues [0].GetComponent <CircleCollider2D> ();

			if (circleCollider2D == null)
			{
				doIT = false;


			}
		}

		Texture2D SpriteToTexture2D (Sprite s)
		{
			Texture2D t = new Texture2D ((int)s.rect.width, (int)s.rect.height);

			Color [] c = s.texture.GetPixels ((int)s.rect.x, (int)s.rect.y, (int)s.rect.width, (int)s.rect.height);

			t.SetPixels (c);

			t.Apply ();

			return t;
		}


		void SetThisToString_0 (object s)
		{
			stringValues [0] = s.ToString ();
		}


		void ShowAd ()
		{
			#if UNITY_IOS || UNITY_ANDROID
			if (UnityEngine.Advertisements.Advertisement.IsReady ())
			{			
				if (boolValues [0])
				{
					UnityEngine.Advertisements.Advertisement.Show ("rewardedVideo", 
						new UnityEngine.Advertisements.ShowOptions (){resultCallback = HandleAdResult});
				}
				else
				{
					UnityEngine.Advertisements.Advertisement.Show ();
				}
			}
			#endif
		}

		#if UNITY_IOS || UNITY_ANDROID
		void HandleAdResult (UnityEngine.Advertisements.ShowResult result)
		{
			switch (result)
			{
			case UnityEngine.Advertisements.ShowResult.Failed:
				ScriptsCreatedByDiamond.DiamodAds.showResult = "Failed";
				break;

			case UnityEngine.Advertisements.ShowResult.Finished:
				ScriptsCreatedByDiamond.DiamodAds.showResult = "Finished";
				break;

			case UnityEngine.Advertisements.ShowResult.Skipped:
				ScriptsCreatedByDiamond.DiamodAds.showResult = "Skipped";
				break;
			}

		}
		#endif


		void WhatWasTheShowAdResult ()
		{
			boolValue = stringValues [0] == ScriptsCreatedByDiamond.DiamodAds.showResult;

			ScriptsCreatedByDiamond.DiamodAds.showResult = "";
		}

		GameObject mdeGameObjectHolder = null;
		ScriptsCreatedByDiamond.MezanixDiamondEvents GetmdeDontCareAboutDoIt ()
		{
			if (mdeGameObjectHolder == null)
				mdeGameObjectHolder = GameObject.Find (ScriptsCreatedByDiamond.MezanixDiamondEvents.gameObjectHolderName);

			if (mdeGameObjectHolder == null)
				return null;

			return mdeGameObjectHolder.GetComponent <ScriptsCreatedByDiamond.MezanixDiamondEvents> ();
		}
		ScriptsCreatedByDiamond.MezanixDiamondEvents Getmde ()
		{
			if ( ! doIT)
				return null;

			if (mdeGameObjectHolder == null)
				mdeGameObjectHolder = GameObject.Find (ScriptsCreatedByDiamond.MezanixDiamondEvents.gameObjectHolderName);

			if (mdeGameObjectHolder == null)
				return null;

			return mdeGameObjectHolder.GetComponent <ScriptsCreatedByDiamond.MezanixDiamondEvents> ();
		}

		bool MezanixDiamondGetEvent (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondEvents mde = Getmde ();

			if (mde == null)
				return false;

			return mde.GetEvent (eName);
		}
		void MezanixDiamondRemoveEvent (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondEvents mde = Getmde ();

			if (mde == null)
				return;

			mde.RemoveEvent (eName);
		}
		void MezanixDiamondSetEvent (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondEvents mde = Getmde ();

			if (mde == null)
				return;

			mde.SetEvent (eName);
		}
		string [] MezanixDiamondEventNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondEvents mde = GetmdeDontCareAboutDoIt ();

			if (mde == null)
				return null;
			
			return mde.eventNames.ToArray ();
		}


		GameObject mddtGameObjectHolder = null;
		ScriptsCreatedByDiamond.MezanixDiamondDataTransfer GetmddtDontCareAboutDoIt ()
		{
			if (mddtGameObjectHolder == null)
				mddtGameObjectHolder = GameObject.Find (ScriptsCreatedByDiamond.MezanixDiamondDataTransfer.gameObjectHolderName);

			if (mddtGameObjectHolder == null)
				return null;

			return mddtGameObjectHolder.GetComponent <ScriptsCreatedByDiamond.MezanixDiamondDataTransfer> ();
		}
		ScriptsCreatedByDiamond.MezanixDiamondDataTransfer Getmddt ()
		{
			if ( ! doIT)
				return null;

			if (mddtGameObjectHolder == null)
				mddtGameObjectHolder = GameObject.Find (ScriptsCreatedByDiamond.MezanixDiamondDataTransfer.gameObjectHolderName);

			if (mddtGameObjectHolder == null)
				return null;

			return mddtGameObjectHolder.GetComponent <ScriptsCreatedByDiamond.MezanixDiamondDataTransfer> ();
		}


		bool MezanixDiamondGetBool (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return boolValues [1];

			return mddt.GetBool (eName, boolValues [1]);
		}
		void MezanixDiamondRemoveBool (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveBool (eName);
		}
		void MezanixDiamondSetBool (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetBool (eName, boolValues [0]);
		}
		string [] MezanixDiamondBoolNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.boolNames.ToArray ();
		}

		List<bool> MezanixDiamondGetBoolList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return boolsListValues [0];

			return mddt.GetBoolList (eName, boolsListValues [0]);
		}
		void MezanixDiamondRemoveBoolList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveBoolList (eName);
		}
		void MezanixDiamondSetBoolList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetBoolList (eName, boolsListValues [0]);
		}
		string [] MezanixDiamondBoolListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.boolListsNames.ToArray ();
		}


		Color MezanixDiamondGetColor (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return colorValues [0];

			return mddt.GetColor (eName, colorValues [0]);
		}
		void MezanixDiamondRemoveColor (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveColor (eName);
		}
		void MezanixDiamondSetColor (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetColor (eName, colorValues [0]);
		}
		string [] MezanixDiamondColorNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.colorNames.ToArray ();
		}

		List<Color> MezanixDiamondGetColorList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return colorsListValues [0];

			return mddt.GetColorList (eName, colorsListValues [0]);
		}
		void MezanixDiamondRemoveColorList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveColorList (eName);
		}
		void MezanixDiamondSetColorList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetColorList (eName, colorsListValues [0]);
		}
		string [] MezanixDiamondColorListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.colorListsNames.ToArray ();
		}


		float MezanixDiamondGetFloat (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return floatValues [0];

			return mddt.GetFloat (eName, floatValues [0]);
		}
		void MezanixDiamondRemoveFloat (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveFloat (eName);
		}
		void MezanixDiamondSetFloat (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetFloat (eName, floatValues [0]);
		}
		string [] MezanixDiamondFloatNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.floatNames.ToArray ();
		}

		List<float> MezanixDiamondGetFloatList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return floatsListValues [0];

			return mddt.GetFloatList (eName, floatsListValues [0]);
		}
		void MezanixDiamondRemoveFloatList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveFloatList (eName);
		}
		void MezanixDiamondSetFloatList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetFloatList (eName, floatsListValues [0]);
		}
		string [] MezanixDiamondFloatListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.floatListsNames.ToArray ();
		}


		GameObject MezanixDiamondGetGameObject (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return gameObjectValues [0];
			
			return mddt.GetGameObject (eName, gameObjectValues [0]);
		}
		void MezanixDiamondRemoveGameObject (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;
			
			mddt.RemoveGameObject (eName);
		}
		void MezanixDiamondSetGameObject (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetGameObject (eName, gameObjectValues [0]);
		}
		string [] MezanixDiamondGameObjectNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.gameObjectNames.ToArray ();
		}

		List<GameObject> MezanixDiamondGetGameObjectList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return gameObjectsListValues [0];

			return mddt.GetGameObjectList (eName, gameObjectsListValues [0]);
		}
		void MezanixDiamondRemoveGameObjectList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveGameObjectList (eName);
		}
		void MezanixDiamondSetGameObjectList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetGameObjectList (eName, gameObjectsListValues [0]);
		}
		string [] MezanixDiamondGameObjectListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.gameObjectListsNames.ToArray ();
		}


		int MezanixDiamondGetInt (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return intValues [0];

			return mddt.GetInt (eName, intValues [0]);
		}
		void MezanixDiamondRemoveInt (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveInt (eName);
		}
		void MezanixDiamondSetInt (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetInt (eName, intValues [0]);
		}
		string [] MezanixDiamondIntNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.intNames.ToArray ();
		}

		List<int> MezanixDiamondGetIntList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return intsListValues [0];

			return mddt.GetIntList (eName, intsListValues [0]);
		}
		void MezanixDiamondRemoveIntList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveIntList (eName);
		}
		void MezanixDiamondSetIntList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetIntList (eName, intsListValues [0]);
		}
		string [] MezanixDiamondIntListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.intListsNames.ToArray ();
		}


		string MezanixDiamondGetString (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return stringValues [1];

			return mddt.GetString (eName, stringValues [1]);
		}
		void MezanixDiamondRemoveString (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveString (eName);
		}
		void MezanixDiamondSetString (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetString (eName, stringValues [1]);
		}
		string [] MezanixDiamondStringNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.stringNames.ToArray ();
		}

		List<string> MezanixDiamondGetStringList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return stringsListValues [0];

			return mddt.GetStringList (eName, stringsListValues [0]);
		}
		void MezanixDiamondRemoveStringList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveStringList (eName);
		}
		void MezanixDiamondSetStringList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetStringList (eName, stringsListValues [0]);
		}
		string [] MezanixDiamondStringListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.stringListsNames.ToArray ();
		}


		Vector2 MezanixDiamondGetVector2 (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return vector2Values [0];

			return mddt.GetVector2 (eName, vector2Values [0]);
		}
		void MezanixDiamondRemoveVector2 (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveVector2 (eName);
		}
		void MezanixDiamondSetVector2 (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetVector2 (eName, vector2Values [0]);
		}
		string [] MezanixDiamondVector2Names ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.vector2Names.ToArray ();
		}

		List<Vector2> MezanixDiamondGetVector2List (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return vector2ListValues [0];

			return mddt.GetVector2List (eName, vector2ListValues [0]);
		}
		void MezanixDiamondRemoveVector2List (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveVector2List (eName);
		}
		void MezanixDiamondSetVector2List (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetVector2List (eName, vector2ListValues [0]);
		}
		string [] MezanixDiamondVector2ListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.vector2ListsNames.ToArray ();
		}


		Vector3 MezanixDiamondGetVector3 (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return vector3Values [0];

			return mddt.GetVector3 (eName, vector3Values [0]);
		}
		void MezanixDiamondRemoveVector3 (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveVector3 (eName);
		}
		void MezanixDiamondSetVector3 (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetVector3 (eName, vector3Values [0]);
		}
		string [] MezanixDiamondVector3Names ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.vector3Names.ToArray ();
		}

		List<Vector3> MezanixDiamondGetVector3List (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return vector3ListValues [0];

			return mddt.GetVector3List (eName, vector3ListValues [0]);
		}
		void MezanixDiamondRemoveVector3List (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveVector3List (eName);
		}
		void MezanixDiamondSetVector3List (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetVector3List (eName, vector3ListValues [0]);
		}
		string [] MezanixDiamondVector3ListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.vector3ListsNames.ToArray ();
		}


		Vector4 MezanixDiamondGetVector4 (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return vector4Values [0];

			return mddt.GetVector4 (eName, vector4Values [0]);
		}
		void MezanixDiamondRemoveVector4 (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveVector4 (eName);
		}
		void MezanixDiamondSetVector4 (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetVector4 (eName, vector4Values [0]);
		}
		string [] MezanixDiamondVector4Names ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.vector4Names.ToArray ();
		}

		List<Vector4> MezanixDiamondGetVector4List (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return vector4ListValues [0];

			return mddt.GetVector4List (eName, vector4ListValues [0]);
		}
		void MezanixDiamondRemoveVector4List (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveVector4List (eName);
		}
		void MezanixDiamondSetVector4List (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetVector4List (eName, vector4ListValues [0]);
		}
		string [] MezanixDiamondVector4ListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.vector4ListsNames.ToArray ();
		}


		Rect MezanixDiamondGetRect (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return rectValues [0];

			return mddt.GetRect (eName, rectValues [0]);
		}
		void MezanixDiamondRemoveRect (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveRect (eName);
		}
		void MezanixDiamondSetRect (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetRect (eName, rectValues [0]);
		}
		string [] MezanixDiamondRectNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.rectNames.ToArray ();
		}

		List<Rect> MezanixDiamondGetRectList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return rectListValues [0];

			return mddt.GetRectList (eName, rectListValues [0]);
		}
		void MezanixDiamondRemoveRectList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveRectList (eName);
		}
		void MezanixDiamondSetRectList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetRectList (eName, rectListValues [0]);
		}
		string [] MezanixDiamondRectListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.rectListsNames.ToArray ();
		}


		Material MezanixDiamondGetMaterial (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return materialValues [0];

			return mddt.GetMaterial (eName, materialValues [0]);
		}
		void MezanixDiamondRemoveMaterial (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveMaterial (eName);
		}
		void MezanixDiamondSetMaterial (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetMaterial (eName, materialValues [0]);
		}
		string [] MezanixDiamondMaterialNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.materialNames.ToArray ();
		}

		List<Material> MezanixDiamondGetMaterialList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return materialsListValues [0];

			return mddt.GetMaterialList (eName, materialsListValues [0]);
		}
		void MezanixDiamondRemoveMaterialList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveMaterialList (eName);
		}
		void MezanixDiamondSetMaterialList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetMaterialList (eName, materialsListValues [0]);
		}
		string [] MezanixDiamondMaterialListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.materialListsNames.ToArray ();
		}


		Texture2D MezanixDiamondGetTexture2D (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return texture2DValues [0];

			return mddt.GetTexture2D (eName, texture2DValues [0]);
		}
		void MezanixDiamondRemoveTexture2D (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveTexture2D (eName);
		}
		void MezanixDiamondSetTexture2D (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetTexture2D (eName, texture2DValues [0]);
		}
		string [] MezanixDiamondTexture2DNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.texture2DNames.ToArray ();
		}

		List<Texture2D> MezanixDiamondGetTexture2DList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return texture2DListValues [0];

			return mddt.GetTexture2DList (eName, texture2DListValues [0]);
		}
		void MezanixDiamondRemoveTexture2DList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveTexture2DList (eName);
		}
		void MezanixDiamondSetTexture2DList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetTexture2DList (eName, texture2DListValues [0]);
		}
		string [] MezanixDiamondTexture2DListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.texture2DListsNames.ToArray ();
		}


		Shader MezanixDiamondGetShader (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return shaderValues [0];

			return mddt.GetShader (eName, shaderValues [0]);
		}
		void MezanixDiamondRemoveShader (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveShader (eName);
		}
		void MezanixDiamondSetShader (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetShader (eName, shaderValues [0]);
		}
		string [] MezanixDiamondShaderNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.shaderNames.ToArray ();
		}

		List<Shader> MezanixDiamondGetShaderList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return shaderListValues [0];

			return mddt.GetShaderList (eName, shaderListValues [0]);
		}
		void MezanixDiamondRemoveShaderList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.RemoveShaderList (eName);
		}
		void MezanixDiamondSetShaderList (string eName)
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();

			if (mddt == null)
				return;

			mddt.SetShaderList (eName, shaderListValues [0]);
		}
		string [] MezanixDiamondShaderListNames ()
		{
			ScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = GetmddtDontCareAboutDoIt ();

			if (mddt == null)
				return null;

			return mddt.shaderListsNames.ToArray ();
		}


		void ParallaxScrollingEnhanced ()
		{
			if (gameObjectValues [1] == null)
				return;

			floatValues [0] = Mathf.Clamp (floatValues [0], 0f, 100f);

			float distNorm = floatValues [0] / 100f;

			Vector3 targetToMeFirstGap = vector3Values [1] - vector3Values [0];

			Vector3 scrollPos =
				vector3Values [1] * (1f - distNorm) + 
				(targetToMeFirstGap + gameObjectValues [1].transform.position) * distNorm;

			switch (stringValues [0])
			{
			case "x":
				transform_.position = new Vector3 (scrollPos.x, transform_.position.y, transform_.position.z);
				break;

			case "y":
				transform_.position = new Vector3 (transform_.position.x, scrollPos.y, transform_.position.z);
				break;

			case "z":
				transform_.position = new Vector3 (transform_.position.x, transform_.position.y, scrollPos.z);
				break;

			default:
				transform_.position = new Vector3 (scrollPos.x, transform_.position.y, transform_.position.z);
				break;
			}
		}

		void SpawnOnGrid ()
		{
			int w = Mathf.Abs (intValues [0]);
			int h = Mathf.Abs (intValues [1]);
			int d = Mathf.Abs (intValues [2]);

			Vector3 pos;

			gameObjectValue = new GameObject ("GridOFObjects");

			for (int i = 0; i < w; i++)
			{
				for (int j = 0; j < h; j++)
				{
					for (int k = 0; k < d; k++)
					{
						pos = vector3Values [0] + new Vector3 (
							(float)i * vector3Values [1].x,
							(float)j * vector3Values [1].y,
							(float)k * vector3Values [1].z);

						GameObject go = MonoBehaviour.Instantiate (gameObjectValues [0], pos,
							gameObjectValues [0].transform.rotation, gameObjectValue.transform);

						go.name = gameObjectValues [0].name + "_"
							+ i.ToString () + "_" + j.ToString () + "_" + k.ToString ();
					}
				}
			}
		}

		void KeplerOrbit ()
		{
			intValue++;

			if (intValue > 10)
				intValue = 1;

			Vector3 focus = vector3Values [0];

			Vector3 pseudoNormal = vector3Values [1].normalized;

			Vector3 aAVu = new Vector3 (vector4Values [0].x, vector4Values [0].y, vector4Values [0].z).normalized;

			float aA = floatValues [0];

			float ecc = Mathf.Clamp (vector4Values [0].w, 0f, 0.9f);

			Vector3 bAV = Vector3.Cross (aAVu, pseudoNormal);

			if (bAV.magnitude == 0f)
				Vector3.Cross (new Vector3 (aAVu.x, aAVu.y, aAVu.z + 10f), pseudoNormal);

			Vector3 bAVu = bAV.normalized;


			if (intValue == 0)
			{
				floatValues [2] = 0f;

				keplerRadius = PolarEllipticEquation (floatValues [2], aA, ecc);
			}


			float dT = 0.02f;

			float tetha_dot = floatValues [1] / (100f * (keplerRadius == 0f?1f:keplerRadius) * dT );

			floatValues [2] = tetha_dot == 0f?1f:tetha_dot * dT + floatValues [2];


			keplerRadius = PolarEllipticEquation (floatValues [2], aA, ecc);

			Vector3 dir = (aAVu * Mathf.Cos (floatValues [2]) + bAVu * Mathf.Sin (floatValues [2])).normalized;

			transform_.position = focus + dir * keplerRadius;
		}
		float PolarEllipticEquation (float angle, float a, float ecc)
		{
			float ecc_2 = ecc*ecc;

			float num = a * (1f - ecc_2);

			float den = 1f + ecc * Mathf.Cos (angle);


			return num / den;
		}
		#endregion actions


		/// <summary>
		/// Methods giving the CsScriptWriter class the necessary data to be writen
		/// in the generated scripts
		/// </summary>
		#region script writers
		const string tab4 = "\t\t\t\t";
		const string ret = "\n";
		const string tab3 = "\t\t\t";

		const string identifiedObjectsNotNull = "\t\t\tif (identifiedObjects != null)\n\t\t\t{\n";






		string GetCodeFrom_ComputeClosed (string [] gcfhln, CsLogicNodeWhere csLogicNodeWhere)
		{
			string globalVariables = "";
			string constructor = "";
			string methodsCall = "";
			string methodsDecl = "";

			string r = "";


			globalVariables += gcfhln [0];


			constructor += gcfhln [1];			


			//if (computeTypeString != "get")
			//{
			methodsCall += gcfhln [2];

			methodsDecl += gcfhln [3] + ret;

				//StringTreatment.AfterThisIndex (
				//	GetEnumInputComputeOutput (
				//		computeTypeString,
				//		eico).compute, 1) + ret + "\t\t}" + ret;

				//StringTreatment.DeleteOneTabOfEachNewLine (
				//	gcfhln [4]) + ret + "\t\t}" + ret;
			//}

			switch (csLogicNodeWhere)
			{
			case CsLogicNodeWhere.globalVariables:
				r = globalVariables;
				break;

			case CsLogicNodeWhere.constructor:
				r = constructor;
				break;

			case CsLogicNodeWhere.logicNodeUpdate:
				r = methodsCall;
				break;

			case CsLogicNodeWhere.methods:
				r = methodsDecl;
				break;
			}


			return r;
		}


		string GetCodeFrom_computeOrOperation (CsLogicNodeWhere csLogicNodeWhere, string computeTypeString, 
			EnumInputComputeOutput [] eico, string computeCall)
		{
			string globalVariables = "";
			string constructor = "";
			string methodsCall = "";
			string methodsDecl = "";

			string r = "";



			globalVariables += GetEnumInputComputeOutput (
				computeTypeString,
				eico).globalVariables;


			constructor += GetEnumInputComputeOutput (
				computeTypeString,
				eico).constructor;			


			//if (computeTypeString != "get")
			//{
				methodsCall += computeCall;

				methodsDecl += GetEnumInputComputeOutput (
					computeTypeString,
					eico).methDecl + ret +

					//StringTreatment.AfterThisIndex (
					//	GetEnumInputComputeOutput (
					//		computeTypeString,
					//		eico).compute, 1) + ret + "\t\t}" + ret;

					StringTreatment.DeleteOneTabOfEachNewLine (
						GetEnumInputComputeOutput (
							computeTypeString,
							eico).compute) + ret + "\t\t}" + ret;
			//}

			switch (csLogicNodeWhere)
			{
			case CsLogicNodeWhere.globalVariables:
				r = globalVariables;
				break;

			case CsLogicNodeWhere.constructor:
				r = constructor;
				break;

			case CsLogicNodeWhere.logicNodeUpdate:
				r = methodsCall;
				break;

			case CsLogicNodeWhere.methods:
				r = methodsDecl;
				break;
			}


			return r;
		}


		string GetCodeFrom_TimeOperation ( CsLogicNodeWhere csLogicNodeWhere)
		{
			string timeOperation_globalVariables;

			string timeOperation_constructor;

			string timeOperation_methodsCall;

			string timeOperation_methodsDecl;


			timeOperation_globalVariables = "\t\tpublic enum TimeType\n\t\t{\n\t\t\tdeltaTime,\n\n\t\t\tfixedDeltaTime,\n\n\t\t\tframesSinceLevelLoad,\n\n\t\t\ttimeSinceLevelLoad,\n\n\t\t\tfps, \n\n\t\t\ttictacOnFrames,\n\n\t\t\ttictacOnTime\n\t\t}" + "\n\n";

			timeOperation_globalVariables += "\t\tpublic TimeType timeType;" + "\n\n";

			timeOperation_globalVariables += "\t\tpublic float floatValue;" + "\n\n"; 

			timeOperation_globalVariables += "\t\tpublic float [] floatValues;" + "\n\n"; 

			timeOperation_globalVariables += "\t\tpublic bool boolValue;" + "\n\n"; 


			timeOperation_constructor = "\t\t\ttimeType = TimeType." + timeType.ToString () + ";\n\n";

			timeOperation_constructor += "\t\t\tfloatValue = 0.000001f" + ";\n\n";

			timeOperation_constructor += "\t\t\tfloatValues = new float [2]" + ";\n\n";

			timeOperation_constructor += "\t\t\tfloatValues [0] = " + floatValues [0].ToString () + "f" + ";\n\n";

			timeOperation_constructor += "\t\t\tfloatValues [1] = " + floatValues [1].ToString () + "f" + ";\n\n";

			timeOperation_constructor += "\t\t\tboolValue = false" + ";\n\n";


			timeOperation_methodsCall = "\t\t\tApplyTimeOperation ();" + "\n";

			timeOperation_methodsDecl = "\t\tvoid ApplyTimeOperation ()\n\t\t{\n\t\t\tswitch (timeType)\n\t\t\t{\n\t\t\tcase TimeType.deltaTime:\n\t\t\t\tfloatValue = Time.deltaTime;\n\t\t\t\tbreak;\n\n\t\t\tcase TimeType.fixedDeltaTime:\n\t\t\t\tfloatValue = Time.fixedDeltaTime;\n\t\t\t\tbreak;\n\n\t\t\tcase TimeType.fps:\n\t\t\t\tfloatValue = 1f / Time.deltaTime;\n\t\t\t\tbreak;\n\n\t\t\tcase TimeType.framesSinceLevelLoad:\n\t\t\t\tfloatValue++;\n\n\t\t\t\tif (floatValues [0] != 0f)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = floatValue % floatValues [0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TimeType.timeSinceLevelLoad:\n\t\t\t\tfloatValue += Time.deltaTime;\n\n\t\t\t\tif (floatValues [0] != 0f)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = floatValue % floatValues [0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TimeType.tictacOnTime:\n\t\t\t\tboolValue = false;\n\n\t\t\t\tfloatValue += Time.deltaTime;\n\n\t\t\t\tif (floatValue > floatValues [0])\n\t\t\t\t{\n\t\t\t\t\tboolValue = true;\n\n\t\t\t\t\tfloatValue = 0f;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TimeType.tictacOnFrames:\n\t\t\t\tboolValue = false;\n\n\t\t\t\tfloatValue++;\n\n\t\t\t\tif (floatValue > floatValues [0])\n\t\t\t\t{\n\t\t\t\t\tboolValue = true;\n\n\t\t\t\t\tfloatValue = 0f;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}" + "\n\n";



			string r = "";

			GetCodeFromAssignR (ref r, 
				timeOperation_globalVariables, 
				timeOperation_constructor, timeOperation_methodsCall, timeOperation_methodsDecl,
				csLogicNodeWhere);
			
			return r;
		}

		void GetCodeFromAssignR (ref string r, string gv, string c, string mc, string md, CsLogicNodeWhere cslnw)
		{
			switch (cslnw)
			{
			case CsLogicNodeWhere.globalVariables:
				r = gv;
				break;

			case CsLogicNodeWhere.constructor:
				r = c;
				break;

			case CsLogicNodeWhere.logicNodeUpdate:
				r = mc;
				break;

			case CsLogicNodeWhere.methods:
				r = md;
				break;
			}
		}


		string GetCodeFrom_computeOrOperation_Bool_ex ( CsLogicNodeWhere csLogicNodeWhere)
		{
			string r = "";

			string globalVariables = "";
			string constructor = "";
			string methodsCall = "";
			string methodsDecl = "";


			string computeTypeString = computeBoolType.ToString ();

			EnumInputComputeOutput [] eico = EnumInputComputeOutput_Bool ();


			globalVariables = GetEnumInputComputeOutput (
				computeTypeString,
				eico).globalVariables;


			constructor = GetEnumInputComputeOutput (
				computeTypeString,
				eico).constructor;			


			methodsCall = StringTreatment.AfterThisIndex (
				GetEnumInputComputeOutput (
					computeTypeString,
					eico).compute, 1) + ret;


			methodsDecl = GetEnumInputComputeOutput (
				computeTypeString,
				eico).methDecl;



			switch (csLogicNodeWhere)
			{

			case CsLogicNodeWhere.globalVariables:
				r = globalVariables;
				break;

			case CsLogicNodeWhere.constructor:
				r = constructor;
				break;

			case CsLogicNodeWhere.logicNodeUpdate:
				r = methodsCall;
				break;

			case CsLogicNodeWhere.methods:
				r = methodsDecl;
				break;
			}

			return r;
		}

		//IEnumerator RunAnimationCurve_color ()
		//{
		//	if ( ! boolValues [0])
		//	{
		//		boolValues [0] = true;
		//
		//		float t = 0f;
		//
		//		float rate = 1f / floatValues [2];
		//
		//		while (t < 1f)
		//		{
		//			t += Time.deltaTime * rate;
		//
		//			colorValue = Color.Lerp (colorValues [0], colorValues [1], animationCurve_.Evaluate (t));
		//
		//			yield return 0;
		//		}
		//
		//		boolValues [0] = false;
		//	}
		//	yield return 0;
		//}

		//string GetCodeFrom_computeOrOperation_Color ( CsLogicNodeWhere csLogicNodeWhere)
		//{
		//	string compute_color_globalVariables = "";
		//	string compute_color_constructor = "";
		//	string compute_color_methodsCall = "";
		//	string compute_color_methodsDecl = "";
		//
		//	string r = "";
		//
		//	if (computeColorType != ComputeColorType.Switch &&
		//		computeColorType != ComputeColorType.animationCurve &&
		//		computeColorType != ComputeColorType.animationCurvePickValue)
		//	{
		//		compute_color_globalVariables = "\t\tpublic float floatValue;" + "\n"
		//			+ "\t\tpublic float [] floatValues;" + "\n\n"
		//			+ "\t\tpublic Color colorValue;\n\n" 
		//			+ "\t\tpublic Color[] colorValues;\n\n"
		//			+ ExprWs.Gv.computeColorType;
		//
		//		compute_color_constructor = "\t\t\tfloatValues = new float [2];\n\n"
		//			+ "\t\t\tfloatValues [0] = " + floatValues [0] + "f;\n"
		//			+ "\t\t\tfloatValues [1] = " + floatValues [1] + "f;\n\n"
		//
		//			+ "\t\t\tcolorValues = new Color [2];\n"
		//
		//			+ "\t\t\tcolorValues [0] = new Color ("
		//			+ colorValues [0].r + "f, " 
		//			+ colorValues [0].g + "f, "
		//			+ colorValues [0].b + "f, " 
		//			+ colorValues [0].a + "f);" + "\n"
		//
		//			+ "\t\t\tcolorValues [1] = new Color ("
		//			+ colorValues [1].r + "f, " 
		//			+ colorValues [1].g + "f, "
		//			+ colorValues [1].b + "f, " 
		//			+ colorValues [1].a + "f);" + "\n"
		//
		//			+ "\t\t\tcomputeColorType = ComputeColorType." + computeColorType.ToString () + ";\n\n"
		//			+ "\t\t\tcolorValue = new Color ("
		//			+ colorValue.r + "f, " 
		//			+ colorValue.g + "f, "
		//			+ colorValue.b + "f, " 
		//			+ colorValue.a + "f);" + "\n";
		//
		//
		//
		//		compute_color_methodsCall = "\t\t\tApplyComputeColor ();" + "\n";
		//
		//		compute_color_methodsDecl = "\t\tvoid ApplyComputeColor ()\n\t\t{\n\t\t\tColor c0 = colorValues [0];\n\n\t\t\t//Color c1 = \n\n\t\t\tfloat o = floatValues [0];\n\n\n\t\t\tfloat o1 = floatValues [1];\n\n\t\t\tColor cm1 = new Color (0f, 0f, 0f, 0f);\n\n\t\t\tColor c1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);\n\n\n\t\t\tif (computeColorType == ComputeColorType.randomHsv)\n\t\t\t\tcolorValue = UnityEngine.Random.ColorHSV (\n\t\t\t\t\tColorsArithmetic.RGBToHSV (colorValues [0]) [0], ColorsArithmetic.RGBToHSV (colorValues [1]) [0],\n\t\t\t\t\tColorsArithmetic.RGBToHSV (colorValues [0]) [1], ColorsArithmetic.RGBToHSV (colorValues [1]) [1],\n\t\t\t\t\tColorsArithmetic.RGBToHSV (colorValues [0]) [2], ColorsArithmetic.RGBToHSV (colorValues [1]) [2]);\n\t\t\telse if (computeColorType == ComputeColorType.add)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Add (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.color)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Color_ (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.colorBurn)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorBurn (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.colorDodge)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorDodge (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.darken)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Darken (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.difference)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Difference (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.exclusion)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Exclusion (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.hardLight)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardLight (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.hardMix)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardMix (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.hue)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Hue (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.lighten)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Lighten (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.linearBurn)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearBurn (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.linearDodge)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearDodge (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.linearLight)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearLight (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.luminosity)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Luminosity (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.multiply)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Multiply (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.overlay)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Overlay (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.pinLight)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.PinLight (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.saturation)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Saturation (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.screen)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Screen (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.softLight)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.SoftLight (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.subtract)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Subtract (c0, c1o), c1o, o);\n\t\t\telse if (computeColorType == ComputeColorType.vividLight)\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.VividLight (c0, c1o), c1o, o);\n\n\n\t\t}" + "\n\n";
		//
		//	}
		//	else if (computeColorType == ComputeColorType.Switch)
		//	{
		//		compute_color_globalVariables = ExprWs.Gv.colorAll + ExprWs.Gv.boolValues;
		//
		//		compute_color_constructor = ExprWs.ConstructorExpr.BoolValues (this) + 
		//			ExprWs.ConstructorExpr.ColorValues (this);
		//
		//		compute_color_methodsCall = "\t\t\tApplyComputeColor ();" + "\n";
		//
		//		compute_color_methodsDecl = "\t\tvoid ApplyComputeColor ()\n\t\t{\n" +
		//			"\t\t\tif (boolValues [0] && ! boolValues [1])\n\t\t\t{\n" +
		//			"\t\t\t\tcolorValue = colorValues [0];\n\t\t\t}\n" +
		//			"\t\t\tif (boolValues [1] && ! boolValues [0])\n" +
		//			"\t\t\t{\n\t\t\t\tcolorValue = colorValues [1];\n\t\t\t}\n " +
		//			"\t\t}\n";			
		//	}
		//	else if (computeColorType == ComputeColorType.animationCurve)
		//	{
		//		compute_color_globalVariables = ExprWs.Gv.colorAll + ExprWs.Gv.boolValues + 
		//			ExprWs.Gv.doIt + ExprWs.Gv.floatValues;
		//		
		//		compute_color_constructor = "\t\t\tboolValues [0] = false;\n" + 
		//			ExprWs.ConstructorExpr.ColorValues (this) + ExprWs.ConstructorExpr.FloattValues (this);
		//
		//		compute_color_methodsCall = "\t\t\tApplyComputeColor ();" + "\n";
		//
		//		compute_color_methodsDecl = 
		//			"\t\tIEnumerator RunAnimationCurve_color ()\n\t\t{\n\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tboolValues [0] = true;\n\t\t\n\t\t\t\tfloat t = 0f;\n\t\t\n\t\t\t\tfloat rate = 1f / floatValues [2];\n\t\t\n\t\t\t\twhile (t < 1f)\n\t\t\t\t{\n\t\t\t\t\tt += Time.deltaTime * rate;\n\t\t\n\t\t\t\t\tcolorValue = Color.Lerp (colorValues [0], colorValues [1], animationCurve_.Evaluate (t));\n\t\t\n\t\t\t\t\tyield return 0;\n\t\t\t\t}\n\t\t\n\t\t\t\tboolValues [0] = false;\n\t\t\t}\n\t\t\tyield return 0;\n\t\t}\n\n" +
		//			"\t\tvoid ApplyComputeColor ()\n\t\t{\n\t\t\tif ( ! doIT)\n" +
		//			"\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n" +
		//			"\t\t\t" +  CsScriptWriter.FromLogicNodeToMonoBehaviour (logic.node.graph, logic.node, logic) 
		//			+ "." + "StartCoroutine (RunAnimationCurve_color ());\n\t\t}" ;
		//	}
		//	else if (computeColorType == ComputeColorType.animationCurvePickValue)
		//	{
		//		
		//	}
		//
		//	switch (csLogicNodeWhere)
		//	{
		//	case CsLogicNodeWhere.constructor:
		//		r = compute_color_constructor;
		//		break;
		//
		//	case CsLogicNodeWhere.globalVariables:
		//		r = compute_color_globalVariables;
		//		break;
		//
		//	case CsLogicNodeWhere.logicNodeUpdate:
		//		r = compute_color_methodsCall;
		//		break;
		//
		//	case CsLogicNodeWhere.methods:
		//		r = compute_color_methodsDecl;
		//		break;
		//	}			 
		//
		//	return r;
		//}


		//string GetCodeFrom_computeOrOperation_colorsList ( CsLogicNodeWhere csLogicNodeWhere)
		//{
		//	string computeOrOperation_colorsList_globalVariables;
		//	string computeOrOperation_colorsList_constructor;
		//	string computeOrOperation_colorsList_methodsCall;
		//	string computeOrOperation_colorsList_methodsDecl;
		//
		//	string r = "";
		//
		//	computeOrOperation_colorsList_globalVariables = "\t\tpublic enum ComputeColorListType\n\t\t{\n\t\t\tget,\n\n\t\t\tmergeWith,\n\t\t}\n\t\tComputeColorListType computeColorListType;\n\n\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge (ref List <Color> to, List <Color> from_0, List <Color> from_1)\n\t\t\t{\n\t\t\t\tto = new List<Color> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic int intValue;\n\n\t\tpublic List <Color> colorsListValue;\n\n\t\tpublic List <Color>[] colorsListValues;" + "\n\n";				       
		//
		//
		//	computeOrOperation_colorsList_constructor = "\t\t\t" + "colorsListValue = new List <Color> ();" + "\n";
		//	for (int i = 0; i < colorsListValue.Count; i++)
		//	{
		//		computeOrOperation_colorsList_constructor += "\t\t\t" + "colorsListValue.Add " +
		//			"(" + ColorToScriptWrite (colorsListValue [i]) + ");\n";
		//	}
		//	computeOrOperation_colorsList_constructor += "\t\t\t" + "intValue" + " = " + colorsListValue.Count.ToString () + ";\n";
		//	computeOrOperation_colorsList_constructor += "\t\t\t" + "computeColorListType = ComputeColorListType." + computeColorListType.ToString () + ";\n";
		//	computeOrOperation_colorsList_constructor += "\t\t\tcolorsListValues = new List<Color>[2];\n\t\t\tcolorsListValues [0] = new List<Color> ();\n\t\t\tcolorsListValues [1] = new List<Color> ();" + "\n";
		//
		//	computeOrOperation_colorsList_methodsCall = "\t\t\t" + "intValue = colorsListValue.Count;\n";
		//	computeOrOperation_colorsList_methodsCall += "\t\t\t" + "ApplyComputeColorList ();" + "\n";
		//	computeOrOperation_colorsList_methodsDecl = "\t\tvoid ApplyComputeColorList ()\n\t\t{\n\t\t\tswitch (computeColorListType)\n\t\t\t{\n\t\t\tcase ComputeColorListType.mergeWith:\n\t\t\t\tListOperations.Merge (ref colorsListValue, colorsListValues [0], colorsListValues [1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}" + "\n";
		//
		//
		//
		//	switch (csLogicNodeWhere)
		//	{
		//	case CsLogicNodeWhere.globalVariables:
		//		r = computeOrOperation_colorsList_globalVariables;
		//		break;
		//
		//	case CsLogicNodeWhere.constructor:
		//		r = computeOrOperation_colorsList_constructor;
		//		break;
		//
		//	case CsLogicNodeWhere.logicNodeUpdate:
		//		r = computeOrOperation_colorsList_methodsCall;
		//		break;
		//
		//	case CsLogicNodeWhere.methods:
		//		r = computeOrOperation_colorsList_methodsDecl;
		//		break;
		//	}
		//
		//	return r;
		//}


		string GetCodeFrom_computeOrOperation_Camera ( CsLogicNodeWhere csLogicNodeWhere)
		{
			string globalVariables = "";
			string constructor = "";
			string methodsCall = "";
			string methodsDecl = "";

			string r = "";


			string computeTypeString = computeCameraType.ToString ();

			EnumInputComputeOutput [] eico = EnumInputComputeOutput_Camera ();


			globalVariables += GetEnumInputComputeOutput (
				computeTypeString,
				eico).globalVariables;


			constructor += GetEnumInputComputeOutput (
				computeTypeString,
				eico).constructor;			


			if (computeCameraType == ComputeCameraType.CopySettingsToTheCamera)
			{
				methodsCall += ExprWs.UMcall.getCam_1;
			}

			methodsCall += ExprWs.UMcall.computeCamera;




			methodsDecl += GetEnumInputComputeOutput (
				computeTypeString,
				eico).methDecl + ret +

				//StringTreatment.AfterThisIndex (
				//	GetEnumInputComputeOutput (
				//		computeTypeString,
				//		eico).compute, 1) + ret + "\t\t}" + ret;

				StringTreatment.DeleteOneTabOfEachNewLine (
					GetEnumInputComputeOutput (
						computeTypeString,
						eico).compute) + ret + "\t\t}" + ret;


			switch (csLogicNodeWhere)
			{
			case CsLogicNodeWhere.globalVariables:
				r = globalVariables;
				break;

			case CsLogicNodeWhere.constructor:
				r = constructor;
				break;

			case CsLogicNodeWhere.logicNodeUpdate:
				r = methodsCall;
				break;

			case CsLogicNodeWhere.methods:
				r = methodsDecl;
				break;
			}

			return r;
		}


		public static string RectToScriptWrite (Rect rectToWrite)
		{
			return "new Rect (" + 
				rectToWrite.x.ToString () + "f, " +
				rectToWrite.y.ToString () + "f, " +
				rectToWrite.width.ToString () + "f, " +
				rectToWrite.height.ToString () + "f)";
		}
		public static string Vector4ToScriptWrite (Vector4 v4Towrite)
		{
			return "new Vector4 (" + 
				v4Towrite.x.ToString () + "f, " +
				v4Towrite.y.ToString () + "f, " +
				v4Towrite.z.ToString () + "f, " +
				v4Towrite.w.ToString () + "f)";
		}
		public static string Vector3ToScriptWrite (Vector3 v3Towrite)
		{
			return "new Vector3 (" + 
				v3Towrite.x.ToString () + "f, " +
				v3Towrite.y.ToString () + "f, " +
				v3Towrite.z.ToString () + "f)";
		}
		public static string Vector2ToScriptWrite (Vector2 v2Towrite)
		{
			return "new Vector2 (" + 
				v2Towrite.x.ToString () + "f, " +
				v2Towrite.y.ToString () + "f)";
		}
		public static string ColorToScriptWrite (Color colorToWrite)
		{
			return "new Color (" + 
				colorToWrite.r.ToString () + "f, " +
				colorToWrite.g.ToString () + "f, " +
				colorToWrite.b.ToString () + "f, " +
				colorToWrite.a.ToString () + "f)";
		}



	

		string InOutAdress (bool isAnInput, int index, bool forWriteScript)
		{
			string r = "";

			string inOutAdressSeparatorScript = "_";

			if (isAnInput)
			{
				r = uniqueID + inOutAdressSeparatorScript + inputsIDs [index] + inOutAdressSeparatorScript + inAdressSignature;
			}
			else
			{
				r = uniqueID + inOutAdressSeparatorScript + outputsIDs [index] + inOutAdressSeparatorScript + outAdressSignature;
			}

			if (forWriteScript)
			{
				r = "v_" + r;
			}

			return r;
		}


		public string GoToStateCommand ()
		{
			return StringTreatment.FirstToLower (logic.node.graph.graphNameRacine) + "_" + logic.node.nodeName + "_" + logic.logicName 
				+ "." + StringTreatment.FirstToLower (logic.node.graph.graphNameRacine) + "_" + logic.node.nodeName
				+ "." + "To" + currentStateNames.ToString () + " ();\n";
		}


		class EnumInputComputeOutput
		{
			public string enumName = "";

			public string input = "";

			public string output = "";

			public string compute = "";


			public string globalVariables = "";

			public string constructor = "";

			public string methDecl = "";


			public string [] embededDocumentation = null;


			public string documentationUrl_0 = "";

			public string documentationUrl_1 = "";


			public EnumInputComputeOutput (string setEnumName,
				string setInput, string setCompute, string setOutput,
				string setGlobalVariables, string setConstructor, 
				string setMethDecl, string [] setEmbededDecumentation)
			{
				enumName = setEnumName;

				input = setInput;

				output = setOutput;

				compute = setCompute;


				globalVariables = setGlobalVariables;

				constructor = setConstructor;

				methDecl = setMethDecl;


				embededDocumentation = setEmbededDecumentation;


				documentationUrl_0 = "";

				documentationUrl_1 = "";
			}

			public EnumInputComputeOutput (string setEnumName,
				string setInput, string setCompute, string setOutput,
				string setGlobalVariables, string setConstructor, 
				string setMethDecl, string [] setEmbededDecumentation,
				string setDocumentationUrl_0, string setDocumentationUrl_1)
			{
				enumName = setEnumName;

				input = setInput;

				output = setOutput;

				compute = setCompute;


				globalVariables = setGlobalVariables;

				constructor = setConstructor;

				methDecl = setMethDecl;


				embededDocumentation = setEmbededDecumentation;


				documentationUrl_0 = setDocumentationUrl_0;

				documentationUrl_1 = setDocumentationUrl_1;
			}
		}

		EnumInputComputeOutput GetEnumInputComputeOutput (
			string enumName, EnumInputComputeOutput [] getFromThis)
		{
			EnumInputComputeOutput r = null;

			for (int i = 0; i < getFromThis.Length; i++)
			{
				if (getFromThis [i].enumName == enumName)
				{
					r = getFromThis [i];

					break;
				}
			}


			return r;
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_UiButton ()
		{			
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeUiButtonType.setEnabled.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "uiButton.enabled = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiButton_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiButtonCheck_computeUiButton,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiButtonType.getIsActiveAndEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiButton.isActiveAndEnabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiButton_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiButtonCheck_computeUiButton,
					new string []
					{
						"Has the Behaviour had enabled called.",
						"True while the behaviour is enabled, false when disabled.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-isActiveAndEnabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiButtonType.getEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiButton.enabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiButton_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiButtonCheck_computeUiButton,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiButtonType.onClick.ToString (),
					"\t\t\t\t" + "DrawLogicNodeLabel (actionOnHowManyFrames);\n" +
					InOutWs.InWs._float + ret + 
					"\t\t\t\t" + "floatValues [0] = Mathf.Max (0f, floatValues [0]);",
					"\t\t\t\tuiButton.onClick.AddListener (TaskOnClick);\n\n" +
					InOutWs.CodeWs.downTimeCounterCode,
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiButton_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue + ExprWs.Gv.floatValues + ExprWs.Gv.downTimeCounter,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this) +
					ExprWs.ConstructorExpr.downTimeCounter,
					ExprWs.UMDecl.taskOnClick +
					ExprWs.UMDecl.GameObjectCheck_uiButtonCheck_computeUiButton,
					new string []
					{
						"",
						"UnityEvent that is triggered when the button is pressed.",
						"Note: Triggered on MouseUp after MouseDown on the same object.",
						"Every logicNode contains a function triggered when you click the button,",
						"this function put the bool output of your logicNode to true.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Button-onClick.html",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_UiImage ()
		{			
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeUiImageType.setPreserveAspect.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "uiImage.preserveAspect = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"Whether this image should preserve its Sprite aspect ratio.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-preserveAspect.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.SetNativeSize.ToString (),
					"",
					"\t\t\t\t" + "uiImage.SetNativeSize ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Adjusts the image size to make it pixel-perfect.",
						"This means setting the Images RectTransform.sizeDelta to be equal to the Sprite dimensions.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image.SetNativeSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.setMaterial.ToString (),
					InOutWs.InWs._material,
					"\t\t\t\t" + "uiImage.material = materialValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.materialValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID, Enums.materialValues_0_ID}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"The Material set by the user.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-material.html",
					""),


				new EnumInputComputeOutput (
					ComputeUiImageType.setFillMethod.ToString (),
					"fillMethod = (UnityEngine.UI.Image.FillMethod)DrawEnum (fillMethod, \"Fill Method\", Skins.logicNodeLabel);",
					"\t\t\t\t" + "uiImage.fillMethod = fillMethod;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.fillMethod,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.fillMethod (this),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"What type of fill method to use.",
						"This willl only have any effect if the Image.type is set to Image.Type.Filled.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillMethod.html",
					""),	

				new EnumInputComputeOutput (
					ComputeUiImageType.setFillClockwise.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "uiImage.fillClockwise = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Whether the Image should be filled clockwise (true) or counter-clockwise (false).",
						"This willl only have any effect if the Image.type is set to Image.Type.Filled and Image.fillMethod is",
						"set to any of the Radial methods.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillClockwise.html",
					""),									

				new EnumInputComputeOutput (
					ComputeUiImageType.setFillCenter.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "uiImage.fillCenter = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Whether or not to render the center of a Tiled or Sliced image.",
						"This will only have any effect if the Image.sprite has borders.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillCenter.html",
					""),


				new EnumInputComputeOutput (
					ComputeUiImageType.setFillAmount.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "uiImage.fillAmount = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Amount of the Image shown when the Image.type is set to Image.Type.Filled.",
						"0-1 range with 0 being nothing shown, and 1 being the full Image.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillAmount.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.setEnabled.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "uiImage.enabled = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.setColor.ToString (),
					InOutWs.InWs._color,
					"\t\t\t\t" + "uiImage.color = colorValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ColorValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Base color of the Graphic.",
						"The builtin UI Components use this as their vertex color.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-color.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getSprite.ToString (),
					"\t\t\t\t" + "DrawLogicNodeLabel (\"Check true read/writeEnabled for the sprite\");",
					"\t\t\t\t" + "texture2DValue = SpriteToTexture2D (uiImage.sprite);\n" + 
					"\t\t\t\t" + "texture2DValue.name = uiImage.sprite.name;",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.texture2DValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.spriteToTexture2D + 
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"The sprite that is used to render this image.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-sprite.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getOverrideSprite.ToString (),
					"\t\t\t\t" + "DrawLogicNodeLabel (\"Check true read/writeEnabled for the sprite\");",
					"\t\t\t\t" + "texture2DValue = SpriteToTexture2D (uiImage.overrideSprite);\n" +
					"\t\t\t\t" + "texture2DValue.name = uiImage.overrideSprite.name;",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.texture2DValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.spriteToTexture2D + 
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"Set an override sprite to be used for rendering.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-sprite.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getPreserveAspect.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiImage.preserveAspect;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"Whether this image should preserve its Sprite aspect ratio.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-preserveAspect.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getPixelsPerUnit.ToString (),
					"",
					"\t\t\t\t" + "floatValue = uiImage.pixelsPerUnit;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"The number of pixels in the sprite that correspond to one unit in world space. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Sprite-pixelsPerUnit.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.GetPixelAdjustedRect.ToString (),
					"",
					"\t\t\t\t" + "rectValue = uiImage.GetPixelAdjustedRect ();",
					InOutWs.OutWs.rect_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.rectValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"Returns a pixel perfect Rect closest to the Graphic RectTransform.",
						"Note: This is only accurate if the Graphic root Canvas is in Screen Space.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic.GetPixelAdjustedRect.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getMaterialForRendering.ToString (),
					"",
					"\t\t\t\t" + "materialValue = uiImage.materialForRendering;",
					InOutWs.OutWs.material_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.materialValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"The material that will be sent for Rendering (Read only).",
						"This is the material that actually gets sent to the CanvasRenderer. By default it's the same as",
						"Graphic.material. When extending Graphic you can override this to send a different material",
						"to the CanvasRenderer than the one set by Graphic.material. This is usefull if you want to modify the user",
						"set material in a non destructive manner.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-materialForRendering.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getMaterial.ToString (),
					"",
					"\t\t\t\t" + "materialValue = uiImage.material;",
					InOutWs.OutWs.material_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.materialValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"The Material set by the user.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-material.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getMainTexture.ToString (),
					"",
					"\t\t\t\t" + "texture2DValue = (Texture2D)uiImage.mainTexture;",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.texture2DValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"The image's texture. (ReadOnly).",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-mainTexture.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getHasBorder.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiImage.hasBorder;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"True if the sprite used has borders.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-hasBorder.html",
					""),



				new EnumInputComputeOutput (
					ComputeUiImageType.getFillClockwise.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiImage.fillClockwise;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Whether the Image should be filled clockwise (true) or counter-clockwise (false).",
						"This willl only have any effect if the Image.type is set to Image.Type.Filled and Image.fillMethod is",
						"set to any of the Radial methods.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillClockwise.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getFillCenter.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiImage.fillCenter;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Whether or not to render the center of a Tiled or Sliced image.",
						"This will only have any effect if the Image.sprite has borders.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillCenter.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getFillAmount.ToString (),
					"",
					"\t\t\t\t" + "floatValue = uiImage.fillAmount;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Amount of the Image shown when the Image.type is set to Image.Type.Filled.",
						"0-1 range with 0 being nothing shown, and 1 being the full Image.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Image-fillAmount.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiImage.enabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getDepth.ToString (),
					"",
					"\t\t\t\t" + "intValue = uiImage.depth;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Absolute depth of the graphic in the hierarchy, used by rendering and events.",
						"The depth is relative to the first root canvas. Here is an example hierarchy and the corresponding graphics",
						"depth: Canvas Graphic <- 1 Graphic <- 2 Nested Canvas Graphic <- 3 Graphic <- 4 Graphic <- 5",
						"This value is used to determine draw and event ordering.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-depth.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getDefaultMaterial.ToString (),
					"",
					"\t\t\t\t" + "materialValue = uiImage.defaultMaterial;",
					InOutWs.OutWs.material_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.materialValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"",
						"Returns the default material for the graphic.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-defaultMaterial.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiImageType.getColor.ToString (),
					"",
					"\t\t\t\t" + "colorValue = uiImage.color;",
					InOutWs.OutWs.color_,
					ExprWs.Gv.uiImage_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiImageCheck_computeUiImage,
					new string []
					{
						"Base color of the Graphic.",
						"The builtin UI Components use this as their vertex color.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-color.html",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_UnityText ()
		{			
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeUnityTextType.setText.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\t" + "unityText.text = stringValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.stringValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"The string value this text will display.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Text-text.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.setMaterial.ToString (),
					InOutWs.InWs._material,
					"\t\t\t\t" + "unityText.material = materialValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.materialValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ConstructorGetIdentifiedObject (new string [] {Enums.materialValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"The Material set by the user.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-material.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.setLineSpacing.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "unityText.lineSpacing = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"Line spacing, specified as a factor of font line height. A value of 1 will produce normal line spacing.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Text-lineSpacing.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.setFontSize.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\t" + "unityText.fontSize = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"The size that the Font should render at.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Text-fontSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.setEnabled.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "unityText.enabled = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.setColor.ToString (),
					InOutWs.InWs._color,
					"\t\t\t\t" + "unityText.color = colorValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ColorValues (this),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"Base color of the Graphic.",
						"The builtin UI Components use this as their vertex color.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-color.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.setAlignment.ToString (),
					"\t\t\t\t" + "textAnchor = (TextAnchor)DrawEnum (textAnchor, \"Text Anchor\", Skins.logicNodeLabel);",
					"\t\t\t\t" + "unityText.alignment = textAnchor;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.textAnchor,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.TextAnchor (this),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"The positioning of the text reliative to its RectTransform.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Text-alignment.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getText.ToString (),
					"",
					"\t\t\t\t" + "stringValue = unityText.text;",
					InOutWs.OutWs.string_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"The string value this text will display.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Text-text.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getPixelsPerUnit.ToString (),
					"",
					"\t\t\t\t" + "floatValue = unityText.pixelsPerUnit;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"(Read Only) Provides information about how fonts are scale to the screen.",
						"For dynamic fonts, the value is equivalent to the scale factor of the canvas. For non-dynamic fonts,",
						"the value is calculated from the requested text size and the size from the font.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Text-pixelsPerUnit.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.GetPixelAdjustedRect.ToString (),
					"",
					"\t\t\t\t" + "rectValue = unityText.GetPixelAdjustedRect ();",
					InOutWs.OutWs.rect_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.rectValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"Returns a pixel perfect Rect closest to the Graphic RectTransform.",
						"Note: This is only accurate if the Graphic root Canvas is in Screen Space.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic.GetPixelAdjustedRect.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getMaterialForRendering.ToString (),
					"",
					"\t\t\t\t" + "materialValue = unityText.materialForRendering;",
					InOutWs.OutWs.material_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.materialValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"The material that will be sent for Rendering (Read only).",
						"This is the material that actually gets sent to the CanvasRenderer. By default it's the same as",
						"Graphic.material. When extending Graphic you can override this to send a different material",
						"to the CanvasRenderer than the one set by Graphic.material. This is usefull if you want to modify the user",
						"set material in a non destructive manner.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-materialForRendering.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getMaterial.ToString (),
					"",
					"\t\t\t\t" + "materialValue = unityText.material;",
					InOutWs.OutWs.material_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.materialValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"The Material set by the user.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-material.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getMainTexture.ToString (),
					"",
					"\t\t\t\t" + "texture2DValue = (Texture2D)unityText.mainTexture;",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.texture2DValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"The Texture that comes from the Font.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Text-mainTexture.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getLineSpacing.ToString (),
					"",
					"\t\t\t\t" + "floatValue = unityText.lineSpacing;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"Line spacing, specified as a factor of font line height. A value of 1 will produce normal line spacing.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Text-lineSpacing.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getFontSize.ToString (),
					"",
					"\t\t\t\t" + "intValue = unityText.fontSize;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"",
						"The size that the Font should render at.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Text-fontSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = unityText.enabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getDepth.ToString (),
					"",
					"\t\t\t\t" + "intValue = unityText.depth;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"Absolute depth of the graphic in the hierarchy, used by rendering and events.",
						"The depth is relative to the first root canvas. Here is an example hierarchy and the corresponding graphics",
						"depth: Canvas Graphic <- 1 Graphic <- 2 Nested Canvas Graphic <- 3 Graphic <- 4 Graphic <- 5",
						"This value is used to determine draw and event ordering.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-depth.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityTextType.getColor.ToString (),
					"",
					"\t\t\t\t" + "colorValue = unityText.color;",
					InOutWs.OutWs.color_,
					ExprWs.Gv.unityText_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_unityTextCheck_computeUnityText,
					new string []
					{
						"Base color of the Graphic.",
						"The builtin UI Components use this as their vertex color.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Graphic-color.html",
					""),
			};
		}



		EnumInputComputeOutput[] EnumInputComputeOutput_GameObjectList ()
		{
			
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeGameObjectListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondGameObjectListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._gameObjectList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "gameObjectsListValue = MezanixDiamondGetGameObjectList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveGameObjectList (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.GameObjectList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + 
					ExprWs.Gv.gameObjectListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.gameObjectListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetGameObjectList + 
					ExprWs.UMDecl.MezanixDiamondRemoveGameObjectList +
					ExprWs.UMDecl.computeGameObjectList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._gameObjectList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetGameObjectList (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues +
					ExprWs.Gv.gameObjectListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ExprWs.ConstructorExpr.gameObjectListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetGameObjectList + ExprWs.UMDecl.computeGameObjectList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeGameObjectListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_gameobject_DrawInput,
					"\t\t\t\tInventoryListAction_gameobject_Compute ();",
					"\t\t\t\tInventoryListAction_gameobject_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.gameObjectListValue + ExprWs.Gv.gameObjectAll +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.gameObjectListValues,
					ConstructorGetIdentifiedObject (
						VariableStruct.list, gameObjectsListValue.Count, Enums.gameObjectsList_ID) +
					ConstructorGetIdentifiedObject (new string [] {
						Enums.gameObjectValues_0_ID,
						Enums.gameObjectValue_ID}) + 
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) + ExprWs.ConstructorExpr.BoolValues (this) +
					ExprWs.ConstructorExpr.gameObjectListValues (this),
					ExprWs.UMDecl.inventoryListAction_gameobject_compute + 
					ExprWs.UMDecl.computeGameObjectList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"In the game object list case, The 'MakeObject Of Following Index Ready',",
						"can be used for example to let a player switch between different weapons ",
						"and activate one of them",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeGameObjectListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_gameObjectList_DrawInputs ();",
					"\t\t\t\tForGet_gameObjectList_Compute ();",
					"\t\t\t\tForGet_gameObjectList_DrawOutputs ();",
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.gameObjectListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (VariableStruct.list, 
						gameObjectsListValue.Count, Enums.gameObjectsList_ID) +
					ExprWs.ConstructorExpr.gameObjectListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_gameObjectList_Compute +
					ExprWs.UMDecl.computeGameObjectList_NoDoIT,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectListType.MergeWith.ToString (),
					InOutWs.InWs._gameObjectList_and_1,
					"\t\t\t\tListOperations.Merge (ref gameObjectsListValue, gameObjectsListValues [0], gameObjectsListValues [1]);\n" +
					"\t\t\t\tintValue = gameObjectsListValue.Count;",
					InOutWs.OutWs.GameObjectList_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeGameObject +
					ExprWs.Gv.gameObjectListValue + ExprWs.Gv.gameObjectListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.gameObjectListValues (this) +
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeGameObjectList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}

		EnumInputComputeOutput[] EnumInputComputeOutput_ShaderList ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeShaderListType.listenToTransferredData.ToString (),
					"\t\t\t\t" + "DrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondShaderListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._shaderList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "shaderListValue = MezanixDiamondGetShaderList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveShaderList (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.ShaderList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.shaderListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ExprWs.ConstructorExpr.shaderListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetShaderList + 
					ExprWs.UMDecl.MezanixDiamondRemoveShaderList +
					ExprWs.UMDecl.computeShaderList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeShaderListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._shaderList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetShaderList (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.shaderListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ExprWs.ConstructorExpr.shaderListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetShaderList + ExprWs.UMDecl.computeShaderList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeShaderListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_shader_DrawInput,
					"\t\t\t\tInventoryListAction_shader_Compute ();",
					"\t\t\t\tInventoryListAction_shader_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.shaderListValue + ExprWs.Gv.shaderAll +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.shaderListValues,
					ConstructorGetIdentifiedObject (
						VariableStruct.list, shaderListValue.Count, Enums.shaderList_ID) +
					ConstructorGetIdentifiedObject (new string [] {
						Enums.shaderValues_0_ID,
						Enums.shaderValue_ID}) + 
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) + ExprWs.ConstructorExpr.BoolValues (this) +
					ExprWs.ConstructorExpr.shaderListValues (this),
					ExprWs.UMDecl.inventoryListAction_shader_compute + 
					ExprWs.UMDecl.computeShaderList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"In the game object list case, The 'MakeObject Of Following Index Ready',",
						"can be used for example to let a player switch between different weapons ",
						"and activate one of them",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeShaderListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_shaderList_DrawInputs ();",
					"\t\t\t\tForGet_shaderList_Compute ();",
					"\t\t\t\tForGet_shaderList_DrawOutputs ();",
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.shaderListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (VariableStruct.list, 
						shaderListValue.Count, Enums.shaderList_ID) +
					ExprWs.ConstructorExpr.shaderListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_shaderList_Compute +
					ExprWs.UMDecl.computeShaderList_NoDoIT,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeShaderListType.MergeWith.ToString (),
					InOutWs.InWs._shaderList_and_1,
					"\t\t\t\tListOperations.Merge (ref shaderListValue, shaderListValues [0], shaderListValues [1]);\n\t",
					InOutWs.OutWs.ShaderList_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeShader +
					ExprWs.Gv.shaderListValue + ExprWs.Gv.shaderListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.shaderListValues (this) +
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeShaderList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}

		EnumInputComputeOutput[] EnumInputComputeOutput_Texture2DList ()
		{

			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeTexture2DListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondTexture2DListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._texture2DList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "texture2DListValue = MezanixDiamondGetTexture2DList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveTexture2DList (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.texture2DList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.texture2DListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ExprWs.ConstructorExpr.Textur2DListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetTexture2DList + 
					ExprWs.UMDecl.MezanixDiamondRemoveTexture2DList +
					ExprWs.UMDecl.computeTexture2DList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._texture2DList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetTexture2DList (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.texture2DListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ExprWs.ConstructorExpr.Textur2DListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetTexture2DList + ExprWs.UMDecl.computeTexture2DList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeTexture2DListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_texture2D_DrawInput,
					"\t\t\t\tInventoryListAction_texture2D_Compute ();",
					"\t\t\t\tInventoryListAction_texture2D_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DListValue + ExprWs.Gv.texture2DAll +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.texture2DListValues,
					ConstructorGetIdentifiedObject (
						VariableStruct.list, texture2DListValue.Count, Enums.texture2DList_ID) +
					ConstructorGetIdentifiedObject (new string [] {
						Enums.texture2DValues_0_ID,
						Enums.texture2DValue_ID}) + 
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) + ExprWs.ConstructorExpr.BoolValues (this) +
					ExprWs.ConstructorExpr.Textur2DListValues (this),
					ExprWs.UMDecl.inventoryListAction_texture2D_compute + 
					ExprWs.UMDecl.computeTexture2DList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"In the game object list case, The 'MakeObject Of Following Index Ready',",
						"can be used for example to let a player switch between different weapons ",
						"and activate one of them",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeTexture2DListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_texture2DList_DrawInputs ();",
					"\t\t\t\tForGet_texture2DList_Compute ();",
					"\t\t\t\tForGet_texture2DList_DrawOutputs ();",
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (VariableStruct.list, 
						texture2DListValue.Count, Enums.texture2DList_ID) +
					ExprWs.ConstructorExpr.Textur2DListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_texture2DList_Compute +
					ExprWs.UMDecl.computeTexture2DList_NoDoIT,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DListType.MergeWith.ToString (),
					InOutWs.InWs._texture2DList_and_1,
					"\t\t\t\tListOperations.Merge (ref texture2DListValue, texture2DListValues [0], texture2DListValues [1]);\n\t",
					InOutWs.OutWs.texture2DList_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeTexture2D +
					ExprWs.Gv.texture2DListValue + ExprWs.Gv.texture2DListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.Textur2DListValues (this) +
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeTexture2DList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_MaterialList ()
		{

			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeMaterialListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondMaterialListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._materialList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "materialsListValue = MezanixDiamondGetMaterialList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveMaterialList (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.materialList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.materialListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ExprWs.ConstructorExpr.MaterialListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetMaterialList + 
					ExprWs.UMDecl.MezanixDiamondRemoveMaterialList +
					ExprWs.UMDecl.computeMaterialList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeMaterialListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._materialList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetMaterialList (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.materialListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ExprWs.ConstructorExpr.MaterialListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetMaterialList + ExprWs.UMDecl.computeMaterialList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeMaterialListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_material_DrawInput,
					"\t\t\t\tInventoryListAction_material_Compute ();",
					"\t\t\t\tInventoryListAction_material_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.materialListValue + ExprWs.Gv.materialAll +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.materialListValues,
					ConstructorGetIdentifiedObject (
						VariableStruct.list, materialsListValue.Count, Enums.materialList_ID) +
					ConstructorGetIdentifiedObject (new string [] {
						Enums.materialValues_0_ID,
						Enums.materialValue_ID}) + 
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) + ExprWs.ConstructorExpr.BoolValues (this) +
					ExprWs.ConstructorExpr.MaterialListValues (this),
					ExprWs.UMDecl.inventoryListAction_material_compute + 
					ExprWs.UMDecl.computeMaterialList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"In the game object list case, The 'MakeObject Of Following Index Ready',",
						"can be used for example to let a player switch between different weapons ",
						"and activate one of them",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeMaterialListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_materialList_DrawInputs ();",
					"\t\t\t\tForGet_materialList_Compute ();",
					"\t\t\t\tForGet_materialList_DrawOutputs ();",
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.materialListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (VariableStruct.list, 
						materialsListValue.Count, Enums.materialList_ID) +
					ExprWs.ConstructorExpr.MaterialListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_materialList_Compute +
					ExprWs.UMDecl.computeMaterialList_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeMaterialListType.MergeWith.ToString (),
					InOutWs.InWs._materialList_and_1,
					"\t\t\t\tListOperations.Merge (ref materialsListValue, materialsListValues [0], materialsListValues [1]);\n\t",
					InOutWs.OutWs.materialList_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeMaterial +
					ExprWs.Gv.materialListValue + ExprWs.Gv.materialListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.MaterialListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeMaterialList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_RectList ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeRectListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondRectListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._rectList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "rectListValue = MezanixDiamondGetRectList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveRectList (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.rectList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.rectListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ExprWs.ConstructorExpr.RectListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetRectList + 
					ExprWs.UMDecl.MezanixDiamondRemoveRectList +
					ExprWs.UMDecl.computeRectList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeRectListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._rectList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetRectList (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.rectListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ExprWs.ConstructorExpr.RectListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetRectList + ExprWs.UMDecl.computeRectList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeRectListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_rect_DrawInput,
					"\t\t\t\tInventoryListAction_rect_Compute ();",
					"\t\t\t\tInventoryListAction_rect_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.rectListAll + ExprWs.Gv.rectAll +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.RectListValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.BoolValue (this) +
					ExprWs.ConstructorExpr.RectValues (this) +
					ExprWs.ConstructorExpr.RectListValues (this),
					ExprWs.UMDecl.inventoryListAction_rect_compute + 
					ExprWs.UMDecl.computeRectList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeRectListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_rectList_DrawInputs ();",
					"\t\t\t\tForGet_RectList_Compute ();",
					"\t\t\t\tForGet_rectList_DrawOutputs ();",
					ExprWs.Gv.rectListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.RectListValue (this) +
					ExprWs.ConstructorExpr.RectListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_RectList_Compute +
					ExprWs.UMDecl.computeRectList_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeRectListType.MergeWith.ToString (),
					InOutWs.InWs._rectList_and_1,
					"\t\t\t\tListOperations.Merge (ref rectListValue, rectListValues [0], rectListValues [1]);\n\t",
					InOutWs.OutWs.rectList_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeRect +
					ExprWs.Gv.rectListValue + ExprWs.Gv.rectListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.RectListValue (this) + ExprWs.ConstructorExpr.RectListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeRectList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_Vector4List ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeVector4ListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondVector4ListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._vector4List + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "vector4ListValue = MezanixDiamondGetVector4List (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveVector4List (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.vector4List_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.vector4ListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ExprWs.ConstructorExpr.Vector4ListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetVector4List + 
					ExprWs.UMDecl.MezanixDiamondRemoveVector4List +
					ExprWs.UMDecl.computeVector4List,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector4ListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._vector4List + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetVector4List (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.vector4ListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ExprWs.ConstructorExpr.Vector4ListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetVector4List + ExprWs.UMDecl.computeVector4List,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				

				new EnumInputComputeOutput (
					ComputeVector4ListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_vector4_DrawInput,
					"\t\t\t\tInventoryListAction_vector4_Compute ();",
					"\t\t\t\tInventoryListAction_vector4_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.vector4ListAll + ExprWs.Gv.vector4All +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.Vector4ListValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.BoolValue (this) +
					ExprWs.ConstructorExpr.Vector4Values (this) +
					ExprWs.ConstructorExpr.Vector4ListValues (this),
					ExprWs.UMDecl.inventoryListAction_vector4_compute + 
					ExprWs.UMDecl.computeVector4List,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector4ListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_vector4List_DrawInputs ();",
					"\t\t\t\tForGet_vector4List_Compute ();",
					"\t\t\t\tForGet_vector4List_DrawOutputs ();",
					ExprWs.Gv.vector4ListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.Vector4ListValue (this) +
					ExprWs.ConstructorExpr.Vector4ListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_vector4List_Compute +
					ExprWs.UMDecl.computeVector4List_NoDoIT,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector4ListType.MergeWith.ToString (),
					InOutWs.InWs._vector4List_and_1,
					"\t\t\t\tListOperations.Merge (ref vector4ListValue, vector4ListValues [0], vector4ListValues [1]);\n\t",
					InOutWs.OutWs.vector4List_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeVector4 +
					ExprWs.Gv.vector4ListValue + ExprWs.Gv.vector4ListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.Vector4ListValue (this) + ExprWs.ConstructorExpr.Vector4ListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeVector4List,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}



		EnumInputComputeOutput [] EnumInputComputeOutput_Vector3List ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeVector3ListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondVector3ListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._vector3List + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "vector3ListValue = MezanixDiamondGetVector3List (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveVector3List (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.vector3List_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.vector3ListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ExprWs.ConstructorExpr.Vector3ListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetVector3List + 
					ExprWs.UMDecl.MezanixDiamondRemoveVector3List +
					ExprWs.UMDecl.computeVector3List,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3ListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._vector3List + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetVector3List (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.vector3ListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ExprWs.ConstructorExpr.Vector3ListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetVector3List + ExprWs.UMDecl.computeVector3List,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3ListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_vector3_DrawInput,
					"\t\t\t\tInventoryListAction_vector3_Compute ();",
					"\t\t\t\tInventoryListAction_vector3_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.vector3ListAll + ExprWs.Gv.vector3All +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.Vector3ListValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.BoolValue (this) +
					ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.Vector3ListValues (this),
					ExprWs.UMDecl.inventoryListAction_vector3_compute + 
					ExprWs.UMDecl.computeVector3List,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector3ListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_vector3List_DrawInputs ();",
					"\t\t\t\tForGet_vector3List_Compute ();",
					"\t\t\t\tForGet_vector3List_DrawOutputs ();",
					ExprWs.Gv.vector3ListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.Vector3ListValue (this) +
					ExprWs.ConstructorExpr.Vector3ListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_vector3List_Compute +
					ExprWs.UMDecl.computeVector3List_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3ListType.MergeWith.ToString (),
					InOutWs.InWs._vector3List_and_1,
					"\t\t\t\tListOperations.Merge (ref vector3ListValue, vector3ListValues [0], vector3ListValues [1]);\n\t",
					InOutWs.OutWs.vector3List_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeVector3 +
					ExprWs.Gv.vector3ListValue + ExprWs.Gv.vector3ListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.Vector3ListValue (this) + ExprWs.ConstructorExpr.Vector3ListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeVector3List,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_ColorList ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeColorListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondColorListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._colorList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "colorsListValue = MezanixDiamondGetColorList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveColorList (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.colorList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.colorListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.ColorListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetColorList + ExprWs.UMDecl.MezanixDiamondRemoveColorList +
					ExprWs.UMDecl.computeColorList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._colorList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetColorList (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.colorListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.ColorListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetColorList + ExprWs.UMDecl.computeColorList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeColorListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_color_DrawInput,
					"\t\t\t\tInventoryListAction_color_Compute ();",
					"\t\t\t\tInventoryListAction_color_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.colorListAll + ExprWs.Gv.colorAll +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.ColorListValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.BoolValue (this) +
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorListValues (this),
					ExprWs.UMDecl.inventoryListAction_color_compute + 
					ExprWs.UMDecl.computeColorList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeColorListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_colorList_DrawInputs ();",
					"\t\t\t\tForGet_colorList_Compute ();",
					"\t\t\t\tForGet_colorList_DrawOutputs ();",
					ExprWs.Gv.colorListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.ColorListValue (this) +
					ExprWs.ConstructorExpr.ColorListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_colorList_Compute +
					ExprWs.UMDecl.computeColorList_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeColorListType.mergeWith.ToString (),
					InOutWs.InWs._colorList_and_1,
					"\t\t\t\tListOperations.Merge (ref colorsListValue, colorsListValues [0], colorsListValues [1]);\n" +
					"\t\t\t\tintValue = colorsListValue.Count;\n",
					InOutWs.OutWs.colorList_,
					ExprWs.Gv.doIt +
					ExprWs.Gv.ListOperationsClass_MergeColor +
					ExprWs.Gv.colorListValue + ExprWs.Gv.colorListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.ColorListValue (this) + 
					ExprWs.ConstructorExpr.ColorListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeColorList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_Vector2List ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeVector2ListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondVector2ListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._vector2List + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "vector2ListValue = MezanixDiamondGetVector2List (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveVector2List (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.vector2List_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.vector2ListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.Vector2ListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetVector2List + 
					ExprWs.UMDecl.MezanixDiamondRemoveVector2List +
					ExprWs.UMDecl.computeVector2List,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2ListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._vector2List + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetVector2List (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.vector2ListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.Vector2ListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetVector2List + ExprWs.UMDecl.computeVector2List,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector2ListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_vector2_DrawInput,
					"\t\t\t\tInventoryListAction_vector2_Compute ();",
					"\t\t\t\tInventoryListAction_vector2_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.vector2ListAll + ExprWs.Gv.vector2All +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.Vector2ListValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.BoolValue (this) +
					ExprWs.ConstructorExpr.Vector2Values (this) +
					ExprWs.ConstructorExpr.Vector2ListValues (this),
					ExprWs.UMDecl.inventoryListAction_vector2_compute + 
					ExprWs.UMDecl.computeVector2List,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector2ListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_vector2List_DrawInputs ();",
					"\t\t\t\tForGet_vector2List_Compute ();",
					"\t\t\t\tForGet_vector2List_DrawOutputs ();",
					ExprWs.Gv.vector2ListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.Vector2ListValue (this) +
					ExprWs.ConstructorExpr.Vector2ListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_vector2List_Compute +
					ExprWs.UMDecl.computeVector2List_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector2ListType.MergeWith.ToString (),
					InOutWs.InWs._vector2List_and_1,
					"\t\t\t\tListOperations.Merge (ref vector2ListValue, vector2ListValues [0], vector2ListValues [1]);\n",
					InOutWs.OutWs.vector2List_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeVector2 +
					ExprWs.Gv.vector2ListValue + ExprWs.Gv.vector2ListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.Vector2ListValue (this) + ExprWs.ConstructorExpr.Vector2ListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeVector2List,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_StringList ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeStringsListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondStringListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._stringList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "stringsListValue = MezanixDiamondGetStringList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveStringList(stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.stringList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.stringListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.StringListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetStringList + ExprWs.UMDecl.MezanixDiamondRemoveStringList +
					ExprWs.UMDecl.computeStringList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeStringsListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._stringList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetStringList (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.stringListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetStringList + ExprWs.UMDecl.computeStringList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				


				new EnumInputComputeOutput (
					ComputeStringsListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_string_DrawInput,
					"\t\t\t\tInventoryListAction_string_Compute ();",
					"\t\t\t\tInventoryListAction_string_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.stringListAll + ExprWs.Gv.floatAll +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.StringListValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.BoolValue (this) +
					ExprWs.ConstructorExpr.FloattValues (this) +
					ExprWs.ConstructorExpr.StringListValues (this),
					ExprWs.UMDecl.inventoryListAction_string_compute + 
					ExprWs.UMDecl.computeStringList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeStringsListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_stringList_DrawInputs ();",
					"\t\t\t\tForGet_stringList_Compute ();",
					"\t\t\t\tForGet_stringList_DrawOutputs ();",
					ExprWs.Gv.stringListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.StringListValue (this) +
					ExprWs.ConstructorExpr.StringListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_stringList_Compute +
					ExprWs.UMDecl.computeStringList_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeStringsListType.MergeWith.ToString (),
					InOutWs.InWs._stringList_and_1,
					"\t\t\t\tListOperations.Merge (ref stringsListValue, stringsListValues [0], stringsListValues [1]);\n\t",
					InOutWs.OutWs.stringList_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeStringt +
					ExprWs.Gv.stringListValue + ExprWs.Gv.stringListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.StringListValue (this) + ExprWs.ConstructorExpr.StringListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeStringList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}



		EnumInputComputeOutput [] EnumInputComputeOutput_IntsList ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeIntsListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondIntListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._intsList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "intsListValue = MezanixDiamondGetIntList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveIntList(stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.intsList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.intListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.IntListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetIntList + ExprWs.UMDecl.MezanixDiamondRemoveIntList +
					ExprWs.UMDecl.computeIntList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntsListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._intsList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetIntList (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.intsListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.IntListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetIntList + ExprWs.UMDecl.computeIntList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				


				new EnumInputComputeOutput (
					ComputeIntsListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_int_DrawInput,
					"\t\t\t\tInventoryListAction_int_Compute ();",
					"\t\t\t\tInventoryListAction_int_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.intListAll + ExprWs.Gv.intAll +
					ExprWs.Gv.stringAll + ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.IntListValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.BoolValue (this) +
					ExprWs.ConstructorExpr.IntListValues (this),
					ExprWs.UMDecl.inventoryListAction_int_compute + 
					ExprWs.UMDecl.computeIntList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntsListType.max.ToString (),
					InOutWs.InWs._intsList,
					tab4 + "intValue = Mathf.Max (intsListValues [0].ToArray ());",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intsListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.IntListValues (this),
					ExprWs.UMDecl.computeIntList,
					new string []
					{
						"",
						"Returns the max value of the list",
					},
					"https://docs.unity3d.com/ScriptReference/Mathf.Max.html",
					""),

				new EnumInputComputeOutput (
					ComputeIntsListType.min.ToString (),
					InOutWs.InWs._intsList,
					tab4 + "intValue = Mathf.Min (intsListValues [0].ToArray ());",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intsListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.IntListValues (this),
					ExprWs.UMDecl.computeIntList,
					new string []
					{
						"",
						"Returns the min value of the list",
					},
					"https://docs.unity3d.com/ScriptReference/Mathf.Min.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeIntsListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_intList_DrawInputs ();",
					"\t\t\t\tForGet_intList_Compute ();",
					"\t\t\t\tForGet_intList_DrawOutputs ();",
					ExprWs.Gv.intListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.IntListValue (this) +
					ExprWs.ConstructorExpr.IntListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_intList_Compute +
					ExprWs.UMDecl.computeIntList_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntsListType.MergeWith.ToString (),
					InOutWs.InWs._intsList_and_1,
					"\t\t\t\tListOperations.Merge (ref intsListValue, intsListValues [0], intsListValues [1]);\n\t",
					InOutWs.OutWs.intsList_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeInt +
					ExprWs.Gv.intsListValue + ExprWs.Gv.intsListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.IntListValue (this) + ExprWs.ConstructorExpr.IntListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeIntList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_BoolsList ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeBoolListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_bool_DrawInput,
					"\t\t\t\tInventoryListAction_bool_Compute ();",
					"\t\t\t\tInventoryListAction_bool_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.boolListAll + ExprWs.Gv.boolAll +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll,
					ExprWs.ConstructorExpr.BoolListValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.BoolValue (this) +
					ExprWs.ConstructorExpr.BoolListValues (this),
					ExprWs.UMDecl.inventoryListAction_bool_compute + 
					ExprWs.UMDecl.computeBoolList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),
				

				new EnumInputComputeOutput (
					ComputeBoolListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", MezanixDiamondBoolListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._boolList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\tboolsListValue = MezanixDiamondGetBoolList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\tMezanixDiamondRemoveBoolList (stringValues [0]);\n\t\t\t\t}\n",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.boolList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.boolListAll +
					ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) +
					ExprWs.ConstructorExpr.BoolListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.mezanixDiamondGetBoolList + ExprWs.UMDecl.mezanixDiamondRemoveBoolList +
					ExprWs.UMDecl.computeBoolList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeBoolListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._boolList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetBoolList (stringValues [0]);\n",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.boolsListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.mezanixDiamondSetBoolList +
					ExprWs.UMDecl.computeBoolList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeBoolListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_boolList_DrawInputs ();",
					"\t\t\t\tForGet_boolList_Compute ();",
					"\t\t\t\tForGet_boolList_DrawOutputs ();",
					ExprWs.Gv.boolListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.BoolListValue (this) +
					ExprWs.ConstructorExpr.BoolListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_boolList_Compute +
					ExprWs.UMDecl.computeBoolList_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeBoolListType.mergeWith.ToString (),
					InOutWs.InWs._boolList_and_1,
					"\t\t\t\tListOperations.Merge (ref boolsListValue, boolsListValues [0], boolsListValues [1]);\n" +
					"\t\t\t\tintValue = boolsListValue.Count;\n",
					InOutWs.OutWs.boolList_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeBool +
					ExprWs.Gv.boolsListValue + ExprWs.Gv.boolsListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.BoolListValue (this) + ExprWs.ConstructorExpr.BoolListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeBoolList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}



		EnumInputComputeOutput [] EnumInputComputeOutput_FloatsList ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeFloatsListType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondFloatListNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._floatsList + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "floatsListValue = MezanixDiamondGetFloatList (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveFloatList (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.floatsList_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.floatListAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.FloatListValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetFloatList + ExprWs.UMDecl.MezanixDiamondRemoveFloatList +
					ExprWs.UMDecl.computeFloatList,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatsListType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._floatsList + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetFloatList (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.floatsListValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloatListValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetFloatList + ExprWs.UMDecl.computeFloatList,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				


				new EnumInputComputeOutput (
					ComputeFloatsListType.inventoryList.ToString (),
					InOutWs.InWs._invetoryListAction_and_float_DrawInput,
					"\t\t\t\tInventoryListAction_float_Compute ();",
					"\t\t\t\tInventoryListAction_float_DrawOutputs ();",
					ExprWs.Gv.doIt + ExprWs.Gv.inventoryListAction + 
					ExprWs.Gv.floatListAll + ExprWs.Gv.floatAll +
					ExprWs.Gv.intAll + ExprWs.Gv.stringAll + ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.FloatListValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.IntValue (this) + 
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.InventoryListAction (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.BoolValue (this) +
					ExprWs.ConstructorExpr.FloattValues (this) +
					ExprWs.ConstructorExpr.FloatListValues (this),
					ExprWs.UMDecl.inventoryListAction_float_compute + 
					ExprWs.UMDecl.computeFloatList,
					new string []
					{
						"Perform actions to manage an inventory list.",
						"",
						"If you check the box 'Act on the input list?', actions will be applied",
						"to the input list and put the result in the output list,",
						"this help to act on a list comming from another node.",
						"",
						"If the box 'Act on the input list?' is not checked, the node will act directly",
						"on its output list.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatsListType.max.ToString (),
					InOutWs.InWs._floatsList,
					tab4 + "floatValue = Mathf.Max (floatsListValues [0].ToArray ());",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatsListValues + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.FloatListValues (this),
					ExprWs.UMDecl.computeFloatList,
					new string []
					{
						"",
						"Returns the max value of the list",
					},
					"https://docs.unity3d.com/ScriptReference/Mathf.Max.html",
					""),

				new EnumInputComputeOutput (
					ComputeFloatsListType.min.ToString (),
					InOutWs.InWs._floatsList,
					tab4 + "floatValue = Mathf.Min (floatsListValues [0].ToArray ());",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatsListValues + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.FloatListValues (this),
					ExprWs.UMDecl.computeFloatList,
					new string []
					{
						"",
						"Returns the min value of the list",
					},
					"https://docs.unity3d.com/ScriptReference/Mathf.Min.html",
					""),

				new EnumInputComputeOutput (
					ComputeFloatsListType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_floatList_DrawInputs ();",
					"\t\t\t\tForGet_floatList_Compute ();",
					"\t\t\t\tForGet_floatList_DrawOutputs ();",
					ExprWs.Gv.floatListAll + 
					ExprWs.Gv.boolValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.FloatListValue (this) +
					ExprWs.ConstructorExpr.FloatListValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_floatList_Compute +
					ExprWs.UMDecl.computeFloatList_NoDoIT,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatsListType.MergeWith.ToString (),
					InOutWs.InWs._floatsList_and_1,
					"\t\t\t\tListOperations.Merge (ref floatsListValue, floatsListValues [0], floatsListValues [1]);\n\t",
					InOutWs.OutWs.floatsList_,
					ExprWs.Gv.doIt + ExprWs.Gv.ListOperationsClass_MergeFloat +
					ExprWs.Gv.floatsListValue + ExprWs.Gv.floatsListValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.FloatListValue (this) + ExprWs.ConstructorExpr.FloatListValues (this) + 
					ExprWs.ConstructorExpr.IntValue (this),
					ExprWs.UMDecl.computeFloatList,
					new string []
					{
						"",
						"Merge the two lists",
					},
					"",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_Matrix44 ()
		{

			return new EnumInputComputeOutput[]
			{		
				new EnumInputComputeOutput (
					ComputeMatrix44Type.getDeterminant.ToString (),
					InOutWs.InWs._m44,
					tab4 + "floatValue = m44Value_Input_entier [0].determinant;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.m44Value_Input_entier + ExprWs.Gv.m44Value_entier + ExprWs.Gv.m44ValueAndProperties +
					ExprWs.Gv.floatValue,
					"",
					ExprWs.UMDecl.computeMatrix44,
					new string []
					{
						"",
						"The determinant of the matrix.",
					},
					"https://docs.unity3d.com/ScriptReference/Matrix4x4-determinant.html",
					""),

				new EnumInputComputeOutput (
					ComputeMatrix44Type.add.ToString (),
					InOutWs.InWs._m44_and_1,
					tab4 + "M44_0_add_1 ();",
					InOutWs.OutWs.m44_,
					ExprWs.Gv.m44Value_Input_entier + ExprWs.Gv.m44Value_entier + ExprWs.Gv.m44ValueAndProperties,
					"",
					"\t\tvoid M44_0_add_1 ()\n\t\t{\n\t\t\tm44Value = new float[16];\n\n\t\t\tfloat [] tmp_0 = new float[16];\n\n\t\t\tfloat [] tmp_1 = new float[16];\n\n\t\t\ttmp_0 = SetM44ValueToArray (m44Value_Input_entier [0]);\n\t\t\t\t\n\t\t\ttmp_1 = SetM44ValueToArray (m44Value_Input_entier [1]);\n\n\t\t\tfor (int i = 0; i < m44Value.Length; i++)\n\t\t\t{\n\t\t\t\tm44Value [i] = tmp_0 [i] + tmp_1 [i];\n\t\t\t}\n\n\t\t\tm44Value_entier = GetM44 (m44Value);\n\n\t\t\tSetM44Value (m44Value_entier);\n\t\t}" 
					+ ret +
					ExprWs.UMDecl.SetM44Value + ret +
					ExprWs.UMDecl.SetM44ValueToArray + ExprWs.UMDecl.GetM44 +
					ExprWs.UMDecl.computeMatrix44,
					new string []
					{
						"",
						"Add all the values of the matrices and put the result of each addition at the ",
						"corresponding place in a result matrix",
					},
					"",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_Rect ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeRectType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondRectNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._rect + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "rectValue = MezanixDiamondGetRect (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveRect (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.rect_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.rectAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ExprWs.ConstructorExpr.RectValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetRect + 
					ExprWs.UMDecl.MezanixDiamondRemoveRect +
					ExprWs.UMDecl.computeRect,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeRectType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._rect + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetRect (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.rectValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ExprWs.ConstructorExpr.RectValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetRect + ExprWs.UMDecl.computeRect,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				

				new EnumInputComputeOutput (
					ComputeRectType.toString.ToString (),
					InOutWs.InWs._rect,
					"\t\t\t\tstringValue = rectValues [0].ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.rectValues + ExprWs.Gv.stringValue,
					ExprWs.ConstructorExpr.RectValues (this),
					ExprWs.UMDecl.computeRect,
					new string []
					{
						"",
						"To string",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeRectType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_rect_DrawInputs ();",
					"\t\t\t\tForGet_rect_Compute ();",
					"\t\t\t\tForGet_rect_DrawOutputs ();",
					ExprWs.Gv.rectAll + 
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.RectValue (this) +
					ExprWs.ConstructorExpr.RectValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_rect_Compute +
					ExprWs.UMDecl.computeRect_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeRectType.contains.ToString (),
					InOutWs.InWs._rect + ret + "\t\t\t\tDrawLogicNodeLabel (\"Is this point inside the rect?\");\n" +
					InOutWs.InWs._vector2,
					tab4 + "boolValue = rectValues [0].Contains (vector2Values [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.rectValues + ExprWs.Gv.vector2Values + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.RectValues (this) + ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeRect,
					new string []
					{
						"",
						"Returns true if the x and y components of point is a point inside this rectangle.",
						"If allowInverse is present and true, the width and height of the Rect are allowed",
						"to take negative values (ie, the min value is greater than the max), and the test",
						"will still work.",
					},
					"https://docs.unity3d.com/ScriptReference/Rect.Contains.html",
					""),
			};
		}

		//IEnumerator RunAnimationCurve_vector4 ()
		//{
		//	if ( ! boolValues [0])
		//	{
		//		boolValues [0] = true;
		//
		//		float t = 0f;
		//
		//		float rate = 1f / floatValues [2];
		//
		//		while (t < 1f)
		//		{
		//			t += Time.deltaTime * rate;
		//
		//			vector4Value = Vector4.Lerp (vector4Values [0], vector4Values [1], animationCurve_.Evaluate (t));
		//
		//			yield return 0;
		//		}
		//
		//		boolValues [0] = false;
		//	}
		//	yield return 0;
		//}

		EnumInputComputeOutput [] EnumInputComputeOutput_Vector4 ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeVector4Type.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondVector4Names (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._vector4 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "vector4Value = MezanixDiamondGetVector4 (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveVector4 (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.vector4_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.vector4All,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.Vector4Values (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetVector4 + ExprWs.UMDecl.MezanixDiamondRemoveVector4 +
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector4Type.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._vector4 + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetVector4 (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.vector4Values + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.Vector4Values (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetVector4 + ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				


				new EnumInputComputeOutput (
					ComputeVector4Type.animationCurvePickValue.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._vector4 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._vector4_1 +
					"\t\t\t\tDrawLogicNodeLabel (\"Pick curve value of this time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);\n",
					"\t\t\t\tvector4Value = Vector4.Lerp (vector4Values [0], vector4Values [1], animationCurve_.Evaluate (floatValues [2]));",
					InOutWs.OutWs.vector4_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve +
					ExprWs.Gv.vector4All ,
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.Vector4Values (this) +
					ExprWs.ConstructorExpr.AnimationCurve (this) +
					ExprWs.ConstructorExpr.Vector4Value (this),
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Pick a vector value on a curve,",
						"between the start and the end value.",
						"You have to choose the time corresponding to your value",
						"The time is the horizontal axis of the curve.",
						"The picked vector, the start and the end vectors are on the",
						"vertical axis of the curve",
						"",
						"About the horizontal axis:",
						"This axis is commonly called time, but in the case of this node",
						"it is an axis having values from 0 to 1 (normalized),",
						"so this node is usful for drawing any curves shape and picking",
						"a vector value (vertical axis) on the curve corresponding of any",
						"position in the horizontal axis, 0 is the left of the horizontal axis,",
						"1 is its right and between them is a value on the axis.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector4Type.animationCurve.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._vector4 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._vector4_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve animation time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Max (0.1f, floatValues [2]);\n",
					"\t\t\t\t" + CsScriptWriter.FromLogicNodeToMonoBehaviour (logic.node.graph, logic.node, logic) + "." +
					"StartCoroutine (RunAnimationCurve_vector4 ());",
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
					InOutWs.OutWs.vector4_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve + ExprWs.Gv.boolValues + 
					ExprWs.Gv.vector4All,
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tboolValues [0] = false;\n" + 
					ExprWs.ConstructorExpr.AnimationCurve (this) + ExprWs.ConstructorExpr.Vector4Values (this) +
					ExprWs.ConstructorExpr.Vector4Value (this),
					"\t\tIEnumerator RunAnimationCurve_vector4 ()\n\t\t{\n\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tboolValues [0] = true;\n\t\t\n\t\t\t\tfloat t = 0f;\n\t\t\n\t\t\t\tfloat rate = 1f / floatValues [2];\n\t\t\n\t\t\t\twhile (t < 1f)\n\t\t\t\t{\n\t\t\t\t\tt += Time.deltaTime * rate;\n\t\t\n\t\t\t\t\tvector4Value = Vector4.Lerp (vector4Values [0], vector4Values [1], animationCurve_.Evaluate (t));\n\t\t\n\t\t\t\t\tyield return 0;\n\t\t\t\t}\n\t\t\n\t\t\t\tboolValues [0] = false;\n\t\t\t}\n\t\t\tyield return 0;\n\t\t}\n" +
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Animate a vector value on a curve,",
						"between the start and the end value.",
						"You have to define the animation time (duration).",
						"The time is the horizontal axis of the curve.",
						"The animated vector, the start and the end vectors are on the",
						"vertical axis of the curve",
					},
					"",
					""),				

				new EnumInputComputeOutput (
					ComputeVector4Type.Vector4ToColor.ToString (),
					InOutWs.InWs._vector4,
					tab4 + "colorValue = new Color (" +
						"Mathf.Clamp (vector4Values [0].x, 0f, 1f), " +
						"Mathf.Clamp (vector4Values [0].y, 0f, 1f), " +
						"Mathf.Clamp (vector4Values [0].z, 0f, 1f), " +
						"Mathf.Clamp (vector4Values [0].w, 0f, 1f));",		
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector4Values + ExprWs.Gv.colorValue,
					ExprWs.ConstructorExpr.Vector4Values (this),
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Vector4 to Color. " +
						"x to R",
						"y to G",
						"z to B",
						"w to A",
						"Vector4 values are clamped between 0f and 1f",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector4Type.vector3ToVector4.ToString (),
					InOutWs.InWs._vector3 +
					"DrawLogicNodeLabel (\"Put this float in W\");\n" +
					InOutWs.InWs._float,
					tab4 + "vector4Value = new Vector4 (vector3Values [0].x, vector3Values [0].y, vector3Values [0].z, floatValues [0]);",		
					InOutWs.OutWs.vector4_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.floatValues + ExprWs.Gv.vector4Value,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Compose a Vector4, put the input Vector3 in X, Y and Z, and the float in W",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector4Type.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_vector4_DrawInputs ();",
					"\t\t\t\tForGet_vector4_Compute ();",
					"\t\t\t\tForGet_vector4_DrawOutputs ();",
					ExprWs.Gv.vector4All + 
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.Vector4Value (this) +
					ExprWs.ConstructorExpr.Vector4Values (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_vector4_Compute +
					ExprWs.UMDecl.computeVector4_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector4Type.toString.ToString (),
					InOutWs.InWs._vector4,
					tab4 + "stringValue = vector4Values [0].ToString ();",		
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector4Values + ExprWs.Gv.stringValue,
					ExprWs.ConstructorExpr.Vector4Values (this),
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Get a string (text) format of the value",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector4Type.Switch.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Want this value?\");" + ret +
					InOutWs.InWs._bool + ret +
					InOutWs.InWs._vector4 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Or this One?\");" + ret +
					InOutWs.InWs._bool_1 + ret +
					InOutWs.InWs._vector4_1,
					"\t\t\t\tif (boolValues [0] && ! boolValues [1])\n" +
					"\t\t\t\t{\n\t\t\t\t\tvector4Value = vector4Values [0];\n\t\t\t\t}\n" +
					"\t\t\t\tif (boolValues [1] && ! boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\tvector4Value = vector4Values [1];\n\t\t\t\t}\n",		
					InOutWs.OutWs.vector4_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector4All + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.Vector4Values (this) + ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Get the value corresponding of the checked box,",
						"if noth boxes have the same value, the node will not compute",
						"and it will conserve it's old output",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector4Type.dot.ToString (),
					InOutWs.InWs._vector4_and_1,
					tab4 + "floatValue = Vector4.Dot (vector4Values [0], vector4Values [1]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector4Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector4Values (this),
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Dot Product of two vectors.",
					},
					"https://docs.unity3d.com/ScriptReference/Vector4.Dot.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector4Type.Add.ToString (),
					InOutWs.InWs._vector4_and_1,
					tab4 + "vector4Value = vector4Values [0] + vector4Values [1];",
					InOutWs.OutWs.vector4_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector4All,
					ExprWs.ConstructorExpr.Vector4Values (this),
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Add two vector4",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector4Type.subtract.ToString (),
					InOutWs.InWs._vector4_and_1,
					tab4 + "vector4Value = vector4Values [0] - vector4Values [1];",
					InOutWs.OutWs.vector4_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector4All,
					ExprWs.ConstructorExpr.Vector4Values (this),
					ExprWs.UMDecl.computeVector4,
					new string []
					{
						"",
						"Subtract two vector4",
					},
					"",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_Texture2D ()
		{
			return new EnumInputComputeOutput[]
			{	
				new EnumInputComputeOutput (
					ComputeTexture2DType.applySetPixelChanges.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Update mipmaps?\");\n" +
					InOutWs.InWs._bool +
					"\t\t\t\tDrawLogicNodeLabel (\"Make No Longer Readable?\");\n" +
					InOutWs.InWs._bool_1,
					"\t\t\t\tif (texture2DValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\ttexture2DValues [0].Apply (boolValues [0], boolValues [1]);\n\n\t\t\t\t\ttexture2DValue = texture2DValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll + 
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"Actually apply all previous SetPixel and SetPixels changes.",
						"If updateMipmaps is true, the mipmap levels are recalculated as well,",
						"using the base level as a source. Usually you want to use true in all cases",
						"except when you've modified the mip levels yourself using SetPixels.",
						"By default updateMipmaps is set to true. If makeNoLongerReadable is true,",
						"texture will be marked as no longer readable and memory will be freed after ",
						"uploading to GPU. By default makeNoLongerReadable is set to false.",
						"Apply is a potentially expensive operation, so you'll want to change ",
						"as many pixels as possible between Apply calls.",
						"Alternatively, if you don't need to access the pixels on the CPU,",
						"you could use Graphics.CopyTexture for fast GPU-side texture data copies.",
						"The texture has to have Is Readable flag set in the import settings.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture2D.Apply.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawInNodeInfo (\"Default value: In the above texture field\");\n" +
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondTexture2DNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "texture2DValue = MezanixDiamondGetTexture2D (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveTexture2D (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.texture2DAll +
					ExprWs.Gv.identifiedObjects,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetTexture2D + 
					ExprWs.UMDecl.MezanixDiamondRemoveTexture2D +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeTexture2DType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetTexture2D (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.texture2DValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.identifiedObjects,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetTexture2D + ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.getName.ToString (),
					"",
					"\t\t\t\tif (texture2DValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tstringValue = texture2DValues [0].name;\n\t\t\t\t}",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DValues + 
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"The name of the object (texture2D).",
					},
					"https://docs.unity3d.com/ScriptReference/Object-name.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeTexture2DType.setName.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\tif (texture2DValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\ttexture2DValues [0].name = stringValues [0];\n\n\t\t\t\t\ttexture2DValue = texture2DValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll + 
					ExprWs.Gv.stringValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) +
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"The name of the object (texture2D).",
					},
					"https://docs.unity3d.com/ScriptReference/Object-name.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.metallicSmoothnessAndOcclusionToTexture.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					"\t\t\t\tDrawLogicNodeLabel (\"The Second Texture (for occlusion)\");\n" +
					"\t\t\t\tDrawTexture2DFieldInput (1);\n\n" +
					"\t\t\t\tif (texture2DValues [0] != null && \n\t\t\t\t\ttexture2DValues [1] != null)\n" +
					"\t\t\t\t{\n\t\t\t\t\tif (texture2DValues [0].width != texture2DValues [1].width)\n" +
					"\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.label, textureNoSameWidthInfo, " +
					"Skins.logicNodeLabel);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n" +
					"\t\t\t\t\telse if (texture2DValues [0].height != texture2DValues [1].height)\n" +
					"\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.label, textureNoSameHeightInfo, " +
					"Skins.logicNodeLabel);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n",
					"\t\t\t\tTexture2D_0_1_metallicSmoothnessAndOcclusionToTexture ();",
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"Result Texture\", Skins.logicNodeLabel);" + ret +
					InOutWs.OutWs.texture2D_ + ret + InOutWs.OutWs.DrawTexture2DViewerForTextureBlend_,
					ExprWs.Gv.identifiedObjects +
					ExprWs.Gv.doIt +
					ExprWs.Gv.texture2DAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID, 
						Enums.texture2DValues_1_ID,}),
					"\t\tvoid Texture2D_0_1_metallicSmoothnessAndOcclusionToTexture ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tif (texture2DValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\t\tColor [] colors_1 = texture2DValues [1].GetPixels ();\n\n\t\t\t\t\tColor [] colors_0 = texture2DValues [0].GetPixels ();\n\n\t\t\t\t\tColor [] colorsRes = new Color [colors_1.Length];\n\n\n\t\t\t\t\tfor (int i = 0; i < colorsRes.Length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcolorsRes [i] = new Color (colors_0 [i].r, colors_1 [i].r, 0f, colors_0 [i].a);\n\t\t\t\t\t}\n\n\t\t\t\t\ttex.SetPixels (colorsRes);\n\n\t\t\t\t\ttex.Apply ();\n\n\t\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\t\ttexture2DValue.name = \"Metallic_Smoothness_Occlusion\";\n\n\t\t\t\t\ttex = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n" +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Takes the red channel of the first texture and put it in",
						"the red channel (Metallic) of the result texture.",
						"Takes the alpha channel of the first texture and put it in",
						"the alpha channel (Smoothness) of the result texture.",
						"",
						"Takes the red channel of the second texture and put it in",
						"the green channel (Occlusion) of the result texture.",
						"for the second input texture (Occlusion map) use a rgb texture with equal values on all channels",
						"Like so, the red channel used bye the node represent the grayscale of your input textures",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeTexture2DType.metallicAndSmoothnesToTexture.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					"\t\t\t\tDrawLogicNodeLabel (\"The Second Texture (for smoothness)\");\n" +
					"\t\t\t\tDrawTexture2DFieldInput (1);\n\n" +
					"\t\t\t\tif (texture2DValues [0] != null && \n\t\t\t\t\ttexture2DValues [1] != null)\n" +
					"\t\t\t\t{\n\t\t\t\t\tif (texture2DValues [0].width != texture2DValues [1].width)\n" +
					"\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.label, textureNoSameWidthInfo, " +
					"Skins.logicNodeLabel);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n" +
					"\t\t\t\t\telse if (texture2DValues [0].height != texture2DValues [1].height)\n" +
					"\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.label, textureNoSameHeightInfo, " +
					"Skins.logicNodeLabel);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n",
					"\t\t\t\tTexture2D_0_1_metallicAndSmoothnesToTexture ();",
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"Result Texture\", Skins.logicNodeLabel);" + ret +
					InOutWs.OutWs.texture2D_ + ret + InOutWs.OutWs.DrawTexture2DViewerForTextureBlend_,
					ExprWs.Gv.identifiedObjects +
					ExprWs.Gv.doIt +
					ExprWs.Gv.texture2DAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID, 
						Enums.texture2DValues_1_ID,}),
					"\t\tvoid Texture2D_0_1_metallicAndSmoothnesToTexture ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tif (texture2DValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\t\tColor [] colors_1 = texture2DValues [1].GetPixels ();\n\n\t\t\t\t\tColor [] colors_0 = texture2DValues [0].GetPixels ();\n\n\t\t\t\t\tColor [] colorsRes = new Color [colors_1.Length];\n\n\n\t\t\t\t\tfor (int i = 0; i < colorsRes.Length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcolorsRes [i] = new Color (colors_0 [i].r, 0f, 0f, colors_1 [i].r);\n\t\t\t\t\t}\n\n\t\t\t\t\ttex.SetPixels (colorsRes);\n\n\t\t\t\t\ttex.Apply ();\n\n\t\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\t\ttexture2DValue.name = \"Metallic_Smoothness\";\n\n\t\t\t\t\ttex = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n" +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Takes the red channel of the first texture and put it in",
						"the red channel (Metallic) of the result texture.",
						"",
						"Takes the red channel of the second texture and put it in",
						"the alpha channel (Smoothness) of the result texture.",
						"for the input textures use a rgb texture with equal values on all channels",
						"Like so, the red channel used bye the node represent the grayscale of your input textures",
					},
					"",
					""),
				

				new EnumInputComputeOutput (
					ComputeTexture2DType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_texture2D_DrawInputs ();",
					"\t\t\t\tForGet_texture2D_Compute ();",
					"\t\t\t\tForGet_texture2D_DrawOutputs ();",
					ExprWs.Gv.texture2DAll + 
					ExprWs.Gv.boolValues +
					ExprWs.Gv.identifiedObjects,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValue_ID,}) +
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_texture2D_Compute +
					ExprWs.UMDecl.computeTexture2D_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeTexture2DType.writeTextureToFile.ToString (),
					"\t\t\t\tDrawMessageBoxUpLeftToPutAdvacedReadableTextures (new string []\n\t\t\t\t\t{\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\t\" Texture Files, Write's Destination:\\n\",\n\t\t\t\t\t\"Assets/TexturesCreatedByDiamond\\n\",\n\t\t\t\t\t});\n" +
					"\t\t\t\tDrawPrepareTexture2DInputs (PrepareTexture2DForWhat.write);\n",
					"\t\t\t\tSetTexture2D_0_WriteFile ();",
					InOutWs.OutWs.texture2D_ + ret + "DrawLogicNodeLabel (\"Only in editor use for now\");\n",
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}),
					"\t\tvoid SetTexture2D_0_WriteFile ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\ttexture2DValue = texture2DValues [0];\n\t\t\t}\n\t\t}" +
					ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Write this texture to a .JPG or .PNG file.",
						"Like so it will be in your project assets (hard drive), so you can use it for this project",
						"or for an another project.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.SwitchColors.ToString (),
					"\t\t\t\tDrawInputsFor_ComputeTexture2DType_SwitchColorsType ();",
					"\t\t\t\tTexture2D_0_SwitchColors ();",
					InOutWs.OutWs.texture2D_ + InOutWs.OutWs.DrawTexture2DViewerForTextureTransform_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.textureComputer + ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects +
					ExprWs.Gv.texture2DAll + ExprWs.Gv.switchColorsType,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.switchColorsType (this),
					"\t\tvoid Texture2D_0_SwitchColors ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\t//Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\ttex.SetPixels (TextureComputer.SwitchColors (texture2DValues [0], switchColorsType));\n\n\t\t\t\ttex.name = texture2DValues [0].name + \"_\" + switchColorsType.ToString ();\n\n\t\t\t\ttex.Apply ();\n\n\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\ttex = null;\n\t\t\t}\n\n\t\t}" +
					ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Do a switch between two of the R, G and B channels",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.setWrapMode.ToString (),
					"\t\t\t\tDrawTextureWrapModeEnum ();",
					ExprWs.UMDecl.texture2D_0_check_block +
					"\t\t\t\ttexture2DValues [0].wrapMode = textureWrapMode;\n\n" +
					"\t\t\t\ttexture2DValue = texture2DValues [0];",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.doIt + ExprWs.Gv.textureWrapMode + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.textureWrapMode (this),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Wrap mode (Repeat or Clamp) of the texture.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture-wrapMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.SetPixelAccordingToAChannelValue.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"Texture To Get Pixel From\", Skins.logicNodeLabel);\n\t\t\t\tDrawTexture2DFieldInput (1);\n\n\t\t\t\tif (texture2DValues [0] != null && texture2DValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tif (texture2DValues [0].width == texture2DValues [1].width)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texture2DValues [0].height == texture2DValues [1].height)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDrawInputsFor_ComputeTexture2DType_SetChannelFromAnother (\n\t\t\t\t\t\t\t\t\"According To value in texture to change\", 1);\n\n\t\t\t\t\t\t\tDrawLabelField (FieldDrawType.label, \"With Tolerance of\", Skins.logicNodeLabel);\n\t\t\t\t\t\t\tDrawIntInputField (2);\n\t\t\t\t\t\t\tintValues [2] = Mathf.Clamp (intValues [2], 18, 512);\n\n\n\n\t\t\t\t\t\t\tDrawInNodeInfo (dontOfenRunTimeInfo);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDrawLabelField (FieldDrawType.nodeName, textureNoSameHeightInfo, Skins.InNodeMessageInfo);\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.nodeName, textureNoSameWidthInfo, Skins.InNodeMessageInfo);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}",
					"\t\t\t\tTexture2D_0_SetPixelAccordingToAChannelValue ();",
					InOutWs.OutWs.texture2D_ + InOutWs.OutWs.DrawTexture2DViewerForTextureBlend_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.textureComputer + ExprWs.Gv.doIt + 
					ExprWs.Gv.intValues + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll + ExprWs.Gv.channels,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.IntValues (this) + 
					ExprWs.ConstructorExpr.Channels (this),
					"\t\tvoid Texture2D_0_SetPixelAccordingToAChannelValue ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tif (texture2DValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\t\t//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t\t//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\t\ttex.SetPixels (TextureComputer.SetPixelAccordingToAChannelValue (channels [1], \n\t\t\t\t\t\tintValues [1], intValues [2], texture2DValues [1],\ttexture2DValues [0]));\n\n\t\t\t\t\ttex.name = \"modifiedTexture\";\n\n\t\t\t\t\ttex.Apply ();\n\n\t\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\t\ttex = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}"
					+ ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Find pixels according to a search value on a channel.",
						"The search value can be by enlarged by the tolerance of search.",
						"Once a pixel is found, put in it the corresponding pixel that come from the second texture",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.SetPixel.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					tab4 + "DrawInputsForSetPixel ();",
					tab4 + "SetTexture2D_0_SetPixel ();",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll +
					ExprWs.Gv.colorValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.IntValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this),
					"\t\tvoid SetTexture2D_0_SetPixel ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tintValues [0] = Mathf.Clamp (intValues [0], 0, texture2DValues [0].width);\n\n\t\t\t\tintValues [1] = Mathf.Clamp (intValues [1], 0, texture2DValues [0].height);\n\n\t\t\t\ttexture2DValues [0].SetPixel (intValues [0], intValues [1], colorValues [0]);\n\n\t\t\t\ttexture2DValue = texture2DValues [0];\n\t\t\t}\n\t\t}"
					+ ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Sets pixel color at coordinates (x,y).",
						"This function works only on RGBA32, ARGB32, RGB24 and Alpha8 texture formats.",
						"For other formats SetPixel is ignored.",
						"The texture also has to have Read/Write Enabled flag set in the import settings.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture2D.SetPixel.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.setMipMapBias.ToString (),
					InOutWs.InWs._float,
					ExprWs.UMDecl.texture2D_0_check_block +
					"\t\t\t\ttexture2DValues [0].mipMapBias = floatValues [0];\n\n" +
					"\t\t\t\ttexture2DValue = texture2DValues [0];",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Mip map bias of the texture.",
						"A positive bias makes a texture appear extra blurry, while a negative bias sharpens",
						"the texture. Note that using large negative bias can reduce performance,",
						"so it's not recommended to use more than -0.5 negative bias. In most cases better",
						"sharpening of the texture can be achieved by using anisotropic filtering.",
						"Also note that mip map bias does not work with MaterialPropertyBlocks, and some platforms,",
						"e.g., OpenGL ES based do not support it without custom shaders.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture-mipMapBias.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.setFilterMode.ToString (),
					tab4 + "DrawFilterModeEnum ();",
					ExprWs.UMDecl.texture2D_0_check_block +
					"\t\t\t\t" + "texture2DValues [0].filterMode = filterMode;" + "\n\n" + 
					"\t\t\t\t" + "texture2DValue = texture2DValues [0];",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.doIt + ExprWs.Gv.filtermode + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.filtermode (this),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Filtering mode for textures. Corresponds to the settings in a texture inspector.",
					},
					"https://docs.unity3d.com/ScriptReference/FilterMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.SetColorAccordingToAChannelValue.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"Put This Color\", Skins.logicNodeLabel);\n\t\t\t\tDrawColorInputField (0);\n\n\t\t\t\tDrawInputsFor_ComputeTexture2DType_SetChannelFromAnother (\"According To This Channel value\", 1);\n\n\t\t\t\tDrawLabelField (FieldDrawType.label, \"With Tolerance of\", Skins.logicNodeLabel);\n\t\t\t\tDrawIntInputField (2);\n\t\t\t\tintValues [2] = Mathf.Clamp (intValues [2], 18, 512);\n\n\n\n\t\t\t\tDrawInNodeInfo (dontOfenRunTimeInfo);",
					tab4 + "Texture2D_0_SetColorAccordingToAChannelValue ();",
					InOutWs.OutWs.texture2D_ + InOutWs.OutWs.DrawTexture2DViewerForTextureTransform_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.textureComputer + ExprWs.Gv.doIt + 
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.intValues +
					ExprWs.Gv.texture2DAll + 
					ExprWs.Gv.channels + ExprWs.Gv.colorValues,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.IntValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) + ExprWs.ConstructorExpr.Channels (this),
					"\t\tvoid Texture2D_0_SetColorAccordingToAChannelValue ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\t//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\ttex.SetPixels (TextureComputer.SetColorAccordingToAChannelValue (channels [1], \n\t\t\t\t\tintValues [1], intValues [2], colorValues [0],\ttexture2DValues [0]));\n\n\t\t\t\ttex.name = \"modifiedTexture\";\n\n\t\t\t\ttex.Apply ();\n\n\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\ttex = null;\n\t\t\t}\n\n\t\t}" +
					ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Find pixels according to a search value on a channel.",
						"The search value can be by enlarged by the tolerance of search.",
						"Once a pixel is found, put in it the color you want.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.SetChannelsToThisTexture.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					"\t\t\t\tDrawInputsFor_ComputeTexture2DType_SetChannelsComingFromTexture ();\n\n" + 
					"\t\t\t\tif (texture2DValues [0] != null && \n\t\t\t\t\ttexture2DValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tif (texture2DValues [0].width != texture2DValues [1].width)\n\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.nodeName, \"Textures widths aren't equal\",\n\t\t\t\t\t\t\tSkins.InNodeMessageInfo);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse if (texture2DValues [0].height != texture2DValues [1].height)\n\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.nodeName, \"Textures heights aren't equal\",\n\t\t\t\t\t\t\tSkins.InNodeMessageInfo);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n",
					tab4 + "Texture2D_0_SetChannelsComingFromTexture ();",
					InOutWs.OutWs.texture2D_ + InOutWs.OutWs.DrawTexture2DViewerForTextureBlend_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.textureComputer + ExprWs.Gv.doIt + 
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.intValues +
					ExprWs.Gv.texture2DAll + 
					ExprWs.Gv.channel,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID, Enums.texture2DValues_1_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					"\t\tvoid Texture2D_0_SetChannelsComingFromTexture ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tif (texture2DValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tif (texture2DValues [0].width == texture2DValues [1].width)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texture2DValues [0].height == texture2DValues [1].height)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\t\t\t\t//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t\t\t\t//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\t\t\t\ttex.SetPixels (TextureComputer.SetChannel (texture2DValues [0], channel, texture2DValues [1]));\n\n\t\t\t\t\t\t\ttex.name = \"modifiedTexture\";\n\n\t\t\t\t\t\t\ttex.Apply ();\n\n\t\t\t\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\t\t\t\ttex = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}" + ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"For all pixels,",
						"pick a channel from the second texture and put it in the first one",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.SetChannels.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					tab4 + "DrawInputsFor_ComputeTexture2DType_SetChannels ();",
					tab4 + "Texture2D_0_SetChannels ();",
					InOutWs.OutWs.texture2D_ + InOutWs.OutWs.DrawTexture2DViewerForTextureTransform_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.textureComputer + ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.intValues + 
					ExprWs.Gv.texture2DAll + 
					ExprWs.Gv.channel,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.IntValues (this),
					"\t\tvoid Texture2D_0_SetChannels ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\t//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\ttex.SetPixels (TextureComputer.SetChannel (texture2DValues [0], channel, intValues [0]));\n\n\t\t\t\ttex.name = \"modifiedTexture\";\n\n\t\t\t\ttex.Apply ();\n\n\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\ttex = null;\n\t\t\t}\n\n\t\t}"
					+ ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"For All pixels, set a uniform value to the choosen channel ",

					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.SetChannelAccordingToAnotherChannelValue.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					"\t\t\t\tDrawInputsFor_ComputeTexture2DType_SetChannelFromAnother (\"Put This Value\", 0);\n\n\t\t\t\tDrawInputsFor_ComputeTexture2DType_SetChannelFromAnother (\"According To This One\", 1);\n\n\t\t\t\tDrawLabelField (FieldDrawType.label, \"With Tolerance of\", Skins.logicNodeLabel);\n\t\t\t\tDrawIntInputField (2);\n\t\t\t\tintValues [2] = Mathf.Clamp (intValues [2], 18, 512);\n\n\t\t\t\tDrawLabelField (FieldDrawType.label, \"Keep other Channels?\", Skins.logicNodeLabel);\n\t\t\t\tDrawBoolInputField (0);\n\t\t\t\tif ( ! boolValues [0])\n\t\t\t\t{\n\t\t\t\t\tif (channels [0] == TextureComputer.ComputeOn.red ||\n\t\t\t\t\t\tchannels [0] == TextureComputer.ComputeOn.green ||\n\t\t\t\t\t\tchannels [0] == TextureComputer.ComputeOn.blue)\n\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.label, \"Keep Alpha?\", Skins.logicNodeLabel);\n\t\t\t\t\t\tDrawBoolInputField (1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tDrawInNodeInfo (dontOfenRunTimeInfo);",
					tab4 + "Texture2D_0_SetChannelAccordingToAnotherChannelValue ();",
					InOutWs.OutWs.texture2D_ + ret + InOutWs.OutWs.DrawTexture2DViewerForTextureTransform_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.textureComputer + ExprWs.Gv.intValues + 
					ExprWs.Gv.boolValues + ExprWs.Gv.channels +
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.IntValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.Channels (this),
					"\t\tvoid Texture2D_0_SetChannelAccordingToAnotherChannelValue ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\t//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\ttex.SetPixels (TextureComputer.SetChannelAccordingToAnotherChannelValue\n\t\t\t\t\t(channels [0], channels [1], intValues [1], intValues [2], intValues [0],\n\t\t\t\t\t\ttexture2DValues [0], boolValues [0], boolValues [1]));\n\n\t\t\t\ttex.name = \"modifiedTexture\";\n\n\t\t\t\ttex.Apply ();\n\n\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\ttex = null;\n\t\t\t}\n\n\t\t}"
					+ ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Find pixels according to a search value on a channel.",
						"The search value can be by enlarged by the tolerance of search.",
						"Once a pixel is found, put in it a choosen value for a choosen channel.",
						"You can toggle to keep other channels or to down them to zero.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.setAnisoLevel.ToString (),
					InOutWs.InWs._int,
					ExprWs.UMDecl.texture2D_0_check_block +
					"\t\t\t\ttexture2DValues [0].anisoLevel = intValues [0];\n\n\t\t\t\ttexture2DValue = texture2DValues [0];",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Anisotropic filtering level of the texture.",
						"Anisotropic filtering makes textures look better when viewed at a shallow angle,",
						"but comes at a performance cost in the graphics hardware. Usually you use it on floor,",
						"ground or road textures to make them look better.",
						"The value range of this variable goes from 1 to 9, where 1 equals no filtering applied",
						"and 9 equals full filtering applied. As the value gets bigger, the texture is clearer at",
						"shallow angles. Lower values mean the texture will be more blurry at shallow angles.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture-anisoLevel.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.MirrorAndRotate.ToString (),
					tab4 + "DrawMirrorTexture2D_DirectionEnum ();",
					tab4 + "Texture2D_0_Mirror ();",
					InOutWs.OutWs.texture2D_ + InOutWs.OutWs.DrawTexture2DViewerForTextureTransform_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.textureComputer + ExprWs.Gv.doIt + 
					ExprWs.Gv.mirrorTexture2D_Direction + 
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DAll,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + 
					ExprWs.ConstructorExpr.MirrorTexture2D_Direction (this),
					"\t\tvoid Texture2D_0_Mirror ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\tif (mirrorTexture2D_Direction == TextureComputer.MirrorTexture2D_Direction.rotate90 ||\n\t\t\t\t\tmirrorTexture2D_Direction == TextureComputer.MirrorTexture2D_Direction.rotateMinus90 ||\n\t\t\t\t\tmirrorTexture2D_Direction == TextureComputer.MirrorTexture2D_Direction.mirrorXAndY)\n\t\t\t\t{\n\t\t\t\t\ttex = new Texture2D (texture2DValues [0].height, texture2DValues [0].width);\n\t\t\t\t}\n\n\t\t\t\t//Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\ttex.SetPixels (TextureComputer.MirrorAndRotate (texture2DValues [0], mirrorTexture2D_Direction));\n\n\t\t\t\ttex.name = texture2DValues [0].name + \"_\" + mirrorTexture2D_Direction.ToString ();\n\n\t\t\t\ttex.Apply ();\n\n\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\ttex = null;\n\t\t\t}\n\t\t}\n" +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Do mirroring and rotation operations on the texture",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.getWidth.ToString (),
					"",
					ExprWs.UMDecl.texture2D_0_check_block +
					tab4 + "intValue = texture2DValues [0].width;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValue + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DValues,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Width of the texture in pixels.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture-width.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.GetPixelBilinear.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo + 
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"At u, v\", Skins.logicNodeLabel);\n\t\t\t\tDrawFloatInputField (0);\n\t\t\t\tDrawFloatInputField (1);",
					tab4 + "GetTexture2D_0_PixelBilinear ();",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorValue + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DValues + ExprWs.Gv.floatValues,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.FloattValues (this),
					"\t\tvoid GetTexture2D_0_PixelBilinear ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tfloatValues [0] = Mathf.Clamp (floatValues [0], 0f, 1f);\n\t\t\t\n\t\t\t\tfloatValues [1] = Mathf.Clamp (floatValues [1], 0f, 1f);\n\n\t\t\t\tcolorValue = texture2DValues [0].GetPixelBilinear (floatValues [0], floatValues [1]);\n\t\t\t}\n\t\t}" + ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Returns filtered pixel color at normalized coordinates (u, v).",
						"The texture must have the Read/Write Enabled flag set in the import settings,",
						"otherwise this function will fail. GetPixelBilinear is not available on Textures using",
						"Crunch texture compression.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture2D.GetPixelBilinear.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.GetPixel.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"At x, y\", Skins.logicNodeLabel);\n\t\t\t\tDrawIntInputField (0);\n\t\t\t\tDrawIntInputField (1);",
					tab4 + "GetTexture2D_0_Pixel ();",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorValue + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DValues + ExprWs.Gv.intValues,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.IntValues (this),
					"\t\tvoid GetTexture2D_0_Pixel ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tintValues [0] = Mathf.Clamp (intValues [0], 0, texture2DValues [0].width);\n\n\t\t\t\tintValues [1] = Mathf.Clamp (intValues [1], 0, texture2DValues [0].height);\n\n\t\t\t\tcolorValue = texture2DValues [0].GetPixel (intValues [0], intValues [1]);\n\t\t\t}\n\t\t}" + ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Returns pixel color at coordinates (x, y).",
						"The texture must have the Read/Write Enabled flag set in the import settings,",
						"otherwise this function will fail. GetPixel is not available on Textures using",
						"Crunch texture compression.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture2D.GetPixel.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.getMipMapCount.ToString (),
					"",
					ExprWs.UMDecl.texture2D_0_check_block +
					tab4 + "intValue = texture2DValues [0].mipmapCount;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValue + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DValues,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"How many mipmap levels are in this texture (Read Only).",
						"The returned value includes the base level as well, so it is always 1 or more.",
						"Mipmap count is used if you use GetPixels or SetPixels to fetch or modify the different",
						"mip levels. For example, you could change a texture so that each mip level is tinted in a",
						"different color - then in the game you'd see which mip levels are actually visible.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture2D-mipmapCount.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.getMipMapBias.ToString (),
					"",
					ExprWs.UMDecl.texture2D_0_check_block +
					tab4 + "floatValue = texture2DValues [0].mipMapBias;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValue + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DValues,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Mip map bias of the texture.",
						"A positive bias makes a texture appear extra blurry, while a negative bias sharpens",
						"the texture. Note that using large negative bias can reduce performance,",
						"so it's not recommended to use more than -0.5 negative bias. In most cases better",
						"sharpening of the texture can be achieved by using anisotropic filtering.",
						"Also note that mip map bias does not work with MaterialPropertyBlocks, and some platforms,",
						"e.g., OpenGL ES based do not support it without custom shaders.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture-mipMapBias.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.getHeight.ToString (),
					"",
					ExprWs.UMDecl.texture2D_0_check_block +
					tab4 + "intValue = texture2DValues [0].height;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValue + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DValues,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Height of the texture in pixels.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture-height.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.getAnisoLevel.ToString (),
					"",
					ExprWs.UMDecl.texture2D_0_check_block +
					"\t\t\t\tintValue = texture2DValues [0].anisoLevel;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValue + ExprWs.Gv.identifiedObjects + ExprWs.Gv.texture2DValues,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}),
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Anisotropic filtering level of the texture.",
						"Anisotropic filtering makes textures look better when viewed at a shallow angle,",
						"but comes at a performance cost in the graphics hardware. Usually you use it on floor,",
						"ground or road textures to make them look better.",
						"The value range of this variable goes from 1 to 9, where 1 equals no filtering applied",
						"and 9 equals full filtering applied. As the value gets bigger, the texture is clearer at",
						"shallow angles. Lower values mean the texture will be more blurry at shallow angles.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture-anisoLevel.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeTexture2DType.ExtractChannels.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo + 
					"\t\t\t\tDrawInputsFor_ComputeTexture2DType_ExtractChannels ();",
					"\t\t\t\tTexture2D_0_ExtractChannels ();",
					InOutWs.OutWs.texture2D_ + ret + InOutWs.OutWs.DrawTexture2DViewerForTextureTransform_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.textureComputer + ExprWs.Gv.extractResultType
					+ ExprWs.Gv.identifiedObjects + ExprWs.Gv.doIt + ExprWs.Gv.channel + ExprWs.Gv.texture2DAll,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + ExprWs.ConstructorExpr.Channel (this) +
					ExprWs.ConstructorExpr.ExtractResultType (this),
					"\t\tvoid Texture2D_0_ExtractChannels ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\t\t\t\t//tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\ttex.SetPixels (TextureComputer.ExtractChannel (texture2DValues [0], channel, extractResultType));\n\n\t\t\t\ttex.name = \"modifiedTexture\";\n\n\t\t\t\ttex.Apply ();\n\n\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\ttex = null;\n\t\t\t}\n\n\t\t}" +
					ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Extract the channel you want, as it or its intensity as a gray scale",	
						"If you use grayscale, the resulting texture still a 4 channels texture",	
						"with the same value at R, G and B",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.ComputeNormalMap.ToString (),
					"\t\t\t\tDrawInputsFor_ComputeTexture2DType_ComputeNormalMap ();" + ret +
					InOutWs.InWs._InNodeReadableTextureInfo,
					"\t\t\t\tTexture2D_0_ComputeNormalMap ();",
					InOutWs.OutWs.texture2D_ + ret + InOutWs.OutWs.DrawTexture2DViewerForTextureTransform_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.textureComputer + ExprWs.Gv.identifiedObjects + 
					ExprWs.Gv.doIt + ExprWs.Gv.boolAll +
					ExprWs.Gv.channel + ExprWs.Gv.texture2DAll +
					"\t\tpublic enum NormalMapComputeIntensity \n\t\t{\n\t\t\t_1, _2, _3, _4, _5, _6, _7, _8, _9, _10,\n\t\t}\n\t\tpublic NormalMapComputeIntensity normalMapComputeIntensity;" + ret + ret, 

					ExprWs.ConstructorExpr.Channel (this) + ExprWs.ConstructorExpr.normalMapComputeIntensity (this) +
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) + 
					ExprWs.ConstructorExpr.BoolValues (this),
					"\t\tvoid Texture2D_0_ComputeNormalMap ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height);\n\n\n\t\t\t\t//Texture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t//TextureWriter.GetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\tint intensity = (int)normalMapComputeIntensity + 1;\n\n\t\t\t\tfloat amplifier = (float)intensity*10f;\n\n\t\t\t\ttex.SetPixels (TextureComputer.NormalColors (texture2DValues [0], boolValues [0], channel,\n\t\t\t\t\tamplifier));\n\n\t\t\t\ttex.name = \"Normal\";\n\n\t\t\t\ttex.Apply ();\n\n\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\ttex = null;\n\t\t\t}\n\t\t}" + ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Compute a Normal map based on your texture.",
						"You can choose the channel on which you want to compute the normal.",
						"You can also choose the intensity of your normal",
						"The flip Y toggle helps to fit with OpenGL or DirectX API conventions",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.Compress.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"Is highQuality Compression\", Skins.logicNodeLabel);\n\n\t\t\t\tDrawBoolInputField (0);",
					"\t\t\t\tTexture2D_0_Compress ();",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.doIt + ExprWs.Gv.texture2DAll +
					ExprWs.Gv.boolValues,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					"\t\tvoid Texture2D_0_Compress ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\ttexture2DValues [0].Compress (boolValues [0]);\n\n\t\t\t\ttexture2DValue = texture2DValues [0];\n\t\t\t}\n\t\t}\n\n" +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Compress texture into DXT format.",
						"Use this to compress textures generated at runtime. Compressed textures use less graphics",
						"memory and are faster to render.",
					},
					"https://docs.unity3d.com/ScriptReference/Texture2D.Compress.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.CaptureGameViewScreenshot.ToString (),
					"\t\t\t\tDrawInputsForCaptureGameViewScreenshot ();" + ret ,
					"",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.StringValues (this),
					//"\t\tvoid Texture2D_CaptureGameViewScreenshot ()\n\t\t{\n\t\t\tif (string.IsNullOrEmpty (stringValues [0]))\n\t\t\t\tstringValues [0] = \"Game View Screenshot\";\n\n\t\t\tstring path = TextureWriter.CreateNewFolder (TextureWriter.screenshotsFolderName)\n\t\t\t\t+ \"/\" + stringValues [0] + \".png\";\n\n\n\n\t\t\t#if UNITY_2017_1_OR_NEWER\n\t\t\tif (intValues [0] > 0)\n\t\t\t\tScreenCapture.CaptureScreenshot (path, intValues [0]);\n\t\t\telse\n\t\t\t\tScreenCapture.CaptureScreenshot (path);\n\t\t\t#else\n\t\t\tif (intValues [0] > 0)\n\t\t\t\tApplication.CaptureScreenshot (path, intValues [0]);\n\t\t\telse\n\t\t\t\tApplication.CaptureScreenshot (path);\n\t\t\t#endif\n\t\t}" + ret +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Captures a screenshot at path filename as a PNG file.",
						"If the image file exists already, it will be overwritten. The location where the image is",
						"written to can include a directory/folder list. For example on macOS the PNG file could be",
						"written to /tmp/ScreenGrab.png. With no directory/folder list the image will be written",
						"into the Project folder. CaptureScreenshot() can also be used from the Editor, for example",
						"in a custom EditorWindow. By default the screen grabbed image will also be written into the",
						"Project folder. Also, the Game view must be selected in order for the Editor screen capture",
						"to work.",
						"When superSize parameter is larger than 1, a larger resolution screenshot will be produced.",
						"For example, passing 4 will make the screenshot be 4x4 larger than it would normally be.",
						"This is useful to produce screenshots for printing.",
					},
					"https://docs.unity3d.com/ScriptReference/Application.CaptureScreenshot.html",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.blendTwoTextures.ToString (),
					InOutWs.InWs._InNodeReadableTextureInfo +
					"\t\t\t\tDrawTexture2DFieldInput (1);\n\n\t\t\t\tif (texture2DValues [0] != null && \n\t\t\t\t\ttexture2DValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tif (texture2DValues [0].width != texture2DValues [1].width)\n\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.label, textureNoSameWidthInfo, Skins.logicNodeLabel);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse if (texture2DValues [0].height != texture2DValues [1].height)\n\t\t\t\t\t{\n\t\t\t\t\t\tDrawLabelField (FieldDrawType.label, textureNoSameHeightInfo, Skins.logicNodeLabel);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n" +
					"\t\t\t\tDrawPrepareTexture2DInputs (PrepareTexture2DForWhat.blend);\n",
					"\t\t\t\tTexture2D_0_1_Blend ();",
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"SAVE\", Skins.logicNodeLabel);\n\t\t\t\tWriteToTheDiscBlendedTextureButton (Texture2D_WriteFile_TextureValue);" + ret +
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"Result Texture\", Skins.logicNodeLabel);" + ret + 
					InOutWs.OutWs.texture2D_ + ret + InOutWs.OutWs.DrawTexture2DViewerForTextureBlend_,
					ExprWs.Gv.colorArithmeticClass + ExprWs.Gv.identifiedObjects +
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.stringValues + ExprWs.Gv.colorAll +
					ExprWs.Gv.boolValues + ExprWs.Gv.texture2DAll + ExprWs.Gv.floatValues +
					ExprWs.Gv.colorBlendMode + ExprWs.Gv.WriteTextureFormat,

					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID, Enums.texture2DValues_1_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.StringValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.colorBlendMode (this) +
					ExprWs.ConstructorExpr.WriteTextureFormat (this) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.applyComputeColorNoGui +
					"\t\tTextureFormat GetTextureFormat (WriteTextureFormat writeTextureFormat)\n\t\t{\n\t\t\tTextureFormat textureFormat = TextureFormat.ARGB32;\n\n\t\t\tswitch (writeTextureFormat)\n\t\t\t{\n\t\t\tcase WriteTextureFormat.Alpha8:\n\t\t\t\ttextureFormat = TextureFormat.Alpha8;\n\t\t\t\tbreak;\n\n\t\t\tcase WriteTextureFormat.ARGB32:\n\t\t\t\ttextureFormat = TextureFormat.ARGB32;\n\t\t\t\tbreak;\n\n\t\t\tcase WriteTextureFormat.RFloat:\n\t\t\t\ttextureFormat = TextureFormat.RFloat;\n\t\t\t\tbreak;\n\n\t\t\tcase WriteTextureFormat.RGB24:\n\t\t\t\ttextureFormat = TextureFormat.RGB24;\n\t\t\t\tbreak;\n\n\t\t\tcase WriteTextureFormat.RGBA32:\n\t\t\t\ttextureFormat = TextureFormat.RGBA32;\n\t\t\t\tbreak;\n\n\t\t\tcase WriteTextureFormat.RGBAFloat:\n\t\t\t\ttextureFormat = TextureFormat.RGBAFloat;\n\t\t\t\tbreak;\n\n\t\t\tcase WriteTextureFormat.RGBAHalf:\n\t\t\t\ttextureFormat = TextureFormat.RGBAHalf;\n\t\t\t\tbreak;\n\n\t\t\tcase WriteTextureFormat.RGFloat:\n\t\t\t\ttextureFormat = TextureFormat.RGFloat;\n\t\t\t\tbreak;\n\n\t\t\tcase WriteTextureFormat.RGHalf:\n\t\t\t\ttextureFormat = TextureFormat.RGHalf;\n\t\t\t\tbreak;\n\n\t\t\tcase WriteTextureFormat.RHalf:\n\t\t\t\ttextureFormat = TextureFormat.RHalf;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn textureFormat;\n\t\t}" + ret +
					"\t\tvoid Texture2D_0_1_Blend ()\n\t\t{\n\t\t\tif (texture2DValues [0] != null)\n\t\t\t{\n\t\t\t\tif (texture2DValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tTexture2D tex = new Texture2D (texture2DValues [0].width, texture2DValues [0].height,\n\t\t\t\t\t\tGetTextureFormat (writeTextureFormat), boolValues [0], boolValues [1]);\n\n\t\t\t\t\tColor [] colors_1 = texture2DValues [1].GetPixels ();\n\n\t\t\t\t\tColor [] colors_0 = texture2DValues [0].GetPixels ();\n\t\t\t\t\t\t\n\t\t\t\t\tColor [] colorsRes = new Color [colors_1.Length];\n\n\t\t\t\t\tfor (int i = 0; i < colorsRes.Length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcolorValues [1] = colors_1 [i];\n\n\t\t\t\t\t\tcolorValues [0] = colors_0 [i];\n\n\t\t\t\t\t\tApplyComputeColorNoGUI ();\n\n\t\t\t\t\t\tcolorsRes [i] = colorValue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttex.SetPixels (colorsRes);\n\n\t\t\t\t\ttex.Apply ();\n\n\t\t\t\t\ttexture2DValue = tex;\n\n\t\t\t\t\ttex = null;\n\n\n\n\t\t\t\t\t//texture2DValue.SetPixels (colorsRes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n" +
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Blend two texture2D with different blend modes.",
						"Like in image editor programs",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTexture2DType.AuthorANewUniColorTexture.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"With width and height\");" + ret + InOutWs.InWs._vector2 + ret +
					"\t\t\t\tvector2Values [0] = Vector2.Max (new Vector2(8f, 8f), vector2Values [0]);" + 
					ret + InOutWs.InWs._color,
					"\t\t\t\tTexture2D_AuthorANewUniColorTexture ();",
					InOutWs.OutWs.texture2D_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2Values + ExprWs.Gv.texture2DValue + ExprWs.Gv.colorValues,
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.ColorValues (this),
					"\t\tvoid Texture2D_AuthorANewUniColorTexture ()\n\t\t{\n\t\t\tint bW = Mathf.CeilToInt (vector2Values[0].x);\n\n\t\t\tint bH = Mathf.CeilToInt (vector2Values[0].y);\n\n\t\t\tTexture2D tex = new Texture2D (bW, bH);\n\n\t\t\tColor[] colors = new Color [bW*bH];\n\n\t\t\tfor (int i = 0; i < colors.Length; i++)\n\t\t\t\tcolors [i] = colorValues [0];\n\n\t\t\ttex.SetPixels (colors);\n\n\n\n\t\t\ttex.Apply ();\n\n\t\t\ttexture2DValue = tex;\n\n\t\t\ttexture2DValue.name = \"AuthoredTexture\";\n\n\t\t\ttex = null;\n\t\t}\n\n" + 
					ExprWs.UMDecl.computeTexture2D,
					new string []
					{
						"",
						"Create a new uni-color texture2D",
					},
					"",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_Shader ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeShaderType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawInNodeInfo (\"Default value: In the above shader field\");\n" +
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondShaderNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "shaderValue = MezanixDiamondGetShader (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveShader (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.shader_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.shaderAll +
					ExprWs.Gv.identifiedObjects,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetShader + 
					ExprWs.UMDecl.MezanixDiamondRemoveShader +
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeShaderType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetShader (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.shaderValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.identifiedObjects,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetShader + ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.getName.ToString (),
					"",
					"\t\t\t\tif (shaderValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tstringValue = shaderValues [0].name;\n\t\t\t\t}",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.shaderValues + 
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"The name of the object (shader).",
					},
					"https://docs.unity3d.com/ScriptReference/Object-name.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.setName.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\tif (shaderValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tshaderValues [0].name = stringValues [0];\n\n\t\t\t\t\tshaderValue = shaderValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.shader_,
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.shaderAll + 
					ExprWs.Gv.stringValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}) +
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"The name of the object (shader).",
					},
					"https://docs.unity3d.com/ScriptReference/Object-name.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_shader_DrawInputs ();",
					"\t\t\t\tForGet_shader_Compute ();",
					"\t\t\t\tForGet_shader_DrawOutputs ();",
					ExprWs.Gv.shaderAll + 
					ExprWs.Gv.boolValues +
					ExprWs.Gv.identifiedObjects,
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValue_ID,}) +
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_shader_Compute +
					ExprWs.UMDecl.computeShader_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.WarmupAllShaders.ToString (),
					"",
					"\t\t\t\tShader.WarmupAllShaders ();",
					"",
					ExprWs.Gv.doIt,
					"",
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Fully load all shaders to prevent future performance hiccups..",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.WarmupAllShaders.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.setMaximumLOD.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tif (shaderValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tshaderValues [0].maximumLOD = intValues [0];\n\n\t\t\t\t\tshaderValue = shaderValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.shader_,
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.intValues + ExprWs.Gv.shaderAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}) + 
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Shader LOD level for this shader.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader-maximumLOD.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.getRenderQueue.ToString (),
					"",
					"\t\t\t\tif (shaderValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tintValue = shaderValues [0].renderQueue;\n\t\t\t\t}",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.intValue + ExprWs.Gv.shaderValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Render queue of this shader. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Shader-renderQueue.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.getMaximumLOD.ToString (),
					"",
					"\t\t\t\tif (shaderValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tintValue = shaderValues [0].maximumLOD;\n\t\t\t\t}",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.intValue + ExprWs.Gv.shaderValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Shader LOD level for this shader.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader-maximumLOD.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.getIsSupported.ToString (),
					"",
					"\t\t\t\tif (shaderValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tboolValue = shaderValues [0].isSupported;\n\t\t\t\t}",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.identifiedObjects + ExprWs.Gv.boolValue + ExprWs.Gv.shaderValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Can this shader run on the end-users graphics card? (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Shader-isSupported.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersSetGlobalVector4.ToString (),
					"\t\t\t\tDrawShadersGetGlobalPropertieModeEnum ();" + ret + InOutWs.InWs._vector4,
					"\t\t\t\tswitch (shadersGetGlobalPropertieMode)\n\t\t\t\t{\n\t\t\t\tcase ShadersGetGlobalPropertieMode.byName:\n\t\t\t\t\tShader.SetGlobalVector (stringValues [0], vector4Values [0]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShadersGetGlobalPropertieMode.byNameID:\n\t\t\t\t\tShader.SetGlobalVector (intValues [0], vector4Values [0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}",
					"",
					ExprWs.Gv.shadersGetGlobalPropertieMode  + ExprWs.Gv.doIt + ExprWs.Gv.stringValues + 
					ExprWs.Gv.intValues + ExprWs.Gv.vector4Values,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.Vector4Values (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.ShaderGetGlobalPropertyMode (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Sets a global vector property for all shaders.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalVector.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersSetGlobalTexture.ToString (),
					"\t\t\t\tDrawShadersGetGlobalPropertieModeEnum ();" + ret + InOutWs.InWs._texture2D,
					"\t\t\t\tif (texture2DValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tswitch (shadersGetGlobalPropertieMode)\n\t\t\t\t\t{\n\t\t\t\t\tcase ShadersGetGlobalPropertieMode.byName:\n\t\t\t\t\t\tShader.SetGlobalTexture (stringValues [0], texture2DValues [0]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShadersGetGlobalPropertieMode.byNameID:\n\t\t\t\t\t\tShader.SetGlobalTexture (intValues [0], texture2DValues [0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}",
					"",
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.shadersGetGlobalPropertieMode +
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.intValues + ExprWs.Gv.texture2DValues,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ConstructorGetIdentifiedObject (new string [] {Enums.texture2DValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this) + 
					ExprWs.ConstructorExpr.ShaderGetGlobalPropertyMode (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Sets a global texture property for all shaders.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalTexture.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersSetGlobalMaximumLOD.ToString (),
					"\t\t\t\tDrawInputsForShaderSetMaximumLOD ();",
					"\t\t\t\tShader.globalMaximumLOD = intValues [0];",
					"",
					ExprWs.Gv.doIt + ExprWs.Gv.intValues, 
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Shader LOD level for all shaders.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader-globalMaximumLOD.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersSetGlobalInt.ToString (),
					"\t\t\t\tDrawShadersGetGlobalPropertieModeEnum ();" + ret + InOutWs.InWs._int_1,
					"\t\t\t\tswitch (shadersGetGlobalPropertieMode)\n\t\t\t\t{\n\t\t\t\tcase ShadersGetGlobalPropertieMode.byName:\n\t\t\t\t\tShader.SetGlobalInt (stringValues [0], intValues [1]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShadersGetGlobalPropertieMode.byNameID:\n\t\t\t\t\tShader.SetGlobalInt (intValues [0], intValues [1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}",
					"",
					ExprWs.Gv.shadersGetGlobalPropertieMode +
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.IntValues (this) +
					ExprWs.ConstructorExpr.ShaderGetGlobalPropertyMode (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Sets a global int property for all shaders.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalInt.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersSetGlobalFloat.ToString (),
					"\t\t\t\tDrawShadersGetGlobalPropertieModeEnum ();" + ret + InOutWs.InWs._float,
					"\t\t\t\tswitch (shadersGetGlobalPropertieMode)\n\t\t\t\t{\n\t\t\t\tcase ShadersGetGlobalPropertieMode.byName:\n\t\t\t\t\tShader.SetGlobalFloat (stringValues [0], floatValues [0]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShadersGetGlobalPropertieMode.byNameID:\n\t\t\t\t\tShader.SetGlobalFloat (intValues [0], floatValues [0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}",
					"",
					ExprWs.Gv.shadersGetGlobalPropertieMode +
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.intValues + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.ShaderGetGlobalPropertyMode (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Sets a global float property for all shaders.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalFloat.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersSetGlobalColor.ToString (),
					"\t\t\t\tDrawShadersGetGlobalPropertieModeEnum ();" + ret + InOutWs.InWs._color,
					"\t\t\t\tswitch (shadersGetGlobalPropertieMode)\n\t\t\t\t{\n\t\t\t\tcase ShadersGetGlobalPropertieMode.byName:\n\t\t\t\t\tShader.SetGlobalColor (stringValues [0], colorValues [0]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShadersGetGlobalPropertieMode.byNameID:\n\t\t\t\t\tShader.SetGlobalColor (intValues [0], colorValues [0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}",
					"",
					ExprWs.Gv.shadersGetGlobalPropertieMode +
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.intValues + ExprWs.Gv.colorValues,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.ShaderGetGlobalPropertyMode (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Sets a global color property for all shaders.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.SetGlobalColor.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersPropertyToID.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\tintValue = Shader.PropertyToID (stringValues [0]);",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Gets unique identifier for a shader property name.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.PropertyToID.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersIsKeywordEnabled.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\tboolValue = Shader.IsKeywordEnabled (stringValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Is global shader keyword enabled?",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.IsKeywordEnabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersGetGlobalMaximumLOD.ToString (),
					"",
					"\t\t\t\tintValue = Shader.globalMaximumLOD;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValue,
					"",
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Shader LOD level for all shaders.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader-globalMaximumLOD.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersEnableKeyword.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\tShader.EnableKeyword (stringValues [0]);",
					"",
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Set a global shader keyword.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.EnableKeyword.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.forAllShadersDisableKeyword.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\tShader.DisableKeyword (stringValues [0]);",
					"",
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Unset a global shader keyword.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.DisableKeyword.html",
					""),

				new EnumInputComputeOutput (
					ComputeShaderType.FindAShaderByName.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\tshaderValue = Shader.Find (stringValues [0]);",
					InOutWs.OutWs.shader_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.shaderValue,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeShader,
					new string []
					{
						"",
						"Finds a shader with the given name.",
						"Shader.Find can be used to switch to another shader without having to keep a reference to the shader.",
						"name is the name you can see in the shader popup of any material, for example 'Standard', 'Unlit/Texture',",
						"'Legacy Shaders/Diffuse' etc.",
					},
					"https://docs.unity3d.com/ScriptReference/Shader.Find.html",
					""),
			};
		}


		//IEnumerator RunAnimationCurve_vector3 ()
		//{
		//	if ( ! boolValues [0])
		//	{
		//		boolValues [0] = true;
		//
		//		float t = 0f;
		//
		//		float rate = 1f / floatValues [2];
		//
		//		while (t < 1f)
		//		{
		//			t += Time.deltaTime * rate;
		//
		//			vector3Value = Vector3.Lerp (vector3Values [0], vector3Values [1], animationCurve_.Evaluate (t));
		//
		//			yield return 0;
		//		}
		//
		//		boolValues [0] = false;
		//	}
		//	yield return 0;
		//}

		EnumInputComputeOutput [] EnumInputComputeOutput_Vector3 ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeVector3Type.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondVector3Names (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._vector3 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "vector3Value = MezanixDiamondGetVector3 (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveVector3 (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.vector3All,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetVector3 + ExprWs.UMDecl.MezanixDiamondRemoveVector3 +
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._vector3 + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetVector3 (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.vector3Values + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetVector3 + ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				

				new EnumInputComputeOutput (
					ComputeVector3Type.animationCurvePickValue.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._vector3 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._vector3_1 +
					"\t\t\t\tDrawLogicNodeLabel (\"Pick curve value of this time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);\n",
					"\t\t\t\tvector3Value = Vector3.Lerp (vector3Values [0], vector3Values [1], animationCurve_.Evaluate (floatValues [2]));",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve +
					ExprWs.Gv.vector3All ,
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.AnimationCurve (this) +
					ExprWs.ConstructorExpr.Vector3Value (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Pick a vector value on a curve,",
						"between the start and the end value.",
						"You have to choose the time corresponding to your value",
						"The time is the horizontal axis of the curve.",
						"The picked vector, the start and the end vectors are on the",
						"vertical axis of the curve",
						"",
						"About the horizontal axis:",
						"This axis is commonly called time, but in the case of this node",
						"it is an axis having values from 0 to 1 (normalized),",
						"so this node is usful for drawing any curves shape and picking",
						"a vector value (vertical axis) on the curve corresponding of any",
						"position in the horizontal axis, 0 is the left of the horizontal axis,",
						"1 is its right and between them is a value on the axis.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector3Type.animationCurve.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._vector3 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._vector3_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve animation time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Max (0.1f, floatValues [2]);\n",
					"\t\t\t\t" + CsScriptWriter.FromLogicNodeToMonoBehaviour (logic.node.graph, logic.node, logic) + "." +
					"StartCoroutine (RunAnimationCurve_vector3 ());",
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve + ExprWs.Gv.boolValues + 
					ExprWs.Gv.vector3All,
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tboolValues [0] = false;\n" + 
					ExprWs.ConstructorExpr.AnimationCurve (this) + ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.Vector3Value (this),
					"\t\tIEnumerator RunAnimationCurve_vector3 ()\n\t\t{\n\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tboolValues [0] = true;\n\t\t\n\t\t\t\tfloat t = 0f;\n\t\t\n\t\t\t\tfloat rate = 1f / floatValues [2];\n\t\t\n\t\t\t\twhile (t < 1f)\n\t\t\t\t{\n\t\t\t\t\tt += Time.deltaTime * rate;\n\t\t\n\t\t\t\t\tvector3Value = Vector3.Lerp (vector3Values [0], vector3Values [1], animationCurve_.Evaluate (t));\n\t\t\n\t\t\t\t\tyield return 0;\n\t\t\t\t}\n\t\t\n\t\t\t\tboolValues [0] = false;\n\t\t\t}\n\t\t\tyield return 0;\n\t\t}\n" +
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Animate a vector value on a curve,",
						"between the start and the end value.",
						"You have to define the animation time (duration).",
						"The time is the horizontal axis of the curve.",
						"The animated vector, the start and the end vectors are on the",
						"vertical axis of the curve",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector3Type.max.ToString (),
					InOutWs.InWs._vector3_and_1,
					tab4 + "vector3Value = new Vector3 (\n\t\t\t\t\tMathf.Max (vector3Values [0].x, vector3Values [1].x)," +
					"\n\t\t\t\t\tMathf.Max (vector3Values [0].y, vector3Values [1].y)," +
					"\n\t\t\t\t\tMathf.Max (vector3Values [0].z, vector3Values [1].z));",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Returns the max value of the first and the second values",
						"Like the max for a float variable acting separately",
						"on both x, y, and z components of the vector",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.min.ToString (),
					InOutWs.InWs._vector3_and_1,
					tab4 + "vector3Value = new Vector3 (\n\t\t\t\t\tMathf.Min (vector3Values [0].x, vector3Values [1].x),\n\t\t\t\t\tMathf.Min (vector3Values [0].y, vector3Values [1].y),\n\t\t\t\t\tMathf.Min (vector3Values [0].z, vector3Values [1].z));",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Returns the min value of the first and the second values",
						"Like the min for a float variable acting separately",
						"on both x, y, and z components of the vector",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.normalize.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = vector3Values [0].normalized;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Returns this vector with a magnitude of 1 (Read Only).",
					},
					"https://docs.unity3d.com/ScriptReference/Vector3-normalized.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.ClampMagnitude.ToString (),
					InOutWs.InWs._vector3 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Max Length\");\n" +
					InOutWs.InWs._float,
					tab4 + "vector3Value = Vector3.ClampMagnitude (vector3Values [0], floatValues [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Returns a copy of vector with its magnitude clamped to maxLength.",
					},
					"https://docs.unity3d.com/ScriptReference/Vector3.ClampMagnitude.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.magnitude.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "floatValue = vector3Values [0].magnitude;",		
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Get the magnitude (length) of the vector",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector3Type.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_vector3_DrawInputs ();",
					"\t\t\t\tForGet_vector3_Compute ();",
					"\t\t\t\tForGet_vector3_DrawOutputs ();",
					ExprWs.Gv.vector3All + 
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.Vector3Value (this) +
					ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_vector3_Compute +
					ExprWs.UMDecl.computeVector3_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.toString.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "stringValue = vector3Values [0].ToString ();",		
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.stringValue,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Get a string (text) format of the value",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.Switch.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Want this value?\");" + ret +
					InOutWs.InWs._bool + ret +
					InOutWs.InWs._vector3 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Or this One?\");" + ret +
					InOutWs.InWs._bool_1 + ret +
					InOutWs.InWs._vector3_1,
					"\t\t\t\tif (boolValues [0] && ! boolValues [1])\n" +
					"\t\t\t\t{\n\t\t\t\t\tvector3Value = vector3Values [0];\n\t\t\t\t}\n" +
					"\t\t\t\tif (boolValues [1] && ! boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\tvector3Value = vector3Values [1];\n\t\t\t\t}\n",		
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Get the value corresponding of the checked box,",
						"if noth boxes have the same value, the node will not compute",
						"and it will conserve it's old output",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.toVector2.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector2Value = new Vector2 (vector3Values [0].x, vector3Values [0].y);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.vector2Value,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Ignore Z, put X and Y in an output Vector2",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.subtract.ToString (),
					InOutWs.InWs._vector3_and_1,
					tab4 + "vector3Value = vector3Values [0] - vector3Values [1];",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Subtract two vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.randomRotationUniform.ToString (),
					"",
					tab4 + "vector3Value = UnityEngine.Random.rotationUniform.eulerAngles;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Value,
					"",
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Returns a random rotation with uniform distribution",
					},
					"https://docs.unity3d.com/ScriptReference/Random-rotationUniform.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.randomRotation.ToString (),
					"",
					tab4 + "vector3Value = UnityEngine.Random.rotation.eulerAngles;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Value,
					"",
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Returns a random rotation",
					},
					"https://docs.unity3d.com/ScriptReference/Random-rotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.putThisFloatInZ.ToString (),
					InOutWs.InWs._vector3 + ret + InOutWs.InWs._float,
					tab4 + "vector3Value = new Vector3 (vector3Values [0].x, vector3Values [0].y, floatValues [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Modifie the Z value of the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.putThisFloatInYZ.ToString (),
					InOutWs.InWs._vector3 + ret + InOutWs.InWs._float,
					tab4 + "vector3Value = new Vector3 (vector3Values [0].x, floatValues [0], floatValues [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Put the same value on the Y and the Z of the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.putThisFloatInY.ToString (),
					InOutWs.InWs._vector3 + ret + InOutWs.InWs._float,
					tab4 + "vector3Value = new Vector3 (vector3Values [0].x, floatValues [0], vector3Values [0].z);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Modifie the Y value of the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.putThisFloatInXZ.ToString (),
					InOutWs.InWs._vector3 + ret + InOutWs.InWs._float,
					tab4 + "vector3Value = new Vector3 (floatValues [0], vector3Values [0].y, floatValues [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Put the same value on the X and the Z of the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.putThisFloatInXYZ.ToString (),
					InOutWs.InWs._vector3 + ret + InOutWs.InWs._float,
					tab4 + "vector3Value = new Vector3 (floatValues [0], floatValues [0], floatValues [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Get a vector3 with same values on X, Y and Z",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.putThisFloatInXY.ToString (),
					InOutWs.InWs._vector3 + ret + InOutWs.InWs._float,
					tab4 + "vector3Value = new Vector3 (floatValues [0], floatValues [0], vector3Values [0].z);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Put the same value on the X and the Y of the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.putThisFloatInX.ToString (),
					InOutWs.InWs._vector3 + ret + InOutWs.InWs._float,
					tab4 + "vector3Value = new Vector3 (floatValues [0], vector3Values [0].y, vector3Values [0].z);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Modifie the X value of the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.onUnitSphere.ToString (),
					"",
					tab4 + "vector3Value = UnityEngine.Random.onUnitSphere;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Value,
					"",
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Returns a random point on the surface of a sphere with radius 1",
					},
					"https://docs.unity3d.com/ScriptReference/Random-onUnitSphere.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.multiply.ToString (),
					InOutWs.InWs._vector3 + ret + InOutWs.InWs._float,
					tab4 + "vector3Value = vector3Values [0] * floatValues [0];",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Multiply vector3 by a float (decimal) value.",
						"This cause a scaling of the vector2 without changing its direction",
						"If the float value is negative, it will flip the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.insideUnitSphere.ToString (),
					"",
					tab4 + "vector3Value = UnityEngine.Random.insideUnitSphere;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Value,
					"",
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Returns a random point inside a sphere with radius 1",
					},
					"https://docs.unity3d.com/ScriptReference/Random-insideUnitSphere.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.getFloatFromZ.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "floatValue = vector3Values [0].z;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Get the Z value of the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.getFloatFromY.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "floatValue = vector3Values [0].y;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Get the Y value of the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.getFloatFromX.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "floatValue = vector3Values [0].x;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Get the X value of the vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.dot.ToString (),
					InOutWs.InWs._vector3_and_1,
					tab4 + "floatValue = Vector3.Dot (vector3Values [0], vector3Values [1]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Dot Product of two vectors.",
						"The dot product is a float value equal to the magnitudes of the two vectors",
						"multiplied together and then multiplied by the cosine of the angle between them.",
						"For normalized vectors Dot returns 1 if they point in exactly the same direction,",
						"-1 if they point in completely opposite directions and zero if the vectors are",
						"perpendicular.",
					},
					"https://docs.unity3d.com/ScriptReference/Vector3.Dot.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.cross.ToString (),
					InOutWs.InWs._vector3_and_1,
					tab4 + "vector3Value = Vector3.Cross (vector3Values [0], vector3Values [1]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Cross Product of two vectors.",
						"The cross product of two vectors results in a third vector which is perpendicular",
						"to the two input vectors. The result's magnitude is equal to the magnitudes of",
						"the two inputs multiplied together and then multiplied by the sine of the angle between",
						"the inputs.",
						"You can determine the direction of the result vector using the 'left hand rule'.",
					},
					"https://docs.unity3d.com/ScriptReference/Vector3.Cross.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.areParallel.ToString (),
					InOutWs.InWs._vector3_and_1,
					tab4 + "boolValue = Vector3.Cross (vector3Values [0], vector3Values [1]).magnitude == 0f;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Are these vector3 parallel?",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.areOrthogonal.ToString (),
					InOutWs.InWs._vector3_and_1,
					tab4 + "boolValue = Vector3.Dot (vector3Values [0], vector3Values [1]) == 0f;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Are these vector3 orthogonal (perpendicular, angle of 90°)?",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.areEqual.ToString (),
					InOutWs.InWs._vector3_and_1,
					tab4 + "boolValue = vector3Values [0] == vector3Values [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3Values + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Are these vector3 equal?",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector3Type.Add.ToString (),
					InOutWs.InWs._vector3_and_1,
					tab4 + "vector3Value = vector3Values [0] + vector3Values [1];",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector3All,
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeVector3,
					new string []
					{
						"",
						"Add two vector3",
					},
					"",
					""),
			};

		}

		//IEnumerator RunAnimationCurve_vector2 ()
		//{
		//	if ( ! boolValues [0])
		//	{
		//		boolValues [0] = true;
		//
		//		float t = 0f;
		//
		//		float rate = 1f / floatValues [2];
		//
		//		while (t < 1f)
		//		{
		//			t += Time.deltaTime * rate;
		//
		//			vector2Value = Vector2.Lerp (vector2Values [0], vector2Values [1], animationCurve_.Evaluate (t));
		//
		//			yield return 0;
		//		}
		//
		//		boolValues [0] = false;
		//	}
		//	yield return 0;
		//}

		EnumInputComputeOutput [] EnumInputComputeOutput_Vector2 ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeVector2Type.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondVector2Names (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._vector2 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "vector2Value = MezanixDiamondGetVector2 (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveVector2 (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.vector2All,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetVector2 + ExprWs.UMDecl.MezanixDiamondRemoveVector2 +
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._vector2 + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetVector2 (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.vector2Values + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.Vector2Values (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetVector2 + ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeVector2Type.animationCurvePickValue.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._vector2 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._vector2_1 +
					"\t\t\t\tDrawLogicNodeLabel (\"Pick curve value of this time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);\n",
					"\t\t\t\tvector2Value = Vector2.Lerp (vector2Values [0], vector2Values [1], animationCurve_.Evaluate (floatValues [2]));",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve +
					ExprWs.Gv.vector2All ,
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.Vector2Values (this) +
					ExprWs.ConstructorExpr.AnimationCurve (this) +
					ExprWs.ConstructorExpr.Vector2Value (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Pick a vector value on a curve,",
						"between the start and the end value.",
						"You have to choose the time corresponding to your value",
						"The time is the horizontal axis of the curve.",
						"The picked vector, the start and the end vectors are on the",
						"vertical axis of the curve",
						"",
						"About the horizontal axis:",
						"This axis is commonly called time, but in the case of this node",
						"it is an axis having values from 0 to 1 (normalized),",
						"so this node is usful for drawing any curves shape and picking",
						"a vector value (vertical axis) on the curve corresponding of any",
						"position in the horizontal axis, 0 is the left of the horizontal axis,",
						"1 is its right and between them is a value on the axis.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector2Type.animationCurve.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._vector2 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._vector2_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve animation time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Max (0.1f, floatValues [2]);\n",
					"\t\t\t\t" + CsScriptWriter.FromLogicNodeToMonoBehaviour (logic.node.graph, logic.node, logic) + "." +
					"StartCoroutine (RunAnimationCurve_vector2 ());",
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve + ExprWs.Gv.boolValues + 
					ExprWs.Gv.vector2All,
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tboolValues [0] = false;\n" + 
					ExprWs.ConstructorExpr.AnimationCurve (this) + ExprWs.ConstructorExpr.Vector2Values (this) +
					ExprWs.ConstructorExpr.Vector2Value (this),
					"\t\tIEnumerator RunAnimationCurve_vector2 ()\n\t\t{\n\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tboolValues [0] = true;\n\t\t\n\t\t\t\tfloat t = 0f;\n\t\t\n\t\t\t\tfloat rate = 1f / floatValues [2];\n\t\t\n\t\t\t\twhile (t < 1f)\n\t\t\t\t{\n\t\t\t\t\tt += Time.deltaTime * rate;\n\t\t\n\t\t\t\t\tvector2Value = Vector2.Lerp (vector2Values [0], vector2Values [1], animationCurve_.Evaluate (t));\n\t\t\n\t\t\t\t\tyield return 0;\n\t\t\t\t}\n\t\t\n\t\t\t\tboolValues [0] = false;\n\t\t\t}\n\t\t\tyield return 0;\n\t\t}\n" +
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Animate a vector value on a curve,",
						"between the start and the end value.",
						"You have to define the animation time (duration).",
						"The time is the horizontal axis of the curve.",
						"The animated vector, the start and the end vectors are on the",
						"vertical axis of the curve",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector2Type.max.ToString (),
					InOutWs.InWs._vector2_and_1,
					tab4 + "vector2Value = new Vector2 (\n\t\t\t\t\tMathf.Max (vector2Values [0].x, vector2Values [1].x)," +
						"\n\t\t\t\t\tMathf.Max (vector2Values [0].y, vector2Values [1].y));",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Returns the max value of the first and the second values",
						"Like the max for a float variable acting separately",
						"on both x and y components of the vector",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.min.ToString (),
					InOutWs.InWs._vector2_and_1,
					tab4 + "vector2Value = new Vector2 (\n\t\t\t\t\tMathf.Min (vector2Values [0].x, vector2Values [1].x)," +
						"\n\t\t\t\t\tMathf.Min (vector2Values [0].y, vector2Values [1].y));",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Returns the min value of the first and the second values",
						"Like the min for a float variable acting separately",
						"on both x and y components of the vector",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeVector2Type.normalize.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "vector2Value = vector2Values [0].normalized;",		
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Returns this vector with a magnitude of 1 (Read Only).",
					},
					"https://docs.unity3d.com/ScriptReference/Vector2-normalized.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.ClampMagnitude.ToString (),
					InOutWs.InWs._vector2 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Max Length\");\n" + 
					InOutWs.InWs._float,
					tab4 + "vector2Value = Vector2.ClampMagnitude (vector2Values [0], floatValues [0]);",		
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Returns a copy of vector with its magnitude clamped to maxLength.",
					},
					"https://docs.unity3d.com/ScriptReference/Vector2.ClampMagnitude.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.magnitude.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "floatValue = vector2Values [0].magnitude;",		
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Get the magnitude (length) of the vector",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector2Type.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_vector2_DrawInputs ();",
					"\t\t\t\tForGet_vector2_Compute ();",
					"\t\t\t\tForGet_vector2_DrawOutputs ();",
					ExprWs.Gv.vector2All + 
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.Vector2Value (this) +
					ExprWs.ConstructorExpr.Vector2Values (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_vector2_Compute +
					ExprWs.UMDecl.computeVector2_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeVector2Type.toRect.ToString (),
					InOutWs.InWs._vector2_and_1,
					tab4 + "rectValue = new Rect (vector2Values [0], vector2Values [1]);",
					InOutWs.OutWs.rect_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2Values + ExprWs.Gv.rectValue,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Use two vector2 to get a rect, ",
						"the first vector is for the Rect position and the second one is for the it's size",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.toString.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "stringValue = vector2Values [0].ToString ();",		
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2Values + ExprWs.Gv.stringValue,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Get a string (text) format of the value",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.Switch.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Want this value?\");" + ret +
					InOutWs.InWs._bool + ret +
					InOutWs.InWs._vector2 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Or this One?\");" + ret +
					InOutWs.InWs._bool_1 + ret +
					InOutWs.InWs._vector2_1,
					"\t\t\t\tif (boolValues [0] && ! boolValues [1])\n" +
					"\t\t\t\t{\n\t\t\t\t\tvector2Value = vector2Values [0];\n\t\t\t\t}\n" +
					"\t\t\t\tif (boolValues [1] && ! boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\tvector2Value = vector2Values [1];\n\t\t\t\t}\n",		
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Get the value corresponding of the checked box,",
						"if noth boxes have the same value, the node will not compute",
						"and it will conserve it's old output",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.subtract.ToString (),
					InOutWs.InWs._vector2_and_1,
					tab4 + "vector2Value = vector2Values [0] - vector2Values [1];",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Subtract two vector2",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.putThisFloatInY.ToString (),
					InOutWs.InWs._vector2 + InOutWs.InWs._float,
					tab4 + "vector2Value = new Vector2 (vector2Values [0].x, floatValues [0]);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Modifies the Y value of the vector2",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.putThisFloatInXY.ToString (),
					InOutWs.InWs._vector2 + InOutWs.InWs._float,
					tab4 + "vector2Value = new Vector2 (floatValues [0], floatValues [0]);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Get a vector2 with same values on X and Y",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.putThisFloatInX.ToString (),
					InOutWs.InWs._vector2 + InOutWs.InWs._float,
					tab4 + "vector2Value = new Vector2 (floatValues [0], vector2Values [0].y);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Modifie the X value of the vector2",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.onUnitCircle.ToString (),
					"",
					"\t\t\t\tVector3 v3 = UnityEngine.Random.onUnitSphere;\n\t\t\t\tvector2Value = new Vector2 (v3.x, v3.z).normalized;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2Value,
					"",
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Returns a random point on a circle with radius 1",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.multiply.ToString (),
					InOutWs.InWs._float + ret + InOutWs.InWs._vector2,
					tab4 + "vector2Value = vector2Values [0] * floatValues [0];",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.vector2All,
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Multiply vector2 by a float (decimal) value.",
						"This cause a scaling of the vector2 without changing its direction",
						"If the float value is negative, it will flip the vector2",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.areParallel.ToString (),
					InOutWs.InWs._vector2_and_1,
					"\t\t\t\tboolValue = Vector3.Cross (\n\t\t\t\t\tnew Vector3(vector2Values [0].x, vector2Values [0].y, 0f), \n\t\t\t\t\tnew Vector3(vector2Values [1].x, vector2Values [1].y, 0f)).magnitude == 0f;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.boolValue + ExprWs.Gv.vector2Values,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Are these vector2 parallel?",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.areOrthogonal.ToString (),
					InOutWs.InWs._vector2_and_1,
					tab4 + "boolValue = Vector2.Dot (vector2Values [0], vector2Values [1]) == 0f;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.boolValue + ExprWs.Gv.vector2Values,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Are these vector2 orthogonal (perpendicular, angle of 90°)?",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeVector2Type.areEqual.ToString (),
					InOutWs.InWs._vector2_and_1,
					tab4 + "boolValue = vector2Values [0] == vector2Values [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.boolValue + ExprWs.Gv.vector2Values,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Are these vector2 equal?",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.insideUnitCircle.ToString (),
					"",
					tab4 + "vector2Value = UnityEngine.Random.insideUnitCircle;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2Value,
					"",
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Returns a random point inside a circle with radius 1",
					},
					"https://docs.unity3d.com/ScriptReference/Random-insideUnitCircle.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.getFloatFromY.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "floatValue = vector2Values [0].y;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Get the Y value of the vector2",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.getFloatFromX.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "floatValue = vector2Values [0].x;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Get the X value of the vector2",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.dot.ToString (),
					InOutWs.InWs._vector2_and_1,
					tab4 + "floatValue = Vector2.Dot (vector2Values [0], vector2Values [1]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2Values + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"Dot Product of two vectors.",
						"For normalized vectors Dot returns 1 if they point in exactly the same direction;",
						"-1 if they point in completely opposite directions; and a number in between for other cases",
						"(e.g. Dot returns zero if vectors are perpendicular).",
						"For vectors of arbitrary length the Dot return values are similar:",
						"they get larger when the angle between vectors decreases.",
					},
					"https://docs.unity3d.com/ScriptReference/Vector2.Dot.html",
					""),

				new EnumInputComputeOutput (
					ComputeVector2Type.Add.ToString (),
					InOutWs.InWs._vector2_and_1,
					tab4 + "vector2Value = vector2Values [0] + vector2Values [1];",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.vector2All,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeVector2,
					new string []
					{
						"",
						"Add two vector2",
					},
					"",
					""),
			};
		}


		public enum StringOperations 
		{
			Contains,

			EndsWith,

			GetHashCode,

			GetIndexOf,

			Insert,

			LastIndexOf,

			GetLength,

			PadLeft,

			PadRight,

			Remove,

			StartsWith,

			Substring,

			ToLower,

			ToLowerInvariant,

			ToUpper,

			ToUpperInvariant,

			Trim,

			TrimEnd,

			TrimStart,

			toFloat,

			toInt,
		}; 
		public StringOperations stringOperations;
		//DrawInNodeInfo ("invalid string format");
		void StringOperations_Inputs ()
		{
			switch (stringOperations)
			{
			case StringOperations.toInt:
				DrawLogicNodeLabel ("This", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				try
				{
					int.Parse (stringValues [0]);
				}
				catch
				{
					DrawInNodeInfo ("invalid string format");

					return;
				}
				break;

			case StringOperations.toFloat:
				DrawLogicNodeLabel ("This", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				try
				{
					float.Parse (stringValues [0]);
				}
				catch
				{
					DrawInNodeInfo ("invalid string format");

					return;
				}
				break;

			case StringOperations.TrimEnd:
				DrawLogicNodeLabel ("This", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.TrimStart:
				DrawLogicNodeLabel ("This", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.Trim:
				DrawLogicNodeLabel ("This", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.ToUpperInvariant:
				DrawLogicNodeLabel ("From this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.ToUpper:
				DrawLogicNodeLabel ("From this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.ToLowerInvariant:
				DrawLogicNodeLabel ("From this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.ToLower:
				DrawLogicNodeLabel ("From this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.Substring:
				DrawLogicNodeLabel ("From this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("Start index", 0, 2);
				DrawIntInputField (0, 1, 2);

				DrawLogicNodeLabel ("Length", 0, 2);
				DrawIntInputField (1, 1, 2);
				break;

			case StringOperations.StartsWith:
				DrawLogicNodeLabel ("Is this?", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("Stars with this", 0, 2);
				DrawStringInputField (1, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.Remove:
				DrawLogicNodeLabel ("From this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("Start index", 0, 2);
				DrawIntInputField (0, 1, 2);

				DrawLogicNodeLabel ("Count", 0, 2);
				DrawIntInputField (1, 1, 2);
				break;

			case StringOperations.PadRight:
				DrawLogicNodeLabel ("Of this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("By width", 0, 2);
				DrawIntInputField (0, 1, 2);
				break;

			case StringOperations.PadLeft:
				DrawLogicNodeLabel ("Of this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("By width", 0, 2);
				DrawIntInputField (0, 1, 2);
				break;

			case StringOperations.GetLength:
				DrawLogicNodeLabel ("Of this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.LastIndexOf:
				DrawLogicNodeLabel ("Inside this?", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("Get last ID of", 0, 2);
				DrawStringInputField (1, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.Insert:
				DrawLogicNodeLabel ("Inside this?", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("Insert this", 0, 2);
				DrawStringInputField (1, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("At Index", 0, 2);
				DrawIntInputField (0, 1, 2);
				break;

			case StringOperations.GetIndexOf:
				DrawLogicNodeLabel ("Inside this?", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("Get index of this", 0, 2);
				DrawStringInputField (1, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.GetHashCode:
				DrawLogicNodeLabel ("Of this", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.EndsWith:
				DrawLogicNodeLabel ("Is this?", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("Ends with this", 0, 2);
				DrawStringInputField (1, stringInputFieldForWhat.general, 1, 2);
				break;

			case StringOperations.Contains:
				DrawLogicNodeLabel ("Is this?", 0, 2);
				DrawStringInputField (0, stringInputFieldForWhat.general, 1, 2);

				DrawLogicNodeLabel ("Contains this", 0, 2);
				DrawStringInputField (1, stringInputFieldForWhat.general, 1, 2);
				break;


			}
		}
		void StringOperations_Compute ()
		{
			switch (stringOperations)
			{
			case StringOperations.toInt:
				try
				{
					intValue = int.Parse (stringValues [0]);
				}
				catch
				{
					Debug.LogWarning ("invalid string format");
				}
				break;

			case StringOperations.toFloat:
				try
				{
					floatValue = float.Parse (stringValues [0]);
				}
				catch
				{
					Debug.LogWarning ("invalid string format");
				}
				break;

			case StringOperations.TrimEnd:
				stringValue = stringValues [0].TrimEnd ();
				break;

			case StringOperations.TrimStart:
				stringValue = stringValues [0].TrimStart ();
				break;

			case StringOperations.Trim:
				stringValue = stringValues [0].Trim ();
				break;

			case StringOperations.ToUpperInvariant:
				stringValue = stringValues [0].ToUpperInvariant ();
				break;

			case StringOperations.ToUpper:
				stringValue = stringValues [0].ToUpper ();
				break;

			case StringOperations.ToLowerInvariant:
				stringValue = stringValues [0].ToLowerInvariant ();
				break;

			case StringOperations.ToLower:
				stringValue = stringValues [0].ToLower ();
				break;

			case StringOperations.Substring:
				stringValue = stringValues [0].Substring (intValues [0], intValues [1]);
				break;

			case StringOperations.StartsWith:
				boolValue = stringValues [0].StartsWith (stringValues [1]);
				break;

			case StringOperations.Remove:
				stringValue = stringValues [0].Remove (intValues [0], intValues [1]);
				break;

			case StringOperations.PadRight:
				stringValue = stringValues [0].PadRight (intValues [0]);
				break;

			case StringOperations.PadLeft:
				stringValue = stringValues [0].PadLeft (intValues [0]);
				break;

			case StringOperations.GetLength:
				intValue = stringValues [0].Length;
				break;

			case StringOperations.LastIndexOf:
				intValue = stringValues [0].LastIndexOf (stringValues [1]);
				break;

			case StringOperations.Insert:
				stringValue = stringValues [0].Insert (intValues [0], stringValues [1]);
				break;

			case StringOperations.GetIndexOf:
				intValue = stringValues [0].IndexOf (stringValues [1]);
				break;

			case StringOperations.GetHashCode:
				intValue = stringValues [0].GetHashCode ();
				break;

			case StringOperations.EndsWith:
				boolValue = stringValues [0].EndsWith (stringValues [1]);
				break;

			case StringOperations.Contains:
				boolValue = stringValues [0].Contains (stringValues [1]);
				break;
			}
		}
		void StringOperations_Outputs ()
		{
			switch (stringOperations)
			{
			case StringOperations.toInt:
				DrawIntResultField (true);
				break;

			case StringOperations.toFloat:
				DrawFloatResultField (true);
				break;

			case StringOperations.TrimEnd:
				DrawStringResultField (true);
				break;

			case StringOperations.TrimStart:
				DrawStringResultField (true);
				break;

			case StringOperations.Trim:
				DrawStringResultField (true);
				break;

			case StringOperations.ToUpperInvariant:
				DrawStringResultField (true);
				break;

			case StringOperations.ToUpper:
				DrawStringResultField (true);
				break;

			case StringOperations.ToLowerInvariant:
				DrawStringResultField (true);
				break;

			case StringOperations.ToLower:
				DrawStringResultField (true);
				break;

			case StringOperations.Substring:
				DrawStringResultField (true);
				break;

			case StringOperations.StartsWith:
				DrawBoolResultField ();
				break;

			case StringOperations.Remove:
				DrawStringResultField (true);
				break;

			case StringOperations.PadRight:
				DrawStringResultField (true);
				break;

			case StringOperations.PadLeft:
				DrawStringResultField (true);
				break;

			case StringOperations.GetLength:
				DrawIntResultField (true);
				break;

			case StringOperations.LastIndexOf:
				DrawIntResultField (true);
				break;

			case StringOperations.Insert:
				DrawStringResultField (true);
				break;

			case StringOperations.GetIndexOf:
				DrawIntResultField (true);
				break;

			case StringOperations.GetHashCode:
				DrawIntResultField (true);
				break;

			case StringOperations.EndsWith:
				DrawBoolResultField ();
				break;

			case StringOperations.Contains:
				DrawBoolResultField ();
				break;


			}
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_String ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeStringType.stringOperations.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Operations\", 0, 2);\n" + 
					"\t\t\t\tstringOperations = (StringOperations)DrawEnum " +
					"(stringOperations, FieldDrawType.label, 1, 2);\n\n" + 
					"\t\t\t\tStringOperations_Inputs ();\n",
					"\t\t\t\tStringOperations_Compute ();\n",
					"\t\t\t\tStringOperations_Outputs ();\n",
					ExprWs.Gv.doIt + ExprWs.Gv.StringOperations + ExprWs.Gv.stringAll + 
					ExprWs.Gv.intValues +
					ExprWs.Gv.boolValue + ExprWs.Gv.intValue + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.IntValues (this) +
					ExprWs.ConstructorExpr.StringOperations (this),
					ExprWs.UMDecl.StringOperations_Compute +
					ExprWs.UMDecl.computeString,
					new string []
					{
						"",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeStringType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondStringNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._string_1 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "stringValue = MezanixDiamondGetString (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveString (stringValues [0]);\n\t\t\t\t}",
					InOutWs.OutWs.string_,
					ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.stringAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetString + ExprWs.UMDecl.MezanixDiamondRemoveString+
					ExprWs.UMDecl.computeString,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeStringType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._string_1 + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\t" + "MezanixDiamondSetString (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetString + ExprWs.UMDecl.computeString,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeStringType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_string_DrawInputs ();",
					"\t\t\t\tForGet_string_Compute ();",
					"\t\t\t\tForGet_string_DrawOutputs ();",
					ExprWs.Gv.stringAll + 
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.StringValue (this) +
					ExprWs.ConstructorExpr.StringValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_string_Compute +
					ExprWs.UMDecl.computeString_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeStringType.Switch.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Want this value?\");" + ret +
					InOutWs.InWs._bool + ret +
					InOutWs.InWs._string + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Or this One?\");" + ret +
					InOutWs.InWs._bool_1 + ret +
					InOutWs.InWs._string_1,
					"\t\t\t\tif (boolValues [0] && ! boolValues [1])\n" +
					"\t\t\t\t{\n\t\t\t\t\tstringValue = stringValues [0];\n\t\t\t\t}\n" +
					"\t\t\t\tif (boolValues [1] && ! boolValues [0])\n" +
					"\t\t\t\t{\n\t\t\t\t\tstringValue = stringValues [1];\n\t\t\t\t}\n",		
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringAll + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeString,
					new string []
					{
						"",
						"Get the value corresponding of the checked box,",
						"if noth boxes have the same value, the node will not compute",
						"and it will conserve it's old output",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeStringType.printToConsole.ToString (),
					InOutWs.InWs._string, 
					tab4 + "Debug.Log (stringValues [0]);",
					"",
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeString,
					new string []
					{
						"",
						"Logs message to the Unity Console.",
						"When you select the message in the console a connection to the context object will be drawn.",
						"This can be useful for locating the object on which an error occurs.",
					},
					"https://docs.unity3d.com/ScriptReference/Debug.Log.html",
					""),

				new EnumInputComputeOutput (
					ComputeStringType.readItFromPlayerPrefs.ToString (),
					"\n\t\t\t\tDrawLogicNodeLabel (\"With key\");\n" +
					InOutWs.InWs._string, 
					tab4 + "stringValue = PlayerPrefs.GetString (stringValues [0]);",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringAll,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeString,
					new string []
					{
						"",
						"Returns the value corresponding to key in the preference file if it exists.",
					},
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.GetString.html",
					""),

				new EnumInputComputeOutput (
					ComputeStringType.saveItInPlayerPrefs.ToString (),
					tab4 + InOutWs.InWs._string_1 + "\n\t\t\t\tDrawLogicNodeLabel (\"With key\");\n" +
					InOutWs.InWs._string, 
					tab4 + "PlayerPrefs.SetString (stringValues [0], stringValues [1]);" + 
					"\n\t\t\t\tPlayerPrefs.Save ();",
					"",
					ExprWs.Gv.doIt + ExprWs.Gv.stringAll,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeString,
					new string []
					{
						"",
						"Sets the value of the preference identified by key.",
					},
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.SetString.html",
					""),

				new EnumInputComputeOutput (
					ComputeStringType.isEqualToTag.ToString (),
					InOutWs.InWs._string_1 + InOutWs.InWs._tagfield,
					tab4 + "boolValue = (stringValues [0] == stringValues [1])?true: false;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeString_InitBoolIfNotDoIT,
					new string []
					{
						"",
						"Returns true if strings (phrases) are equal, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeStringType.isEqual.ToString (),
					InOutWs.InWs._string_and_1,
					tab4 + "boolValue = (stringValues [0] == stringValues [1])?true: false;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeString_InitBoolIfNotDoIT,
					new string []
					{
						"",
						"Returns true if strings (phrases) are equal, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeStringType.add.ToString (),
					InOutWs.InWs._string_and_1,
					tab4 + "stringValue = \"\" + stringValues [0] + stringValues [1];",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringAll,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeString,
					new string []
					{
						"",
						"Add two string (phrase) values",
					},
					"",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_Ray2D ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeRayType.Raycast.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Origine\");" + ret +
					InOutWs.InWs._vector2 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Direction\");" + ret +
					InOutWs.InWs._vector2_1 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Distance\");" + ret +
					InOutWs.InWs._float + ret + 
					"\t\t\t\tDrawLogicNodeLabel (\"Layer Mask  (-1 for everything)\");" + ret +
					InOutWs.InWs._int + ret + "\t\t\t\tintValues [0] = Mathf.Clamp (intValues [0], -1, 31);" + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Min Depth\");" + ret +
					InOutWs.InWs._float_1 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Max Depth\");" + ret +
					InOutWs.InWs._float_2,
					"\t\t\t\thit2D = Physics2D.Raycast (vector2Values [0], vector2Values [1],\n" +
					"\t\t\t\t\tfloatValues [0], intValues [0], floatValues [1], floatValues [2]);\n" +
					"\t\t\t\tAssignRayCasthit_2D_Infos ();\n",
					"\t\t\t\tDrawHit_2D_ResultField ();",
					ExprWs.Gv.doIt + ExprWs.Gv.raycast_2D_hitValues + ExprWs.Gv.raycast_2D_hit +
					ExprWs.Gv.vector2Values + 
					ExprWs.Gv.floatValues + 
					ExprWs.Gv.intValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.Vector2Values (this) + 
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.resetRaycast_2D_hitInfos + ExprWs.UMDecl.assignRaycast_2D_hitInfos + 
					ExprWs.UMDecl.computeRay2D,
					new string []
					{
						"Casts a ray against colliders in the scene.",
						"A raycast is conceptually like a laser beam that is fired from a point in space",
						"along a particular direction. Any object making contact with the beam can be detected",
						"and reported.",
						"This function returns a RaycastHit object with a reference to the collider that is hit",
						"by the ray (the collider property of the result will be NULL if nothing was hit).",
						"The layerMask can be used to detect objects selectively only on certain layers",
						"(this allows you to apply the detection only to enemy characters, for example).",
					},
					"https://docs.unity3d.com/ScriptReference/Physics2D.Raycast.html",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_Ray ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeRayType.Raycast.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Origine\");" + ret +
					InOutWs.InWs._vector3 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Direction\");" + ret +
					InOutWs.InWs._vector3_1 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Distance\");" + ret +
					InOutWs.InWs._float + ret + 
					"\t\t\t\tDrawLogicNodeLabel (\"Layer Mask (-1 for everything)\");" + ret +
					InOutWs.InWs._int + ret + "\t\t\t\tintValues [0] = Mathf.Clamp (intValues [0], -1, 31);" + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Query Trigger Interaction\");" + ret +
					"\t\t\t\tDrawQueryTriggerInteractionEnum ();",
					"\t\t\t\tboolValue = Physics.Raycast (vector3Values [0], " +
					"vector3Values [1],\n\t\t\t\t\tout hit, floatValues [0], intValues [0], queryTriggerInteraction);\n\n\t\t\t\tAssignRayCasthitInfos ();",
					"\t\t\t\tDrawSweepTestResultField ();",
					ExprWs.Gv.doIt + ExprWs.Gv.raycastHitValues + ExprWs.Gv.boolValue + ExprWs.Gv.raycastHit +
					ExprWs.Gv.vector3Values + 
					ExprWs.Gv.floatValues + 
					ExprWs.Gv.intValues +
					"\t\tQueryTriggerInteraction queryTriggerInteraction;\n\n",
					ExprWs.ConstructorExpr.Vector3Values (this) + 
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.IntValues (this) +
					ExprWs.ConstructorExpr.QueryTriggerInteraction (this),
					ExprWs.UMDecl.resetRayCastHitInfos + ExprWs.UMDecl.assignRayCastHitInfos + ExprWs.UMDecl.computeRay,
					new string []
					{
						"Casts a ray against all colliders in the scene and",
						"returns detailed information on what was hit.",
						"The Layer mask is used to selectively ignore colliders when casting a ray.",
					},
					"https://docs.unity3d.com/ScriptReference/Physics.Raycast.html",
					""),
			};

		}


		EnumInputComputeOutput [] EnumInputComputeOutput_GameObject ()
		{ 
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeGameObjectType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawInNodeInfo (\"Default value: in the above gameObject field\");\n" +
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondGameObjectNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool,
					"\t\t\t\t" + "gameObjectValue = MezanixDiamondGetGameObject (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveGameObject (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.identifiedObjects + ExprWs.Gv.gameObjectAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + 
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetGameObject + ExprWs.UMDecl.MezanixDiamondRemoveGameObject +
					ExprWs.UMDecl.computeGameObject_NoCheck_NoAssign,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\t" + "MezanixDiamondSetGameObject (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.identifiedObjects + ExprWs.Gv.gameObjectValues +
					ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetGameObject + 
					ExprWs.UMDecl.computeGameObject_NoCheck_NoAssign,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeGameObjectType.SpawnMeInAGrid.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Grid Origine\");\n" +
					InOutWs.InWs._vector3 +
					"\t\t\t\tDrawLogicNodeLabel (\"How many on X, Y, and Z\");\n" +
					InOutWs.InWs._int_all +
					"\t\t\t\tDrawLogicNodeLabel (\"How much spacing on X, Y, and Z\");\n" +
					InOutWs.InWs._vector3_1,
					"\t\t\t\tSpawnOnGrid ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.doIt +
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.gameObjectAll + ExprWs.Gv.vector3Values +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.IntValues (this),
					"\t\tvoid SpawnOnGrid ()\n\t\t{\n\t\t\tint w = Mathf.Abs (intValues [0]);\n\t\t\tint h = Mathf.Abs (intValues [1]);\n\t\t\tint d = Mathf.Abs (intValues [2]);\n\n\t\t\tVector3 pos;\n\n\t\t\tgameObjectValue = new GameObject (\"GridOFObjects\");\n\n\t\t\tfor (int i = 0; i < w; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < h; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k < d; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos = vector3Values [0] + new Vector3 (\n\t\t\t\t\t\t\t(float)i * vector3Values [1].x,\n\t\t\t\t\t\t\t(float)j * vector3Values [1].y,\n\t\t\t\t\t\t\t(float)k * vector3Values [1].z);\n\t\t\t\t\t\t\n\t\t\t\t\t\tGameObject go = MonoBehaviour.Instantiate (gameObjectValues [0], pos,\n\t\t\t\t\t\t\tgameObjectValues [0].transform.rotation, gameObjectValue.transform);\n\n\t\t\t\t\t\tgo.name = gameObjectValues [0].name + \"_\"\n\t\t\t\t\t\t\t+ i.ToString () + \"_\" + j.ToString () + \"_\" + k.ToString ();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
					new string []
					{
						"",
						"Duplicate your gamobject on a 3D grid.",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeGameObjectType.otherGameObjectFoundOnMyWayAtDistance_2D.ToString (),
					"\t\t\t\tOtherGameObjectFoundOnMyWayAtDistance_InputFields_2D ();",
					"\t\t\t\tOtherGameObjectFoundOnMyWayAtDistance_Compute_2D ();",
					"\t\t\t\tOtherGameObjectFoundOnMyWayAtDistance_OutputFields_2D ();",
					ExprWs.Gv.doIt +
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.gameObjectAll + ExprWs.Gv.floatValues +
					ExprWs.Gv.intValues + ExprWs.Gv.boolValue + ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.IntValues (this),
					"\t\tvoid OtherGameObjectFoundOnMyWayAtDistance_Compute_2D ()\n\t\t{\n\t\t\tVector2 dori = Vector2.zero;\n\n\t\t\tRigidbody2D rigi = gameObjectValues [0].GetComponent <Rigidbody2D> ();\n\n\t\t\tbool noRigi = rigi == null;\n\n\t\t\tif (noRigi)\n\t\t\t\treturn;\n\n\t\t\tdori = rigi.velocity.normalized;\n\n\t\t\tif (Vector2.Dot (dori, dori) == 0f)\n\t\t\t\treturn;\n\n\t\t\tVector2 ori = new Vector2 (gameObjectValues [0].transform.position.x, gameObjectValues [0].transform.position.y);\n\n\t\t\tfloat gap = 0.03f;\n\n\t\t\tCollider2D colli = gameObjectValues [0].GetComponent <Collider2D> ();\n\n\t\t\tbool noColli = colli == null;\n\t\t\tif ( ! noColli)\n\t\t\t{\n\t\t\t\tBounds boundi = colli.bounds;\t\t\t\t\n\n\t\t\t\tfloat semiDiag = (boundi.max - boundi.center).magnitude + gap;\n\t\t\t\tori = new Vector2 (boundi.center.x, boundi.center.y) + dori*semiDiag;\n\t\t\t}\n\n\n\t\t\tRaycastHit2D hiti;\n\n\t\t\tboolValue = false;\n\n\t\t\thiti = Physics2D.Raycast (ori, dori, floatValues [0], intValues [0]);\n\n\t\t\tboolValue = hiti.transform != null;\n\n\t\t\tgameObjectValue = null;\n\t\t\tstringValue = \"\";\n\t\t\tif (boolValue)\n\t\t\t{\n\t\t\t\tif (gameObjectValue == gameObjectValues [0])\n\t\t\t\t{\n\t\t\t\t\tgameObjectValue = null;\n\t\t\t\t}\n\n\t\t\t\tgameObjectValue = hiti.transform.gameObject;\n\n\t\t\t\tstringValue = gameObjectValue.tag;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
					new string []
					{
						"Need a Rigidbody component",
						"While moving, find if another game object is on the way of your game object ",
						"by a defined distance.",
						"Only one game object can be detected by frame.",
						"If your game object has a collider on it, the search zone will begin outside",
						"the collider bounds, if not, the search zone begin at your object's transform position",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeGameObjectType.otherGameObjectFoundAtRadius_2D.ToString (),
					"\t\t\t\tOtherGameObjectFoundAtRadius_InputFields_2D ();",
					"\t\t\t\tOtherGameObjectFoundAtRadius_Compute_2D ();",
					"\t\t\t\tOtherGameObjectFoundAtRadius_OutputFields_2D ();",
					ExprWs.Gv.doIt +
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.gameObjectAll + ExprWs.Gv.floatValues +
					ExprWs.Gv.intValues + ExprWs.Gv.boolValue + ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.IntValues (this),
					"\t\tvoid OtherGameObjectFoundAtRadius_Compute_2D ()\n\t\t{\n\t\t\tVector2 ori = new Vector2 (gameObjectValues [0].transform.position.x, gameObjectValues [0].transform.position.y);\n\t\t\tVector2 dori = UnityEngine.Random.insideUnitCircle.normalized;\n\t\t\tfloat gap = 0.03f;\n\n\t\t\tCollider2D colli = gameObjectValues [0].GetComponent <Collider2D> ();\n\n\t\t\tbool noColli = colli == null;\n\n\t\t\tif ( ! noColli)\n\t\t\t{\n\t\t\t\tBounds boundi = colli.bounds;\t\t\t\t\n\n\t\t\t\tfloat semiDiag = (boundi.max - boundi.center).magnitude + gap;\n\t\t\t\tori = new Vector2 (boundi.center.x, boundi.center.y) + dori*semiDiag;\n\t\t\t}\n\n\n\n\t\t\tRaycastHit2D hiti;\n\n\t\t\tboolValue = false;\n\n\t\t\thiti = Physics2D.Raycast (ori, dori, floatValues [0], intValues [0]);\n\n\t\t\tboolValue = hiti.transform != null;\n\n\n\t\t\tgameObjectValue = null;\n\t\t\tstringValue = \"\";\n\t\t\tif (boolValue)\n\t\t\t{\n\t\t\t\tif (gameObjectValue == gameObjectValues [0])\n\t\t\t\t{\n\t\t\t\t\tgameObjectValue = null;\n\t\t\t\t}\n\n\t\t\t\tgameObjectValue = hiti.transform.gameObject;\n\n\t\t\t\tstringValue = gameObjectValue.tag;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
					new string []
					{
						"",
						"Find if another game object is near of your game object by a defined radius.",
						"Only one game object can be detected by frame.",
						"If your game object has a collider on it, the search zone will begin outside",
						"the collider bounds, if not, the search zone begin at your object's transform position",
					},
					"",
					""),





				new EnumInputComputeOutput (
					ComputeGameObjectType.otherGameObjectFoundOnMyWayAtDistance.ToString (),
					"\t\t\t\tOtherGameObjectFoundOnMyWayAtDistance_InputFields ();",
					"\t\t\t\tOtherGameObjectFoundOnMyWayAtDistance_Compute ();",
					"\t\t\t\tOtherGameObjectFoundOnMyWayAtDistance_OutputFields ();",
					ExprWs.Gv.doIt +
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.gameObjectAll + ExprWs.Gv.floatValues +
					ExprWs.Gv.intValues + ExprWs.Gv.boolValue + ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.IntValues (this),
					"\t\tvoid OtherGameObjectFoundOnMyWayAtDistance_Compute ()\n\t\t{\n\t\t\tVector3 dori = Vector3.zero;\n\n\t\t\tRigidbody rigi = gameObjectValues [0].GetComponent <Rigidbody> ();\n\n\t\t\tbool noRigi = rigi == null;\n\n\t\t\tif (noRigi)\n\t\t\t\treturn;\n\n\t\t\tdori = rigi.velocity.normalized;\n\n\t\t\tif (Vector3.Dot (dori, dori) == 0f)\n\t\t\t\treturn;\n\n\t\t\tVector3 ori = gameObjectValues [0].transform.position;\n\t\t\t\n\t\t\tfloat gap = 0.03f;\n\n\t\t\tCollider colli = gameObjectValues [0].GetComponent <Collider> ();\n\n\t\t\tbool noColli = colli == null;\n\t\t\tif ( ! noColli)\n\t\t\t{\n\t\t\t\tBounds boundi = colli.bounds;\t\t\t\t\n\n\t\t\t\tfloat semiDiag = (boundi.max - boundi.center).magnitude + gap;\n\t\t\t\tori = boundi.center + dori*semiDiag;\n\t\t\t}\n\n\n\t\t\tRaycastHit hiti;\n\n\t\t\tboolValue = false;\n\t\t\tboolValue = Physics.Raycast (ori, dori, out hiti, floatValues [0], intValues [0]);\n\n\t\t\t//Debug.DrawLine (ori, ori + dori*floatValues [0], Color.cyan, 0.2f);\n\n\t\t\tgameObjectValue = null;\n\t\t\tstringValue = \"\";\n\t\t\tif (boolValue)\n\t\t\t{\n\t\t\t\tif (gameObjectValue == gameObjectValues [0])\n\t\t\t\t{\n\t\t\t\t\tgameObjectValue = null;\n\t\t\t\t}\n\n\t\t\t\tgameObjectValue = hiti.transform.gameObject;\n\n\t\t\t\tstringValue = gameObjectValue.tag;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
					new string []
					{
						"Need a Rigidbody component",
						"While moving, find if another game object is on the way of your game object ",
						"by a defined distance.",
						"Only one game object can be detected by frame.",
						"If your game object has a collider on it, the search zone will begin outside",
						"the collider bounds, if not, the search zone begin at your object's transform position",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.otherGameObjectFoundAtRadius.ToString (),
					"\t\t\t\tOtherGameObjectFoundAtRadius_InputFields ();",
					"\t\t\t\tOtherGameObjectFoundAtRadius_Compute ();",
					"\t\t\t\tOtherGameObjectFoundAtRadius_OutputFields ();",
					ExprWs.Gv.doIt +
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.gameObjectAll + ExprWs.Gv.floatValues +
					ExprWs.Gv.intValues + ExprWs.Gv.boolValue + ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.IntValues (this),
					"\t\tvoid OtherGameObjectFoundAtRadius_Compute ()\n\t\t{\n\t\t\tVector3 ori = gameObjectValues [0].transform.position;\n\t\t\tVector3 dori = UnityEngine.Random.onUnitSphere;\n\t\t\tfloat gap = 0.03f;\n\n\t\t\tCollider colli = gameObjectValues [0].GetComponent <Collider> ();\n\n\t\t\tbool noColli = colli == null;\n\n\t\t\tif ( ! noColli)\n\t\t\t{\n\t\t\t\tBounds boundi = colli.bounds;\t\t\t\t\n\n\t\t\t\tfloat semiDiag = (boundi.max - boundi.center).magnitude + gap;\n\t\t\t\tori = boundi.center + dori*semiDiag;\n\t\t\t}\n\n\n\n\t\t\tRaycastHit hiti;\n\n\t\t\tboolValue = false;\n\n\t\t\tboolValue = Physics.Raycast (ori, dori, out hiti, floatValues [0], intValues [0]);\n\t\t\t\t\t\n\t\t\t//Debug.DrawLine (ori, ori + dori*floatValues [0], Color.cyan, 0.2f);\n\n\t\t\tgameObjectValue = null;\n\t\t\tstringValue = \"\";\n\t\t\tif (boolValue)\n\t\t\t{\n\t\t\t\tif (gameObjectValue == gameObjectValues [0])\n\t\t\t\t{\n\t\t\t\t\tgameObjectValue = null;\n\t\t\t\t}\n\n\t\t\t\tgameObjectValue = hiti.transform.gameObject;\n\n\t\t\t\tstringValue = gameObjectValue.tag;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
					new string []
					{
						"",
						"Find if another game object is near of your game object by a defined radius.",
						"Only one game object can be detected by frame.",
						"If your game object has a collider on it, the search zone will begin outside",
						"the collider bounds, if not, the search zone begin at your object's transform position",
					},
					"",
					""),



				new EnumInputComputeOutput (
					ComputeGameObjectType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_gameObject_DrawInputs ();",
					"\t\t\t\tForGet_gameObject_Compute ();",
					"\t\t\t\tForGet_gameObject_DrawOutputs ();",
					ExprWs.Gv.gameObjectAll + 
					ExprWs.Gv.boolValues +
					ExprWs.Gv.identifiedObjects,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValue_ID,}) +
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_gameObject_Compute +
					ExprWs.UMDecl.computeGameObject_NoDoIT_NoCheck,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),




				//new EnumInputComputeOutput (
				//	ComputeGameObjectType.hadExitCollision2DWithGameObjectOfTag.ToString (),
				//	"\t\t\t\tattachedToGameObject [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tpublicInputs [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tDrawLogicNodeLabel (\"Choose tag\");\n" +
				//	InOutWs.InWs._tagfield + 
				//	"\t\t\t\tDrawLogicNodeLabel (actionOnHowManyFrames);\n" +
				//	InOutWs.InWs._float + "\n" + 
				//	"\t\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);",
				//	InOutWs.CodeWs.downTimeCounterCode,
				//	"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
				//	InOutWs.OutWs.bool_+ InOutWs.OutWs.gameObject_,
				//	ExprWs.Gv.gameObjectAll + ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.floatValues +
				//	ExprWs.Gv.boolValue + ExprWs.Gv.downTimeCounter,
				//	ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) + 
				//	ExprWs.ConstructorExpr.downTimeCounter,
				//	ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
				//	new string []
				//	{						
				//		"The output bool become 'true' when",
				//		"the 'The Attached to' gameobject exit from contact with the gameobject",
				//		"tagged by 'Choose tag'.",
				//		"At least, one of the two gameobjects must have a",
				//		"non-kinematic rigid body componenet on it.",
				//		"",
				//		"Works only on generated scripts, but you can connect",
				//		"the bool output to other nodes.",
				//		"The bool output, will act as a impulse during the 'Action On How Many Frames'.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnCollisionExit2D.html",
				//	""),
				//
				//new EnumInputComputeOutput (
				//	ComputeGameObjectType.hadEnteredCollision2DWithGameObjectOfTag.ToString (),
				//	"\t\t\t\tattachedToGameObject [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tpublicInputs [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tDrawLogicNodeLabel (\"Choose tag\");\n" +
				//	InOutWs.InWs._tagfield + 
				//	"\t\t\t\tDrawLogicNodeLabel (actionOnHowManyFrames);\n" +
				//	InOutWs.InWs._float + "\n" + 
				//	"\t\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);",
				//	InOutWs.CodeWs.downTimeCounterCode,
				//	"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
				//	InOutWs.OutWs.bool_+ InOutWs.OutWs.gameObject_,
				//	ExprWs.Gv.gameObjectAll + ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.floatValues +
				//	ExprWs.Gv.boolValue + ExprWs.Gv.downTimeCounter,
				//	ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) + 
				//	ExprWs.ConstructorExpr.downTimeCounter,
				//	ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
				//	new string []
				//	{						
				//		"The output gameobject is tagged by 'Choose tag' and it is found when",
				//		"the 'The Attached to' gameobject enter in collision with it.",
				//		"At least, one of the two gameobjects must have a",
				//		"non-kinematic rigid body componenet on it.",
				//		"",
				//		"Works only on generated scripts, but you can connect",
				//		"the potentially found gameobject, named as :",
				//		"'none GameObject', to other nodes.",
				//		"Like so, in generated scripts, you can apply the logic",
				//		"of these nodes on it",
				//		"the bool output to other nodes.",
				//		"The bool output, will act as a impulse during the 'Action On How Many Frames'.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnCollisionEnter2D.html",
				//	""),
				//
				//
				//
				//
				//
				//new EnumInputComputeOutput (
				//	ComputeGameObjectType.hadExitCollisionWithGameObjectOfTag.ToString (),
				//	"\t\t\t\tattachedToGameObject [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tpublicInputs [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tDrawLogicNodeLabel (\"Choose tag\");\n" +
				//	InOutWs.InWs._tagfield + 
				//	"\t\t\t\tDrawLogicNodeLabel (actionOnHowManyFrames);\n" +
				//	InOutWs.InWs._float + "\n" + 
				//	"\t\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);",
				//	InOutWs.CodeWs.downTimeCounterCode,
				//	"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
				//	InOutWs.OutWs.bool_+ InOutWs.OutWs.gameObject_,
				//	ExprWs.Gv.gameObjectAll + ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.floatValues +
				//	ExprWs.Gv.boolValue + ExprWs.Gv.downTimeCounter,
				//	ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) + 
				//	ExprWs.ConstructorExpr.downTimeCounter,
				//	ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
				//	new string []
				//	{						
				//		"The output bool become 'true' when",
				//		"the 'The Attached to' gameobject exit from collision with the gameobject",
				//		"tagged by 'Choose tag'.",
				//		"At least, one of the two gameobjects must have a",
				//		"non-kinematic rigid body componenet on it.",
				//		"",
				//		"Works only on generated scripts, but you can connect",
				//		"the bool output to other nodes.",
				//		"The bool output, will act as a impulse during the 'Action On How Many Frames'.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/Collider.OnCollisionExit.html",
				//	""),
				//
				//new EnumInputComputeOutput (
				//	ComputeGameObjectType.hadEnteredCollisionWithGameObjectOfTag.ToString (),
				//	"\t\t\t\tattachedToGameObject [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tpublicInputs [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tDrawLogicNodeLabel (\"Choose tag\");\n" +
				//	InOutWs.InWs._tagfield + 
				//	"\t\t\t\tDrawLogicNodeLabel (actionOnHowManyFrames);\n" +
				//	InOutWs.InWs._float + "\n" + 
				//	"\t\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);",
				//	InOutWs.CodeWs.downTimeCounterCode,
				//	"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
				//	InOutWs.OutWs.bool_+ InOutWs.OutWs.gameObject_,
				//	ExprWs.Gv.gameObjectAll + ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.floatValues +
				//	ExprWs.Gv.boolValue + ExprWs.Gv.downTimeCounter,
				//	ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) + 
				//	ExprWs.ConstructorExpr.downTimeCounter,
				//	ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
				//	new string []
				//	{						
				//		"The output gameobject is tagged by 'Choose tag' and it is found when",
				//		"the 'The Attached to' gameobject enter in collision with it.",
				//		"At least, one of the two gameobjects must have a",
				//		"non-kinematic rigid body componenet on it.",
				//		"",
				//		"Works only on generated scripts, but you can connect",
				//		"the potentially found gameobject, named as :",
				//		"'none GameObject', to other nodes.",
				//		"Like so, in generated scripts, you can apply the logic",
				//		"of these nodes on it",
				//		"the bool output to other nodes.",
				//		"The bool output, will act as a impulse during the 'Action On How Many Frames'.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/Collider.OnCollisionEnter.html",
				//	""),
				//
				//
				//
				//
				//
				//
				//new EnumInputComputeOutput (
				//	ComputeGameObjectType.hadExitTrigger2DWithGameObjectOfTag.ToString (),
				//	"\t\t\t\tattachedToGameObject [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tpublicInputs [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tDrawLogicNodeLabel (\"Choose tag\");\n" +
				//	InOutWs.InWs._tagfield + 
				//	"\t\t\t\tDrawLogicNodeLabel (actionOnHowManyFrames);\n" +
				//	InOutWs.InWs._float + "\n" + 
				//	"\t\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);",
				//	InOutWs.CodeWs.downTimeCounterCode,
				//	"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
				//	InOutWs.OutWs.bool_+ InOutWs.OutWs.gameObject_,
				//	ExprWs.Gv.gameObjectAll + ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.floatValues +
				//	ExprWs.Gv.boolValue + ExprWs.Gv.downTimeCounter,
				//	ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) + 
				//	ExprWs.ConstructorExpr.downTimeCounter,
				//	ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
				//	new string []
				//	{						
				//		"The output bool become 'true' when",
				//		"the 'The Attached to' gameobject exit from contact with the gameobject",
				//		"tagged by 'Choose tag'.",
				//		"'The Attached to' gameobject must have 'is Trigger'",
				//		"enabled in its collider, and",
				//		"at least, one of the two gameobjects must have a",
				//		"rigid body componenet on it.",
				//		"",
				//		"Works only on generated scripts, but you can connect",
				//		"the bool output to other nodes.",
				//		"The bool output, will act as a impulse during the 'Action On How Many Frames'.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerExit2D.html",
				//	""),
				//
				//new EnumInputComputeOutput (
				//	ComputeGameObjectType.hadEnteredTrigger2DWithGameObjectOfTag.ToString (),
				//	"\t\t\t\tattachedToGameObject [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tpublicInputs [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tDrawLogicNodeLabel (\"Choose tag\");\n" +
				//	InOutWs.InWs._tagfield + 
				//	"\t\t\t\tDrawLogicNodeLabel (actionOnHowManyFrames);\n" +
				//	InOutWs.InWs._float + "\n" + 
				//	"\t\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);",
				//	InOutWs.CodeWs.downTimeCounterCode,
				//	"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
				//	InOutWs.OutWs.bool_+ InOutWs.OutWs.gameObject_,
				//	ExprWs.Gv.gameObjectAll + ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.floatValues +
				//	ExprWs.Gv.boolValue + ExprWs.Gv.downTimeCounter,
				//	ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) + 
				//	ExprWs.ConstructorExpr.downTimeCounter,
				//	ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
				//	new string []
				//	{						
				//		"The output gameobject is tagged by 'Choose tag' and it is found when",
				//		"the 'The Attached to' gameobject enter in contact with it.",
				//		"'The Attached to' gameobject must have 'is Trigger'",
				//		"enabled in its collider, and",
				//		"at least, one of the two gameobjects must have a",
				//		"rigid body componenet on it.",
				//		"",
				//		"Works only on generated scripts, but you can connect",
				//		"the potentially found gameobject, named as :",
				//		"'none GameObject', to other nodes.",
				//		"Like so, in generated scripts, you can apply the logic",
				//		"of these nodes on it",
				//		"the bool output to other nodes.",
				//		"The bool output, will act as a impulse during the 'Action On How Many Frames'.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter2D.html",
				//	""),
				//
				//
				//
				//new EnumInputComputeOutput (
				//	ComputeGameObjectType.hadExitTriggerWithGameObjectOfTag.ToString (),
				//	"\t\t\t\tattachedToGameObject [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tpublicInputs [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tDrawLogicNodeLabel (\"Choose tag\");\n" +
				//	InOutWs.InWs._tagfield + 
				//	"\t\t\t\tDrawLogicNodeLabel (actionOnHowManyFrames);\n" +
				//	InOutWs.InWs._float + "\n" + 
				//	"\t\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);",
				//	InOutWs.CodeWs.downTimeCounterCode,
				//	"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
				//	InOutWs.OutWs.bool_+ InOutWs.OutWs.gameObject_,
				//	ExprWs.Gv.gameObjectAll + ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.floatValues +
				//	ExprWs.Gv.boolValue + ExprWs.Gv.downTimeCounter,
				//	ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) + 
				//	ExprWs.ConstructorExpr.downTimeCounter,
				//	ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
				//	new string []
				//	{						
				//		"The output bool become 'true' when",
				//		"the 'The Attached to' gameobject exit from contact with the gameobject",
				//		"tagged by 'Choose tag'.",
				//		"'The Attached to' gameobject must have 'is Trigger'",
				//		"enabled in its collider, and",
				//		"at least, one of the two gameobjects must have a",
				//		"rigid body componenet on it.",
				//		"",
				//		"Works only on generated scripts, but you can connect",
				//		"the bool output to other nodes.",
				//		"The bool output, will act as a impulse during the 'Action On How Many Frames'.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerExit.html",
				//	""),
				//
				//new EnumInputComputeOutput (
				//	ComputeGameObjectType.hadEnteredTriggerWithGameObjectOfTag.ToString (),
				//	"\t\t\t\tattachedToGameObject [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tpublicInputs [IndexOfInID (Enums.gameObjectValues_0_ID)] = true;\n" +
				//	"\t\t\t\tDrawLogicNodeLabel (\"Choose tag\");\n" +
				//	InOutWs.InWs._tagfield + 
				//	"\t\t\t\tDrawLogicNodeLabel (actionOnHowManyFrames);\n" +
				//	InOutWs.InWs._float + "\n" + 
				//	"\t\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);",
				//	InOutWs.CodeWs.downTimeCounterCode,
				//	"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
				//	InOutWs.OutWs.bool_+ InOutWs.OutWs.gameObject_,
				//	ExprWs.Gv.gameObjectAll + ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.floatValues +
				//	ExprWs.Gv.boolValue + ExprWs.Gv.downTimeCounter,
				//	ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) + 
				//	ExprWs.ConstructorExpr.downTimeCounter,
				//	ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObjectNoGameObjectAssign,
				//	new string []
				//	{						
				//		"The output gameobject is tagged by 'Choose tag' and it is found when",
				//		"the 'The Attached to' gameobject enter in contact with it.",
				//		"'The Attached to' gameobject must have 'is Trigger'",
				//		"enabled in its collider, and",
				//		"at least, one of the two gameobjects must have a",
				//		"rigid body componenet on it.",
				//		"",
				//		"Works only on generated scripts, but you can connect",
				//		"the potentially found gameobject, named as :",
				//		"'none GameObject', to other nodes.",
				//		"Like so, in generated scripts, you can apply the logic",
				//		"of these nodes on it",
				//		"the bool output to other nodes.",
				//		"The bool output, will act as a impulse during the 'Action On How Many Frames'.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter.html",
				//	""),



				new EnumInputComputeOutput (
					ComputeGameObjectType.hasThisTag.ToString (),
					InOutWs.InWs._tagfield,
					tab4 + "boolValue = gameObjectValue.tag == stringValues [0];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"",
						"Returns true if the game object has this tag, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.isChildOf.ToString (),
					InOutWs.InWs._gameObject_1,
					tab4 + "boolValue = gameObjectValues[0].transform.parent == gameObjectValues[1].transform;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string  [] {
						Enums.gameObjectValues_0_ID,
						Enums.gameObjectValues_1_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.gameObjectCheck_1 +
					ExprWs.UMDecl.computeGameObject_1,
					new string []
					{
						"",
						"Returns true if the first game object is a child of the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.isEqualTo.ToString (),
					InOutWs.InWs._gameObject_1,
					tab4 + "boolValue = gameObjectValues[0] == gameObjectValues[1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string  [] {
						Enums.gameObjectValues_0_ID,
						Enums.gameObjectValues_1_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.gameObjectCheck_1 +
					ExprWs.UMDecl.computeGameObject_1, 
					new string []
					{
						"",
						"Returns true if game objects are equal, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.setTag.ToString (),
					InOutWs.InWs._tagfield,
					tab4 + "gameObjectValues[0].tag = stringValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.stringValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"The tag of this game object.",
						"A tag can be used to identify a game object. Tags must be declared in the Tags",
						"and Layers manager before using them.",
					},
					"https://docs.unity3d.com/ScriptReference/GameObject-tag.html",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.setName.ToString (),
					InOutWs.InWs._string,
					tab4 + "gameObjectValues[0].name = stringValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.stringValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"The name of the object.",
						"Components share the same name with the game object and all attached components.",
					},
					"https://docs.unity3d.com/ScriptReference/Object-name.html",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.setLayer.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tintValues [0] = Mathf.Clamp (intValues [0], 0, 31);\n\n\t\t\t\tgameObjectValues[0].layer = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMcall.computeGameObject,
					new string []
					{
						"The layer the game object is in. A layer is in the range [0...31].",
						"Layers can be used for selective rendering from cameras or ignoring raycasts.",
					},
					"https://docs.unity3d.com/ScriptReference/GameObject-layer.html",
					""),


				new EnumInputComputeOutput (
					ComputeGameObjectType.instantiateAndChooseUp.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"At this position\");" + InOutWs.InWs._vector3 +
					"\t\t\t\tDrawLogicNodeLabel (\"Instatiated with this Up\");" + InOutWs.InWs._vector3_1,
					"\t\t\t\tgameObjectValue = MonoBehaviour.Instantiate (" +
					"gameObjectValues [0], vector3Values [0], \n\t\t\t\t\tQuaternion.identity) as GameObject;\n" + 
					"\t\t\t\tgameObjectValue.transform.up = vector3Values [1];\n",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"Like the original Unity standard instantiation methode.",
						"In this one you can additionaly set the Up (y axis, green arrow on transfrom gizmos).",
						"of the intantiated gameobject.",
						"For example this is useful when you want to simulate the effect on a wall after",
						"a bullet shot, so you can intantiate a particle system oriented as same as the wall's normal.",
					},
					"https://docs.unity3d.com/ScriptReference/Object.Instantiate.html",
					""),


				new EnumInputComputeOutput (
					ComputeGameObjectType.instantiate.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"At this position\");" + InOutWs.InWs._vector3 +
					"\t\t\t\tDrawLogicNodeLabel (\"With this rotation\");" + InOutWs.InWs._vector3_1,
					"\t\t\t\tgameObjectValue = MonoBehaviour.Instantiate (" +
					"gameObjectValues [0], vector3Values [0], \n\t\t\t\t\tQuaternion.Euler (vector3Values [1])) as GameObject;\n",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"Clones the object original and returns the clone.",
						"This function makes a copy of an object in a similar way to the Duplicate",
						"command in the editor. If you are cloning a GameObject then you can also",
						"optionally specify its position and rotation (these default to the original",
						"GameObject's position and rotation otherwise).",
					},
					"https://docs.unity3d.com/ScriptReference/Object.Instantiate.html",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.getTag.ToString (),
					"",
					tab4 + "stringValue = gameObjectValues [0].tag;",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"The tag of this game object.",
						"A tag can be used to identify a game object. Tags must be declared in the Tags",
						"and Layers manager before using them.",
					},
					"https://docs.unity3d.com/ScriptReference/GameObject-tag.html",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.getName.ToString (),
					"",
					tab4 + "stringValue = gameObjectValues [0].name;",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"The name of the object.",
						"Components share the same name with the game object and all attached components.",
					},
					"https://docs.unity3d.com/ScriptReference/Object-name.html",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.getLayer.ToString (),
					"",
					tab4 + "intValue = gameObjectValues [0].layer;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"The layer the game object is in. A layer is in the range [0...31].",
						"Layers can be used for selective rendering from cameras or ignoring raycasts.",
					},
					"https://docs.unity3d.com/ScriptReference/GameObject-layer.html",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.getActiveSelf.ToString (),
					"",
					tab4 + "boolValue = gameObjectValues [0].activeSelf;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"The local active state of this GameObject. (Read Only)",
						"This returns the local active state of this GameObject,",
						"which is set using GameObject.SetActive. Note that a GameObject may be inactive",
						"because a parent is not active, even if this returns true.",
						"This state will then be used once all parents are active.",
						"Use GameObject.activeInHierarchy if you want to check if the GameObject",
						"is actually treated as active in the scene.",
					},
					"https://docs.unity3d.com/ScriptReference/GameObject-activeSelf.html",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.getActiveInHierarchy.ToString (),
					"",
					tab4 + "boolValue = gameObjectValues [0].activeInHierarchy;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"Is the GameObject active in the scene?",
						"This lets you know if a gameObject is active in the game.",
						"That is the case if its GameObject.activeSelf property is enabled,",
						"as well as that of all it's parents.",
					},
					"https://docs.unity3d.com/ScriptReference/GameObject-activeInHierarchy.html",
					""),


				new EnumInputComputeOutput (
					ComputeGameObjectType.destroy.ToString (),
					tab4 + "DrawLogicNodeLabel (\"Destroy with this delay\");\n" + 
					InOutWs.InWs._float,
					tab4 + "floatValues [0] = Mathf.Max (floatValues [0], 0f);\n\n" +
					tab4 + "MonoBehaviour.Destroy (gameObjectValues [0], floatValues [0]);\n\n",
					"",
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"Removes a gameobject, component or asset.",
						"The object obj will be destroyed now or if a time is specified t seconds from now.",
						"If obj is a Component it will remove the component from the GameObject and destroy",
						"it. If obj is a GameObject it will destroy the GameObject, all its components and",
						"all transform children of the GameObject.",
						"Actual object destruction is always delayed until after the current Update loop,",
						"but will always be done before rendering.",
					},
					"https://docs.unity3d.com/ScriptReference/Object.Destroy.html",
					""),

				//new EnumInputComputeOutput (
				//	ComputeGameObjectType.destroy.ToString (),
				//	tab4 + "DrawLogicNodeLabel (\"Destroy with this delay\");\n" + 
				//	InOutWs.InWs._float,
				//	"\t\t\t\tboolValue = false;\n" +
				//	tab4 + "floatValues [0] = Mathf.Max (floatValues [0], 0f);\n\n" +
				//	tab4 + "MonoBehaviour.Destroy (gameObjectValues [0], floatValues [0]);\n\n" +
				//	"\t\t\t\tif (gameObjectValues [0] == null)\n" +
				//	"\t\t\t\t{\n\t\t\t\t\tboolValue = true;\n" +
				//	"\t\t\t\t}",
				//	InOutWs.OutWs.bool_,
				//	ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
				//	ExprWs.Gv.floatValues + ExprWs.Gv.boolValue,
				//	ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
				//	ExprWs.ConstructorExpr.FloattValues (this),
				//	ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
				//	new string []
				//	{
				//		"Removes a gameobject, component or asset.",
				//		"The object obj will be destroyed now or if a time is specified t seconds from now.",
				//		"If obj is a Component it will remove the component from the GameObject and destroy",
				//		"it. If obj is a GameObject it will destroy the GameObject, all its components and",
				//		"all transform children of the GameObject.",
				//		"Actual object destruction is always delayed until after the current Update loop,",
				//		"but will always be done before rendering.",
				//		"The bool output is set only Once to true when the game object is destroyed",
				//		"and reset to false after that.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/Object.Destroy.html",
				//	""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.deactivate.ToString (),
					"",
					tab4 + "gameObjectValues [0].SetActive (false);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"Activates/Deactivates the GameObject.",
						"Note that a GameObject may be inactive because a parent is not active.",
						"In that case, calling SetActive() will not activate it, but only set the local",
						"state of the GameObject, which can be checked using GameObject.activeSelf.",
						"This state will then be used once all parents are active.",
						"Making a GameObject inactive will disable every component, turning off any",
						"attached renderers, colliders, rigidbodies, scripts, etc...",
						"Any scripts that you have attached to the GameObject will no longer have",
						"Update() called, for example.",
					},
					"https://docs.unity3d.com/ScriptReference/GameObject.SetActive.html",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.CompareTag.ToString (),
					InOutWs.InWs._tagfield,
					tab4 + "boolValue = gameObjectValues [0].CompareTag (stringValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"Is this game object tagged with tag ?",
					},
					"https://docs.unity3d.com/ScriptReference/GameObject.CompareTag.html",
					""),

				new EnumInputComputeOutput (
					ComputeGameObjectType.activate.ToString (),
					"",
					tab4 + "gameObjectValues [0].SetActive (true);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.computeGameObject,
					new string []
					{
						"Activates/Deactivates the GameObject.",
						"Note that a GameObject may be inactive because a parent is not active.",
						"In that case, calling SetActive() will not activate it, but only set the local",
						"state of the GameObject, which can be checked using GameObject.activeSelf.",
						"This state will then be used once all parents are active.",
						"Making a GameObject inactive will disable every component, turning off any",
						"attached renderers, colliders, rigidbodies, scripts, etc...",
						"Any scripts that you have attached to the GameObject will no longer have",
						"Update() called, for example.",
					},
					"https://docs.unity3d.com/ScriptReference/GameObject.SetActive.html",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_Ads ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeAdsType.WhatWasTheShowAdResult.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Is The Ad Result Was\", new String []{\"Finished\", \"Failed\", \"Skipped\"}, new String [] {\"\",});\n" + 
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n",
					"\t\t\t\tWhatWasTheShowAdResult ();",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.boolValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					"\t\tvoid WhatWasTheShowAdResult ()\n\t\t{\n\t\t\tboolValue = stringValues [0] == DiamodAds.showResult;\n\n\t\t\tDiamodAds.showResult = \"\";\n\t\t}\n" +
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"This logic node indicates by true/false if the Ad had one of the following results:",
						"Finished -> Indicates that the advertisement completed successfully. Or",
						"Failed -> Indicates that the advertisement failed to complete. Or",
						"Skipped -> Indicates that the advertisement was skipped.",
						"",
						"Click the button 'Is The Ad Result Was' to choose one from the above list",
						"",
						"This logic node is usually used with the Do It button set to Always Do It,",
						"So you are always checking the Ads results",
					},
					"",
					""),
				//rewardedVideo
				new EnumInputComputeOutput (
					ComputeAdsType.Show.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Rewarded?\");\n" + 
					InOutWs.InWs._bool,
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\tShowAd ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringValue + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.BoolValues (this),
					"\t\tvoid ShowAd ()\n\t\t{\n\t\t\t#if UNITY_IOS || UNITY_ANDROID\n\t\t\tif (UnityEngine.Advertisements.Advertisement.IsReady ())\n\t\t\t{\t\t\t\n\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Advertisements.Advertisement.Show (\"rewardedVideo\", \n\t\t\t\t\tnew UnityEngine.Advertisements.ShowOptions (){resultCallback = HandleAdResult});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tUnityEngine.Advertisements.Advertisement.Show ();\n\t\t\t\t}\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\n\t\t#if UNITY_IOS || UNITY_ANDROID\n\t\tvoid HandleAdResult (UnityEngine.Advertisements.ShowResult result)\n\t\t{\n\t\t\tswitch (result)\n\t\t\t{\n\t\t\tcase UnityEngine.Advertisements.ShowResult.Failed:\n\t\t\t\tDiamodAds.showResult = \"Failed\";\n\t\t\t\tbreak;\n\n\t\t\tcase UnityEngine.Advertisements.ShowResult.Finished:\n\t\t\t\tDiamodAds.showResult = \"Finished\";\n\t\t\t\tbreak;\n\n\t\t\tcase UnityEngine.Advertisements.ShowResult.Skipped:\n\t\t\t\tDiamodAds.showResult = \"Skipped\";\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\t#endif\n" +
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Show an advertisement in your project.",
						"If you choose 'Rewarded', tha ad result can be:",
						"Finished -> Indicates that the advertisement completed successfully. Or",
						"Failed -> Indicates that the advertisement failed to complete. Or",
						"Skipped -> Indicates that the advertisement was skipped.",
						"",
						"To know the Ads result use the logic node 'What Was The Show Ad Result',",
						"this node returns a bool that tells information about the Ads result,",
						"so you can use this bool to Invoke actions.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement.Show.html",
					""),

				new EnumInputComputeOutput (
					ComputeAdsType.setDebugMode.ToString (),
					InOutWs.InWs._bool,
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\t#if UNITY_IOS || " +
					"UNITY_ANDROID\n\t\t\t\tUnityEngine.Advertisements.Advertisement.debugMode = " +
					"boolValues [0];\n\t\t\t\t#endif",
					"",
					ExprWs.Gv.doIt + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Controls the amount of logging output from the advertisement system.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-debugMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeAdsType.isSupported.ToString (),
					"",
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\t#if UNITY_IOS || UNITY_ANDROID\n\t\t\t\tboolValue = " +
					"UnityEngine.Advertisements.Advertisement.isSupported;\n\t\t\t\t#endif",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Returns if the current platform is supported by the advertisement system.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-isSupported.html",
					""),

				new EnumInputComputeOutput (
					ComputeAdsType.isShowing.ToString (),
					"",
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\t#if UNITY_IOS || UNITY_ANDROID\n\t\t\t\tboolValue = " +
					"UnityEngine.Advertisements.Advertisement.isShowing;\n\t\t\t\t#endif",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Returns whether an advertisement is currently being shown.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-isShowing.html",
					""),

				new EnumInputComputeOutput (
					ComputeAdsType.IsReady.ToString (),
					"",
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\t#if UNITY_IOS || UNITY_ANDROID\n\t\t\t\tboolValue = " +
					"UnityEngine.Advertisements.Advertisement.IsReady ();\n\t\t\t\t#endif",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Returns whether an advertisement is ready to be shown. ",
						"Placements are configured per",
						" game in the UnityAds admin site, ",
						"where you can also set your default placement.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement.IsReady.html",
					""),

				new EnumInputComputeOutput (
					ComputeAdsType.isInitialized.ToString (),
					"",
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\t#if UNITY_IOS || UNITY_ANDROID\n\t\t\t\tboolValue = " +
					"UnityEngine.Advertisements.Advertisement.isInitialized;\n\t\t\t\t#endif",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Returns whether the advertisement system is initialized successfully.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-isInitialized.html",
					""),

				new EnumInputComputeOutput (
					ComputeAdsType.Initialize.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Game ID\");\n" + 
					InOutWs.InWs._string +
					"\t\t\t\tDrawLogicNodeLabel (\"Test Mode?\");\n" + 
					InOutWs.InWs._bool,
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\t#if UNITY_IOS ||" +
					" UNITY_ANDROID\n\t\t\t\t" +
					"UnityEngine.Advertisements.Advertisement.Initialize (stringValues [0], boolValues [0]);" +
					"\n\t\t\t\t#endif",
					"",
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Manually initializes the advertisement system. ",
						"Normally this is done from editor, and you should only ",
						"call this method if you are using UnityAds with automatic initialization disabled.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement.Initialize.html",
					""),

				new EnumInputComputeOutput (
					ComputeAdsType.getVersion.ToString (),
					"",
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\t#if UNITY_IOS || " +
					"UNITY_ANDROID\n\t\t\t\tstringValue = UnityEngine.Advertisements.Advertisement.version;" +
					"\n\t\t\t\t#endif",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringValue,
					"",
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Returns the current Unity Ads version.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-version.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeAdsType.GetPlacementState.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Placement Identifier\", new String [] {\"video\", \"rewardedVideo\"}, new String [] {\"\",});\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n",
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\t#if UNITY_IOS || " +
					"UNITY_ANDROID\n\t\t\t\tstringValue =" +
					" UnityEngine.Advertisements.Advertisement.GetPlacementState (stringValues [0]).ToString ();\n\t\t\t\t#endif",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringAll,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Returns the placement state.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement.GetPlacementState.html",
					""),

				//new EnumInputComputeOutput (
				//	ComputeAdsType.getIsTestMode.ToString (),
				//	"",
				//	InOutWs.CodeWs.ifApplicationNotPlayingReturn +
				//	"\t\t\t\t#if UNITY_IOS || UNITY_ANDROID\n\t\t\t\tboolValue = UnityEngine.Advertisements.Advertisement.testMode;\n\t\t\t\t#endif",
				//	InOutWs.OutWs.bool_,
				//	ExprWs.Gv.doIt + ExprWs.Gv.boolValue,
				//	"",
				//	ExprWs.UMDecl.computeAds,
				//	new string []
				//	{
				//		"",
				//		"Returns whether the testing mode is enabled.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-testMode.html",
				//	""),
				//
				//new EnumInputComputeOutput (
				//	ComputeAdsType.getGameId.ToString (),
				//	"",
				//	InOutWs.CodeWs.ifApplicationNotPlayingReturn +
				//	"\t\t\t\t#if UNITY_IOS || UNITY_ANDROID\n\t\t\t\tstringValue = UnityEngine.Advertisements.Advertisement.gameId;\n\t\t\t\t#endif",
				//	InOutWs.OutWs.string_,
				//	ExprWs.Gv.doIt + ExprWs.Gv.stringValue,
				//	"",
				//	ExprWs.UMDecl.computeAds,
				//	new string []
				//	{
				//		"",
				//		"Returns the game identifier for the current platform.",
				//	},
				//	"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-gameId.html",
				//	""),

				new EnumInputComputeOutput (
					ComputeAdsType.getDebugMode.ToString (),
					"",
					InOutWs.CodeWs.ifApplicationNotPlayingReturn +
					"\t\t\t\t#if UNITY_IOS || UNITY_ANDROID\n\t\t\t\tboolValue = " +
					"UnityEngine.Advertisements.Advertisement.debugMode;\n\t\t\t\t#endif",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeAds,
					new string []
					{
						"",
						"Controls the amount of logging output from the advertisement system.",
					},
					"https://docs.unity3d.com/ScriptReference/Advertisements.Advertisement-debugMode.html",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_MouseInput ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeMouseInputType.getMouseScrollDelta.ToString (),
					"",
					tab4 + "vector2Value = Input.mouseScrollDelta;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.vector2Value,
					"",
					ExprWs.UMDecl.computeMouseInput,
					new string []
					{
						"",
						"The current mouse scroll delta. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-mouseScrollDelta.html",
					""),

				new EnumInputComputeOutput (
					ComputeMouseInputType.getMousePresent.ToString (),
					"",
					tab4 + "boolValue = Input.mousePresent;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeMouseInput,
					new string []
					{
						"",
						"Indicates if a mouse device is detected.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-mousePresent.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeMouseInputType.getMousePosition.ToString (),
					"\t\t\t\tDrawInNodeInfo (\"First Person Cameras may lock the cursor\");\n\t\t\t\tDrawInNodeInfo (\"Get position after freeing the Cursor\");\n",
					tab4 + "Cursor.lockState = CursorLockMode.None;\n" +
					tab4 + "vector3Value = Input.mousePosition;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.vector3Value,
					"",
					ExprWs.UMDecl.computeMouseInput,
					new string []
					{
						"",
						"In the Logic Type: 'Unity Input Class and Cross Platform'",
						"you can also get the 'Mouse Position'",
						"but without freeing the cursor.",
						"Here you get the mouse position after freeing the cursor.",
						"",
						goToTheUnityDocumentation,
					},
					"https://docs.unity3d.com/ScriptReference/Input-mousePosition.html",
					""),
			};
		}



		EnumInputComputeOutput [] EnumInputComputeOutput_Rigidbody2D ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeRigidBody2DType.WakeUp.ToString (),
					"",
					tab4 + "rigidBody2D.WakeUp ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{ 
						"Disables the 'sleeping' state of a rigidbody.",
						"Sleeping is an optimisation that is used to",
						"temporarily remove an object from physics simulation when it is at rest.",
						"This function wakes up a rigidbody that is currently sleeping.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.WakeUp.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.Sleep.ToString (),
					"",
					tab4 + "rigidBody2D.Sleep ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Make the rigidbody 'sleep'.",
						"Sleeping is an optimisation that is used to temporarily remove an object",
						"from physics simulation when it is at rest. This function makes the rigidbody",
						"sleep - it is sometimes desirable to enable this manually rather than allowing",
						"automatic sleeping with",
						"the sleepMode property.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.Sleep.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setVelocity.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "rigidBody2D.velocity = vector2Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Linear velocity of the rigidbody.",
						"The velocity is specified as a vector with components in the X and Y directions",
						"(there is no Z direction in 2D physics). The value is not usually set directly",
						"but rather by using forces. The velocity can also gradually decay due to the",
						"effect of drag if this is enabled.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setUseAutoMass.ToString (),
					InOutWs.InWs._bool,
					tab4 + "rigidBody2D.useAutoMass = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Should the total rigid-body mass be automatically calculated from",
						"the [[Collider2D.density]] of attached colliders?",
						"When false, the explicitly set mass is used for the rigid-body mass.",
						"When true, the mass is automatically calculated from all attached Collider2D as",
						"a product of their [[Collider2D.density]] and area.",
						"When true, inside the Unity editor, the [[Collider2D.density]] property",
						"will appear on any attached Collider2D and the mass property will become read-only.",
						"When false, the mass property can be written to and the [[Collider2D.density]]",
						"property is not shown.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-useAutoMass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setSimulated.ToString (),
					InOutWs.InWs._bool,
					tab4 + "rigidBody2D.simulated = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Indicates whether the rigid body should be simulated or not by the physics system.",
						"When not simulated, any attached Collider2D or Joint2D also do not participate",
						"in the physics simulation.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-simulated.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setRotation.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody2D.rotation = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The rotation of the rigidbody.",
						"This is the rotation around the Z axis only.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-rotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setPosition.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "rigidBody2D.position = vector2Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The position of the rigidbody.",
						"This is the position of the X and Y axis only.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-position.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setMass.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody2D.mass = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Mass of the rigidbody.",
						"The mass is given in arbitrary units but the basic physical principles of",
						"mass apply. From Newton's classic equation force = mass x accelelation,",
						"it is apparent that the larger an object's mass, the more force it requires",
						"to accelerate it to a given velocity. Also, mass affects momentum,",
						"which is significant during collisions; an object with large mass will",
						"be moved less by a collision than an object with lower mass.",
						"The mass can also be automatically calculated when useAutoMass is true.",
						"In this case, you cannot set the mass property directly.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-mass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setIsKinematic.ToString (),
					InOutWs.InWs._bool,
					tab4 + "rigidBody2D.isKinematic = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Should this rigidbody be taken out of physics control?",
						"If this property is set to true then the rigidbody will stop",
						"reacting to collisions and applied forces. This can be useful when",
						"an object should usually be controlled 'kinematically' (ie, non-physically)",
						"but then sometimes needs physics for realism. For example, a human character is",
						"usually not implemented using physics but may sometimes be thrown through",
						"the air and collide with objects as the result",
						"of an impact or explosion.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-isKinematic.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setInertia.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody2D.inertia = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The rigidBody rotational inertia.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-inertia.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setGravityScale.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody2D.gravityScale = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The degree to which this object is affected by gravity.",
						"In 2D physics, the gravity is a global setting in the Physics2D class but",
						"you can also control the proportion of that gravity applied to each object",
						"individually using gravityScale. For example, it may be easier to implement",
						"a flying character by turning off its gravity rather than simulating the",
						"forces that keep it aloft.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-gravityScale.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setFreezeRotation.ToString (),
					InOutWs.InWs._bool,
					tab4 + "rigidBody2D.freezeRotation = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Controls whether physics will change the rotation of the object.",
						"If freezeRotation is enabled, the rotation in Z is not modified by the physics",
						"simulation.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-freezeRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setDrag.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody2D.drag = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Coefficient of drag.",
						"Drag is the tendency of an object to slow down due to friction with the air",
						"or water that surrounds it. The linear drag applies to positional movement and",
						"is set up separately from the angular drag that affects rotational movement.",
						"A higher value of drag will cause an object's rotation to come to rest more",
						"quickly following a collision or force.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-drag.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setCenterOfMass.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "rigidBody2D.centerOfMass = vector2Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The center of mass of the rigidBody in local space.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-centerOfMass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setAngularVelocity.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody2D.angularVelocity = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Angular velocity in degrees per second.",
						"Unlike a 3D Rigidbody, a Rigidbody2D can only rotate around one axis",
						"(perpendicular to the plane) so the angular velocity is just a float value",
						"rather than a vector. Typically, the value of this property is not set directly",
						"but rather by applying torques to the rigidbody.",
						"The angular velocity will also decrease automatically under the effect of angular drag.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-angularVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.setAngularDrag.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody2D.angularDrag = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Coefficient of angular drag.",
						"Drag is the tendency of an object to slow down due to friction with",
						"the air or water that surrounds it.",
						"The angular drag applies to",
						"rotational movement and is set up separately from the linear",
						"drag that affects positional movement.",
						"A higher value of angular drag will cause an object's rotation to come to rest",
						"more quickly following a collision or torque.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-angularDrag.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.MoveRotation.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody2D.MoveRotation (floatValues [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Rotates the rigidbody to angle (given in degrees).",
						"Rotates the rigidbody to the specified angle by calculating the appropriate",
						"angular velocity required to rotate the rigidbody to that angle during the next",
						"physics update.",
						"During the move, angular drag won't affect the body. This causes the object to",
						"rapidly move from the existing angle to the specified angle.",
						"Because this feature allows a rigidbody to be rotated rapidly to the specified",
						"angle, any colliders attached to the rigidbody will react as expected i.e.",
						"they will produce collisions and/or triggers. This also means that if the",
						"colliders produce a collision then it will affect the rigidbody movement and",
						"potentially stop it from reaching the specified angle during the next physics",
						"update. If the rigidbody is kinematic then any collisions won't affect the",
						"rigidbody itself and will only affect any other dynamic colliders.",
						"2D rigidbodies have a fixed limit on how fast they can rotate therefore attempting",
						"to rotate large angles over short time-scales can result in the rigidbody not",
						"reaching the specified angle during the next physics update. It is recommended",
						"that you use this for relatively small rotational movements only.",
						"It is important to understand that the actual rotation change will only occur",
						"during the next physics update therefore calling this method repeatedly without",
						"waiting for the next physics update will result in the last call being used.",
						"For this reason, it is recommended that it is called during the FixedUpdate",
						"callback.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.MoveRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.MovePosition.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "rigidBody2D.MovePosition (vector2Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Moves the rigidbody to position.",
						"Moves the rigidbody to the specified position by calculating the appropriate linear",
						"velocity required to move the rigidbody to that position during the next physics",
						"update.",
						"During the move, neither gravity or linear drag will affect the body. This causes",
						"the object to rapidly move from the existing position, through the world, to the",
						"specified position.",
						"Because this feature allows a rigidbody to be moved rapidly",
						"to the specified position through the world, any colliders attached to the",
						"rigidbody will react as expected i.e. they will produce collisions and/or triggers.",
						"This also means that if the colliders produce a collision then it will affect the",
						"rigidbody movement and potentially stop it from reaching the specified position",
						"during the next physics update. If the rigidbody is kinematic then any collisions",
						"won't affect the rigidbody itself and will only affect any other dynamic colliders.",
						"2D rigidbodies have a fixed limit on how fast they can move therefore attempting to",
						"move large distances over short time-scales can result in the rigidbody not",
						"reaching the specified position during the next physics update.",
						"It is recommended that you use this for relatively small distance movements only.",
						"It is important to understand that the actual position change will only occur",
						"during the next physics update therefore calling this method repeatedly without",
						"waiting for the next physics update will result in the last call being used.",
						"For this reason, it is recommended that it is called during the FixedUpdate",
						"callback.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.MovePosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.IsTouchingLayers.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tboolValue = rigidBody2D.IsTouchingLayers (intValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue + ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Checks whether any of the collider(s) attached to this rigidbody are touching any",
						"colliders on the specified layerMask or not.",
						"It is important to understand that checking if colliders are touching or not is",
						"performed against the last physics system update i.e. the state of touching",
						"colliders at that time. If you have just added a new Collider2D or have moved",
						"a Collider2D but a physics update has not yet taken place then the colliders",
						"will not be shown as touching. The touching state is identical to that indicated by",
						"the physics collision or trigger callbacks.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.IsTouchingLayers.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.IsTouching.ToString (),
					InOutWs.InWs._gameObject_1 + InOutWs.InWs._gameObject_1_check + 
					InOutWs.InWs._collider2D_1_Check,
					"\t\t\t\tif (gameObjectValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tcollider2D_1 = gameObjectValues [1].GetComponent<Collider2D>();\n\n\t\t\t\t\tif (collider2D_1 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tboolValue = rigidBody2D.IsTouching (collider2D_1);\n\t\t\t\t\t}\n\t\t\t\t}",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.collider2D_1 + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Checks whether the collider is touching any of the collider(s)",
						"attached to this rigidbody or not.",
						"It is important to understand that checking whether colliders are touching or not",
						"is performed against the last physics system update; that is the state of touching",
						"colliders at that time. If you have just added a new Collider2D or",
						"have moved a Collider2D but a physics update has not yet taken place then",
						"the colliders will not be shown as touching. This function returns the same",
						"collision results as the physics collision or trigger callbacks.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.IsTouching.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.IsSleeping.ToString (),
					"",
					tab4 + "boolValue = rigidBody2D.IsSleeping ();",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Is the rigidbody 'sleeping'?",
						"Sleeping is an optimisation that is used to temporarily remove an object from",
						"physics simulation when it is at rest.",
						"This function tells if the rigidbody is currently sleeping.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.IsSleeping.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.IsAwake.ToString (),
					"",
					tab4 + "boolValue = rigidBody2D.IsAwake ();",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Is the rigidbody 'awake'?",
						"Sleeping is an optimisation that is used to temporarily remove an object from",
						"physics simulation when it is at rest.",
						"This function tells if the rigidbody is currently awake.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.IsAwake.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getWorldCenterOfMass.ToString (),
					"",
					tab4 + "vector2Value = rigidBody2D.worldCenterOfMass;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Gets the center of mass of the rigidBody in global space.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-worldCenterOfMass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getVelocity.ToString (),
					"",
					tab4 + "vector2Value = rigidBody2D.velocity;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Linear velocity of the rigidbody.",
						"The velocity is specified as a vector with components in the X and Y directions",
						"(there is no Z direction in 2D physics). The value is not usually set directly",
						"but rather by using forces. The velocity can also gradually decay due to the",
						"effect of drag if this is enabled.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.GetVector.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "vector2Value = rigidBody2D.GetVector (vector2Values [0]);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Get a local space vector given the vector vector in rigidBody global space.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetVector.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getUseAutoMass.ToString (),
					"",
					tab4 + "boolValue = rigidBody2D.useAutoMass;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Should the total rigid-body mass be automatically calculated from",
						"the [[Collider2D.density]] of attached colliders?",
						"When false, the explicitly set mass is used for the rigid-body mass.",
						"When true, the mass is automatically calculated from all attached Collider2D as",
						"a product of their [[Collider2D.density]] and area.",
						"When true, inside the Unity editor, the [[Collider2D.density]] property",
						"will appear on any attached Collider2D and the mass property will become read-only.",
						"When false, the mass property can be written to and the [[Collider2D.density]]",
						"property is not shown.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-useAutoMass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getSimulated.ToString (),
					"",
					tab4 + "boolValue = rigidBody2D.simulated;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Indicates whether the rigid body should be simulated or not by the physics system.",
						"When not simulated, any attached Collider2D or Joint2D also do not participate",
						"in the physics simulation.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-simulated.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getRotation.ToString (),
					"",
					tab4 + "floatValue = rigidBody2D.rotation;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The rotation of the rigidbody.",
						"This is the rotation around the Z axis only.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-rotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.GetRelativeVector.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "vector2Value = rigidBody2D.GetRelativeVector (vector2Values [0]);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Get a global space vector given the vector relativeVector in rigidBody local space.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetRelativeVector.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.GetRelativePointVelocity.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "vector2Value = rigidBody2D.GetRelativePointVelocity (vector2Values [0]);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The velocity of the rigidbody at the point Point in local space.",
						"GetRelativePointVelocity will take the angularVelocity of the rigidbody into",
						"account when calculating the velocity.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetRelativePointVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.GetRelativePoint.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "vector2Value = rigidBody2D.GetRelativePoint (vector2Values [0]);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Get a global space point given the point relativePoint in rigidBody local space.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetRelativePoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getPosition.ToString (),
					"",
					tab4 + "vector2Value = rigidBody2D.position;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The position of the rigidbody.",
						"This is the position of the X and Y axis only.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-position.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.GetPointVelocity.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "vector2Value = rigidBody2D.GetPointVelocity (vector2Values [0]);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The velocity of the rigidbody at the point Point in global space.",
						"GetPointVelocity will take the angularVelocity of the rigidbody into account",
						"when calculating the velocity.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetPointVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.GetPoint.ToString (),
					InOutWs.InWs._vector2,
					tab4 + "vector2Value = rigidBody2D.GetPoint (vector2Values [0]);",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Get a local space point given the point point in rigidBody global space.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.GetPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getMass.ToString (),
					"",
					tab4 + "floatValue = rigidBody2D.mass;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Mass of the rigidbody.",
						"The mass is given in arbitrary units but the basic physical principles of",
						"mass apply. From Newton's classic equation force = mass x accelelation,",
						"it is apparent that the larger an object's mass, the more force it requires",
						"to accelerate it to a given velocity. Also, mass affects momentum,",
						"which is significant during collisions; an object with large mass will",
						"be moved less by a collision than an object with lower mass.",
						"The mass can also be automatically calculated when useAutoMass is true.",
						"In this case, you cannot set the mass property directly.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-mass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getIsKinematic.ToString (),
					"",
					tab4 + "boolValue = rigidBody2D.isKinematic;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Should this rigidbody be taken out of physics control?",
						"If this property is set to true then the rigidbody will stop",
						"reacting to collisions and applied forces. This can be useful when",
						"an object should usually be controlled 'kinematically' (ie, non-physically)",
						"but then sometimes needs physics for realism. For example, a human character is",
						"usually not implemented using physics but may sometimes be thrown through",
						"the air and collide with objects as the result",
						"of an impact or explosion.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-isKinematic.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getInertia.ToString (),
					"",
					tab4 + "floatValue = rigidBody2D.inertia;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The rigidBody rotational inertia.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-inertia.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getGravityScale.ToString (),
					"",
					tab4 + "floatValue = rigidBody2D.gravityScale;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The degree to which this object is affected by gravity.",
						"In 2D physics, the gravity is a global setting in the Physics2D class but",
						"you can also control the proportion of that gravity applied to each object",
						"individually using gravityScale. For example, it may be easier to implement",
						"a flying character by turning off its gravity rather than simulating the",
						"forces that keep it aloft.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-gravityScale.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getFreezeRotation.ToString (),
					"",
					tab4 + "boolValue = rigidBody2D.freezeRotation;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Controls whether physics will change the rotation of the object.",
						"If freezeRotation is enabled, the rotation in Z is not modified by the physics",
						"simulation.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-freezeRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getDrag.ToString (),
					"",
					tab4 + "floatValue = rigidBody2D.drag;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Coefficient of drag.",
						"Drag is the tendency of an object to slow down due to friction with the air",
						"or water that surrounds it. The linear drag applies to positional movement and",
						"is set up separately from the angular drag that affects rotational movement.",
						"A higher value of drag will cause an object's rotation to come to rest more",
						"quickly following a collision or force.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-drag.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getCenterOfMass.ToString (),
					"",
					tab4 + "vector2Value = rigidBody2D.centerOfMass;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"The center of mass of the rigidBody in local space.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-centerOfMass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getAngularVelocity.ToString (),
					"",
					tab4 + "floatValue = rigidBody2D.angularVelocity;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Angular velocity in degrees per second.",
						"Unlike a 3D Rigidbody, a Rigidbody2D can only rotate around one axis",
						"(perpendicular to the plane) so the angular velocity is just a float value",
						"rather than a vector. Typically, the value of this property is not set directly",
						"but rather by applying torques to the rigidbody.",
						"The angular velocity will also decrease automatically under the effect of angular drag.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-angularVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.getAngularDrag.ToString (),
					"",
					tab4 + "floatValue = rigidBody2D.angularDrag;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Coefficient of angular drag.",
						"Drag is the tendency of an object to slow down due to friction with",
						"the air or water that surrounds it.",
						"The angular drag applies to",
						"rotational movement and is set up separately from the linear",
						"drag that affects positional movement.",
						"A higher value of angular drag will cause an object's rotation to come to rest",
						"more quickly following a collision or torque.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D-angularDrag.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.ApplyForce.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Force\");" + ret +
					InOutWs.InWs._vector2 + ret + InOutWs.InWs._forceMode2D,
					tab4 + "rigidBody2D.AddForce (vector2Values [0], forceMode2D);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2Values + ExprWs.Gv.forceMode2D,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.ForceMode2D (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Apply a force to the rigidbody.",
						"The force is specified as two separate components in the X and Y directions",
						"(there is no Z direction in 2D physics). The object will be accelerated by the",
						"force according to the law force = mass x acceleration - the larger the mass,",
						"the greater the force required to accelerate to a given speed.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.AddForce.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.AddTorque.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Torque\");" + ret +
					InOutWs.InWs._float + ret + InOutWs.InWs._forceMode2D,
					tab4 + "rigidBody2D.AddTorque (floatValues [0], forceMode2D);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues + ExprWs.Gv.forceMode2D,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.ForceMode2D (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Apply a torque at the rigidbody's centre of mass.",
						"A torque is conceptually a force being applied at the end of an imaginary lever,",
						"with the fulcrum at the centre of mass. A torque of five units could thus",
						"be equivalent to a force of five units pushing on the end of a lever one unit long,",
						"or a force of one unit on a lever five units long. Unity's units are arbitrary",
						"but the principle that torque = force x lever length still applies.",
						"Note that unlike a 3D Rigidbody, a Rigidbody2D can only rotate in one axis and",
						"so torque is a float value rather than a vector.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.AddTorque.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.AddRelativeForce.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Relarive Force\");" + ret +
					InOutWs.InWs._vector2 + ret + InOutWs.InWs._forceMode2D,
					tab4 + "rigidBody2D.AddRelativeForce (vector2Values [0], forceMode2D);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2Values + ExprWs.Gv.forceMode2D,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.ForceMode2D (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Adds a force to the rigidbody2D relative to its coordinate system.",
						"The force is specified as two separate components in the X and Y directions",
						"(there is no Z direction in 2D physics).",
						"The object will be accelerated by the force according to the",
						"law force = mass x acceleration - the larger the mass,",
						"the greater the force required to accelerate to a given speed.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.AddRelativeForce.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBody2DType.AddForceAtPosition.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Force\");" + ret +
					InOutWs.InWs._vector2 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Position\");" + ret +
					InOutWs.InWs._vector2_1 + ret,
					tab4 + "rigidBody2D.AddForceAtPosition (vector2Values [0], vector2Values [1]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody2D_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector2Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck2D + ExprWs.UMDecl.computeRigidbody2D,
					new string []
					{
						"Apply a force at a given position in space.",
						"The AddForce function applies a force that acts straight through the rigidbody's",
						"centre of mass and so produces only positional movement and no rotation.",
						"AddForceAtPosition can apply the force at any position in world space and will",
						"typically also apply a torque to the object which will set it rotating. Note that",
						"for the purposes of this function, the rigidbody is just a coordinate space of",
						"infinite size, so there is no reason why the force needs to be applied within",
						"the confines of the object's graphic or colliders.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody2D.AddForceAtPosition.html",
					""),


			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_Light ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeLightType.getSpotAngle.ToString (),
					"",
					"\t\t\t\t" + "floatValue = lightComp.spotAngle;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The angle of the light's spotlight cone in degrees.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-spotAngle.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setSpotAngle.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "lightComp.spotAngle = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The angle of the light's spotlight cone in degrees.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-spotAngle.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getShadowStrength.ToString (),
					"",
					"\t\t\t\t" + "floatValue = lightComp.shadowStrength;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Strength of light's shadows.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowStrength.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setShadowStrength.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "lightComp.shadowStrength = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Strength of light's shadows.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowStrength.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeLightType.getShadowNormalBias.ToString (),
					"",
					"\t\t\t\t" + "floatValue = lightComp.shadowNormalBias;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Shadow mapping normal-based bias.",
						"Shadow caster surfaces are pushed inwards along their normals by this amount,",
						"to help prevent self-shadowing ('shadow acne') artifacts. Units of normal-based bias",
						"are expressed in terms of shadowmap texel size; typically values between 0.3-0.7 work well.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowNormalBias.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setShadowNormalBias.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "lightComp.shadowNormalBias = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Shadow mapping normal-based bias.",
						"Shadow caster surfaces are pushed inwards along their normals by this amount,",
						"to help prevent self-shadowing ('shadow acne') artifacts. Units of normal-based bias",
						"are expressed in terms of shadowmap texel size; typically values between 0.3-0.7 work well.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowNormalBias.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getShadowNearPlane.ToString (),
					"",
					"\t\t\t\t" + "floatValue = lightComp.shadowNearPlane;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Near plane value to use for shadow frustums.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowNearPlane.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setShadowNearPlane.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "lightComp.shadowNearPlane = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Near plane value to use for shadow frustums.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowNearPlane.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getShadowCustomResolution.ToString (),
					"",
					"\t\t\t\t" + "intValue = lightComp.shadowCustomResolution;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The custom resolution of the shadow map.",
						"By default, shadow map resolution is computed from its importance on screen.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowCustomResolution.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setShadowCustomResolution.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\t" + "lightComp.shadowCustomResolution = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The custom resolution of the shadow map.",
						"By default, shadow map resolution is computed from its importance on screen.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowCustomResolution.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getShadowBias.ToString (),
					"",
					"\t\t\t\t" + "floatValue = lightComp.shadowBias;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Shadow mapping constant bias.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowBias.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setShadowBias.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "lightComp.shadowBias = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Shadow mapping constant bias.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-shadowBias.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getRange.ToString (),
					"",
					"\t\t\t\t" + "floatValue = lightComp.range;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The range of the light.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-range.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setRange.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "lightComp.range = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The range of the light.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-range.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getIsBaked.ToString (),
					"",
					"\t\t\t\t" + "boolValue = lightComp.isBaked;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Is the light contribution already stored in lightmaps and/or lightprobes.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-isBaked.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getIntensity.ToString (),
					"",
					"\t\t\t\t" + "floatValue = lightComp.intensity;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The Intensity of a light is multiplied with the Light color.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-intensity.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setIntensity.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "lightComp.intensity = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The Intensity of a light is multiplied with the Light color.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-intensity.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getCullingMask.ToString (),
					"",
					"\t\t\t\t" + "intValue = lightComp.cullingMask;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"This is used to light certain objects in the scene selectively.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-cullingMask.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setCullingMask.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\t" + "lightComp.cullingMask = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"This is used to light certain objects in the scene selectively.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-cullingMask.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getCookieSize.ToString (),
					"",
					"\t\t\t\t" + "floatValue = lightComp.cookieSize;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The size of a directional light's cookie.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-cookieSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setCookieSize.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "lightComp.cookieSize = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The size of a directional light's cookie.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-cookieSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getColor.ToString (),
					"",
					"\t\t\t\t" + "colorValue = lightComp.color;",
					InOutWs.OutWs.color_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The color of the light.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-color.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setColor.ToString (),
					InOutWs.InWs._color,
					"\t\t\t\t" + "lightComp.color = colorValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ColorValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The color of the light.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-color.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getBounceIntensity.ToString (),
					"",
					"\t\t\t\t" + "floatValue = lightComp.bounceIntensity;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The multiplier that defines the strength of the bounce lighting.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-bounceIntensity.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setBounceIntensity.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\t" + "lightComp.bounceIntensity = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The multiplier that defines the strength of the bounce lighting.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-bounceIntensity.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getAreaSize.ToString (),
					"",
					"\t\t\t\t" + "vector2Value = lightComp.areaSize;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The size of the area light.",
						"This property is only exposed to Editor scripts.",
						"It is not exposed during Play mode.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-areaSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setAreaSize.ToString (),
					InOutWs.InWs._vector2,
					"\t\t\t\t" + "lightComp.areaSize = vector2Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"The size of the area light.",
						"This property is only exposed to Editor scripts.",
						"It is not exposed during Play mode.",
					},
					"https://docs.unity3d.com/ScriptReference/Light-areaSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setAlreadyLightmapped.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "lightComp.alreadyLightmapped = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Has the light already been lightmapped.",
					},
					"https://docs.unity3d.com/530/Documentation/ScriptReference/Light-alreadyLightmapped.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getAlreadyLightmapped.ToString (),
					"",
					"\t\t\t\t" + "boolValue = lightComp.alreadyLightmapped;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"",
						"Has the light already been lightmapped.",
					},
					"https://docs.unity3d.com/530/Documentation/ScriptReference/Light-alreadyLightmapped.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.setEnabled.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "lightComp.enabled = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getIsActiveAndEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = lightComp.isActiveAndEnabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"Has the Behaviour had enabled called.",
						"True while the behaviour is enabled, false when disabled.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-isActiveAndEnabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeLightType.getEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = lightComp.enabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.light_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_lightCheck_computeLight,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_Rigidbody ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeRigidBodyType.WakeUp.ToString (),
					"",
					tab4 + "rigidBody.WakeUp ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Forces a rigidbody to wake up.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.WakeUp.html",
					""),


				new EnumInputComputeOutput (
					ComputeRigidBodyType.SweepTestAll.ToString (),
					tab4 + "DrawFieldsForSweepTestAll ();" + "\n\n",
					tab4 + "hits = rigidBody.SweepTestAll (vector3Values [0], floatValues [0], queryTriggerInteraction);" + "\n\n" +
					tab4 + "AssignRayCasthitInfos (intValues [0]);",
					tab4 + "DrawIntWhichHit ();" + ret +
					tab4 + "DrawSweepTestResultField ();",
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +					 
					"\t\tQueryTriggerInteraction queryTriggerInteraction;\n\n" + 
					ExprWs.Gv.raycastHits + ExprWs.Gv.raycastHitValues +
					ExprWs.Gv.floatValues + ExprWs.Gv.vector3Values + ExprWs.Gv.intValues + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.QueryTriggerInteraction (this) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.assignRayCastHitInfosByIndex + ExprWs.UMDecl.resetRayCastHitInfos +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{						
						"Like Rigidbody.SweepTest, but returns all hits.",
						"The sweep may return multiple hits against the same collider if more then one of",
						"the rigidbody's attached colliders would hit it.",
						"Note that this function only works when a primitive collider type",
						"(sphere, cube or capsule) or a convex mesh is attached to",
						"the rigidbody object - concave mesh colliders will not work, although they can be",
						"detected in the scene by the sweep.",
						"This function can only return up to 128 hits.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.SweepTestAll.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.SweepTest.ToString (),
					tab4 + "DrawFieldsForSweepTest ();",
					tab4 + "boolValue = rigidBody.SweepTest (vector3Values [0], out hit, floatValues [0], queryTriggerInteraction);" + "\n\n" +
					tab4 + "AssignRayCasthitInfos ();",
					tab4 + "DrawSweepTestResultField ();",
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +					 
					"\t\tQueryTriggerInteraction queryTriggerInteraction;\n\n" + 
					ExprWs.Gv.raycastHit + ExprWs.Gv.raycastHitValues +
					ExprWs.Gv.floatValues + ExprWs.Gv.vector3Values + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.QueryTriggerInteraction (this) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.assignRayCastHitInfos + ExprWs.UMDecl.resetRayCastHitInfos +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{						
						"Tests if a rigidbody would collide with anything, if it was moved through the scene.",
						"This is similar to doing a Physics.Raycast for all points contained in any of",
						"a Rigidbody's colliders and returning the closest of all hits (if any) reported.",
						"This is useful for AI code, say if you need to know that an object would fit",
						"through a gap without colliding with anything.",
						"Note that this function only",
						"works when a primitive collider type (sphere, cube or capsule) or a convex mesh",
						"is attached to the rigidbody object - concave mesh colliders will not work,",
						"although they can be detected in the scene by the sweep.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.SweepTest.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.Sleep.ToString (),
					"",
					tab4 + "rigidBody.Sleep ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Forces a rigidbody to sleep at least one frame.",
						"A common use is to call this from Awake in order to make a rigidbody sleep at",
						"startup. See the Rigidbodies Overview in the manual for more information",
						"about Rigidbody sleeping.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.Sleep.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setVelocity.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "rigidBody.velocity = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The velocity vector of the rigidbody.",
						"In most cases you should not modify the velocity directly, as this can result",
						"in unrealistic behaviour. Don't set the velocity of an object every physics step,",
						"this will lead to unrealistic physics simulation. A typical example where you",
						"would change the velocity is when jumping in a first person shooter,",
						"because you want an immediate change in velocity.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-velocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setUseGravity.ToString (),
					InOutWs.InWs._bool,
					tab4 + "rigidBody.useGravity = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Controls whether gravity affects this rigidbody.",
						"If set to false the rigidbody will behave as in outer space.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-useGravity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setSolverIterations.ToString (),
					InOutWs.InWs._int,
					tab4 + "rigidBody.solverIterationCount = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The default solver iteration count permitted for any rigid bodies (default 7).",
						"Must be positive.",
						"The solverIterationCount determines how accurately joints",
						"and contacts are resolved. If you are having trouble with connected bodies",
						"oscillating and behaving erratically setting a higher solver iteration count",
						"may improve their stability (but is slower). Usually a value of 7 works very",
						"well for almost all situations.",
						"This value is usually changed in",
						"Edit->Project Settings->Physics inspector instead of from scripts.",
					},
					"https://docs.unity3d.com/530/Documentation/ScriptReference/Physics-solverIterationCount.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setSleepThreshold.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody.sleepThreshold = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The mass-normalized energy threshold, below which objects start going to sleep.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-sleepThreshold.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setRotation.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "rigidBody.rotation = Quaternion.Euler (vector3Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The rotation of the rigidbody.",
						"Rigidbody.rotation allows you to get and set the rotation of a Rigidbody using ",
						"the physics engine. If you change the rotation of a Rigidbody using",
						"Rigidbody.rotation, the transform will be updated after the next physics",
						"simulation step. This is faster than updating the rotation using Transform.rotation,",
						"as the latter will cause all attached Colliders to recalculate their rotation relative",
						"to the Rigidbody.",
						"If you want to continuously rotate a rigidbody use MoveRotation instead,",
						"which takes interpolation into account.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-rotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setPosition.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "rigidBody.position = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The position of the rigidbody.",
						"Rigidbody.position allows you to get and set the position of a Rigidbody using",
						"the physics engine. If you change the position of a Rigibody using",
						"Rigidbody.position, the transform will be updated after the next physics simulation",
						"step. This is faster than updating the position using Transform.position,",
						"as the latter will cause all attached Colliders to recalculate their positions",
						"relative to the Rigidbody.",
						"If you want to continuously move a rigidbody use",
						"MovePosition instead, which takes interpolation into account.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-position.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setMaxDepenetrationVelocity.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody.maxDepenetrationVelocity = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Maximum velocity of a rigidbody when moving out of penetrating state.",
						"Use this property when you want to make your bodies move out of colliding",
						"state in a more smooth way than by default.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-maxDepenetrationVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setMaxAngularVelocity.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody.maxAngularVelocity = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The maximimum angular velocity of the rigidbody. (Default 7) range { 0, infinity }.",
						"The angular velocity of rigidbodies is clamped to maxAngularVelocity to",
						"avoid numerical instability with fast rotating bodies.",
						"Because this may prevent intentional fast rotations on objects such as wheels,",
						"you can override this value per rigidbody.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-maxAngularVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setMass.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody.mass = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The mass of the rigidbody.",
						"Different Rigidbodies with large differences in mass can make the physics",
						"simulation unstable.",
						"Higher mass objects push lower mass objects more when colliding.",
						"Think of a big truck, hitting a small car.",
						"A common mistake is to assume",
						"that heavy objects fall faster than light ones. This is not true as the speed",
						"is dependent on gravity and drag.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-mass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setIsKinemaic.ToString (),
					InOutWs.InWs._bool,
					tab4 + "rigidBody.isKinematic = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Controls whether physics affects the rigidbody.",
						"If isKinematic is enabled, Forces, collisions or joints will not affect",
						"the rigidbody anymore. The rigidbody will be under full control of animation",
						"or script control by changing transform.position. Kinematic bodies also affect",
						"the motion of other rigidbodies through collisions or joints. Eg. can connect",
						"a kinematic rigidbody to a normal rigidbody with a joint and the rigidbody",
						"will be constrained with the motion of the kinematic body. Kinematic rigidbodies",
						"are also particularly useful for making characters which are normally driven by",
						"an animation, but on certain events can be quickly turned into a ragdoll by",
						"setting isKinematic to false.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-isKinematic.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setInertiaTensorRotation.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "rigidBody.inertiaTensorRotation = Quaternion.Euler (vector3Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The rotation of the inertia tensor.",
						"If you don't set intertia tensor rotation from a script it will be calculated",
						"automatically from all colliders attached to the rigidbody.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-inertiaTensorRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setInertiaTensor.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "rigidBody.inertiaTensor = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The diagonal inertia tensor of mass relative to the center of mass.",
						"The inertia tensor is rotated by the inertiaTensorRotation.",
						"If you don't set intertia tensor from a script it will be calculated automatically",
						"from all colliders attached to the rigidbody.",
						"You can reset the inertia tensor to the automatically computed value by",
						"calling Rigidbody.ResetInertiaTensor.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-inertiaTensor.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setDrag.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody.drag = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The drag of the object.",
						"Drag can be used to slow down an object. The higher the drag the more the object",
						"slows down.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-drag.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setDetectCollisions.ToString (),
					InOutWs.InWs._bool,
					tab4 + "rigidBody.detectCollisions = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Should collision detection be enabled? (By default always enabled).",
						"Disabling collision detections is useful when you have a ragdoll which is",
						"setup to be kinematic and you want to avoid heavy collision detection calculations",
						"on that rigidbody. detectCollisions is not serialized.",
						"This means it doesn't show up in the Inspector and when Instantiating",
						"the rigidbody or saving it in a scene, it will not be saved.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-detectCollisions.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.SetDensity.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody.SetDensity (floatValues [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Sets the mass based on the attached colliders assuming a constant density.",
						"This is useful to set the mass to a value which scales with the size of",
						"the colliders.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.SetDensity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setCenterOfMass.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "rigidBody.centerOfMass = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The center of mass relative to the transform's origin.",
						"If you don't set the center of mass from a script it will be calculated",
						"automatically from all colliders attached to the rigidbody. After a custom",
						"center of mass set, it will no longer be recomputed automatically on modifications",
						"such as adding or removing colliders, translating them, scaling etc.",
						"To revert back to the automatically computed center of mass,",
						"use Rigidbody.ResetCenterOfMass.",
						"Setting the center of mass is often",
						"useful when simulating cars to make them more stable.",
						"A car with a lower center of mass is less likely to topple over.",
						"Note: centerOfMass is relative to the transform's position and rotation,",
						"but will not reflect the transform's scale!",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-centerOfMass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setAngularVelocity.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "rigidBody.angularVelocity = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The angular velocity vector of the rigidbody measured in radians per second.",
						"In most cases you should not modify it directly, as this can result in unrealistic",
						"behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-angularVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.setAngularDrag.ToString (),
					InOutWs.InWs._float,
					tab4 + "rigidBody.angularDrag = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The angular drag of the object.",
						"Angular drag can be used to slow down the rotation of an object.",
						"The higher the drag the more the rotation slows down.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-angularDrag.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.ResetInertiaTensor.ToString (),
					"",
					tab4 + "rigidBody.ResetInertiaTensor ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Reset the inertia tensor value and rotation.",
						"Computes the inertia tensor, and the inertia tensor rotation from the colliders",
						"attached to this rigidbody and stores it. After calling this function,",
						"the inertia tensor and tensor rotation will be updated automatically after",
						"any modification of the rigidbody.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.ResetInertiaTensor.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.ResetCenterOfMass.ToString (),
					"",
					tab4 + "rigidBody.ResetCenterOfMass ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Reset the center of mass of the rigidbody.",
						"Computes the actual center of mass of the rigidbody from all the colliders attached,",
						"and stores it. After calling this function, the center of mass will get updated",
						"automatically after any modification to the rigidbody.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.ResetCenterOfMass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.MoveRotation.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "rigidBody.MoveRotation (Quaternion.Euler (vector3Values [0]));",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Rotates the rigidbody to rotation.",
						"Use Rigidbody.MoveRotation to rotate a Rigidbody, complying with",
						"the Rigidbody's interpolation setting.",
						"If Rigidbody interpolation is enabled on the Rigidbody,",
						"calling Rigidbody.MoveRotation will resulting in a smooth transition between",
						"the two positions in any intermediate frames rendered. This should be used",
						"if you want to continuously rotate a rigidbody in each FixedUpdate.",
						"Set Rigidbody.rotation instead, if you want to teleport a rigidbody from",
						"one rotation to another, with no intermediate positions being rendered.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.MoveRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.MovePosition.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "rigidBody.MovePosition (vector3Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Moves the rigidbody to position.",
						"Use Rigidbody.MovePosition to move a Rigidbody, complying with",
						"the Rigidbody's interpolation setting.",
						"If Rigidbody interpolation is enabled on the Rigidbody,",
						"calling Rigidbody.MovePosition results in a smooth transition between",
						"the two positions in any intermediate frames rendered. This should be used",
						"if you want to continuously move a rigidbody in each FixedUpdate.",
						"Set Rigidbody.position instead, if you want to teleport a rigidbody from one",
						"position to another, with no intermediate positions being rendered.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.MovePosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.IsSleeping.ToString (),
					"",
					tab4 + "boolValue = rigidBody.IsSleeping ();",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Is the rigidbody sleeping?",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.IsSleeping.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getWorldCenterOfMass.ToString (),
					"",
					tab4 + "vector3Value = rigidBody.worldCenterOfMass;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The center of mass of the rigidbody in world space (Read Only).",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-worldCenterOfMass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getVelocity.ToString (),
					"",
					tab4 + "vector3Value = rigidBody.velocity;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The velocity vector of the rigidbody.",
						"In most cases you should not modify the velocity directly, as this can result",
						"in unrealistic behaviour. Don't set the velocity of an object every physics step,",
						"this will lead to unrealistic physics simulation. A typical example where you",
						"would change the velocity is when jumping in a first person shooter,",
						"because you want an immediate change in velocity.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-velocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getUseGravity.ToString (),
					"",
					tab4 + "boolValue = rigidBody.useGravity;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Controls whether gravity affects this rigidbody.",
						"If set to false the rigidbody will behave as in outer space.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-useGravity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getSolverIterations.ToString (),
					"",
					tab4 + "intValue = rigidBody.solverIterationCount;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The default solver iteration count permitted for any rigid bodies (default 7).",
						"Must be positive.",
						"The solverIterationCount determines how accurately joints",
						"and contacts are resolved. If you are having trouble with connected bodies",
						"oscillating and behaving erratically setting a higher solver iteration count",
						"may improve their stability (but is slower). Usually a value of 7 works very",
						"well for almost all situations.",
						"This value is usually changed in",
						"Edit->Project Settings->Physics inspector instead of from scripts.",
					},
					"https://docs.unity3d.com/530/Documentation/ScriptReference/Physics-solverIterationCount.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getSleepThreshold.ToString (),
					"",
					tab4 + "floatValue = rigidBody.sleepThreshold;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The mass-normalized energy threshold, below which objects start going to sleep.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-sleepThreshold.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getRotation.ToString (),
					"",
					tab4 + "vector3Value = rigidBody.rotation.eulerAngles;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The rotation of the rigidbody.",
						"Rigidbody.rotation allows you to get and set the rotation of a Rigidbody using ",
						"the physics engine. If you change the rotation of a Rigidbody using",
						"Rigidbody.rotation, the transform will be updated after the next physics",
						"simulation step. This is faster than updating the rotation using Transform.rotation,",
						"as the latter will cause all attached Colliders to recalculate their rotation relative",
						"to the Rigidbody.",
						"If you want to continuously rotate a rigidbody use MoveRotation instead,",
						"which takes interpolation into account.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-rotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.GetRelativePointVelocity.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = rigidBody.GetRelativePointVelocity (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The velocity relative to the rigidbody at the point relativePoint.",
						"GetRelativePointVelocity will take the angularVelocity of the rigidbody into",
						"account when calculating the velocity.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.GetRelativePointVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getPosition.ToString (),
					"",
					tab4 + "vector3Value = rigidBody.position;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The position of the rigidbody.",
						"Rigidbody.position allows you to get and set the position of a Rigidbody using",
						"the physics engine. If you change the position of a Rigibody using",
						"Rigidbody.position, the transform will be updated after the next physics simulation",
						"step. This is faster than updating the position using Transform.position,",
						"as the latter will cause all attached Colliders to recalculate their positions",
						"relative to the Rigidbody.",
						"If you want to continuously move a rigidbody use",
						"MovePosition instead, which takes interpolation into account.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-position.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.GetPointVelocity.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = rigidBody.GetPointVelocity (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The velocity of the rigidbody at the point worldPoint in global space.",
						"GetPointVelocity will take the angularVelocity of the rigidbody into account",
						"when calculating the velocity.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.GetPointVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getMaxDepenetrationVelocity.ToString (),
					"",
					tab4 + "floatValue = rigidBody.maxDepenetrationVelocity;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Maximum velocity of a rigidbody when moving out of penetrating state.",
						"Use this property when you want to make your bodies move out of colliding",
						"state in a more smooth way than by default.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-maxDepenetrationVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getMaxAngularVelocity.ToString (),
					"",
					tab4 + "floatValue = rigidBody.maxAngularVelocity;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The maximimum angular velocity of the rigidbody. (Default 7) range { 0, infinity }.",
						"The angular velocity of rigidbodies is clamped to maxAngularVelocity to",
						"avoid numerical instability with fast rotating bodies.",
						"Because this may prevent intentional fast rotations on objects such as wheels,",
						"you can override this value per rigidbody.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-maxAngularVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getMass.ToString (),
					"",
					tab4 + "floatValue = rigidBody.mass;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The mass of the rigidbody.",
						"Different Rigidbodies with large differences in mass can make the physics",
						"simulation unstable.",
						"Higher mass objects push lower mass objects more when colliding.",
						"Think of a big truck, hitting a small car.",
						"A common mistake is to assume",
						"that heavy objects fall faster than light ones. This is not true as the speed",
						"is dependent on gravity and drag.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-mass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getIsKinemaic.ToString (),
					"",
					tab4 + "boolValue = rigidBody.isKinematic;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Controls whether physics affects the rigidbody.",
						"If isKinematic is enabled, Forces, collisions or joints will not affect",
						"the rigidbody anymore. The rigidbody will be under full control of animation",
						"or script control by changing transform.position. Kinematic bodies also affect",
						"the motion of other rigidbodies through collisions or joints. Eg. can connect",
						"a kinematic rigidbody to a normal rigidbody with a joint and the rigidbody",
						"will be constrained with the motion of the kinematic body. Kinematic rigidbodies",
						"are also particularly useful for making characters which are normally driven by",
						"an animation, but on certain events can be quickly turned into a ragdoll by",
						"setting isKinematic to false.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-isKinematic.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getInertiaTensorRotation.ToString (),
					"",
					"\t\t\t\tvector3Value = rigidBody.inertiaTensorRotation.eulerAngles;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The rotation of the inertia tensor.",
						"If you don't set intertia tensor rotation from a script it will be calculated",
						"automatically from all colliders attached to the rigidbody.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-inertiaTensorRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getInertiaTensor.ToString (),
					"",
					"\t\t\t\tvector3Value = rigidBody.inertiaTensor;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The diagonal inertia tensor of mass relative to the center of mass.",
						"The inertia tensor is rotated by the inertiaTensorRotation.",
						"If you don't set intertia tensor from a script it will be calculated automatically",
						"from all colliders attached to the rigidbody.",
						"You can reset the inertia tensor to the automatically computed value by",
						"calling Rigidbody.ResetInertiaTensor.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-inertiaTensor.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getDrag.ToString (),
					"",
					"\t\t\t\tfloatValue = rigidBody.drag;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The drag of the object.",
						"Drag can be used to slow down an object. The higher the drag the more the object",
						"slows down.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-drag.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getDetectCollisions.ToString (),
					"",
					"\t\t\t\tboolValue = rigidBody.detectCollisions;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Should collision detection be enabled? (By default always enabled).",
						"Disabling collision detections is useful when you have a ragdoll which is",
						"setup to be kinematic and you want to avoid heavy collision detection calculations",
						"on that rigidbody. detectCollisions is not serialized.",
						"This means it doesn't show up in the Inspector and when Instantiating",
						"the rigidbody or saving it in a scene, it will not be saved.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-detectCollisions.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getCenterOfMass.ToString (),
					"",
					"\t\t\t\tvector3Value = rigidBody.centerOfMass;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The center of mass relative to the transform's origin.",
						"If you don't set the center of mass from a script it will be calculated",
						"automatically from all colliders attached to the rigidbody. After a custom",
						"center of mass set, it will no longer be recomputed automatically on modifications",
						"such as adding or removing colliders, translating them, scaling etc.",
						"To revert back to the automatically computed center of mass,",
						"use Rigidbody.ResetCenterOfMass.",
						"Setting the center of mass is often",
						"useful when simulating cars to make them more stable.",
						"A car with a lower center of mass is less likely to topple over.",
						"Note: centerOfMass is relative to the transform's position and rotation,",
						"but will not reflect the transform's scale!",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-centerOfMass.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getAngularVelocity.ToString (),
					"",
					"\t\t\t\tvector3Value = rigidBody.angularVelocity;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The angular velocity vector of the rigidbody measured in radians per second.",
						"In most cases you should not modify it directly, as this can result in unrealistic",
						"behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-angularVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.getAngularDrag.ToString (),
					"",
					"\t\t\t\tfloatValue = rigidBody.angularDrag;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The angular drag of the object.",
						"Angular drag can be used to slow down the rotation of an object.",
						"The higher the drag the more the rotation slows down.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody-angularDrag.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.ClosestPointOnBounds.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Position\");\n\t\t\t\tDrawVector3InputField (0);",
					"\t\t\t\tvector3Value = rigidBody.ClosestPointOnBounds (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"The closest point to the bounding box of the attached colliders.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.ClosestPointOnBounds.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.ApplyForce.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Force\");\n\t\t\t\tDrawVector3InputField (0);\n\n\t\t\t\tforceMode = (ForceMode)DrawEnum (forceMode, \"Force Mode\", Skins.logicNodeLabel);",
					"\t\t\t\trigidBody.AddForce (vector3Values [0], forceMode);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values + ExprWs.Gv.forceMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.ForceMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Adds a force to the Rigidbody.",
						"Force is applied continuously along the direction of the force vector.",
						"Specifying the ForceMode mode allows the type of force to be changed to",
						"an Acceleration, Impulse or Velocity Change.",
						"Force can be applied only to an active Rigidbody. If a GameObject is inactive,",
						"AddForce has no effect.",
						"By default the Rigidbody's state is set to awake once a force is applied,",
						"unless the force is Vector3.zero.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.AddTorque.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Torque\");\n\t\t\t\tDrawVector3InputField (0);\n\n\t\t\t\tforceMode = (ForceMode)DrawEnum (forceMode, \"Force Mode\", Skins.logicNodeLabel);",
					"\t\t\t\trigidBody.AddTorque (vector3Values [0], forceMode);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values + ExprWs.Gv.forceMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.ForceMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Adds a torque to the rigidbody.",
						"Force can be applied only to an active rigidbody. If a GameObject is inactive,",
						"AddTorque has no effect.",
						"Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody",
						"will not be woken up.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddTorque.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.AddRelativeTorque.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Torque\");\n\t\t\t\tDrawVector3InputField (0);\n\n\t\t\t\tforceMode = (ForceMode)DrawEnum (forceMode, \"Force Mode\", Skins.logicNodeLabel);",
					"\t\t\t\trigidBody.AddRelativeTorque (vector3Values [0], forceMode);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values + ExprWs.Gv.forceMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.ForceMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Adds a torque to the rigidbody relative to its coordinate system.",
						"Force can be applied only to an active rigidbody. If a GameObject is inactive,",
						"AddRelativeTorque has no effect.",
						"Wakes up the Rigidbody by default.",
						"If the torque size is zero then the Rigidbody will not be woken up.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddRelativeTorque.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.AddRelativeForce.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Force\");\n\t\t\t\tDrawVector3InputField (0);\n\n\t\t\t\tforceMode = (ForceMode)DrawEnum (forceMode, \"Force Mode\", Skins.logicNodeLabel);",
					"\t\t\t\trigidBody.AddRelativeForce (vector3Values [0], forceMode);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values + ExprWs.Gv.forceMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.ForceMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Adds a force to the rigidbody relative to its coordinate system.",
						"Force can be applied only to an active rigidbody. If a GameObject is inactive,",
						"AddRelativeForce has no effect.",
						"Wakes up the Rigidbody by default.",
						"If the force size is zero then the Rigidbody will not be woken up.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddRelativeForce.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.AddForceAtPosition.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Force\");\n\t\t\t\tDrawVector3InputField (0);\n\n\t\t\t\tDrawLogicNodeLabel (\"Position\");\n\t\t\t\tDrawVector3InputField (1);",
					"\t\t\t\trigidBody.AddForceAtPosition (vector3Values [0], vector3Values [1]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Applies force at position. As a result this will apply a torque and force on",
						"the object.",
						"For realistic effects position should be approximately in the",
						"range of the surface of the rigidbody. This is most commonly used for explosions.",
						"When applying explosions it is best to apply forces over several frames instead",
						"of just one. Note that when position is far away from the center of the rigidbody",
						"the applied torque will be unrealistically large.",
						"Force can be applied only",
						"to an active rigidbody. If a GameObject is inactive, AddForceAtPosition has",
						"no effect.",
						"Wakes up the Rigidbody by default. If the force size is zero then",
						"the Rigidbody will not be woken up.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddForceAtPosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeRigidBodyType.AddExplosionForce.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Explosion Force\");\n\t\t\t\tDrawFloatInputField (0);\n\n\t\t\t\tDrawLogicNodeLabel (\"Explosion Position\");\n\t\t\t\tDrawVector3InputField (0);\n\n\t\t\t\tDrawLogicNodeLabel (\"Explosion Radius\");\n\t\t\t\tDrawFloatInputField (1);\n\n\t\t\t\tDrawLogicNodeLabel (\"Upwards Modifier\");\n\t\t\t\tDrawFloatInputField (2);\n\n\t\t\t\tforceMode = (ForceMode)DrawEnum (forceMode, \"Force Mode\", Skins.logicNodeLabel);",
					"\t\t\t\trigidBody.AddExplosionForce (floatValues [0], vector3Values [0], floatValues [1], floatValues [2], forceMode);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.rigidBody_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues + ExprWs.Gv.vector3Values + ExprWs.Gv.forceMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.ForceMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.rigidbodyCheck + ExprWs.UMDecl.computeRigidbody,
					new string []
					{
						"Applies a force to a rigidbody that simulates explosion effects.",
						"The explosion is modelled as a sphere with a certain centre position and radius",
						"in world space; normally, anything outside the sphere is not affected by",
						"the explosion and the force decreases in proportion to distance from the centre.",
						"However, if a value of zero is passed for the radius then the full force will",
						"be applied regardless of how far the centre is from the rigidbody.",
						"By default, the direction of the force is the line going from the explosion centre",
						"to the rigidbody's centre of mass. If you pass a non-zero value for",
						"the upwardsModifier parameter, the direction will be modified by subtracting that",
						"value from the Y component of the centre point.",
						"For example, if you pass a value of 2.0 for upwardsModifier,",
						"the explosion will appear to be centred 2.0 units below its actual position",
						"for purposes of calculating the force direction (ie, the centre and the radius",
						"of effect are not modified). Using this parameter, you can easily make",
						"the explosion appear to throw objects up into the air, which often gives",
						"a more dramatic effect than a simple outward force.",
						"Force can be applied only to an active rigidbody. If a GameObject is inactive,",
						"AddExplosionForce has no effect.",
					},
					"https://docs.unity3d.com/ScriptReference/Rigidbody.AddExplosionForce.html",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_LineRenderer ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeLineRendererType.setLineRendererColors.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Start and End Colors\");\n" +
					InOutWs.InWs._color_and_1,
					"\t\t\t\tlineRenderer.startColor = colorValues [0];\n" +
					"\t\t\t\tlineRenderer.endColor = colorValues [1];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.lineRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ColorValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.lineRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Set the line color at the start and at the end.",
					},
					"https://docs.unity3d.com/ScriptReference/LineRenderer-startColor.html",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_SpriteRenderer ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeSpriteRendererType.tile.ToString (),
					"\t\t\t\tDrawSpriteRendererTileInputs ();",
					"\t\t\t\tTileSprite ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Values + ExprWs.Gv.floatValues + ExprWs.Gv.boolValues + ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this) + ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.FloattValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.tileSprite +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Tile a sprite horizontally and vertically.",
						"You can perform rotations over tiling, separatly on x and y or continusly.",
						"Your tiling can be fractional, 2.5 on x will give you 2 sprites and half tiled",
						"P.S. transform scale and sprite size are bothe taked into account to offer more control,",
						"so for simple adjacent tiling you can put one or both of sprite size and transform scale to 1,",
						"this will help you te see more clearly what is happening.",
						"IMPORTANT - 2 thinks to do before using the tile node:",
						"1. In the sprite import settings choose 'Full rect' for the Mesh Type",
						"2. Put the Sprite Renderer Draw Mode to Sliced in the sprite renderer inspector or via Diamond",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.getSize.ToString (),
					"",
					"\t\t\t\tvector2Value = spriteRenderer.size;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll + ExprWs.Gv.vector2Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Property to set/get the size to render when",
						"the SpriteRenderer.drawMode is set to SpriteDrawMode.NineSlice.",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-size.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.setSize.ToString (),
					InOutWs.InWs._vector2,
					"\t\t\t\tspriteRenderer.size = vector2Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Property to set/get the size to render when",
						"the SpriteRenderer.drawMode is set to SpriteDrawMode.NineSlice.",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-size.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.getAdaptiveModeThreshold.ToString (),
					"",
					"\t\t\t\tfloatValue = spriteRenderer.adaptiveModeThreshold;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll + ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"The current threshold for Sprite Renderer tiling.",
						"This specifies the threshold to determine when Sprite Renderer",
						"will tile the sprite when SpriteRenderer.tileMode is set to SpriteTileMode.Adaptive.",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-adaptiveModeThreshold.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.setAdaptiveModeThreshold.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tspriteRenderer.adaptiveModeThreshold = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"The current threshold for Sprite Renderer tiling.",
						"This specifies the threshold to determine when Sprite Renderer",
						"will tile the sprite when SpriteRenderer.tileMode is set to SpriteTileMode.Adaptive.",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-adaptiveModeThreshold.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.setSpriteTileMode.ToString (),
					"\t\t\t\tspriteTileMode = (SpriteTileMode)DrawEnum (spriteTileMode, \"Sprite Tile Mode\", Skins.logicNodeLabel);\n",
					"\t\t\t\tspriteRenderer.tileMode = spriteTileMode;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.spriteTileMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.spriteTileMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"The current tile mode of the Sprite Renderer.",
						"SpriteRenderer.tileMode affects the tiling behaviour",
						"when SpriteRenderer.drawMode",
						"is set to SpriteDrawMode.Tiled.",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-tileMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.setSpriteDrawMode.ToString (),
					"\t\t\t\tspriteDrawMode = (SpriteDrawMode)DrawEnum (spriteDrawMode, \"Sprite Draw Mode\", Skins.logicNodeLabel);\n",
					"\t\t\t\tspriteRenderer.drawMode = spriteDrawMode;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.spriteDrawMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.spriteDrawMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"The current draw mode of the Sprite Renderer.",
						"When the drawMode is set to SpriteDrawMode.Sliced or SpriteDrawMode.Tiled,",
						"the SpriteRenderer will render the sprite as a 9-slice image.",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-drawMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.setSpriteRendererFlipY.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tspriteRenderer.flipY = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Flips the sprite on the Y axis.",
						"Only the rendering is affected. Use negative Transform.scale,",
						"if you want to affect all the other components (for example colliders).",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-flipY.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.setSpriteRendererFlipX.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tspriteRenderer.flipX = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Flips the sprite on the X axis.",
						"Only the rendering is affected. Use negative Transform.scale,",
						"if you want to affect all the other components (for example colliders).",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-flipX.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.setSpriteRendererColor.ToString (),
					InOutWs.InWs._color,
					"\t\t\t\tspriteRenderer.color = colorValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ColorValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Rendering color for the Sprite graphic.",
						"Becomes the vertex color and can be accessed in a pixel shader.",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-color.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.getSpriteRendererFlipY.ToString (),
					"",
					"\t\t\t\tboolValue = spriteRenderer.flipY;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Flips the sprite on the Y axis.",
						"Only the rendering is affected. Use negative Transform.scale,",
						"if you want to affect all the other components (for example colliders).",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-flipY.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.getSpriteRendererFlipX.ToString (),
					"",
					"\t\t\t\tboolValue = spriteRenderer.flipX;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Flips the sprite on the X axis.",
						"Only the rendering is affected. Use negative Transform.scale,",
						"if you want to affect all the other components (for example colliders).",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-flipX.html",
					""),

				new EnumInputComputeOutput (
					ComputeSpriteRendererType.getSpriteRendererColor.ToString (),
					"",
					"\t\t\t\tcolorValue = spriteRenderer.color;",
					InOutWs.OutWs.color_,
					ExprWs.Gv.spriteRenderer_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.spriteRendererCheck + ExprWs.UMDecl.computeRenderer,
					new string []
					{
						"Rendering color for the Sprite graphic.",
						"Becomes the vertex color and can be accessed in a pixel shader.",
					},
					"https://docs.unity3d.com/ScriptReference/SpriteRenderer-color.html",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_ParticleSystem ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeParticleSystemType.Stop.ToString (),
					"",
					"\t\t\t\tparticleSystem.Stop ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Stops playing the particle system using the supplied stop behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.Stop.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setStartSpeed.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tpsMain.startSpeed = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"",
						"The initial speed of particles when emitted",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startSpeed.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setStartSize.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tpsMain.startSize = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"",
						"The initial size of particles when emitted.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setStartRotation3D.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tpsMain.startRotation3D = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"",
						"A flag to enable 3D particle rotation.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startRotation3D.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setStartRotation.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tpsMain.startRotation = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The initial rotation of particles when emitted.",
						"Note that the value should be given in radians",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setStartLifeTime.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tpsMain.startLifetime = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The total lifetime in seconds that each new particle will have.",
						"This value is set on the particle when it is created by the particle system",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startLifetime.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setStartDelay.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tpsMain.startDelay = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Start delay in seconds.",
						"Use this to delay when the playback starts on the system.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startDelay.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setStartColor.ToString (),
					InOutWs.InWs._color,
					"\t\t\t\tpsMain.startColor = colorValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ColorValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The initial color of particles when emitted.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startColor.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setSimulationSpace.ToString (),
					"\t\t\t\tparticleSystemSimulationSpace = (ParticleSystemSimulationSpace)DrawEnum (particleSystemSimulationSpace, \"Simulation Space\", Skins.logicNodeLabel);",
					"\t\t\t\tpsMain.simulationSpace = particleSystemSimulationSpace;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.particleSystemSimulationSpace,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ParticleSystemSimulationSpace (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"This selects the space in which to simulate particles.",
						"It can be either world or local space.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-simulationSpace.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setScalingMode.ToString (),
					"\t\t\t\tparticleSystemScalingMode = (ParticleSystemScalingMode)DrawEnum (particleSystemScalingMode, \"Scaling Mode\", Skins.logicNodeLabel);",
					"\t\t\t\tpsMain.scalingMode = particleSystemScalingMode;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.particleSystemScalingMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ParticleSystemScalingMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Control how the particle system's Transform Component is applied to the particle system.",
						"Hierarchy: Scale according to its Transform and all its parents. Local: Scale using only",
						"its own Transform,",
						"ignroing all parents. Shape: Only apply scale to the source positions of the particles,",
						"but not their size. The source positions are defined by the Shape module.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-scalingMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setRandomSeed.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tparticleSystem.randomSeed = (uint)intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Override the random seed used for the particle system emission.",
						"Setting this will also set ParticleSystem.useAutoRandomSeed to false.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-randomSeed.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setPlayOnAwake.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tpsMain.playOnAwake = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"If set to true, the particle system will automatically start playing on startup.",
						"Note that this setting is shared between all particle systems in the current particle",
						"effect.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-playOnAwake.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setPlaybackTime.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tparticleSystem.time = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Playback position in seconds.",
						"Use this to read current playback time or to seek to a new playback time.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-time.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setPlaybackSpeed.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tpsMain.simulationSpeed = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Override the default playback speed of the Particle System.",
						"Useful for speeding up or slowing down the entire simulation.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-simulationSpeed.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setMaxParticles.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tpsMain.maxParticles = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The maximum number of particles to emit.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-maxParticles.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setIsLooping.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tpsMain.loop = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Is the particle system looping?",
						"If you disable looping on a playing particle system, it will stop after the end of",
						"the current loop.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-loop.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.setGravityModifier.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tpsMain.gravityModifier = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Scale being applied to the gravity defined by Physics.gravity.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-gravityModifier.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.Play.ToString (),
					"",
					"\t\t\t\tparticleSystem.Play ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Starts the particle system.",
						"Sets the particle systems into play mode and enables emitting (if it has been disabled).",
						"If the particle system has been paused, then this resumes playing from the previous time.",
						"If the particle system has stopped, then the system starts from time 0,",
						"and, if it is relevant, the startDelay is applied.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.Play.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.Pause.ToString (),
					"",
					"\t\t\t\tparticleSystem.Pause ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Pauses the system so no new particles are emitted and the existing particles are not updated.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.Pause.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getStartSpeed.ToString (),
					"",
					"\t\t\t\tfloatValue = particleSystem.main.startSpeed.constant;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"",
						"The initial speed of particles when emitted",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startSpeed.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getStartSize.ToString (),
					"",
					"\t\t\t\tfloatValue = psMain.startSize.constant;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"",
						"The initial size of particles when emitted.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getStartRotation3D.ToString (),
					"",
					"\t\t\t\tboolValue = psMain.startRotation3D;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"",
						"A flag to enable 3D particle rotation.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startRotation3D.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getStartRotation.ToString (),
					"",
					"\t\t\t\tfloatValue = psMain.startRotation.constant;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The initial rotation of particles when emitted.",
						"Note that the value should be given in radians",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getStartLifeTime.ToString (),
					"",
					"\t\t\t\tfloatValue = psMain.startLifetime.constant;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The total lifetime in seconds that each new particle will have.",
						"This value is set on the particle when it is created by the particle system",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startLifetime.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getStartDelay.ToString (),
					"",
					"\t\t\t\tfloatValue = psMain.startDelay.constant;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Start delay in seconds.",
						"Use this to delay when the playback starts on the system.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startDelay.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getStartColor.ToString (),
					"",
					"\t\t\t\tcolorValue = psMain.startColor.color;",
					InOutWs.OutWs.color_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The initial color of particles when emitted.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-startColor.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getRandomSeed.ToString (),
					"",
					"\t\t\t\tintValue = (int)particleSystem.randomSeed;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Override the random seed used for the particle system emission.",
						"Setting this will also set ParticleSystem.useAutoRandomSeed to false.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-randomSeed.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getPlayOnAwake.ToString (),
					"",
					"\t\t\t\tboolValue = psMain.playOnAwake;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"If set to true, the particle system will automatically start playing on startup.",
						"Note that this setting is shared between all particle systems in the current particle",
						"effect.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-playOnAwake.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getPlaybackTime.ToString (),
					"",
					"\t\t\t\tfloatValue = particleSystem.time;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Playback position in seconds.",
						"Use this to read current playback time or to seek to a new playback time.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-time.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getPlaybackSpeed.ToString (),
					"",
					"\t\t\t\tfloatValue = psMain.simulationSpeed;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Override the default playback speed of the Particle System.",
						"Useful for speeding up or slowing down the entire simulation.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-simulationSpeed.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getParticleCount.ToString (),
					"",
					"\t\t\t\tintValue = particleSystem.particleCount;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The current number of particles (Read Only).",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-particleCount.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getMaxParticles.ToString (),
					"",
					"\t\t\t\tintValue = psMain.maxParticles;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The maximum number of particles to emit.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-maxParticles.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getIsStopped.ToString (),
					"",
					"\t\t\t\tboolValue = particleSystem.isStopped;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Is the particle system stopped right now ?",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-isStopped.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getIsPlaying.ToString (),
					"",
					"\t\t\t\tboolValue = particleSystem.isPlaying;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Is the particle system playing right now ?",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-isPlaying.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getIsPaused.ToString (),
					"",
					"\t\t\t\tboolValue = particleSystem.isPaused;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Is the particle system paused right now ?",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-isPaused.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getIsLooping.ToString (),
					"",
					"\t\t\t\tboolValue = psMain.loop;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Is the particle system looping?",
						"If you disable looping on a playing particle system, it will stop after the end of",
						"the current loop.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-loop.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getIsAlive.ToString (),
					"",
					"\t\t\t\tboolValue = particleSystem.IsAlive ();",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Does the system have any live particles (or will produce more)?",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.IsAlive.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getGravityModifier.ToString (),
					"",
					"\t\t\t\tfloatValue = psMain.gravityModifier.constant;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Scale being applied to the gravity defined by Physics.gravity.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.MainModule-gravityModifier.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.getDuration.ToString (),
					"",
					"\t\t\t\tfloatValue = psMain.duration;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"The duration of the particle system in seconds (Read Only).",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem-duration.html",
					""),

				new EnumInputComputeOutput (
					ComputeParticleSystemType.EmitImmediat.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Count particles\");\n\t\t\t\tDrawIntInputField (0);",
					"\t\t\t\tparticleSystem.Emit (intValues [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.particleSystem_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.particleSystemCheck +ExprWs.UMDecl.computeParticleSystem,
					new string []
					{
						"Emit count particles immediately.",
					},
					"https://docs.unity3d.com/ScriptReference/ParticleSystem.Emit.html",
					""),
			};
		}



		EnumInputComputeOutput [] EnumInputComputeOutput_CircleCollider_2D ()
		{
			return new EnumInputComputeOutput[]
			{

				new EnumInputComputeOutput (
					ComputeCircleCollider2DType.getCircleCollider2DRadius.ToString (),
					"",
					"\t\t\t\tfloatValue = circleCollider2D.radius;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.circleCollider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.circleCollider2DCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Radius of the circle.",
					},
					"https://docs.unity3d.com/ScriptReference/CircleCollider2D-radius.html",
					""),




				new EnumInputComputeOutput (
					ComputeCircleCollider2DType.setCircleCollider2DRadius.ToString (),
					InOutWs.InWs._circleCollider2DCheck + ret + ret + InOutWs.InWs._float,
					"\t\t\t\tcircleCollider2D.radius = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.circleCollider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.circleCollider2DCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Radius of the circle.",
					},
					"https://docs.unity3d.com/ScriptReference/CircleCollider2D-radius.html",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_BoxCollider_2D ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeBoxCollider2DType.getBoxCollider2DSize.ToString (),
					"",
					"\t\t\t\tvector2Value = boxCollider2D.size;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.boxCollider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.boxCollider2DCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The width and height of the rectangle.",
						"The X coordinate of the vector represents the width while the Y represents the height.",
						"These values are specified relative to a center point, so the distance from the center",
						"to the left edge is actually width/2.",
					},
					"https://docs.unity3d.com/ScriptReference/BoxCollider2D-size.html",
					""),

				new EnumInputComputeOutput (
					ComputeBoxCollider2DType.setBoxCollider2DSize.ToString (),
					InOutWs.InWs._boxCollider2DCheck + ret + ret + InOutWs.InWs._vector2,
					"\t\t\t\tboxCollider2D.size = vector2Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.boxCollider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.boxCollider2DCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The width and height of the rectangle.",
						"The X coordinate of the vector represents the width while the Y represents the height.",
						"These values are specified relative to a center point, so the distance from the center",
						"to the left edge is actually width/2.",
					},
					"https://docs.unity3d.com/ScriptReference/BoxCollider2D-size.html",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_Collider_2D ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeCollider2DType.setUsedByEffector.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tcollider2D.usedByEffector = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Whether the collider is used by an attached effector or not.",
						"When checked, the Collider2D continues to work as a collision or trigger area",
						"however it will also be used by any Effector2D on the same GameObject.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-usedByEffector.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.setSharedPhysicMaterialFriction.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tif (collider2D.sharedMaterial != null)\n\t\t\t\t{\n\t\t\t\t\tcollider2D.sharedMaterial.friction = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Coefficient of friction.",
						"A value of zero indicates a surface with no friction while a value of 1 indicates maximum",
						"friction (eg, rubber).",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicsMaterial2D-friction.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.setSharedPhysicMaterialBounciness.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tif (collider2D.sharedMaterial != null)\n\t\t\t\t{\n\t\t\t\t\tcollider2D.sharedMaterial.bounciness = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"The degree of elasticity during collisions.",
						"A value of zero indicates no elasticity (ie, no bounce at all)",
						"while a value of one indicates perfect elasticity.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicsMaterial2D-bounciness.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.setOffset.ToString (),
					InOutWs.InWs._vector2,
					"\t\t\t\tcollider2D.offset = vector2Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"The local offset of the collider geometry.",
						"This offset can be used to shift the local origin of any 2D collider geometry.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-offset.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.setIsTrigger.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tcollider2D.isTrigger = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Is this collider configured as a trigger?",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-isTrigger.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.setEnabled.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tcollider2D.enabled = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.setDensity.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tcollider2D.density = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"The density of the collider used to calculate its mass (when auto mass is enabled).",
						"When using Rigidbody2D.useAutoMass, increasing the collider density",
						"increases its mass - as does increasing its area - as the collider mass is calculated as",
						"a product of density and area.",
						"Note that by default, Rigidbody2D.useAutoMass is disabled,",
						"so the mass of the collider is set directly by Rigidbody2D.mass,",
						"and this density value is ignored.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-density.html",
					""),



				new EnumInputComputeOutput (
					ComputeCollider2DType.OverlapPoint.ToString (),
					InOutWs.InWs._vector3,
					"\t\t\t\tboolValue = collider2D.OverlapPoint (vector3Values [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Check if a collider overlaps a point in space.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D.OverlapPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.IsTouchingTheCollider2D.ToString (),
					InOutWs.InWs._gameObject_1 + InOutWs.InWs._gameObject_1_check + 
					InOutWs.InWs._collider2D_1_Check,
					"\t\t\t\tif (gameObjectValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tcollider2D_1 = gameObjectValues [1].GetComponent<Collider2D>();\n\n\t\t\t\t\tif (collider2D_1 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tboolValue = collider2D.IsTouching (collider2D_1);\n\t\t\t\t\t}\n\t\t\t\t}",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.collider2D_1 + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Works in runtime or editor runtime",
						"Works when objects have rigidbody2D attached to them",
						"Check whether this collider is touching the collider or not.",
						"It is important to understand that checking whether colliders are touching or not",
						"is performed against the last physics system update; that is the state of",
						"touching colliders at that time. If you have just added a new Collider2D or have moved",
						"a Collider2D but a physics update has not yet taken place then the colliders will not be",
						"shown as touching. This function returns the same collision results as the physics collision",
						"or trigger callbacks.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D.IsTouching.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.IsTouchingAnyColliderInThisLayerMask.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tboolValue = collider2D.IsTouchingLayers (intValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue + ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Checks whether this collider is touching any colliders on the specified layerMask or not.",
						"It is important to understand that checking if colliders are touching or not is performed",
						"against the last physics system update i.e. the state of touching colliders at that time.",
						"If you have just added a new Collider2D or have moved a Collider2D but a physics update",
						"has not yet taken place then the colliders will not be shown as touching.",
						"The touching state is identical to that indicated by the physics collision or trigger callbacks.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D.IsTouchingLayers.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.getUsedByEffector.ToString (),
					"",
					"\t\t\t\tboolValue = collider2D.usedByEffector;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Whether the collider is used by an attached effector or not.",
						"When checked, the Collider2D continues to work as a collision or trigger area",
						"however it will also be used by any Effector2D on the same GameObject.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-usedByEffector.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.getSharedPhysicMaterialFriction.ToString (),
					"",
					"\t\t\t\tif (collider2D.sharedMaterial != null)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = collider2D.sharedMaterial.friction;\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Coefficient of friction.",
						"A value of zero indicates a surface with no friction while a value of 1 indicates maximum",
						"friction (eg, rubber).",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicsMaterial2D-friction.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.getSharedPhysicMaterialBounciness.ToString (),
					"",
					"\t\t\t\tif (collider2D.sharedMaterial != null)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = collider2D.sharedMaterial.bounciness;\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"The degree of elasticity during collisions.",
						"A value of zero indicates no elasticity (ie, no bounce at all)",
						"while a value of one indicates perfect elasticity.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicsMaterial2D-bounciness.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.getShapeCount.ToString (),
					"",
					"\t\t\t\tintValue = collider2D.shapeCount;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"The number of separate shaped regions in the collider.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-shapeCount.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.getOffset.ToString (),
					"",
					"\t\t\t\tvector2Value = collider2D.offset;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector2Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"The local offset of the collider geometry.",
						"This offset can be used to shift the local origin of any 2D collider geometry.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-offset.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.getIsTrigger.ToString (),
					"",
					"\t\t\t\tboolValue = collider2D.isTrigger;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Is this collider configured as a trigger?",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-isTrigger.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.getEnabled.ToString (),
					"",
					"\t\t\t\tboolValue = collider2D.enabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeCollider2DType.getDensity.ToString (),
					"",
					"\t\t\t\tfloatValue = collider2D.density;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"The density of the collider used to calculate its mass (when auto mass is enabled).",
						"When using Rigidbody2D.useAutoMass, increasing the collider density",
						"increases its mass - as does increasing its area - as the collider mass is calculated as",
						"a product of density and area.",
						"Note that by default, Rigidbody2D.useAutoMass is disabled,",
						"so the mass of the collider is set directly by Rigidbody2D.mass,",
						"and this density value is ignored.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-density.html",
					""),



				new EnumInputComputeOutput (
					ComputeCollider2DType.getBounds.ToString (),
					"",
					"\t\t\t\tboundsCenterValue = collider2D.bounds.center;\n\n\t\t\t\tboundsExtentsValue = collider2D.bounds.extents;\n\n\t\t\t\tboundsMaxValue = collider2D.bounds.max;\n\n\t\t\t\tboundsMinValue = collider2D.bounds.min;\n\n\t\t\t\tboundsSizeValue = collider2D.bounds.size;",
					"\t\t\t\tDrawBoundsResultField ();",
					ExprWs.Gv.collider2D_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.bounds,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.collider2DCheck + ExprWs.UMDecl.computeCollider2D,
					new string []
					{
						"The world space bounding volume of the collider.",
						"Note that this will be an empty bounding box if the collider is disabled",
						"or the game object is inactive.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider2D-bounds.html",
					""),
			};
		}




		EnumInputComputeOutput [] EnumInputComputeOutput_MeshCollider ()
		{
			return
				new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeMeshColliderType.SetMeshColliderConvex.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tmeshCollider.convex = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.meshCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.meshColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Use a convex collider from the mesh.",
						"This means that if you have this set to true, your mesh collider wont have holes or",
						"entrances. Convex meshes can collide with other convex colliders and non-convex meshes.",
						"Thus convex mesh colliders are suitable on rigidibodies, if you really need more detailed",
						"colliders than what the primitive colliders provide you with.",
						"Note: A convex mesh is required by the physics engine to have a non-zero volume.",
						"Flat meshes such as quads or planes that are marked as convex will be modified by",
						"the physics engine to have a thickness (and therefore a volume) to satisfy this requirement.",
						"The thickness of the resulting mesh is proportional to its size and can be up to 0.05 of its",
						"longest dimension in the plane of the mesh.",
					},
					"https://docs.unity3d.com/ScriptReference/MeshCollider-convex.html",
					""),

				new EnumInputComputeOutput (
					ComputeMeshColliderType.GetMeshColliderConvex.ToString (),
					"",
					"\t\t\t\tboolValue = meshCollider.convex;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.meshCollider_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.meshColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Use a convex collider from the mesh.",
						"This means that if you have this set to true, your mesh collider wont have holes or",
						"entrances. Convex meshes can collide with other convex colliders and non-convex meshes.",
						"Thus convex mesh colliders are suitable on rigidibodies, if you really need more detailed",
						"colliders than what the primitive colliders provide you with.",
						"Note: A convex mesh is required by the physics engine to have a non-zero volume.",
						"Flat meshes such as quads or planes that are marked as convex will be modified by",
						"the physics engine to have a thickness (and therefore a volume) to satisfy this requirement.",
						"The thickness of the resulting mesh is proportional to its size and can be up to 0.05 of its",
						"longest dimension in the plane of the mesh.",
					},
					"https://docs.unity3d.com/ScriptReference/MeshCollider-convex.html",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_CapsuleCollider ()
		{
			return
				new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeCapsuleColliderType.SetCapsuleColliderRadius.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Radius\");\n" + 
					InOutWs.InWs._float,
					"\t\t\t\tcapsuleCollider.radius = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.capsuleCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.capsuleColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The radius of the sphere, measured in the object's local space.",
						"The capsule's radius will be scaled by the transform's scale.",
					},
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-radius.html",
					""),

				new EnumInputComputeOutput (
					ComputeCapsuleColliderType.SetCapsuleColliderHeight.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Height\");\n" +
					InOutWs.InWs._float,
					"\t\t\t\tcapsuleCollider.height = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.capsuleCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.capsuleColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The height of the capsule meased in the object's local space.",
						"The capsule's height will be scaled by the transform's scale.",
						"Note that the height is the actual height including the half-spheres at each end.",
					},
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-height.html",
					""),

				new EnumInputComputeOutput (
					ComputeCapsuleColliderType.SetCapsuleColliderDirection.ToString (),
					"\t\t\t\tDrawLabelFields (new string []\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Direction\",\n\t\t\t\t\t\t\"0\" + StringTreatment.rArrow + \"x\",\n\t\t\t\t\t\t\"1\" + StringTreatment.rArrow + \"y\",\n\t\t\t\t\t\t\"2\" + StringTreatment.rArrow + \"z\",\n\t\t\t\t\t});\n\t\t\t\tDrawIntInputField (0);\n\t\t\t\tintValues [0] = Mathf.Clamp (intValues [0], 0, 2);",
					"\t\t\t\tcapsuleCollider.direction = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.capsuleCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.capsuleColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The direction of the capsule.",
						"The value can be 0, 1 or 2 corresponding to the X, Y and Z axes, respectively.",
					},
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-direction.html",
					""),

				new EnumInputComputeOutput (
					ComputeCapsuleColliderType.SetCapsuleColliderCenter.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Center\");\n" +
					InOutWs.InWs._vector3,
					"\t\t\t\tcapsuleCollider.center = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.capsuleCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.capsuleColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The center of the capsule, measured in the object's local space.",
					},
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-center.html",
					""),

				new EnumInputComputeOutput (
					ComputeCapsuleColliderType.GetCapsuleColliderRadius.ToString (),
					"",
					"\t\t\t\tfloatValue = capsuleCollider.radius;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.capsuleCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.capsuleColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The radius of the sphere, measured in the object's local space.",
						"The capsule's radius will be scaled by the transform's scale.",
					},
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-radius.html",
					""),

				new EnumInputComputeOutput (
					ComputeCapsuleColliderType.GetCapsuleColliderHeight.ToString (),
					"",
					"\t\t\t\tfloatValue = capsuleCollider.height;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.capsuleCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.capsuleColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The height of the capsule meased in the object's local space.",
						"The capsule's height will be scaled by the transform's scale.",
						"Note that the height is the actual height including the half-spheres at each end.",
					},
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-height.html",
					""),

				new EnumInputComputeOutput (
					ComputeCapsuleColliderType.GetCapsuleColliderDirection.ToString (),
					"\t\t\t\tDrawLabelFields (new string []\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Direction\",\n\t\t\t\t\t\t\"0\" + StringTreatment.rArrow + \"x\",\n\t\t\t\t\t\t\"1\" + StringTreatment.rArrow + \"y\",\n\t\t\t\t\t\t\"2\" + StringTreatment.rArrow + \"z\",\n\t\t\t\t\t});",
					"\t\t\t\tintValue = capsuleCollider.direction;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.capsuleCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.capsuleColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The direction of the capsule.",
						"The value can be 0, 1 or 2 corresponding to the X, Y and Z axes, respectively.",
					},
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-direction.html",
					""),

				new EnumInputComputeOutput (
					ComputeCapsuleColliderType.GetCapsuleColliderCenter.ToString (),
					"",
					"\t\t\t\tvector3Value = capsuleCollider.center;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.capsuleCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.capsuleColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The center of the capsule, measured in the object's local space.",
					},
					"https://docs.unity3d.com/ScriptReference/CapsuleCollider-center.html",
					""),

			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_SphereCollider ()
		{
			return
				new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeSphereColliderType.SetSphereColliderRadius.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tsphereCollider.radius = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.sphereCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.sphereColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The radius of the sphere measured in the object's local space.",
						"The sphere radius will be scaled by the transform's scale.",
					},
					"https://docs.unity3d.com/ScriptReference/SphereCollider-radius.html",
					""),

				new EnumInputComputeOutput (
					ComputeSphereColliderType.SetSphereColliderCenter.ToString (),
					InOutWs.InWs._vector3,
					"\t\t\t\tsphereCollider.center = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.sphereCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.sphereColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The center of the sphere in the object's local space.",
					},
					"https://docs.unity3d.com/ScriptReference/SphereCollider-center.html",
					""),

				new EnumInputComputeOutput (
					ComputeSphereColliderType.GetSphereColliderRadius.ToString (),
					"",
					"\t\t\t\tfloatValue = sphereCollider.radius;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.sphereCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.sphereColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The radius of the sphere measured in the object's local space.",
						"The sphere radius will be scaled by the transform's scale.",
					},
					"https://docs.unity3d.com/ScriptReference/SphereCollider-radius.html",
					""),

				new EnumInputComputeOutput (
					ComputeSphereColliderType.GetSphereColliderCenter.ToString (),
					"",
					"\t\t\t\tvector3Value = sphereCollider.center;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.sphereCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.sphereColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The center of the sphere in the object's local space.",
					},
					"https://docs.unity3d.com/ScriptReference/SphereCollider-center.html",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_BoxCollider ()
		{
			return
				new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeBoxColliderType.SetBoxColliderSize.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Size\");\n" + 
					InOutWs.InWs._vector3,
					"\t\t\t\tboxCollider.size = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.boxCollider_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.boxColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The size of the box, measured in the object's local space.",
						"The box size will be scaled by the transform's scale.",
					},
					"https://docs.unity3d.com/ScriptReference/BoxCollider-size.html",
					""),

				new EnumInputComputeOutput (
					ComputeBoxColliderType.SetBoxColliderCenter.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Center\");\n" + 
					InOutWs.InWs._vector3,
					"\t\t\t\tboxCollider.center = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.boxCollider_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.boxColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The center of the box, measured in the object's local space.",
					},
					"https://docs.unity3d.com/ScriptReference/BoxCollider-center.html",
					""),

				new EnumInputComputeOutput (
					ComputeBoxColliderType.GetBoxColliderSize.ToString (),
					"",
					"\t\t\t\tvector3Value = boxCollider.size;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.boxCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.boxColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The size of the box, measured in the object's local space.",
						"The box size will be scaled by the transform's scale.",
					},
					"https://docs.unity3d.com/ScriptReference/BoxCollider-size.html",
					""),

				new EnumInputComputeOutput (
					ComputeBoxColliderType.GetBoxColliderCenter.ToString (),
					"",
					"\t\t\t\tvector3Value = boxCollider.center;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.boxCollider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.boxColliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The center of the box, measured in the object's local space.",
					},
					"https://docs.unity3d.com/ScriptReference/BoxCollider-center.html",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_Collider ()
		{
			return
				new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeColliderType.setStaticFrictionOnSharedPhysicMaterial.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tif (collider.sharedMaterial != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.sharedMaterial.staticFriction = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The friction coefficient used when an object is lying on a surface.",
						"Must be greater than or equal to zero. Natural materials will usually",
						"have a friction coefficient between 0 (no friction at all, like slippy ice)",
						"and 1 (full friction, like rubber).",
						"Values larger then 1 are possible, and may be realistic for sticky materials.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-staticFriction.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.setStaticFrictionOnPhysicMaterial.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tif (collider.material != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.material.staticFriction = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The friction coefficient used when an object is lying on a surface.",
						"Must be greater than or equal to zero. Natural materials will usually",
						"have a friction coefficient between 0 (no friction at all, like slippy ice)",
						"and 1 (full friction, like rubber).",
						"Values larger then 1 are possible, and may be realistic for sticky materials.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-staticFriction.html",
					""),






				new EnumInputComputeOutput (
					ComputeColliderType.setIsTrigger.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tcollider.isTrigger = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Is the collider a trigger?",
						"A trigger doesn't register a collision with an incoming Rigidbody.",
						"Instead, it sends OnTriggerEnter, OnTriggerExit and OnTriggerStay message",
						"when a rigidbody enters or exits the trigger volume.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider-isTrigger.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.setFrictionCombineOnSharedPhysicMaterial.ToString (),
					"\t\t\t\tDrawPhysicMaterialCombineEnum ();",
					"\t\t\t\tif (collider.sharedMaterial != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.sharedMaterial.frictionCombine = physicMaterialCombine;\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.physicMaterialCombine,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.PhysicMaterialCombine (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Determines how the friction is combined.",
						"Traditionally friction properties are dependent on the combination of the two materials",
						"in contact. This is however impractical in a game. Instead you can use the combine mode",
						"to tune how the friction values of two materials are combined.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-frictionCombine.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeColliderType.setFrictionCombineOnPhysicMaterial.ToString (),
					"\t\t\t\tDrawPhysicMaterialCombineEnum ();",
					"\t\t\t\tif (collider.material != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.material.frictionCombine = physicMaterialCombine;\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.physicMaterialCombine,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.PhysicMaterialCombine (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Determines how the friction is combined.",
						"Traditionally friction properties are dependent on the combination of the two materials",
						"in contact. This is however impractical in a game. Instead you can use the combine mode",
						"to tune how the friction values of two materials are combined.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-frictionCombine.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.setEnabled.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tcollider.enabled = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Enabled Colliders will collide with other colliders, disabled Colliders won't.",
						"This is shown as the small checkbox in the inspector of the Colliders.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.setDynamicFrictionOnSharedPhysicMaterial.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Dynamic Friction\");\n" + 
					InOutWs.InWs._float,
					"\t\t\t\tif (collider.sharedMaterial != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.sharedMaterial.dynamicFriction = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The friction used when already moving. This value has to be between 0 and 1.",
						"A value of 0 feels like ice, 1 feels like rubber.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-dynamicFriction.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.setDynamicFrictionOnPhysicMaterial.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Dynamic Friction\");\n" +
					InOutWs.InWs._float,
					"\t\t\t\tif (collider.material != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.material.dynamicFriction = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The friction used when already moving. This value has to be between 0 and 1.",
						"A value of 0 feels like ice, 1 feels like rubber.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-dynamicFriction.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.setContactOffset.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Contact Offset\");\n" + 
					InOutWs.InWs._float,
					"\t\t\t\tcollider.contactOffset = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Contact offset value of this collider.",
						"Colliders whose distance is less than the sum of their contactOffset",
						"values will generate contacts. The contact offset must be positive.",
						"Contact offset allows the collision detection system to predictively",
						"enforce the contact constraint even when the objects are slightly separated.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider-contactOffset.html",
					""),





				new EnumInputComputeOutput (
					ComputeColliderType.setBouncinessOnSharedPhysicMaterial.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Bounciness\");\n" +
					InOutWs.InWs._float,
					"\t\t\t\tif (collider.sharedMaterial != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.sharedMaterial.bounciness = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"How bouncy is the surface? A value of 0 will not bounce.",
						"A value of 1 will bounce without any loss of energy.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounciness.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.setBouncinessOnPhysicMaterial.ToString (),
					//"\t\t\t\tDrawLogicNodeLabel (\"Bounciness\");\n" + 
					InOutWs.InWs._float,
					"\t\t\t\tif (collider.material != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.material.bounciness = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"How bouncy is the surface? A value of 0 will not bounce.",
						"A value of 1 will bounce without any loss of energy.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounciness.html",
					""),


				new EnumInputComputeOutput (
					ComputeColliderType.setBounceCombineOnSharedPhysicMaterial.ToString (),
					"\t\t\t\tDrawPhysicMaterialCombineEnum ();",
					"\t\t\t\tif (collider.sharedMaterial != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.sharedMaterial.bounceCombine = physicMaterialCombine;\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.physicMaterialCombine,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.PhysicMaterialCombine (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Determines how the bounciness is combined.",
						"Traditionally bounciness properties are dependent on the combination of the two materials",
						"in contact. This is however impractical in a game.",
						"Instead you can use the combine mode to tune how the bounciness values of two materials",
						"are combined.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounceCombine.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.setBounceCombineOnPhysicMaterial.ToString (),
					"\t\t\t\tDrawPhysicMaterialCombineEnum ();",
					"\t\t\t\tif (collider.material != null)\n\t\t\t\t{\n\t\t\t\t\tcollider.material.bounceCombine = physicMaterialCombine;\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.physicMaterialCombine,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.PhysicMaterialCombine (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Determines how the bounciness is combined.",
						"Traditionally bounciness properties are dependent on the combination of the two materials",
						"in contact. This is however impractical in a game.",
						"Instead you can use the combine mode to tune how the bounciness values of two materials",
						"are combined.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounceCombine.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.getStaticFrictionFromPhysicMaterial.ToString (),
					"",
					"\t\t\t\tif (collider.material != null)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = collider.material.staticFriction;\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The friction coefficient used when an object is lying on a surface.",
						"Must be greater than or equal to zero. Natural materials will usually",
						"have a friction coefficient between 0 (no friction at all, like slippy ice)",
						"and 1 (full friction, like rubber).",
						"Values larger then 1 are possible, and may be realistic for sticky materials.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-staticFriction.html",
					""),





				new EnumInputComputeOutput (
					ComputeColliderType.getIsTrigger.ToString (),
					"",
					"\t\t\t\tboolValue = collider.isTrigger;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Is the collider a trigger?",
						"A trigger doesn't register a collision with an incoming Rigidbody.",
						"Instead, it sends OnTriggerEnter, OnTriggerExit and OnTriggerStay message",
						"when a rigidbody enters or exits the trigger volume.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider-isTrigger.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.getEnabled.ToString (),
					"",
					"\t\t\t\tboolValue = collider.enabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Enabled Colliders will collide with other colliders, disabled Colliders won't.",
						"This is shown as the small checkbox in the inspector of the Colliders.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider-enabled.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeColliderType.getDynamicFrictionFromPhysicMaterial.ToString (),
					"",
					"\t\t\t\tif (collider.material != null)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = collider.material.dynamicFriction;\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The friction used when already moving. This value has to be between 0 and 1.",
						"A value of 0 feels like ice, 1 feels like rubber.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-dynamicFriction.html",
					""),

				new EnumInputComputeOutput (
					ComputeColliderType.getContactOffset.ToString (),
					"",
					"\t\t\t\tfloatValue = collider.contactOffset;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"Contact offset value of this collider.",
						"Colliders whose distance is less than the sum of their contactOffset",
						"values will generate contacts. The contact offset must be positive.",
						"Contact offset allows the collision detection system to predictively",
						"enforce the contact constraint even when the objects are slightly separated.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider-contactOffset.html",
					""),




				new EnumInputComputeOutput (
					ComputeColliderType.getBouunds.ToString (),
					"",
					"\t\t\t\tboundsCenterValue = collider.bounds.center;\n\n\t\t\t\tboundsExtentsValue = collider.bounds.extents;\n\n\t\t\t\tboundsMaxValue = collider.bounds.max;\n\n\t\t\t\tboundsMinValue = collider.bounds.min;\n\n\t\t\t\tboundsSizeValue = collider.bounds.size;",
					"\t\t\t\tDrawBoundsResultField ();",
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.bounds,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"The world space bounding volume of the collider.",
						"Note that this will be an empty bounding box if the collider is disabled",
						"or the game object is inactive.",
					},
					"https://docs.unity3d.com/ScriptReference/Collider-bounds.html",
					""),



				new EnumInputComputeOutput (
					ComputeColliderType.getBouncinessFromPhysicMaterial.ToString (),
					"",
					"\t\t\t\tif (collider.material != null)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = collider.material.bounciness;\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.collider_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.colliderCheck + ExprWs.UMDecl.computeCollider,
					new string []
					{
						"How bouncy is the surface? A value of 0 will not bounce.",
						"A value of 1 will bounce without any loss of energy.",
					},
					"https://docs.unity3d.com/ScriptReference/PhysicMaterial-bounciness.html",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_NavMeshAgent ()
		{
			return
				new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.Stop.ToString (),
					"",
					"\t\t\t\tnavMeshAgent.isStopped = true;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"This property holds the stop or resume condition of the NavMesh agent.",
						"If set to True, the NavMesh agent's movement will be stopped along its current path.",
						"If set to False after the NavMesh agent has stopped, it will resume moving along its",
						"current path.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isStopped.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.shouldTheAgentUpdateTheTransformRotation.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tnavMeshAgent.updateRotation = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Should the agent update the transform orientation?",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-updateRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.shouldTheAgentUpdateTheTransformPosition.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tnavMeshAgent.updatePosition = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Gets or sets whether the transform position is synchronized with the simulated agent position.",
						"The default value is true.",
						"When true: changing the transform position will affect,",
						"the simulated position and vice-versa.",
						"When false: the simulated position",
						"will not be applied to the transform position and vice-versa.",
						"Setting updatePosition to false can be used to enable explicit control",
						"of the transform position via script. This allows you to use the agent's simulated",
						"position to drive another component, which in turn sets",
						"the transform position (eg. animation with root motion or physics).",
						"When enabling the updatePosition (from previously being disabled),",
						"the transform will be moved to the simulated position.",
						"This way the agent stays constrained to the navmesh surface.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-updatePosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setStoppingDistance.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tnavMeshAgent.stoppingDistance = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Stop within this distance from the target position.",
						"It is seldom possible to land exactly at the target point, so this property",
						"can be used to set an acceptable radius within which the agent should stop.",
						"A larger stopping distance will give the agent more room for manoeuvre",
						"at the end of the path and might avoid sudden braking,",
						"turning or other unconvincing AI behaviour.",
					},

					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-stoppingDistance.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setSpeed.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tnavMeshAgent.speed = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Maximum movement speed when following a path.",
						"An agent will typically need to speed up and slow down as it follows",
						"a path (eg, it will slow down to make a tight turn).",
						"The speed is often limited by the length of a path segment and the time taken",
						"to accelerate and brake, but the speed will not exceed the value set by",
						"this property even on a long, straight path.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-speed.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setRadius.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tnavMeshAgent.radius = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The avoidance radius for the agent.",
						"This is the agent's 'personal space' within which obstacles and other agents",
						"should not pass.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-radius.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setObstacleAvoidanceType.ToString (),
					"\t\t\t\tobstacleAvoidanceType = (UnityEngine.AI.ObstacleAvoidanceType)DrawEnum (obstacleAvoidanceType, \"Obstacle Avoidance Type\", Skins.logicNodeLabel);\n",
					"\t\t\t\tnavMeshAgent.obstacleAvoidanceType = obstacleAvoidanceType;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.obstacleAvoidanceType,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ObstacleAvoidanceType (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Level of obstacle avoidance.",
						"NoObstacleAvoidance\tDisable avoidance.",
						"LowQualityObstacleAvoidance\tEnable simple avoidance. Low performance impact.",
						"MedQualityObstacleAvoidance\tMedium avoidance. Medium performance impact.",
						"GoodQualityObstacleAvoidance\tGood avoidance. High performance impact.",
						"HighQualityObstacleAvoidance\tEnable highest precision. Highest performance impact.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.ObstacleAvoidanceType.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setNextPosition.ToString (),
					InOutWs.InWs._vector3,
					"\t\t\t\tnavMeshAgent.nextPosition = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Gets or sets the simulation position of the navmesh agent.",
						"The position vector is in world space coordinates and units.",
						"The nextPosition is coupled to Transform.position. In the default case",
						"the navmesh agent's Transform position will match the internal simulation",
						"position at the time the script Update function is called.",
						"This coupling can be turned on and off by setting updatePosition.",
						"When updatePosition is true, the Transform.position reflects the simulated position,",
						"when false the position of the transform and the navmesh agent is not synchronized,",
						"and you'll see a difference between the two in general.",
						"When updatePosition is turned back on, the Transform.position will be immediately",
						"move to match nextPosition.",
						"By setting nextPosition you can directly control where the internal agent position",
						"should be. The agent will be moved towards the position, but is constrained",
						"by the navmesh connectivity and boundaries. As such it will be useful only if",
						"the positions are continuously updated and assessed.",
						"You can also use Warp for teleporting a navmesh agent.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-nextPosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setHeight.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tnavMeshAgent.height = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The height of the agent for purposes of passing under obstacles, etc.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-height.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.SetDestinationWithReturn.ToString (),
					InOutWs.InWs._vector3,
					"\t\t\t\tboolValue = navMeshAgent.SetDestination (vector3Values [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Sets or updates the destination thus triggering the calculation for a new path.",
						"Note that the path may not become available until after a few frames later.",
						"While the path is being computed, pathPending will be true.",
						"If a valid path becomes available then the agent will resume movement.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.SetDestination.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setDestination.ToString (),
					InOutWs.InWs._vector3,
					"\t\t\t\tnavMeshAgent.destination = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Gets or attempts to set the destination of the agent in world-space units.",
						"Getting:",
						"Returns the destination set for this agent.",
						"• If a destination is set but the path is not yet processed the position",
						"returned will be valid navmesh position that's closest to the previously",
						"set position.",
						"• If the agent has no path or requested path - returns the agents position on",
						"the navmesh.",
						"• If the agent is not mapped to the navmesh (e.g. scene has no navmesh) - returns a",
						"position at infinity.",
						"Setting:",
						"Requests the agent to move to the valid navmesh position that's closest to the",
						"requested destination.",
						"• The path result may not become available until after a few frames.",
						"Use pathPending to query for outstanding results.",
						"• If it's not possible to find a valid nearby navmesh position (e.g. scene has",
						"no navmesh) no path is requested.",
						"Use SetDestination and check return value if you need to handle this case explicitly.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-destination.html",
					""),	

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setCurrentVelocity.ToString (),
					InOutWs.InWs._vector3,
					"\t\t\t\tnavMeshAgent.velocity = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Access the current velocity of the NavMeshAgent component, or set a velocity to control",
						"the agent manually.",
						"Reading the variable will return the current velocity of the agent based on the",
						"crowd simulation.",
						"Setting the variable will override the simulation (including: moving towards",
						"destination, collision avoidance, and acceleration control) and command the NavMesh",
						"Agent to move using the specific velocity directly.",
						"When the agent is controlled using a velocity, its movement is still constrained",
						"on the NavMesh.",
						"Setting the velocity directly, can be used for implementing",
						"player characters, which are moving on NavMesh and affecting the rest of the",
						"simulated crowd. In addition, setting priority to high (a small value is higher",
						"priority), will make other simulated agents to avoid the player controlled agent",
						"even more eagerly.",
						"It is recommended to set the velocity each frame when",
						"controlling the agent manually, and if releasing the control to the simulation,",
						"set the velocity to zero. If agent’s velocity is set to some value and then",
						"stopped updating it, the simulation will pick up from there and the agent will",
						"slowly decelerate (assuming no destination is set).",
						"Note that reading the velocity will always return value from the simulation.",
						"If you set the value, the effect will show up in the next update. Since the",
						"returned velocity comes from the simulation (including avoidance and collision",
						"handling), it can be different than the one you set.",
						"The velocity is specified in distance units per second (same as physics),",
						"and represented in global coordinate system.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-velocity.html",
					""),


				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setBaseOffset.ToString (),
					"\t\t\t\tDrawFloatInputField (0); floatValues [0] = Mathf.Max (0f, floatValues [0]);\n",
					"\t\t\t\tnavMeshAgent.baseOffset = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The relative vertical displacement of the owning GameObject.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-baseOffset.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setAvoidancePriority.ToString (),
					"\t\t\t\t\tDrawLabelFields (new string[]\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"Most important = 0\",\n\n\t\t\t\t\t\t\t\"Least important = 99\",\n\n\t\t\t\t\t\t\t\"Default = 50\",\n\t\t\t\t\t\t});\n\n\t\t\t\t\tDrawIntInputField (0); intValues [0] = Mathf.Clamp (intValues [0], 0, 99);\n",
					"\t\t\t\tnavMeshAgent.avoidancePriority = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The avoidance priority level.",
						"When the agent is performing avoidance, agents of lower priority are ignored.",
						"The valid range is from 0 to 99 where: Most important = 0. Least important = 99.",
						"Default = 50.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-avoidancePriority.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setAutoTraverseOffMeshLink.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tnavMeshAgent.autoTraverseOffMeshLink = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Should the agent move across OffMeshLinks automatically?",
						"Off-mesh links are used to connect disjoint regions of the NavMesh. Usually,",
						"a character should be able to pass through or traverse a link automatically,",
						"which will happen if this property is set to true. However, it can also be set",
						"to false in cases where special control over movement is needed.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoTraverseOffMeshLink.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setAutoRepath.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tnavMeshAgent.autoRepath = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Should the agent attempt to acquire a new path if the existing path becomes invalid?",
						"A new path calculation is also attempted aquired if the agent reaches the",
						"end of a partial and stale path.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoRepath.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setAutoBraking.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tnavMeshAgent.autoBraking = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Should the agent brake automatically to avoid overshooting the destination point?",
						"If the agent needs to land close to the destination point then it will typically",
						"need to brake to avoid overshooting or endless 'orbiting' around the target zone.",
						"If this property is set to true, the agent will brake automatically as it nears",
						"the destination.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoBraking.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setAreaMask.ToString (),
					"\t\t\t\t\tDrawLabelField (FieldDrawType.label, \"For default layers:\", Skins.logicNodeLabel);\n\n\t\t\t\t\tDrawLabelFields (new string[]\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"-1\" + StringTreatment.rArrow + \"everything\",\n\n\t\t\t\t\t\t\t\"0\" + StringTreatment.rArrow + \"nothing\",\n\n\t\t\t\t\t\t\t\"1\" + StringTreatment.rArrow + \"walkable\",\n\n\t\t\t\t\t\t\t\"2\" + StringTreatment.rArrow + \"not walkable\",\n\n\t\t\t\t\t\t\t\"3\" + StringTreatment.rArrow + \"walkable + not walkable\",\n\n\t\t\t\t\t\t\t\"4\" + StringTreatment.rArrow + \"jump\",\n\n\t\t\t\t\t\t\t\"5\" + StringTreatment.rArrow + \"walkable + jump\",\n\n\t\t\t\t\t\t\t\"6\" + StringTreatment.rArrow + \"not walkable + jump\",\n\n\t\t\t\t\t\t\t\"changes are effective only in editor\",\n\t\t\t\t\t\t});\n\n\t\t\t\t\tDrawIntInputField (0); intValues [0] = Mathf.Max (-1, intValues [0]);",
					"\t\t\t\tnavMeshAgent.areaMask = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Specifies which NavMesh areas are passable. Changing areaMask will make the path",
						"stale (see isPathStale).",
						"This is a bitfield.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-areaMask.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.SetAreaCost.ToString (),
					"\t\t\t\t\tDrawLabelField (FieldDrawType.label, \"Of area of index\", \n\t\t\t\t\t\tSkins.logicNodeLabel);\n\n\t\t\t\t\tDrawIntInputField (0); intValues [0] = Mathf.Clamp (intValues [0], 0, 31);\n\n\t\t\t\t\tDrawLabelField (FieldDrawType.label, \"Cost\", \n\t\t\t\t\t\tSkins.logicNodeLabel);\n\t\t\t\t\tDrawFloatInputField (0);",
					"\t\t\t\tnavMeshAgent.SetAreaCost (intValues [0], floatValues [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues + ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Sets the cost for finding path over geometry of the area type on all agents.",
						"This will replace any custom area costs on all agents, and set the default cost",
						"for new agents that are created after calling the function. The cost must be larger",
						"than 1.0.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMesh.SetAreaCost.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setAngularSpeed.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tnavMeshAgent.angularSpeed = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Maximum turning speed in (deg/s) while following a path.",
						"This is the maximum rate at which the agent can turn as it",
						"rounds the 'corner' defined by a waypoint. The actual turning",
						"circle is also influenced by the speed of the agent on approach",
						"and also the maximum acceleration.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-angularSpeed.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.setAcceleration.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tnavMeshAgent.acceleration = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The maximum acceleration of an agent as it follows a path,",
						"given in units / sec^2.",
						"An agent does not follow precisely the line segments of the path",
						"calculated by the navigation system but rather uses the waypoints",
						"along the path as intermediate destinations. This value is the maximum",
						"amount by which the agent can accelerate while moving towards the next",
						"waypoint.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-acceleration.html",			
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.SamplePathPositionGetInfoFacingTheAgent.ToString (),
					"\t\t\t\t\tDrawLabelFields (new string[]\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"Get Info Facing the Agent\",\n\n\t\t\t\t\t\t\t\"Mask of which areas can be used by trac\",\n\t\t\t\t\t\t});\n\n\t\t\t\t\tDrawIntInputField (0);\n\n\t\t\t\t\tDrawLabelField (FieldDrawType.label, \"For default layers:\", Skins.logicNodeLabel);\n\n\t\t\t\t\tDrawLabelFields (new string[]\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"-1\" + StringTreatment.rArrow + \"everything\",\n\n\t\t\t\t\t\t\t\"0\" + StringTreatment.rArrow + \"nothing\",\n\n\t\t\t\t\t\t\t\"1\" + StringTreatment.rArrow + \"walkable\",\n\n\t\t\t\t\t\t\t\"2\" + StringTreatment.rArrow + \"not walkable\",\n\n\t\t\t\t\t\t\t\"3\" + StringTreatment.rArrow + \"walkable + not walkable\",\n\n\t\t\t\t\t\t\t\"4\" + StringTreatment.rArrow + \"jump\",\n\n\t\t\t\t\t\t\t\"5\" + StringTreatment.rArrow + \"walkable + jump\",\n\n\t\t\t\t\t\t\t\"6\" + StringTreatment.rArrow + \"not walkable + jump\",\n\n\t\t\t\t\t\t\t\"changes are effective only in editor\",\n\t\t\t\t\t\t});\n\n\n\t\t\t\t\tDrawLabelFields (new string[]\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"Distance of tracing\",\n\t\t\t\t\t\t});\n\n\t\t\t\t\tDrawFloatInputField (0);",
					"\t\t\t\tboolValue = navMeshAgent.SamplePathPosition (intValues [0], floatValues [0], out navMeshHit);\n\n\t\t\t\tExtractNavMeshHitValues ();",
					"\t\t\t\tDrawNavMeshHitResultField ();",
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.NavMeshHit + ExprWs.Gv.floatValues + ExprWs.Gv.intValues +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.extractNavMeshHitValues +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Sample a position along the current path.",
						"This function looks ahead a specified distance along the current path.",
						"Details of the mesh at that position are then returned in a NavMeshHit",
						"object. This could be used, for example, to check the type of surface",
						"that lies ahead before the character gets there - a character could",
						"raise his gun above his head if he is about to wade through water, say.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.SamplePathPosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.Resume.ToString (),
					"",
					"\t\t\t\tnavMeshAgent.isStopped = false;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"This property holds the stop or resume condition of the NavMesh agent.",
						"If set to True, the NavMesh agent's movement will be stopped along its current path.",
						"If set to False after the NavMesh agent has stopped, it will resume moving along its",
						"current path.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isStopped.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.ResetPath.ToString (),
					"",
					"\t\t\t\tnavMeshAgent.ResetPath ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Clears the current path.",
						"When the path is cleared,",
						"the agent will not start looking for a new path until",
						"SetDestination is called.",
						"Note that if the agent is on an",
						"OffMeshLink when this function is called, it will complete the",
						"link immediately.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.ResetPath.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.RayCast.ToString (),
					"\t\t\t\tDrawLabelFields (new string[]\n\t\t\t\t\t{\n\t\t\t\t\t\t\"More Efficient than Physics.RayCast\",\n\t\t\t\t\t\t\"Put the End of the Ray\",\n\t\t\t\t\t});\n\n\t\t\t\tDrawVector3InputField (0);",
					"\t\t\t\tboolValue = navMeshAgent.Raycast (vector3Values [0], out navMeshHit);\n\n\t\t\t\tExtractNavMeshHitValues ();",
					"\t\t\t\tDrawNavMeshHitResultField ();",
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.NavMeshHit + ExprWs.Gv.vector3Values + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.extractNavMeshHitValues +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Trace a straight path towards a target postion in the NavMesh without",
						"moving the agent.",
						"This function follows the path of a 'ray' between the agent's position",
						"and the specified target position. If an obstruction is encountered",
						"along the line then a true value is returned and the position and other",
						"details of the obstructing object are stored in the hit parameter.",
						"This can be used to check if there is a clear shot or line of sight",
						"between a character and a target object. This function is preferable",
						"to the similar Physics.Raycast because the line tracing is performed",
						"in a simpler way using the navmesh and has a lower processing overhead.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.Raycast.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.Move.ToString (),
					"\t\t\t\t\tDrawLabelFields (new string[] {\"Do Quick Movment by this Vector\"});\n\n\t\t\t\t\tDrawVector3InputField (0);",
					"\t\t\t\tnavMeshAgent.Move (vector3Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Apply relative movement to current position.",
						"If the agent has a path it will be adjusted.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.Move.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.isAgentUpdatingTransformRotation.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.updateRotation;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Should the agent update the transform orientation?",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-updateRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.isAgentUpdatingTransformPosition.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.updatePosition;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Gets or sets whether the transform position is synchronized with the",
						"simulated agent position. The default value is true.",
						"When true: changing the transform position will affect the simulated",
						"position and vice-versa.",
						"When false: the simulated position will not be applied to the transform",
						"position and vice-versa.",
						"Setting updatePosition to false can be used to enable explicit control",
						"of the transform position via script. This allows you to use",
						"the agent's simulated position to drive another component, which in",
						"turn sets the transform position (eg. animation with root motion or",
						"physics).",
						"When enabling the updatePosition (from previously being",
						"disabled), the transform will be moved to the simulated position.",
						"This way the agent stays constrained to the navmesh surface.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-updatePosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getStoppingDistance.ToString (),
					"",
					"\t\t\t\tfloatValue = navMeshAgent.stoppingDistance;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Stop within this distance from the target position.",
						"It is seldom possible to land exactly at the target point,",
						"so this property can be used to set an acceptable radius within which",
						"the agent should stop. A larger stopping distance will give the agent",
						"more room for manoeuvre at the end of the path and might avoid sudden",
						"braking, turning or other unconvincing AI behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-stoppingDistance.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getSteeringTarget.ToString (),
					"",
					"\t\t\t\tvector3Value = navMeshAgent.steeringTarget;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Get the current steering target along the path. (Read Only)",
						"This is typically the next corner along the path or the end point",
						"of the path.",
						"Unless the agent is moving on an OffMeshLink,",
						"there is a straight path between the agent and the steeringTarget.",
						"When approaching an OffMeshLink for traversal - the value is",
						"the position where the agent will enter the link. While agent",
						"is traversing an OffMeshLink the value is the position where the",
						"agent will leave the link.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-steeringTarget.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getSpeed.ToString (),
					"",
					"\t\t\t\tfloatValue = navMeshAgent.speed;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Maximum movement speed when following a path.",
						"An agent will typically need to speed up and slow down as",
						"it follows a path (eg, it will slow down to make a tight turn).",
						"The speed is often limited by the length of a path segment and",
						"the time taken to accelerate and brake, but the speed will",
						"not exceed the value set by this property even on a long,",
						"straight path.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-speed.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getRemainingDistance.ToString (),
					"",
					"\t\t\t\tfloatValue = navMeshAgent.remainingDistance;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The distance between the agent's position and the destination on",
						"the current path. (Read Only)",
						"If the remaining distance is unknown then",
						"this will have a value of infinity.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-remainingDistance.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getRadius.ToString (),
					"",
					"\t\t\t\tfloatValue = navMeshAgent.radius;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The avoidance radius for the agent.",
						"This is the agent's 'personal space' within which obstacles and",
						"other agents should not pass.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-radius.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getPathStatus.ToString (),
					"\t\t\t\t\tDrawLabelFields (new string[]\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"-1\" + StringTreatment.rArrow + \"Path Invalid\",\n\t\t\t\t\t\t\t\"0.5\" + StringTreatment.rArrow + \"Path Cannot Reach Destination\",\n\t\t\t\t\t\t\t\"1\" + StringTreatment.rArrow + \"Path Can Reach Destination\",\n\t\t\t\t\t\t});",
					"\t\t\t\tswitch (navMeshAgent.pathStatus)\n\t\t\t\t{\n" +
					"\t\t\t\tcase UnityEngine.AI.NavMeshPathStatus.PathComplete:\n" +
					"\t\t\t\t\tfloatValue = 1f;\n\t\t\t\t\tbreak;\n" +
					"\n\t\t\t\tcase UnityEngine.AI.NavMeshPathStatus.PathInvalid:\n" +
					"\t\t\t\t\tfloatValue = -1f;\n\t\t\t\t\tbreak;\n\n" +
					"\t\t\t\tcase UnityEngine.AI.NavMeshPathStatus.PathPartial:\n" +
					"\t\t\t\t\tfloatValue = 0.5f;\n\t\t\t\t\tbreak;\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Status of path.",
						"PathComplete\tThe path terminates at the destination.",
						"PathPartial\tThe path cannot reach the destination.",
						"PathInvalid\tThe path is invalid.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshPathStatus.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getNextPosition.ToString (),
					"",
					"\t\t\t\tvector3Value = navMeshAgent.nextPosition;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Gets or sets the simulation position of the navmesh agent.",
						"The position vector is in world space coordinates and units.",
						"The nextPosition is coupled to Transform.position. In the default case",
						"the navmesh agent's Transform position will match the internal simulation",
						"position at the time the script Update function is called.",
						"This coupling can be turned on and off by setting updatePosition.",
						"When updatePosition is true, the Transform.position reflects the simulated position,",
						"when false the position of the transform and the navmesh agent is not synchronized,",
						"and you'll see a difference between the two in general.",
						"When updatePosition is turned back on, the Transform.position will be immediately",
						"move to match nextPosition.",
						"By setting nextPosition you can directly control where the internal agent position",
						"should be. The agent will be moved towards the position, but is constrained",
						"by the navmesh connectivity and boundaries. As such it will be useful only if",
						"the positions are continuously updated and assessed.",
						"You can also use Warp for teleporting a navmesh agent.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-nextPosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getNextOffMeshLinkData.ToString (),
					"",
					"\t\t\t\tOffMeshLinkData_activated = navMeshAgent.nextOffMeshLinkData.activated;\n\n\t\t\t\tOffMeshLinkData_endPosition = navMeshAgent.nextOffMeshLinkData.endPos;\n\n\t\t\t\tOffMeshLinkData_startPosition = navMeshAgent.nextOffMeshLinkData.startPos;\n\n\t\t\t\tOffMeshLinkData_valid = navMeshAgent.nextOffMeshLinkData.valid;\n\n\n\t\t\t\tOffMeshLinkData_Type = navMeshAgent.nextOffMeshLinkData.linkType;",
					"\t\t\t\tDrawOffMeshLinkDataResultField ();",
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.offMeshLinkData,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The next OffMeshLinkData on the current path.",
						"In the case that the current path does not contain an OffMeshLink",
						"the OffMeshLinkData is marked as invalid.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-nextOffMeshLinkData.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getIsPathStale.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.isPathStale;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Is the current path stale. (Read Only)",
						"When true, the path may no longer be valid or optimal.",
						"This flag will be set if: there are any changes to the areaMask,",
						"if any OffMeshLink is enabled or disabled, or if the costs for",
						"the NavMeshAreas have been changed.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isPathStale.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getIsPathPending.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.pathPending;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Is a path in the process of being computed but not yet ready? (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-pathPending.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getIsOnOffMeshLink.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.isOnOffMeshLink;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Is the agent currently positioned on an OffMeshLink? (Read Only)",
						"This property is useful when autoTraverseOffMeshLink is false and custom",
						"movement is needed when crossing the link.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isOnOffMeshLink.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getIsOnNavMesh.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.isOnNavMesh;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Is the agent currently bound to the navmesh? (Read Only)",
						"This property is true if the agent, for some reason, could not bind to the navmesh.",
						"E.g. if scene has no navmesh.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-isOnNavMesh.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getHeight.ToString (),
					"",
					"\t\t\t\tfloatValue = navMeshAgent.height;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The height of the agent for purposes of passing under obstacles, etc.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-height.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getHasPath.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.hasPath;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Does the agent currently have a path? (Read Only)",
						"This property will be true if the agent has a path calculated to the desired",
						"destination and false otherwise.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-hasPath.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getDestination.ToString (),
					"",
					"\t\t\t\tvector3Value = navMeshAgent.destination;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Gets or attempts to set the destination of the agent in world-space units.",
						"Getting:",
						"Returns the destination set for this agent.",
						"• If a destination is set but the path is not yet processed the position",
						"returned will be valid navmesh position that's closest to the previously",
						"set position.",
						"• If the agent has no path or requested path - returns the agents position on",
						"the navmesh.",
						"• If the agent is not mapped to the navmesh (e.g. scene has no navmesh) - returns a",
						"position at infinity.",
						"Setting:",
						"Requests the agent to move to the valid navmesh position that's closest to the",
						"requested destination.",
						"• The path result may not become available until after a few frames.",
						"Use pathPending to query for outstanding results.",
						"• If it's not possible to find a valid nearby navmesh position (e.g. scene has",
						"no navmesh) no path is requested.",
						"Use SetDestination and check return value if you need to handle this case explicitly.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-destination.html",
					""),	

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getDesiredVelocity.ToString (),
					"",
					"\t\t\t\tvector3Value = navMeshAgent.desiredVelocity;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The desired velocity of the agent including",
						"any potential contribution from avoidance. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-desiredVelocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getCurrentVelocity.ToString (),
					"",
					"\t\t\t\tvector3Value = navMeshAgent.velocity;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Access the current velocity of the NavMeshAgent component, or set a velocity to control",
						"the agent manually.",
						"Reading the variable will return the current velocity of the agent based on the",
						"crowd simulation.",
						"Setting the variable will override the simulation (including: moving towards",
						"destination, collision avoidance, and acceleration control) and command the NavMesh",
						"Agent to move using the specific velocity directly.",
						"When the agent is controlled using a velocity, its movement is still constrained",
						"on the NavMesh.",
						"Setting the velocity directly, can be used for implementing",
						"player characters, which are moving on NavMesh and affecting the rest of the",
						"simulated crowd. In addition, setting priority to high (a small value is higher",
						"priority), will make other simulated agents to avoid the player controlled agent",
						"even more eagerly.",
						"It is recommended to set the velocity each frame when",
						"controlling the agent manually, and if releasing the control to the simulation,",
						"set the velocity to zero. If agent’s velocity is set to some value and then",
						"stopped updating it, the simulation will pick up from there and the agent will",
						"slowly decelerate (assuming no destination is set).",
						"Note that reading the velocity will always return value from the simulation.",
						"If you set the value, the effect will show up in the next update. Since the",
						"returned velocity comes from the simulation (including avoidance and collision",
						"handling), it can be different than the one you set.",
						"The velocity is specified in distance units per second (same as physics),",
						"and represented in global coordinate system.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-velocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getCurrentOffMeshLinkData.ToString (),
					"",
					"\t\t\t\tOffMeshLinkData_activated = navMeshAgent.currentOffMeshLinkData.activated;\n\n\t\t\t\tOffMeshLinkData_endPosition = navMeshAgent.currentOffMeshLinkData.endPos;\n\n\t\t\t\tOffMeshLinkData_startPosition = navMeshAgent.currentOffMeshLinkData.startPos;\n\n\t\t\t\tOffMeshLinkData_valid = navMeshAgent.currentOffMeshLinkData.valid;\n\n\n\t\t\t\tOffMeshLinkData_Type = navMeshAgent.currentOffMeshLinkData.linkType;",
					"\t\t\t\tDrawOffMeshLinkDataResultField ();",
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.offMeshLinkData,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The current OffMeshLinkData.",
						"In the case that this agent is not on an OffMeshLink the OffMeshLinkData",
						"is marked as invalid.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-currentOffMeshLinkData.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getBaseOffset.ToString (),
					"",
					"\t\t\t\tfloatValue = navMeshAgent.baseOffset;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The relative vertical displacement of the owning GameObject.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-baseOffset.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getAvoidancePriority.ToString (),
					"",
					"\t\t\t\tintValue = navMeshAgent.avoidancePriority;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The avoidance priority level.",
						"When the agent is performing avoidance, agents of lower priority are ignored.",
						"The valid range is from 0 to 99 where: Most important = 0. Least important = 99.",
						"Default = 50.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-avoidancePriority.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getAutoTraverseOffMeshLink.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.autoTraverseOffMeshLink;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new String []
					{
						"Should the agent move across OffMeshLinks automatically?",
						"Off-mesh links are used to connect disjoint regions of the NavMesh.",
						"Usually, a character should be able to pass through or traverse a link",
						"automatically, which will happen if this property is set to true.",
						"However, it can also be set to false in cases where special control",
						"over movement is needed.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoTraverseOffMeshLink.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getAutoRepath.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.autoRepath;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Should the agent attempt to acquire a new path if the existing path becomes invalid?",
						"A new path calculation is also attempted aquired if the agent reaches the",
						"end of a partial and stale path.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoRepath.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getAutoBraking.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.autoBraking;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Should the agent brake automatically to avoid overshooting the destination point?",
						"If the agent needs to land close to the destination point then it will typically",
						"need to brake to avoid overshooting or endless 'orbiting' around the target zone.",
						"If this property is set to true, the agent will brake automatically as it nears",
						"the destination.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-autoBraking.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getAreaMask.ToString (),
					"\t\t\t\tDrawLabelField (FieldDrawType.label, \"For default layers:\", Skins.logicNodeLabel);\n\n\t\t\t\tDrawLabelFields (new string[]\n\t\t\t\t\t{\n\t\t\t\t\t\t\"-1\" + StringTreatment.rArrow + \"everything\",\n\n\t\t\t\t\t\t\"0\" + StringTreatment.rArrow + \"nothing\",\n\n\t\t\t\t\t\t\"1\" + StringTreatment.rArrow + \"walkable\",\n\n\t\t\t\t\t\t\"2\" + StringTreatment.rArrow + \"not walkable\",\n\n\t\t\t\t\t\t\"3\" + StringTreatment.rArrow + \"walkable + not walkable\",\n\n\t\t\t\t\t\t\"4\" + StringTreatment.rArrow + \"jump\",\n\n\t\t\t\t\t\t\"5\" + StringTreatment.rArrow + \"walkable + jump\",\n\n\t\t\t\t\t\t\"6\" + StringTreatment.rArrow + \"not walkable + jump\",\n\t\t\t\t\t});",
					"\t\t\t\tintValue = navMeshAgent.areaMask;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Specifies which NavMesh areas are passable. Changing areaMask will make the path",
						"stale (see isPathStale).",
						"This is a bitfield.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-areaMask.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.GetAreaCost.ToString (),
					"\t\t\t\t\tDrawLabelField (FieldDrawType.label, \"Of area of index\", \n\t\t\t\t\t\tSkins.logicNodeLabel);\n\n" +
					InOutWs.InWs._int + "\n\t\t\tintValues [0] = Mathf.Clamp (intValues [0], 0, 31);",
					"\t\t\t\tfloatValue = navMeshAgent.GetAreaCost (intValues [0]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues + ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Gets the cost for path finding over geometry of the area type.",
						"he value applies to all agents unless you the value has been customized",
						"per agent by calling NavMeshAgent.SetAreaCost.",
						"You can use NavMesh.GetAreaFromName to find the area index based",
						"on the name of the NavMesh area type.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMesh.GetAreaCost.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getAngularSpeed.ToString (),
					"",
					"\t\t\t\tfloatValue = navMeshAgent.angularSpeed;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Maximum turning speed in (deg/s) while following a path.",
						"This is the maximum rate at which the agent can turn as it",
						"rounds the 'corner' defined by a waypoint. The actual turning",
						"circle is also influenced by the speed of the agent on approach",
						"and also the maximum acceleration.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-angularSpeed.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.getAcceleration.ToString (),
					"",
					"\t\t\t\tfloatValue = navMeshAgent.acceleration;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"The maximum acceleration of an agent as it follows a path,",
						"given in units / sec^2.",
						"An agent does not follow precisely the line segments of the path",
						"calculated by the navigation system but rather uses the waypoints",
						"along the path as intermediate destinations. This value is the maximum",
						"amount by which the agent can accelerate while moving towards the next",
						"waypoint.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent-acceleration.html",			
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.FindClosestEdge.ToString (),
					"",
					"\t\t\t\tboolValue = navMeshAgent.FindClosestEdge (out navMeshHit);\n\n\t\t\t\tExtractNavMeshHitValues ();",
					"\t\t\t\tDrawNavMeshHitResultField ();"	,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.NavMeshHit + ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.extractNavMeshHitValues +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Locate the closest NavMesh edge from a point on the NavMesh.",
						"The returned NavMeshHit object contains the position and details of the nearest",
						"point on the nearest edge of the navmesh. This can be used to query how much",
						"extra space there is around the agent.", 
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMesh.FindClosestEdge.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.CompleteOffMeshLink.ToString (),
					"",
					tab4 + "navMeshAgent.CompleteOffMeshLink ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Completes the movement on the current OffMeshLink.",
						"The agent will move to the closest valid navmesh position on the other end of",
						"the current OffMeshLink.",
						"CompleteOffMeshLink has no effect unless the agent",
						"is on an OffMeshLink (See Also: isOnOffMeshLink).",
						"When autoTraverseOffMeshLink is disabled an agent will pause at an off-mesh",
						"link until this function is called. It is useful for implementing custom movement",
						"across OffMeshLinks.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.CompleteOffMeshLink.html",
					""),

				new EnumInputComputeOutput (
					ComputeNavMeshAgentType.ActivateCurrentOffMeshLink.ToString (),
					InOutWs.InWs._bool,
					tab4 + "navMeshAgent.ActivateCurrentOffMeshLink (boolValues [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.navMeshAgent_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.navMeshAgentCheck + ExprWs.UMDecl.computeNavMeshAgent,
					new string []
					{
						"Enables or disables the current off-mesh link.",
						"This function activates or deactivates the off-mesh link where the agent",
						"is currently waiting. This is useful for granting access to newly discovered",
						"areas of the game world or simulating the creation or removal of an obstacle",
						"to an area.",
					},
					"https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.ActivateCurrentOffMeshLink.html",
					""),
			};

		}



		EnumInputComputeOutput [] EnumInputComputeOutput_Camera ()
		{
			return 
				new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeCameraType.WorldToViewportPoint.ToString (),
					InOutWs.InWs._cameraWorldToScreenPoint,
					"\t\t\t\tvector3Value = " +
					"cam.WorldToViewportPoint (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Transforms position from world space",
						"into viewport space.",
						"Viewport space is normalized and relative to the camera.",
						"The bottom-left of the camera is (0,0);", 
						"the top-right is (1,1).",
						"The z position is in world units from the camera.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.WorldToViewportPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.WorldToScreenPoint.ToString (),
					InOutWs.InWs._cameraWorldToScreenPoint,
					"\t\t\t\tvector3Value = cam.WorldToScreenPoint (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Transforms position from world space into screen space.",
						"Screenspace is defined in pixels. The bottom-left of the screen is (0,0)",
						"the right-top is (pixelWidth, pixelHeight).",
						"The z position is in world units from the camera.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.WorldToScreenPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ViewportToWorldPoint.ToString (),
					InOutWs.InWs._cameraViewportToScreenPoint,
					"\t\t\t\tvector3Value = cam.ViewportToWorldPoint (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Transforms position from viewport space into world space.",
						"Viewport space is normalized and relative to the camera.",
						"The bottom-left of the viewport is (0,0); the top-right is (1,1).",
						"The z position is in world units from the camera.",
						"Note that ViewportToWorldPoint transforms an x-y screen position",
						"into a x-y-z position in 3D space.", 
						"Provide the function with a vector where the x-y components",
						"of the vector are the screen coordinates",
						"and the z component is the distance of the resulting plane from the camera.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ViewportToWorldPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ViewportToScreenPoint.ToString (),
					InOutWs.InWs._cameraViewportToScreenPoint,
					"\t\t\t\tvector3Value = cam.ViewportToScreenPoint (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Transforms position from viewport space into screen space.",
						"Viewport space is normalized and relative to the camera.",
						"The bottom-left of the camera is (0,0); the top-right is (1,1).",
						"The z position is in world units from the camera.",
						"Screenspace is defined in pixels.",
						"The bottom-left of the screen is (0,0);",
						"the right-top is (pixelWidth,pixelHeight).",
						"The z position is in world units from the camera.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ViewportToScreenPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ViewportPointToRay.ToString (),
					InOutWs.InWs._cameraViewportPointToRay,
					"\t\t\t\trayValue = cam.ViewportPointToRay (vector3Values [0]);\n\n\t\t\t\tSetRayValueOrigine (rayValue.origin);\n\t\t\t\tSetRayDirectionValue (rayValue.direction);",
					InOutWs.OutWs.ray_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.rayValueOriginAndNNDirection + ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.SetRayValueOriginAndDirection +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Returns a ray going from camera through a viewport point.",
						"Resulting ray is in world space, starting on the near plane of the camera",
						"and going through position's (x,y) coordinates on the viewport (position.z is ignored).",
						"Viewport coordinates are normalized and relative to the camera.",
						"The bottom-left of the camera is (0,0); the top-right is (1,1).",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ViewportPointToRay.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setUseOcclusionCulling.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tcam.useOcclusionCulling = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Set a bool value to tell the camera:",
						"whether or not to use occlusion culling during rendering.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-useOcclusionCulling.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setTransparencySortMode.ToString (),
					InOutWs.InWs._cameraSetTransparencySortMode,
					"\t\t\t\tcam.transparencySortMode = transparencySortMode;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.transparencySortMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.TransparencySortMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Transparent object sorting mode of a Camera.",
						"By default, perspective cameras sort objects based",
						"on distance from camera position to the object center;",
						"and orthographic cameras sort based on distance along the view direction.",
					},
					"https://docs.unity3d.com/ScriptReference/TransparencySortMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setTargetDisplay.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tcam.targetDisplay = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Set the target display for this Camera.",
						"This setting makes a Camera render into the specified display.",
						"Maximum number of displays (eg. monitors) supported is 8.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-targetDisplay.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.SetStereoViewMatrices.ToString (),
					InOutWs.InWs._camera_StereoscopicEye +
					InOutWs.InWs._cameraSetStereoProjectionMAtrix_0,
					"\t\t\t\tcam.SetStereoViewMatrix (camera_StereoscopicEye, m44Value_Input_entier [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.camera_StereoscopicEye +
					ExprWs.Gv.m44Value_Input_entier,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.camera_StereoscopicEye (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Sets a custom view matrix for a specific stereoscopic eye.",
						"In general it is recommended to stick with the view matrices provided by the VR SDK",
						"to ensure accurate stereoscopic rendering. However for some specific scenarios it",
						"can be useful to override the view matrices to achieve specific effects.",
						"For example, custom view matrices would be required to implement binoculars in VR.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.SetStereoViewMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setStereoSeparation.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tcam.stereoSeparation = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Distance between the virtual eyes.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-stereoSeparation.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getNonJitteredProjectionMatrix.ToString (),
					"",
					CodeOfSetM44EntierAndValues ("cam.nonJitteredProjectionMatrix"),
					InOutWs.OutWs.m44_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.m44Value_entier + ExprWs.Gv.m44ValueAndProperties,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.SetM44Value + 
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Get or set the raw projection matrix with no camera offset (no jittering).",
						"For many temporal image effects, the camera that is currently rendering needs to",
						"be slightly offset from the default projection (that is, the camera is ‘jittered’).",
						"Use this function to specify the default (non-jittered) perspective matrix that was",
						"used before the offset was applied. It is posible to configure whether the jittered or",
						"non jittered matrix should be used for objects rendered after the opaque objects pass",
						"(transparent objects for example), see [[Camera.useJitteredProjectionMatrixForTransparent].",
						"If you use motion vectors and camera jittering together, use this property to keep",
						"the motion vectors stable between frames.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-nonJitteredProjectionMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setNonJitteredProjectionMatrix.ToString (),
					InOutWs.InWs._cameraSetStereoProjectionMAtrix_0,
					"\t\t\t\tcam.nonJitteredProjectionMatrix = m44Value_Input_entier [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.m44Value_Input_entier,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Get or set the raw projection matrix with no camera offset (no jittering).",
						"For many temporal image effects, the camera that is currently rendering needs to",
						"be slightly offset from the default projection (that is, the camera is ‘jittered’).",
						"Use this function to specify the default (non-jittered) perspective matrix that was",
						"used before the offset was applied. It is posible to configure whether the jittered or",
						"non jittered matrix should be used for objects rendered after the opaque objects pass",
						"(transparent objects for example), see [[Camera.useJitteredProjectionMatrixForTransparent].",
						"If you use motion vectors and camera jittering together, use this property to keep",
						"the motion vectors stable between frames.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-nonJitteredProjectionMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.SetStereoProjectionMatrices.ToString (),
					InOutWs.InWs._camera_StereoscopicEye +
					InOutWs.InWs._cameraSetStereoProjectionMAtrix_0,
					"\t\t\t\tcam.SetStereoProjectionMatrix (camera_StereoscopicEye, m44Value_Input_entier [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.m44Value_Input_entier + ExprWs.Gv.camera_StereoscopicEye,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.camera_StereoscopicEye (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Sets a custom projection matrix for a specific stereoscopic eye.",
						"In general it is recommended to stick with the projection matrices provided by",
						"the VR SDK to ensure accurate stereoscopic rendering. However for some specific scenarios",
						"it can be useful to override the projection matrices to achieve specific effects.",
						"For example, custom projection matrices would be required to implement binoculars in VR.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.SetStereoProjectionMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setStereoConvergence.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tcam.stereoConvergence = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Distance to a point where virtual eyes converge.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-stereoConvergence.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.SetReplacementShader.ToString (),
					InOutWs.InWs._cameraRenderWithShader,
					InOutWs.CodeWs.Cam.setReplacementShader,
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.identifiedObjects + ExprWs.Gv.stringValues +
					ExprWs.Gv.shaderValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +					
					ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}) +
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Make the camera render with shader replacement.",
						"See Rendering with Replaced Shaders page for details.",
						"After calling this function, camera will render its view",
						"with shader replacement. Call ResetReplacementShader",
						"to reset it back to normal rendering.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.SetReplacementShader.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setRenderingPath.ToString (),
					InOutWs.InWs._cameraSetRenderingPath,
					"\t\t\t\tcam.renderingPath = renderingPath;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.renderingPath,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.RenderingPath (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Rendering path of a Camera.",
					},
					"https://docs.unity3d.com/ScriptReference/RenderingPath.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setRectNormalizedToTheScreen.ToString (),
					InOutWs.InWs._rect,
					"\t\t\t\tcam.rect = rectValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.rectValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.RectValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Where on the screen is the camera rendered in normalized coordinates.",
						"The values in rect range from zero (left/bottom) to one (right/top).", 
					},
					"https://docs.unity3d.com/ScriptReference/Camera-rect.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setProjectionMatrix.ToString (),
					InOutWs.InWs._m44,
					"\t\t\t\tcam.projectionMatrix = m44Value_Input_entier [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.m44Value_Input_entier,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Set a custom projection matrix.",
						"If you change this matrix, the camera no longer updates its",
						"rendering based on its fieldOfView.",
						"This lasts until you call ResetProjectionMatrix.",
						"Use a custom projection only if you really need",
						"a non-standard projection.",
						"This property is used by Unity's water rendering to setup",
						"an oblique projection matrix. Using custom projections",
						"requires good knowledge of transformation and",
						"projection matrices.",
						"Note that projection matrix passed to shaders",
						"can be modified depending on platform and other state.",
						"If you need to calculate projection matrix for shader",
						"use from camera's projection, use GL.GetGPUProjectionMatrix.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-projectionMatrix.html",
					""),
				//
				new EnumInputComputeOutput (
					ComputeCameraType.setPixelRect.ToString (),
					InOutWs.InWs._rect,
					"\t\t\t\tcam.pixelRect = rectValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.rectValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.RectValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Where on the screen is the camera rendered in pixel coordinates.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-pixelRect.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setOrthographicSize.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tcam.orthographicSize = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Camera's half-size when in orthographic mode.",
						"This is half of the vertical size of the viewing volume.",
						"Horizontal viewing size varies depending on viewport's aspect ratio.",
						"Orthographic size is ignored when camera is not orthographic",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-orthographicSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setOrthographic.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tcam.orthographic = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Is the camera orthographic (true) or perspective (false)?",
						"When ortho is true, camera's viewing volume is defined by orthographicSize.",
						"When orthographic is false, camera's viewing volume is defined by fieldOfView.",
						"NOTE: Deferred rendering is not supported when using Orthographic projection.",
						"If the camera's projection mode is set to Orthographic,",
						"the camera will always use Forward rendering.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-orthographic.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setOpaqueSortMode.ToString (),
					InOutWs.InWs._cameraSetOpaqueSortMode,
					"\t\t\t\tcam.opaqueSortMode = opaqueSortMode;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.opaqueSortMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.OpaqueSortMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Opaque objects are sorted by various criteria (sorting layers, shader queues, materials, distance, lightmaps etc.)",
						"to maximize both the CPU efficiency (reduce number of state changes and improve draw call batching),",
						"and to maximize GPU efficiency (many GPUs prefer rough front-to-back rendering order for faster rejection of invisible surfaces).",
						"By default, opaque objects are grouped in rough front-to-back buckets,",
						"on the GPUs where doing that is beneficial. There are GPUs where doing this distance based sorting is not really helpful",
						"(most notably, PowerVR/Apple GPUs), and so on these GPUs the distance based sorting is not done by default.",
						"The Camera.opaqueSortMode property lets you override this default behavior.",
						"For example, you might want to never do distance-based sorting for opaque objects,",
						"if you know you need much more CPU performance than GPU performance.",
					},
					"https://docs.unity3d.com/ScriptReference/Rendering.OpaqueSortMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setNearClipPlane.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tcam.nearClipPlane = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The near clipping plane distance.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-nearClipPlane.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setIsStereoMirrorMode.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t#if UNITY_5_6 || UNITY_2017_1\n" +
					"\t\t\t\tcam.stereoMirrorMode = boolValues [0];\n" +
					"\t\t\t\t#endif",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Render only once and use resulting image for both eyes.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-stereoMirrorMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setAllowHdr.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tcam.allowHDR = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"High dynamic range rendering.",
						"True if the camera is using HDR rendering and false if it is not.",
						"Even if this property is true, HDR is only used if also supported by the current",
						"Graphics Tier.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-allowHDR.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setFieldOfView.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tcam.fieldOfView = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The field of view of the camera in degrees.",
						"This is the vertical field of view; horizontal FOV varies depending",
						"on the viewport's aspect ratio. Field of view is ignored",
						"when camera is orthographic",
						"Some VR SDKs have fixed field of view values that are used",
						"for VR cameras. When VR is enabled with those SDKs,",
						"this property will always return the value from the SDK.",
						"You will see a warning logged if you attempt to set",
						"the property and the value will be ignored.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setFarClipPlane.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tcam.farClipPlane = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The far clipping plane distance.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-farClipPlane.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setEventMask.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tcam.eventMask = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Mask to select which layers can trigger events on the camera.",
						"Just as the camera's cullingMask determines if the camera is able",
						"to see the GameObject, the event mask determines whether",
						"the GameObject is able to receive mouse events.",
						"Only objects visible by the camera and whose layerMask",
						"overlaps with the camera's eventMask will be able to receive",
						"OnMouseXXX events. Setting this mask to zero will improve",
						"performance and is recommended if you don't use OnMouseXXX events.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-eventMask.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setEnabled.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tcam.enabled = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new String []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector",
						"of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setDepthTextureMode.ToString (),
					InOutWs.InWs._cameraSetDEpthTextureMode,
					"\t\t\t\tcam.depthTextureMode = depthTextureMode;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.depthTextureMode,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.DepthTextureMode (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Depth texture generation mode for Camera.",
						"The flags can be combined, so you can",
						"set a Camera to generate any combination of:",
						"Depth, Depth+Normals, and MotionVector textures if needed.",
					},
					"https://docs.unity3d.com/ScriptReference/DepthTextureMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setDepth.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tcam.depth = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Camera's depth in the camera rendering order.",
						"Cameras with lower depth are rendered before",
						"cameras with higher depth.",
						"Use this to control the order in which cameras are drawn",
						"if you have multiple cameras and some of them don't cover the full screen.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-depth.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setCullingMask.ToString (),
					InOutWs.InWs._cullingMask,
					"\t\t\t\tcam.cullingMask = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"This is used to render parts of the scene selectively.",
						"If the GameObject's layerMask AND the camera's cullingMask",
						"is zero then the game object will be invisible from",
						"this camera.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-cullingMask.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setBackgroundColor.ToString (),
					InOutWs.InWs._color,
					"\t\t\t\tcam.backgroundColor = colorValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.ColorValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The color with which the screen will be cleared.",
						"Only used if clearFlags are set to CameraClearFlags.SolidColor",
						"(or CameraClearFlags.Skybox but the skybox is not set up).",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-backgroundColor.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.setAspectRatio.ToString (),
					InOutWs.InWs._float + "\n\t\t\t\tfloatValues [0] = Mathf.Max (0.2f, floatValues [0]);",
					"\t\t\t\tcam.aspect = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The aspect ratio (width divided by height).",
						"By default the aspect ratio is automatically calculated from",
						"the screen's aspect ratio, even if the camera is not rendering to full area.",
						"If you modify the aspect ratio of the camera, the value will stay until",
						"you call camera.ResetAspect(); which resets the aspect to the screen's aspect ratio.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-aspect.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ScreenToWorldPoint.ToString (),
					"\t\t\t\tDrawLabelFields (new string[] {\"Screen Point (pixels)\",});\n\t\t\t\tDrawVector3InputField (0);",
					"\t\t\t\tvector3Value = cam.ScreenToWorldPoint (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Transforms position from screen space into world space.",
						"Screenspace is defined in pixels. The bottom-left of the screen is (0,0);",
						"the right-top is (pixelWidth,pixelHeight).",
						"The z position is in world units from the camera.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ScreenToViewportPoint.ToString (),
					"\t\t\t\tDrawLabelFields (new string[] {\"Screen Point (pixels)\",});\n\t\t\t\tDrawVector3InputField (0);",
					"\t\t\t\tvector3Value = cam.ScreenToViewportPoint (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Transforms position from screen space into viewport space.",
						"Screenspace is defined in pixels. The bottom-left of the screen is (0,0);",
						"the right-top is (pixelWidth,pixelHeight).",
						"The z position is in world units from the camera.",
						"Viewport space is normalized and relative to the camera.",
						"The bottom-left of the camera is (0,0); the top-right is (1,1).",
						"The z position is in world units from the camera.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ScreenToViewportPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ScreenPointToRay.ToString (),
					"\t\t\t\tDrawLabelFields (new string[] {\"Screen Point (pixels), z ignored\",});\n\t\t\t\tDrawVector3InputField (0);",
					"\t\t\t\trayValue = cam.ScreenPointToRay (vector3Values [0]);\n\n\t\t\t\tSetRayValueOrigine (rayValue.origin);\n\n\t\t\t\tSetRayDirectionValue (rayValue.direction);",
					InOutWs.OutWs.ray_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values + ExprWs.Gv.rayValueOriginAndNNDirection,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.SetRayValueOriginAndDirection +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Returns a ray going from camera through a screen point.",
						"Resulting ray is in world space, starting on the near plane of the camera",
						"and going through position's (x,y) pixel coordinates on the screen (position.z is ignored).",
						"Screenspace is defined in pixels. The bottom-left of the screen is (0,0);",
						"the right-top is (pixelWidth,pixelHeight).",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ScreenPointToRay.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ResetWorldToCameraMatrix.ToString (),
					"",
					tab4 + "cam.ResetWorldToCameraMatrix ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Make the rendering position reflect the camera's position in the scene.",
						"Call this to end the effect of setting worldToCameraMatrix.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ResetWorldToCameraMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ResetStereoViewMatrices.ToString (),
					"",
					tab4 + "cam.ResetStereoViewMatrices ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Reset the camera to using the Unity computed view matrices for all stereoscopic eyes.",
						"If Camera.SetStereoViewMatrices or Camera.SetStereoViewMatrix were used",
						"to provide custom view matrices, this method reverts the camera back",
						"to using view matrices provided by the VR SDK.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ResetStereoViewMatrices.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ResetStereoProjectionMatrices.ToString (),
					"",
					tab4 + "cam.ResetStereoProjectionMatrices ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Reset the camera to using the Unity computed projection matrices for all stereoscopic eyes.",
						"If Camera.SetStereoProjectionMatrices or Camera.SetStereoProjectionMatrix were used",
						"to provide custom projection matrices, this method reverts the camera back",
						"to using projection matrices provided by the VR SDK.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ResetStereoProjectionMatrices.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ResetReplacementShader.ToString (),
					"",
					tab4 + "cam.ResetReplacementShader ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Remove shader replacement from camera.",
						"Call this to end the effect of setting SetReplacementShader.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ResetReplacementShader.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ResetProjectionMatrix.ToString (),
					"",
					tab4 + "cam.ResetProjectionMatrix ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Make the projection reflect normal camera's parameters.",
						"Call this to end the effect of setting projectionMatrix.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ResetProjectionMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ResetFieldOfView.ToString (),
					"",
					tab4 + "cam.fieldOfView = 60f;",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Reset to the default field of view.",
						"Call this to end the effect of setting fieldOfView.",
						"Default field of view may be set dynamically by VR devices.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ResetFieldOfView.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.ResetAspect.ToString (),
					"",
					tab4 + "cam.ResetAspect ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Revert the aspect ratio to the screen's aspect ratio.",
						"Call this to end the effect of setting aspect.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.ResetAspect.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.RenderWithShader.ToString (),
					InOutWs.InWs._cameraRenderWithShader,
					InOutWs.CodeWs.Cam.renderWithShader,
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.shaderValues + ExprWs.Gv.stringValues + ExprWs.Gv.identifiedObjects,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +

					ExprWs.ConstructorExpr.StringValues (this) + ConstructorGetIdentifiedObject (new string [] {Enums.shaderValues_0_ID,}),

					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"This will render the camera. It will use the camera's clear flags,",
						"target texture and all other settings.",
						"The camera will not send OnPreCull, OnPreRender or OnPostRender to attached scripts.",
						"Image filters will not be rendered either.",
						"This is used for special effects, e.g. rendering screenspace normal buffer",
						"of the whole scene, heat vision and so on. To make use of this feature,",
						"usually you create a camera and disable it. Then call RenderWithShader on it.",
						"You are not able to call the Render function from a camera that is currently rendering.",
						"If you wish to do this create a copy of the camera, and make it match",
						"the original one using CopyFrom.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.RenderWithShader.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.RenderManually.ToString (),
					"",
					tab4 + "cam.Render ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Render the camera manually.",
						"This will render the camera. It will use the camera's clear flags,",
						"target texture and all other settings.",
						"The camera will send OnPreCull,",
						"OnPreRender and OnPostRender to any scripts attached,",
						"and render any eventual image filters.",
						"This is used for taking precise control of render order.",
						"To make use of this feature, create a camera and disable it. Then call Render on it.",
						"You are not able to call the Render function from a camera that is currently rendering.",
						"If you wish to do this create a copy of the camera, and make it match the original one using CopyFrom.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.Render.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getWorldToCameraMatrix.ToString (),
					"",
					CodeOfSetM44EntierAndValues ("cam.worldToCameraMatrix"),
					InOutWs.OutWs.m44_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.m44Value_entier + ExprWs.Gv.m44ValueAndProperties,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.SetM44Value + 
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Matrix that transforms from world to camera space.",
						"Use this to calculate the camera space position of objects or to provide",
						"custom camera's location that is not based on the transform.",
						"Note that camera space matches OpenGL convention:",
						"camera's forward is the negative Z axis. This is different from Unity's convention,",
						"where forward is the positive Z axis.",
						"If you change this matrix,",
						"the camera no longer updates its rendering based on its Transform.",
						"This lasts until you call ResetWorldToCameraMatrix.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-worldToCameraMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getVelocity.ToString (),
					"",
					tab4 + "vector3Value = cam.velocity;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Get the world-space speed of the camera (Read Only).",
						"This camera's motion in units per second as it was during the last frame.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-velocity.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getUseOcclusionCulling.ToString (),
					"",
					tab4 + "boolValue = cam.useOcclusionCulling;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Whether or not the Camera will use occlusion culling during rendering.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-useOcclusionCulling.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getTransparencySortMode.ToString (),
					"",
					tab4 + "stringValue = cam.transparencySortMode.ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Transparent object sorting mode of a Camera.",
						"By default, perspective cameras sort objects based on distance from camera position to the object center;",
						"and orthographic cameras sort based on distance along the view direction.",
						"If you're making a 2D game with a perspective camera, you might want to use TransparencySortMode.Orthographic sort mode",
						"so that objects are sorted based on distance along the camera's view.",
					},
					"https://docs.unity3d.com/ScriptReference/TransparencySortMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getTargetDisplay.ToString (),
					"",
					tab4 + "intValue = cam.targetDisplay;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Set the target display for this Camera.",
						"This setting makes a Camera render into the specified display.",
						"Maximum number of displays (eg. monitors) supported is 8.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-targetDisplay.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getStereoSeparation.ToString (),
					"",
					tab4 + "floatValue = cam.stereoSeparation;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Distance between the virtual eyes.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-stereoSeparation.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getStereoEnabled.ToString (),
					"",
					tab4 + "boolValue = cam.stereoEnabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Stereoscopic rendering.",
						"Is this camera rendering from two virtual eye-points to a stereoscopic output?",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-stereoEnabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getStereoConvergence.ToString (),
					"",
					tab4 + "floatValue = cam.stereoConvergence;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Distance to a point where virtual eyes converge.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-stereoConvergence.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getRenderingPath.ToString (),
					"",
					tab4 + "stringValue = cam.renderingPath.ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Rendering path of a Camera.",
					},
					"https://docs.unity3d.com/ScriptReference/RenderingPath.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getRectNormalizedToTheScreen.ToString (),
					"",
					tab4 + "rectValue = cam.rect;",
					InOutWs.OutWs.rect_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.rectValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Where on the screen is the camera rendered in normalized coordinates.",
						"The values in rect range from zero (left/bottom) to one (right/top).",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-rect.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getProjectionMatrix.ToString (),
					"",
					CodeOfSetM44EntierAndValues ("cam.projectionMatrix"),
					InOutWs.OutWs.m44_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.m44Value_entier + ExprWs.Gv.m44ValueAndProperties,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.SetM44Value +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Projection matrix. If you change this matrix, the camera no longer updates",
						"its rendering based on its fieldOfView. This lasts until you call",
						"ResetProjectionMatrix.",
						"Use a custom projection only if you really need",
						"a non-standard projection. This property is used by Unity's water rendering",
						"to setup an oblique projection matrix.",
						"Using custom projections requires good knowledge of",
						"transformation and projection matrices.",
						"Note that projection matrix passed to shaders can be modified",
						"depending on platform and other state.",
						"If you need to calculate projection matrix for shader use from camera's projection, use GL.GetGPUProjectionMatrix.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-projectionMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getPixelWidth.ToString (),
					"",
					tab4 + "intValue = cam.pixelWidth;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"How wide is the camera in pixels (Read Only).",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-pixelWidth.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getPixelRect.ToString (),
					"",
					tab4 + "rectValue = cam.pixelRect;",
					InOutWs.OutWs.rect_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.rectValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Where on the screen is the camera rendered in pixel coordinates.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-pixelRect.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getPixelHeight.ToString (),
					"",
					tab4 + "intValue = cam.pixelHeight;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"How tall is the camera in pixels (Read Only).",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-pixelHeight.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getOrthographicSize.ToString (),
					"",
					tab4 + "floatValue = cam.orthographicSize;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Camera's half-size when in orthographic mode.",
						"This is half of the vertical size of the viewing volume.",
						"Horizontal viewing size varies depending on viewport's aspect ratio.",
						"Orthographic size is ignored when camera is not orthographic.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-orthographicSize.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getOrthographic.ToString (),
					"",
					tab4 + "boolValue = cam.orthographic;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Is the camera orthographic (true) or perspective (false)?",
						"When ortho is true, camera's viewing volume is defined by orthographicSize.",
						"When orthographic is false, camera's viewing volume is defined by fieldOfView.",
						"NOTE: Deferred rendering is not supported when using Orthographic projection.",
						"If the camera's projection mode is set to Orthographic,",
						"the camera will always use Forward rendering.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-orthographic.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getOpaqueSortMode.ToString (),
					"",
					tab4 + "stringValue = cam.opaqueSortMode.ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Opaque object sorting mode of a Camera.",
						"Opaque objects are sorted by various criteria",
						"(sorting layers, shader queues, materials, distance, lightmaps etc.)",
						"to maximize both the CPU efficiency (reduce number of state changes",
						"and improve draw call batching), and to maximize GPU efficiency (many GPUs",
						"prefer rough front-to-back rendering order for faster rejection of invisible surfaces).",
						"By default, opaque objects are grouped in rough front-to-back buckets, on the GPUs where doing",
						"that is beneficial. There are GPUs where doing this distance based sorting is not really helpful",
						"(most notably, PowerVR/Apple GPUs), and so on these GPUs the distance based sorting is not done by default.",
						"The Camera.opaqueSortMode property lets you override this default behavior.",
						"For example, you might want to never do distance-based sorting for opaque objects,",
						"if you know you need much more CPU performance than GPU performance.",
					},
					"https://docs.unity3d.com/ScriptReference/Rendering.OpaqueSortMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getNearClipPlane.ToString (),
					"",
					tab4 + "floatValue = cam.nearClipPlane;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The near clipping plane distance.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-nearClipPlane.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getIsStereoMirrorMode.ToString (),
					"",
					"\t\t\t\t#if UNITY_5_6 || UNITY_2017_1\n" +
					"\t\t\t\tboolValue = cam.stereoMirrorMode;\n" +
					"\t\t\t\t#endif",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Render only once and use resulting image for both eyes.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-stereoMirrorMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getAllowHdr.ToString (),
					"",
					tab4 + "boolValue = cam.allowHDR;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"High dynamic range rendering.",
						"True if the camera is using HDR rendering and false if it is not.",
						"Even if this property is true, HDR is only used if also supported by the current",
						"Graphics Tier.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-allowHDR.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getFieldOfView.ToString (),
					"",
					tab4 + "floatValue = cam.fieldOfView;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The field of view of the camera in degrees.",
						"This is the vertical field of view; horizontal FOV varies depending",
						"on the viewport's aspect ratio. Field of view is ignored",
						"when camera is orthographic (see orthographic).",
						"Some VR SDKs have fixed field of view values that are used for VR cameras.",
						"When VR is enabled with those SDKs, this property will always return",
						"the value from the SDK. You will see a warning logged if you attempt to",
						"set the property and the value will be ignored.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getFarClipPlane.ToString (),
					"",
					"\t\t\t\tfloatValue = cam.farClipPlane;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The far clipping plane distance.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-farClipPlane.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getEventMask.ToString (),
					"",
					"\t\t\t\tintValue = cam.eventMask;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Mask to select which layers can trigger events on the camera.",
						"Just as the camera's cullingMask determines if the camera is able to see the GameObject,",
						"the event mask determines whether the GameObject is able to receive mouse events.",
						"Only objects visible by the camera and whose layerMask overlaps with the camera's eventMask",
						"will be able to receive OnMouseXXX events. Setting this mask to zero will",
						"improve performance and is recommended if you don't use OnMouseXXX events.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-eventMask.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getEnabled.ToString (),
					"",
					"\t\t\t\tboolValue = cam.enabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getDepthTextureMode.ToString (),
					"",
					"\t\t\t\tstringValue = cam.depthTextureMode.ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Depth texture generation mode for Camera.",
						"The flags can be combined, so you can set a Camera to generate any combination of:",
						"Depth, Depth+Normals, and MotionVector textures if needed.",
					},
					"https://docs.unity3d.com/ScriptReference/DepthTextureMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getDepth.ToString (),
					"",
					"\t\t\t\tfloatValue = cam.depth;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Camera's depth in the camera rendering order.",
						"Cameras with lower depth are rendered before cameras with higher depth.",
						"Use this to control the order in which cameras are drawn if you have multiple cameras",
						"and some of them don't cover the full screen.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-depth.html",
					""),


				new EnumInputComputeOutput (
					ComputeCameraType.getCullingMask.ToString (),
					"",
					"\t\t\t\tintValue = cam.cullingMask;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"This is used to render parts of the scene selectively.",
						"If the GameObject's layerMask AND the camera's cullingMask is zero then the game object",
						"will be invisible from this camera. See Layers for more information.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-cullingMask.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getCameraToWorldMatrix.ToString (),
					"",
					CodeOfSetM44EntierAndValues ("cam.cameraToWorldMatrix"),
					InOutWs.OutWs.m44_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.m44Value_entier + ExprWs.Gv.m44ValueAndProperties,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.SetM44Value +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Matrix that transforms from camera space to world space (Read Only).",
						"Use this to calculate where in the world a specific camera space point is.",
						"Note that camera space matches OpenGL convention: camera's forward is the negative Z axis.",
						"This is different from Unity's convention, where forward is the positive Z axis.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-cameraToWorldMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getBackgroundColor.ToString (),
					"",
					"\t\t\t\tcolorValue = cam.backgroundColor;",
					InOutWs.OutWs.color_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.colorValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The color with which the screen will be cleared.",
						"Only used if clearFlags are set to CameraClearFlags.SolidColor",
						"(or CameraClearFlags.Skybox but the skybox is not set up).",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-backgroundColor.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getAspectRatio.ToString (),
					"",
					"\t\t\t\tfloatValue = cam.aspect;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The aspect ratio (width divided by height).",
						"By default the aspect ratio is automatically calculated from the screen's aspect ratio,",
						"even if the camera is not rendering to full area. If you modify the aspect ratio",
						"of the camera, the value will stay until you call camera.ResetAspect();",
						"which resets the aspect to the screen's aspect ratio.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-aspect.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.getActualRenderingPath.ToString (),
					"",
					"\t\t\t\tstringValue = cam.actualRenderingPath.ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"The rendering path that is currently being used (Read Only).",
						"The actual rendering path might be different from the user-specified renderingPath",
						"if the underlying GPU/platform does not support the requested one,",
						"or some other situation causes a fallback (for example, if deferred rendering",
						"is not supported with orthographic projection cameras).",
					},
					"https://docs.unity3d.com/ScriptReference/Camera-actualRenderingPath.html",
					""),	

				new EnumInputComputeOutput (
					ComputeCameraType.CopySettingsToTheCamera.ToString (),
					InOutWs.InWs._cameraCopyCameraSettings,
					InOutWs.CodeWs.Cam.copyFromCam_1,
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.cam_1,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.getCam_1 +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Makes this camera's settings match other camera.",
						"This will copy all camera's variables (field of view, clear flags, culling mask, ...)",
						"from the other/ camera. It will also set this camera's transform to match the other camera,",
						"as well as this camera's layer to match the layer of the other camera.",
						"This can be useful if you want one camera to match the other camera's setup,",
						"when doing custom rendering effects. For example when using RenderWithShader.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.CopyFrom.html",
					""),

				new EnumInputComputeOutput (
					ComputeCameraType.CalculateObliqueMatrix.ToString (),
					InOutWs.InWs._cameraCalculateOblicMatrix,
					CodeOfSetM44EntierAndValues ("cam.CalculateObliqueMatrix (vector4Values [0])"),
					InOutWs.OutWs.m44_,
					ExprWs.Gv.cam_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.m44Value_entier + ExprWs.Gv.m44ValueAndProperties + ExprWs.Gv.vector4Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector4Values (this),
					ExprWs.UMDecl.SetM44Value +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.cameraCheck + ExprWs.UMDecl.computeCamera,
					new string []
					{
						"Calculates and returns oblique near-plane projection matrix.",
						"Given a clip plane vector, this function returns camera's projection matrix",
						"which has this clip plane set as its near plane.",
					},
					"https://docs.unity3d.com/ScriptReference/Camera.CalculateObliqueMatrix.html",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_Bool ()
		{
			return
				new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeBoolType.atStateStart.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"how much start pulses?\");\n" +
					InOutWs.InWs._int_1 + ret + "\t\t\t\tintValues [1] = Mathf.Max (intValues [1], 1);", 
					"\t\t\t\tif (intValues [0] < intValues [1]+1)\n\t\t\t{\n\t\t\t\tintValues [0]++;\n\t\t\t\tboolValue = true;\n\t\t\t}\n\n\t\t\tif (intValues [0] >= intValues [1]+1)\n\t\t\t{\n\t\t\t\tboolValue = false;\n\t\t\t}\n",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.IntValues (this) +
					"\t\t\tintValues [0] = 0;\n",
					"",
					new string []
					{
						"",
						"Returns a number of true pulses at the game start and ",
						"after that, a false at every frame when playing.",
					},
					"",
					""),
				

				new EnumInputComputeOutput (
					ComputeBoolType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", MezanixDiamondBoolNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._bool_1 + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret +
					"\t\t\t\tDrawDoItButton ();\n",
					"\t\t\t\tboolValue = MezanixDiamondGetBool (stringValues [0]);\n" +
					"\t\t\tif (boolValues [0])\n\t\t\t{\n" +
					"\t\t\t\tMezanixDiamondRemoveBool (stringValues [0]);\n\t\t\t}\n",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.bool_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolAll + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.mezanixDiamondGetBool + ExprWs.UMDecl.mezanixDiamondRemoveBool,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeBoolType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._bool + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n" +
					"\t\t\t\tDrawDoItButton ();\n",
					"\t\t\t\tMezanixDiamondSetBool (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.mezanixDiamondSetBool,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeBoolType.invertPeriodically.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Period\");\n" +
					InOutWs.InWs._float + "\n" + 
					"\t\t\t\tfloatValues [0] = Mathf.Abs (floatValues [0]);",
					"\t\t\t\tfloatValues [1] -= Time.deltaTime;\n\n\t\t\t\tif (floatValues [1] <= 0f)\n\t\t\t\t{\n\t\t\t\t\tfloatValues [1] = floatValues [0];\n\n\t\t\t\t\tboolValue = ! boolValue;\n\t\t\t\t}\n",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.floatValues + ExprWs.Gv.boolValue, 
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tfloatValues [1] = floatValues [0];\n",
					"",
					new string []
					{						
						"the output bool is inverted periodically",
						"P.S. the editor time is faster than game time",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeBoolType.invertAtPulse.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\tboolValue = ! boolValue;\n\n\t\t\t\t\tboolValues [0] = false;\n\t\t\t\t}",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.BoolValues (this),
					"",
					new string []
					{
						"If the input bool receive a true impulse,",
						"the output bool is inverted",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeBoolType.listenToEvent.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 " +
					"(\"Event Name\", MezanixDiamondEventNames (), noEventFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the event?\");\n" +
					InOutWs.InWs._bool + ret +
					"\t\t\t\tDrawDoItButton ();\n",
					"\t\t\t\tboolValue = MezanixDiamondGetEvent (stringValues [0]);\n" +
					"\t\t\tif (boolValues [0])\n\t\t\t{\n" +
					"\t\t\t\tMezanixDiamondRemoveEvent (stringValues [0]);\n\t\t\t}\n",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.bool_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolAll + ExprWs.Gv.doIt +
					ExprWs.Gv.mdeGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mdeGameObjectHolder,
					ExprWs.UMDecl.getmde +
					ExprWs.UMDecl.mezanixDiamondGetEvent + ExprWs.UMDecl.mezanixDiamondRemoveEvent,
					new string []
					{
						"",
						"Listen to an event by its name.",
						"If you want to listen to this event at this moment",
						"and no need to listen to it later, it's recommended",
						"to consume it.",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeBoolType.sendEvent.ToString (),
					"DrawLogicNodeLabel (\"Event Name\");\n" +
					InOutWs.InWs._string + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name event, click doIT\");\n" +
					"\t\t\t\tDrawDoItButton ();\n",
					"\t\t\t\tMezanixDiamondSetEvent (stringValues [0]);\n",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mdeGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + 
					ExprWs.ConstructorExpr.mdeGameObjectHolder,
					ExprWs.UMDecl.getmde +
					ExprWs.UMDecl.mezanixDiamondSetEvent,
					new string []
					{
						"",
						"Send an event by its name. The name can be used",
						"by another graph (script) to listen to this event.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeBoolType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool_1 + "\n" +
					"\t\t\t\tForGet_bool_DrawInputs ();",
					"\t\t\t\tForGet_bool_Compute ();",
					"\t\t\t\tForGet_bool_DrawOutputs ();",
					ExprWs.Gv.boolValue + 
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.BoolValues (this) +
					ExprWs.ConstructorExpr.BoolValue (this),
					ExprWs.UMDecl.ForGet_bool_Compute,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeBoolType.sendATruePulseWithDelay.ToString (),
					InOutWs.InWs._bool + ret + InOutWs.InWs._float + ret + 
					"\t\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);\n",
					InOutWs.CodeWs.downTimeCounterCodeForBoolImpulse,
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					InOutWs.OutWs.bool_,
					ExprWs.Gv.floatValues + ExprWs.Gv.boolAll + ExprWs.Gv.downTimeCounterForBoolImpulse,
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.BoolValues (this) +
					ExprWs.ConstructorExpr.downTimeCountForBoolImpulse,
					"",
					new string []
					{
						"",
						"Wait for some delay and return one true pulse" +
						"Sometimes you need that to trigger an action delayed in time",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeBoolType.quitApplication.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t\tApplication.Quit ();",
					"",
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.BoolValues (this),
					"",
					new string []
					{
						"",
						"Quits the player application.",
						"Quit is ignored in the editor",
					},
					"https://docs.unity3d.com/ScriptReference/Application.Quit.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeBoolType.atGameStart.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"how much start pulses?\");\n" +
					InOutWs.InWs._int_1 + ret + "\t\t\t\tintValues [1] = Mathf.Max (intValues [1], 1);", 
					"\t\t\t\tif (intValues [0] < intValues [1]+1)\n\t\t\t{\n\t\t\t\tintValues [0]++;\n\t\t\t\tboolValue = true;\n\t\t\t}\n\n\t\t\tif (intValues [0] >= intValues [1]+1)\n\t\t\t{\n\t\t\t\tboolValue = false;\n\t\t\t}\n",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.boolValueEqualTrue + ExprWs.ConstructorExpr.IntValues (this) +
					"\t\t\tintValues [0] = 0;\n",
					"",
					new string []
					{
						"",
						"Returns a number of true pulses at the game start and ",
						"after that, a false at every frame when playing.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeBoolType.loadScene.ToString (),
					InOutWs.InWs._bool + ret + 
					InOutWs.InWs._DrawChooseSceneFromBuildScenes + ret +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);" +
					InOutWs.InWs.__loadSceneModeEnum,
					"\t\t\t\tif (boolValues [0])\n" +
					"\t\t\t\t{\n\t\t\t\t\tUnityEngine.SceneManagement.SceneManager.LoadScene (" +
					"stringValues [0], loadSceneMode);\n\t\t\t\t}\n",
					"",
					ExprWs.Gv.boolValues + ExprWs.Gv.stringValues + ExprWs.Gv.loadSceneMode,
					ExprWs.ConstructorExpr.BoolValues (this) + ExprWs.ConstructorExpr.StringValues (this) +
					ExprWs.ConstructorExpr.loadSceneMode (this),
					"",
					new string []
					{
						"Load the scene of chosen scene name",
						"Choose also the loading mode",
					}),

				new EnumInputComputeOutput (
					ComputeBoolType.itIsNot.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tboolValue = !boolValues [0];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.BoolValues (this),
					"",
					new string []
					{
						"Use it to inverse a bool",
						"If the checkbox is checked:",
						"Return false",
						"If not:",
						"Return true.",
					}),

				new EnumInputComputeOutput (
					ComputeBoolType.toString.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tstringValue = boolValues [0].ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.boolValues + ExprWs.Gv.stringValue,
					ExprWs.ConstructorExpr.BoolValues (this),
					"",
					new string []
					{
						"If the checkbox is checked:",
						"Return the string (word or phrase) 'True'",
						"If not:",
						"Return the string (word or phrase) 'False'.",
					}),

				new EnumInputComputeOutput (
					ComputeBoolType.toFloat.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tfloatValue = boolValues [0]? 1f: 0f;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.boolValues + ret + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.BoolValues (this),
					"",
					new string []
					{
						"If the checkbox is checked:",
						"Return a float (decimal) equal 1.",
						"If not:",
						"Return a float (decimal) equal zero.",
					}),

				new EnumInputComputeOutput (
					ComputeBoolType.or.ToString (),
					InOutWs.InWs._bool_and_1,
					"\t\t\t\tboolValue = (boolValues [0] || boolValues [1]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.BoolValues (this),
					"",
					new String []
					{
						"Return true",
						"if one of checkboxes",
						"are checked.",
					}),

				new EnumInputComputeOutput (
					ComputeBoolType.goToState.ToString (),
					InOutWs.InWs._gotoState,
					"\t\t\t\tGoToState ();",
					"",
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GoToState (this),
					new String []
					{
						"When the checkboxe",
						"is checked:",
						"Go to The choosen state.",
					}),

				new EnumInputComputeOutput (
					ComputeBoolType.and.ToString (),
					InOutWs.InWs._bool_and_1,
					"\t\t\t\tboolValue = (boolValues [0] && boolValues [1]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolAll,
					ExprWs.ConstructorExpr.BoolValues (this),
					"",
					new String []
					{
						"Return true only",
						"if both checkboxes",
						"are checked.",
					}),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_unityInpuClassAndCrossPlatform ()
		{
			return new EnumInputComputeOutput[]
			{

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.touchSupported.ToString (),
					"",
					"\t\t\t\tboolValue = Input.touchSupported;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns whether the device on which application is currently running supports touch input.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-touchSupported.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.touchPressureSupported.ToString (),
					"",
					"\t\t\t\tboolValue = Input.touchPressureSupported;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Bool value which let's users check if touch pressure is supported.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-touchPressureSupported.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.touchCount.ToString (),
					"",
					"\t\t\t\tintValue = Input.touchCount;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.intValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Number of touches. Guaranteed not to change throughout the frame. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-touchCount.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.stylusTouchSupported.ToString (),
					"",
					"\t\t\t\tboolValue = Input.stylusTouchSupported;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true when Stylus Touch is supported by a device or platform.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-stylusTouchSupported.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.stopLocationService.ToString (),
					"",
					"\t\t\t\tInput.location.Stop ();",
					"",
					"",
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Stops location service updates. This could be useful for saving battery life.",
					},
					"https://docs.unity3d.com/ScriptReference/LocationService.Stop.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.startLocationService.ToString (),
					"",
					"\t\t\t\tInput.location.Start ();",
					"",
					"",
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Starts location service updates. Last location coordinates could be.",
					},
					"https://docs.unity3d.com/ScriptReference/LocationService.Start.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.setSimulateMouseWithTouches.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tInput.simulateMouseWithTouches = boolValues [0];",
					"",
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Enables/Disables mouse simulation with touches. By default this option is enabled.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-simulateMouseWithTouches.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.setImeCompositionMode.ToString (),
					"\t\t\t\tiMECompositionMode = (IMECompositionMode)DrawEnum " +
					"(iMECompositionMode, \"IME Composition Mode\", Skins.logicNodeLabel);\n",
					"\t\t\t\tInput.imeCompositionMode = iMECompositionMode;",
					"",
					"\t\tpublic IMECompositionMode iMECompositionMode;\n",
					"\t\t\t\tiMECompositionMode = IMECompositionMode." + iMECompositionMode.ToString () + ";\n",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Controls IME input.",
					},
					"https://docs.unity3d.com/ScriptReference/IMECompositionMode.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.setCompositionCursorPos.ToString (),
					InOutWs.InWs._vector2,
					"\t\t\t\tInput.compositionCursorPos = vector2Values [0];",
					"",
					ExprWs.Gv.vector2Values,
					ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"The current text input position used by IMEs to open windows.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-compositionCursorPos.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.setCompensateSensors.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tInput.compensateSensors = boolValues [0];",
					"",
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"This property controls if input sensors should be compensated for screen orientation.",
						"Compensated sensors are accelerometer, compass, gyroscope.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-compensateSensors.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.setBackButtonLeavesApp.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\tInput.backButtonLeavesApp = boolValues [0];",
					"",
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Should Back button quit the application?",
					},
					"https://docs.unity3d.com/ScriptReference/Input-backButtonLeavesApp.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.ResetInputAxes.ToString (),
					"",
					"\t\t\t\tInput.ResetInputAxes ();",
					"",
					"",
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Resets all input. After ResetInputAxes all axes return to 0",
						" and all buttons return to 0 for one frame.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.ResetInputAxes.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.multiTouchEnabled.ToString (),
					"",
					"\t\t\t\tboolValue = Input.multiTouchEnabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Property indicating whether the system handles multiple touches.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-multiTouchEnabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.mouseScrollDelta.ToString (),
					"",
					"\t\t\t\tvector2Value = Input.mouseScrollDelta;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.vector2Value,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"The current mouse scroll delta. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-mouseScrollDelta.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.mousePresent.ToString (),
					"",
					"\t\t\t\tboolValue = Input.mousePresent;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Indicates if a mouse device is detected.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-mousePresent.html",
					""),



				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.mousePosition.ToString (),
					"\t\t\t\tDrawInNodeInfo (crossPlatformRunOnlyInRunTime);\n\t\t\t\tDrawInNodeInfo (makeSureCrossPlatformImported);\n",
					"#if CROSS_PLATFORM_INPUT\n" +
					"\t\t\t\tvector3Value = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.mousePosition;\n" +
					"#else\n" +
					"\t\t\t\tvector3Value = Input.mousePosition;\n" +
					"#endif\n",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.vector3Value,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"The current mouse position in pixel coordinates. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-mousePosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.mousePositionNoCrossPlatform.ToString (),
					"",
					"\t\t\t\tvector3Value = Input.mousePosition;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.vector3Value,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"The current mouse position in pixel coordinates. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-mousePosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.locationServiceGetStatus.ToString (),
					"",
					"\t\t\t\tstringValue = Input.location.status.ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.stringValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Describes location service status.",
					},
					"https://docs.unity3d.com/ScriptReference/LocationServiceStatus.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.locationServiceGetLastData.ToString (),
					"",
					"\t\t\t\tstringValue = Input.location.lastData.ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.stringValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Structure describing device location.",
					},
					"https://docs.unity3d.com/ScriptReference/LocationInfo.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.locationServiceIsEnabledByUser.ToString (),
					"",
					"\t\t\t\tboolValue = Input.location.isEnabledByUser;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Specifies whether location service is enabled in user settings.",
					},
					"https://docs.unity3d.com/ScriptReference/LocationService-isEnabledByUser.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.IsJoystickPreconfigured.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Joystick Name\");\n" +
					InOutWs.InWs._string,
					"\t\t\t\tboolValue = Input.IsJoystickPreconfigured (stringValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Determine whether a particular joystick model has been preconfigured by Unity. (Linux-only).",
					},
					"https://docs.unity3d.com/ScriptReference/Input.IsJoystickPreconfigured.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.inputString.ToString (),
					"",
					"\t\t\t\tstringValue = Input.inputString;",
					InOutWs.OutWs.string_,
					ExprWs.Gv.stringValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns the keyboard input entered this frame. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-inputString.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.imeIsSelected.ToString (),
					"",
					"\t\t\t\tboolValue = Input.imeIsSelected;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Does the user have an IME keyboard input source selected?",
					},
					"https://docs.unity3d.com/ScriptReference/Input-imeIsSelected.html",
					""),


				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.getImeCompositionMode .ToString (),
					"",
					"\t\t\t\tstringValue = Input.imeCompositionMode.ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.stringValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Controls IME input.",
					},
					"https://docs.unity3d.com/ScriptReference/IMECompositionMode.html",
					""),


				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.gyro.ToString (),
					"",
					"\t\t\t\tGyroscope gyro = Input.gyro;\n\n\n\t\t\t\tboolValue = gyro.enabled;\n\n\t\t\t\tvector3Value = gyro.gravity;\n\n\t\t\t\tfloatValue = gyro.updateInterval;\n\n\n\n\t\t\t\tm44Value [0] = gyro.attitude.x;\n\n\t\t\t\tm44Value [1] = gyro.attitude.y;\n\n\t\t\t\tm44Value [2] = gyro.attitude.z;\n\n\t\t\t\tm44Value [3] = gyro.attitude.w;\n\n\n\n\t\t\t\tm44Value [4] = gyro.rotationRate.x;\n\n\t\t\t\tm44Value [5] = gyro.rotationRate.y;\n\n\t\t\t\tm44Value [6] = gyro.rotationRate.z;\n\n\t\t\t\tm44Value [7] = 1f;\n\n\n\t\t\t\tm44Value [8] = gyro.userAcceleration.x;\n\n\t\t\t\tm44Value [9] = gyro.userAcceleration.y;\n\n\t\t\t\tm44Value [10] = gyro.userAcceleration.z;\n\n\t\t\t\tm44Value [11] = 1f;\n\n\n\t\t\t\tm44Value [12] = gyro.rotationRateUnbiased.x;\n\n\t\t\t\tm44Value [13] = gyro.rotationRateUnbiased.y;\n\n\t\t\t\tm44Value [14] = gyro.rotationRateUnbiased.z;\n\n\t\t\t\tm44Value [15] = 1f;\n",
					"\tDrawM44ResultField (new string []\n\t\t\t\t\t{\n\t\t\t\t\t\t\"gyro.attitude.x\",\n\t\t\t\t\t\t\"gyro.attitude.y\",\n\t\t\t\t\t\t\"gyro.attitude.z\",\n\t\t\t\t\t\t\"gyro.attitude.w\",\n\n\t\t\t\t\t\t\"gyro.rotationRate.x\",\n\t\t\t\t\t\t\"gyro.rotationRate.y\",\n\t\t\t\t\t\t\"gyro.rotationRate.z\",\n\t\t\t\t\t\t\"none\",\n\n\t\t\t\t\t\t\"gyro.userAcceleration.x\",\n\t\t\t\t\t\t\"gyro.userAcceleration.y\",\n\t\t\t\t\t\t\"gyro.userAcceleration.z\",\n\t\t\t\t\t\t\"none\",\n\n\t\t\t\t\t\t\"gyro.rotationRateUnbiased.x\",\n\t\t\t\t\t\t\"gyro.rotationRateUnbiased.y\",\n\t\t\t\t\t\t\"gyro.rotationRateUnbiased.z\",\n\t\t\t\t\t\t\"none\",\n\t\t\t\t\t});\n",
					ExprWs.Gv.boolValue + ExprWs.Gv.vector3Value + ExprWs.Gv.floatValue +
					ExprWs.Gv.m44Value,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Interface into the Gyroscope.",
					},
					"https://docs.unity3d.com/ScriptReference/Gyroscope.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetTouch.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tintValues [0] = Mathf.Clamp  (intValues [0], 0, Input.touchCount);" +
					"\n\n\t\t\t\tif (Input.touchCount > 0) \n\t\t\t\t{" +
					"\n\t\t\t\t\tTouch touch = Input.GetTouch (intValues [0]);\n\n\n\t\t\t\t\ttouch_altitudeAngle = touch.altitudeAngle; \n\n\t\t\t\t\ttouch_azimuthAngle = touch.azimuthAngle;\n\n\t\t\t\t\ttouch_deltaPosition = touch.deltaPosition;\n\n\t\t\t\t\ttouch_deltaTime = touch.deltaTime;\n\n\n\n\t\t\t\t\ttouch_fingerId = touch.fingerId;\n\n\t\t\t\t\ttouch_maximumPossiblePressure = touch.maximumPossiblePressure;\n\n\t\t\t\t\ttouch_phase = touch.phase.ToString ();\n\n\t\t\t\t\ttouch_position = touch.position;\n\n\t\t\t\t\ttouch_pressure = touch.pressure;\n\n\n\n\t\t\t\t\ttouch_radius = touch.radius;\n\n\t\t\t\t\ttouch_radiusVariance = touch.radiusVariance;\n\n\t\t\t\t\ttouch_rawPosition = touch.rawPosition;\n\n\t\t\t\t\ttouch_tapCount = touch.tapCount;\n\n\t\t\t\t\ttouch_type = touch.type.ToString ();\n\t\t\t\t}\n",
					"\t\t\t\tDrawTouchOutputField ();",
					ExprWs.Gv.Touch + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns object representing status of a specific touch.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetTouch.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.getSimulateMouseWithTouches.ToString (),
					"",
					"\t\t\t\tboolValue = Input.simulateMouseWithTouches;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Enables/Disables mouse simulation with touches. By default this option is enabled.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-simulateMouseWithTouches.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetMouseButtonUp.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tboolValue = Input.GetMouseButtonUp (intValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true during the frame the user releases the given mouse button..",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetMouseButtonUp.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetMouseButtonDown.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tboolValue = Input.GetMouseButtonDown (intValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true during the frame the user pressed the given mouse button.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetMouseButtonDown.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetMouseButton.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tboolValue = Input.GetMouseButton (intValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns whether the given mouse button is held down.",
						"button values are 0 for left button, 1 for right button, 2 for the middle button.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetKeyUp.ToString (),
					"\t\t\t\tDrawKeyCodeEnum ();\n",
					"\t\t\t\tboolValue = Input.GetKeyUp (keyCode);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.keyCode,
					ExprWs.ConstructorExpr.keyCode (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true during the frame the user releases the key identified by name.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetKeyUp.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetKeyDown.ToString (),
					"\t\t\t\tDrawKeyCodeEnum ();\n",
					"\t\t\t\tboolValue = Input.GetKeyDown (keyCode);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.keyCode,
					ExprWs.ConstructorExpr.keyCode (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true during the frame the user starts pressing down the key identified by name.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetKeyDown.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetKey.ToString (),
					"\t\t\t\tDrawKeyCodeEnum ();\n",
					"\t\t\t\tboolValue = Input.GetKey (keyCode);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.keyCode,
					ExprWs.ConstructorExpr.keyCode (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true while the user holds down the key identified by name. Think auto fire.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetKey.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetJoystickNames.ToString (),
					"",
					"\t\t\t\tstringsListValue = new List<string>();\n\t\t\t\tfor (int i = 0; i < Input.GetJoystickNames ().Length; i++)\n\t\t\t\t{\n\t\t\t\t\tstringsListValue.Add (Input.GetJoystickNames ()[i]);\n\t\t\t\t}\n\n",
					InOutWs.OutWs.stringList_,
					ExprWs.Gv.stringListValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns an array of strings describing the connected joysticks",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetJoystickNames.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.getCompositionCursorPos.ToString (),
					"",
					"\t\t\t\tvector2Value = Input.compositionCursorPos;",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.vector2Value,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"The current text input position used by IMEs to open windows.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-compositionCursorPos.html",
					""),



				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.getCompensateSensors.ToString (),
					"",
					"\t\t\t\tboolValue = Input.compensateSensors;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"This property controls if input sensors should be compensated ",
						"for screen orientation.",
						"Compensated sensors are accelerometer, compass, gyroscope.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-compensateSensors.html",
					""),


				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetButtonUp.ToString (),
					"\t\t\t\tDrawInNodeInfo (crossPlatformRunOnlyInRunTime);\n\t\t\t\tDrawInNodeInfo (makeSureCrossPlatformImported);" +
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"#if CROSS_PLATFORM_INPUT\n" +
					"\t\t\t\tboolValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetButtonUp (stringValues [0]);\n" +
					"#else\n" +
					"\t\t\t\tboolValue = Input.GetButtonUp (stringValues [0]);\n" +
					"#endif\n",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true the first frame the user releases the virtual",
						" button identified by buttonName.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetButtonUp.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetButtonUpNoCrossPlatform.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"\t\t\t\tboolValue = Input.GetButtonUp (stringValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true the first frame the user releases the virtual",
						" button identified by buttonName.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetButtonUp.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetButtonDown.ToString (),
					"\t\t\t\tDrawInNodeInfo (crossPlatformRunOnlyInRunTime);\n\t\t\t\tDrawInNodeInfo (makeSureCrossPlatformImported);" +
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"#if CROSS_PLATFORM_INPUT\n" +
					"\t\t\t\tboolValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetButtonDown (stringValues [0]);\n" +
					"#else\n" +
					"\t\t\t\tboolValue = Input.GetButtonDown (stringValues [0]);\n" +
					"#endif\n",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true during the frame the user pressed down the virtual ",
						"button identified by buttonName.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetButtonDown.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetButtonDownNoCrossPlatform.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"\t\t\t\tboolValue = Input.GetButtonDown (stringValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true during the frame the user pressed down the virtual ",
						"button identified by buttonName.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetButtonDown.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetButton.ToString (),
					"\t\t\t\tDrawInNodeInfo (crossPlatformRunOnlyInRunTime);\n\t\t\t\tDrawInNodeInfo (makeSureCrossPlatformImported);" +
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"#if CROSS_PLATFORM_INPUT\n" +
					"\t\t\t\tboolValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetButton (stringValues [0]);\n" +
					"#else\n" +
					"\t\t\t\tboolValue = Input.GetButton (stringValues [0]);\n" +
					"#endif\n",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true while the virtual button identified by buttonName is held down.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetButton.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetButtonNoCrossPlatform.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"\t\t\t\tboolValue = Input.GetButton (stringValues [0]);",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true while the virtual button identified by buttonName is held down.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetButton.html",
					""),
				

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.getBackButtonLeavesApp.ToString (),
					"",
					"\t\t\t\tboolValue = Input.backButtonLeavesApp;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Should Back button quit the application?",
					},
					"https://docs.unity3d.com/ScriptReference/Input-backButtonLeavesApp.html",
					""),


				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetAxisRaw.ToString (),
					"\t\t\t\tDrawInNodeInfo (crossPlatformRunOnlyInRunTime);\n\t\t\t\tDrawInNodeInfo (makeSureCrossPlatformImported);" +
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"#if CROSS_PLATFORM_INPUT\n" +
					"\t\t\t\tfloatValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetAxisRaw (stringValues [0]);\n" + 
					"#else\n" +
					"\t\t\t\tfloatValue = Input.GetAxisRaw (stringValues [0]);\n" +
					"#endif\n",
					InOutWs.OutWs.float_,
					ExprWs.Gv.floatValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns the value of the virtual axis identified by axisName ",
						"with no smoothing filtering applied.",
						"The value will be in the range -1...1 for keyboard and joystick input. ",
						"Since input is not smoothed, keyboard input will always be either -1, 0 or 1. ",
						"This is useful if you want to do all smoothing of keyboard input processing yourself.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetAxisRaw.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetAxisRawNoCrossPlatform.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"\t\t\t\tfloatValue = Input.GetAxisRaw (stringValues [0]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.floatValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns the value of the virtual axis identified by axisName ",
						"with no smoothing filtering applied.",
						"The value will be in the range -1...1 for keyboard and joystick input. ",
						"Since input is not smoothed, keyboard input will always be either -1, 0 or 1. ",
						"This is useful if you want to do all smoothing of keyboard input processing yourself.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetAxisRaw.html",
					""),


				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetAxis.ToString (),
					"\t\t\t\tDrawInNodeInfo (crossPlatformRunOnlyInRunTime);\n\t\t\t\tDrawInNodeInfo (makeSureCrossPlatformImported);" +
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"#if CROSS_PLATFORM_INPUT\n" +
					"\t\t\t\t\tfloatValue = UnityStandardAssets.CrossPlatformInput.CrossPlatformInputManager.GetAxis " +
					"(stringValues [0]);\n" +
					"#else\n" +
					"\t\t\t\t\tfloatValue = Input.GetAxis (stringValues [0]);\n" +
					"#endif\n",
					InOutWs.OutWs.float_,
					ExprWs.Gv.floatValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns the value of the virtual axis identified by axisName.",
						"The value will be in the range -1...1 for keyboard and joystick input. ",
						"If the axis is setup to be delta mouse movement, ",
						"the mouse delta is multiplied by the axis sensitivity and the range is not -1...1.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetAxis.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetAxisNoCrossPlatform.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Axis Name\");\n" + 
					InOutWs.InWs._string + ret + InOutWs.InWs.CheckAxisNameSetup,
					"\t\t\t\t\tfloatValue = Input.GetAxis (stringValues [0]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.floatValue + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns the value of the virtual axis identified by axisName.",
						"The value will be in the range -1...1 for keyboard and joystick input. ",
						"If the axis is setup to be delta mouse movement, ",
						"the mouse delta is multiplied by the axis sensitivity and the range is not -1...1.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetAxis.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetAccelerationEventDeltaTime.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tfloatValue = Input.GetAccelerationEvent (intValues [0]).deltaTime;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.floatValue + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns specific acceleration measurement which ",
						"occurred during last frame.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetAccelerationEvent.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.GetAccelerationEventAcceleration.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tvector3Value = Input.GetAccelerationEvent (intValues [0]).acceleration;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.vector3Value + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns specific acceleration measurement which ",
						"occurred during last frame.",
					},
					"https://docs.unity3d.com/ScriptReference/Input.GetAccelerationEvent.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.deviceOrientation.ToString (),
					"",
					"\t\t\t\tstringValue = Input.deviceOrientation.ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.stringValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Describes physical orientation of the device as determined by the OS.",
					},
					"https://docs.unity3d.com/ScriptReference/DeviceOrientation.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.compositionString.ToString (),
					"",
					"\t\t\t\tstringValue = Input.compositionString;",
					InOutWs.OutWs.string_,
					ExprWs.Gv.stringValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"The current IME composition string being typed by the user.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-compositionString.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.compass.ToString (),
					"",
					"\t\t\t\tboolValue = Input.compass.enabled;\n\t\t\t\n\t\t\t\tvector4Value = new Vector4 (\n\t\t\t\t\tInput.compass.headingAccuracy,\n\t\t\t\t\tInput.compass.magneticHeading,\n\t\t\t\t\tInput.compass.trueHeading,\n\t\t\t\t\t(float)Input.compass.timestamp);\n\n\t\t\t\tvector3Value = Input.compass.rawVector;\n",
					"\t\t\t\tDrawLogicNodeLabel (\"Enabled\");\n" +
					InOutWs.OutWs.bool_ +
					"\t\t\t\tDrawLogicNodeLabel (\"headingAccuracy -> x\");\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"magneticHeading -> y\");\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"trueHeading -> z\");\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"(float)timestamp -> w\");\n" +
					InOutWs.OutWs.vector4_ +
					"\t\t\t\tDrawLogicNodeLabel (\"rawVector\");\n" +
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.boolValue + ExprWs.Gv.vector3Value + ExprWs.Gv.vector4Value,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Interface into compass functionality.",
					},
					"https://docs.unity3d.com/ScriptReference/Compass.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.anyKeyDown.ToString (),
					"",
					"boolValue = Input.anyKeyDown;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns true the first frame the user hits any key or mouse button. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-anyKeyDown.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.anyKey.ToString (),
					"",
					"\t\t\t\tboolValue = Input.anyKey;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.boolValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Is any key or mouse button currently held down? (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-anyKey.html",
					""),




				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.accelerationEventsDeltaTimes.ToString (),
					"",
					"\t\t\t\taccelerationEvents = Input.accelerationEvents;\n\n\t\t\t\tfloatsListValue = new List<float> ();\n\n\t\t\t\tfor (int i = 0; i < accelerationEvents.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloatsListValue.Add (accelerationEvents [i].deltaTime);\n\t\t\t\t}\n",
					InOutWs.OutWs.floatsList_,
					ExprWs.Gv.floatsListValue + ExprWs.Gv.accelerationEvents,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns list of acceleration measurements which",
						"occurred during the last frame. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-accelerationEvents.html",
					""),



				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.accelerationEventsAccelerations.ToString (),
					"",
					"\t\t\t\taccelerationEvents = Input.accelerationEvents;\n\n\t\t\t\tvector3ListValue = new List<Vector3> ();\n\n\t\t\t\tfor (int i = 0; i < accelerationEvents.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tvector3ListValue.Add (accelerationEvents [i].acceleration);\n\t\t\t\t}\n",
					InOutWs.OutWs.vector3List_,
					ExprWs.Gv.vector3ListValue + ExprWs.Gv.accelerationEvents,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Returns list of acceleration measurements which",
						"occurred during the last frame. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-accelerationEvents.html",
					""),


				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.accelerationEventCount.ToString (),
					"",
					"\t\t\t\tintValue = Input.accelerationEventCount;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.intValue,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Number of acceleration measurements which occurred during last frame.",
					},
					"https://docs.unity3d.com/ScriptReference/Input-accelerationEventCount.html",
					""),

				new EnumInputComputeOutput (
					ComputeUnityInputClassAndCrossPlatformType.acceleration.ToString (),
					"",
					"\t\t\t\tvector3Value = Input.acceleration;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.vector3Value,
					"",
					ExprWs.UMDecl.computeUnityInputClassAndCrossPlatform,
					new string []
					{
						"",
						"Last measured linear acceleration of a device in three-dimensional space. (Read Only)",
					},
					"https://docs.unity3d.com/ScriptReference/Input-acceleration.html",
					""),
			};
		}

		void Loop ()
		{
			if (intValues [0] == intValues [1])
			{
				intValue = intValues [0];
			}
			else if (intValues [0] < intValues [1])
			{
				intValue = Mathf.Clamp (intValue, intValues [0], intValues [1]);

				intValue++;

				if (intValue >= intValues [1])
				{
					intValue = intValues [0];
				}
			}
			else if (intValues [0] > intValues [1])
			{
				intValue = Mathf.Clamp (intValue, intValues [1], intValues [0]);

				intValue--;

				if (intValue <= intValues [1])
				{
					intValue = intValues [0];
				}
			}
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_Int ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeIntType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondIntNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._int + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "intValue = MezanixDiamondGetInt (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveInt(stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.int_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetInt + ExprWs.UMDecl.MezanixDiamondRemoveInt +
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._int + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetInt (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.intValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.IntValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetInt + ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),
				


				new EnumInputComputeOutput (
					ComputeIntType.loop.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Loop from\");\n" +
					InOutWs.InWs._int +
					"\t\t\t\tDrawLogicNodeLabel (\"Loop to (excluded)\");\n" +
					InOutWs.InWs._int_1,
					"\t\t\t\tLoop ();",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					"\t\tvoid Loop ()\n\t\t{\n\t\t\tif (intValues [0] == intValues [1])\n\t\t\t{\n\t\t\t\tintValue = intValues [0];\n\t\t\t}\n\t\t\telse if (intValues [0] < intValues [1])\n\t\t\t{\n\t\t\t\tintValue = Mathf.Clamp (intValue, intValues [0], intValues [1]);\n\n\t\t\t\tintValue++;\n\n\t\t\t\tif (intValue >= intValues [1])\n\t\t\t\t{\n\t\t\t\t\tintValue = intValues [0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (intValues [0] > intValues [1])\n\t\t\t{\n\t\t\t\tintValue = Mathf.Clamp (intValue, intValues [1], intValues [0]);\n\n\t\t\t\tintValue--;\n\n\t\t\t\tif (intValue <= intValues [1])\n\t\t\t\t{\n\t\t\t\t\tintValue = intValues [0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n" +
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Loop from the first to the second value.",
						"No matter if 'from' is greater or smaller than 'to',",
						"the loop can go in 2 directions",
					},
					"",
					""),



				new EnumInputComputeOutput (
					ComputeIntType.MultiplicativeInverse.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tif (intValues [0] != 0)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = 1f / (float)intValues [0];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfloatValue = (float)intValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Multiplicative Inverse (One over) of the int value.",
						"The result type is float.",
						"If the int value is zero, ",
						"the result will be a zero of type float.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.modulo.ToString (),
					InOutWs.InWs._int_and_1,
					"\t\t\t\tif (intValues [1] != 0)\n\t\t\t\t{\n\t\t\t\t\tintValue = intValues [0] % intValues [1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tintValue = intValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Compute the remainder after dividing the first int by the second one.",
						"If the second one is zero, the first int will be the result.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.multiplyWithVector4.ToString (),
					InOutWs.InWs._int + 
					"\t\t\t\tDrawLogicNodeLabel (\"Vector4 Value\");\n" +
					InOutWs.InWs._vector4,
					tab4 + "vector4Value = (float)intValues [0] * vector4Values [0];",
					InOutWs.OutWs.vector4_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.vector4All,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.Vector4Values (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Multiply an integere with an Vector4 and have result of type Vector4",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.multiplyWithVector3.ToString (),
					InOutWs.InWs._int + 
					"\t\t\t\tDrawLogicNodeLabel (\"Vector3 Value\");\n" +
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = (float)intValues [0] * vector3Values [0];",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.vector3All,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Multiply an integere with an Vector3 and have result of type Vector3",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.multiplyWithVector2.ToString (),
					InOutWs.InWs._int + 
					"\t\t\t\tDrawLogicNodeLabel (\"Vector2 Value\");\n" +
					InOutWs.InWs._vector2,
					tab4 + "vector2Value = (float)intValues [0] * vector2Values [0];",
					InOutWs.OutWs.vector2_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.vector2All,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.Vector2Values (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Multiply an integere with an Vector2 and have result of type Vector2",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.multiplyWithFloatOutInt.ToString (),
					InOutWs.InWs._int + 
					"\t\t\t\tDrawLogicNodeLabel (\"Float Value\");\n" +
					InOutWs.InWs._float,
					tab4 + "intValue = (int)((float)intValues [0] * floatValues [0]);",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Multiply an integere with a float and have result of type int",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeIntType.multiplyWithFloatOutFloat.ToString (),
					InOutWs.InWs._int + 
					"\t\t\t\tDrawLogicNodeLabel (\"Float Value\");\n" +
					InOutWs.InWs._float,
					tab4 + "floatValue = (float)intValues [0] * floatValues [0];",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Multiply an integere with a float and have result of type float",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.max.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "intValue = Mathf.Max (intValues [0], intValues [1]);",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Returns the largest of two values",
					},
					"https://docs.unity3d.com/ScriptReference/Mathf.Max.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeIntType.min.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "intValue = Mathf.Min (intValues [0], intValues [1]);",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Returns the smallest of two values",
					},
					"https://docs.unity3d.com/ScriptReference/Mathf.Min.html",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.incrementStaticWithInit.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Init?\");\n" +
					InOutWs.InWs._bool +
					"\t\t\t\tDrawLogicNodeLabel (\"Initial Value\");\n" +
					InOutWs.InWs._int_1 +
					"\t\t\t\tDrawLogicNodeLabel (\"Increment amount\");\n" +
					InOutWs.InWs._int,
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n\t\t\t\t\tintStatic = intValues [1];\n\t\t\t\t}\n" +
					"\t\t\t\tintStatic += intValues [0];\n" +
					"\t\t\t\tintValue = intStatic;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll + "\t\tstatic int intStatic;\n" + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{						
						"",
						"If DoIT enabled, increment the result value by the increment amount",
						"If the Init field is true, the result value will be reset to the initial value",
						"This is a static version of the increment node, you use it when you want", 
						"To prevent your incremented value from being intitialized,",
						"because in the dynamic version of the incriment node, your incremented value",
						"could be initialized if the game object holding the generated script is destroyed",
						"or if an another object having tha same script on it is spawned in the scene.",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeIntType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_int_DrawInputs ();",
					"\t\t\t\tForGet_int_Compute ();",
					"\t\t\t\tForGet_int_DrawOutputs ();",
					ExprWs.Gv.intAll + 
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.IntValue (this) +
					ExprWs.ConstructorExpr.IntValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_int_Compute +
					ExprWs.UMDecl.computeInt_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeIntType.or.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "intValue = intValues [0] | intValues [1];",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Perform or operator on two integer",
						"It is useful for combining layermasks",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.shiftOperatorOfOne.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Shifting amount\");" + ret +
					InOutWs.InWs._int + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Inverse it\");" + ret + 
					InOutWs.InWs._bool,
					"\t\t\t\tif ( ! boolValues [0])\n\t\t\t\t{\n\t\t\t\t\tintValue = 1 << intValues [0];\n" +
					"\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tintValue = ~(1 << intValues [0]);\n\t\t\t\t}",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Get the corresponding integer of a 1 shifted in binary, you can get also its binary inverse",
						"This is useful to use for defining layermasks",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeIntType.incrementStatic.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tintStatic += intValues [0];\n" +
					"\t\t\t\tintValue = intStatic;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll + "\t\tstatic int intStatic;\n",
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{						"",
						"If DoIT enabled, increment the result value by the amount of the first one.",
						"This is the static version of the increment node, you use it when you want", 
						"To prevent your incremented value from being intitialized,",
						"because in the dynamic version of the incriment node, your incremented value",
						"could be initialized if the game object holding the generated script is destroyed",
						"or if an another object having tha same script on it is spawned in the scene.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.increment.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "intValue = intValues [0] + intValues [1];" + ret +
					tab4 + "intValues [0] = intValue;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"If DoIT enabled, increment the first value by the amount of the second one.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.Switch.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Want this value?\");" + ret +
					InOutWs.InWs._bool + ret +
					InOutWs.InWs._int + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Or this One?\");" + ret +
					InOutWs.InWs._bool_1 + ret +
					InOutWs.InWs._int_1,
					"\t\t\t\tif (boolValues [0] && ! boolValues [1])\n\t\t\t\t{\n" +
					"\t\t\t\t\tintValue = intValues [0];\n\t\t\t\t}\n" +
					"\t\t\t\tif (boolValues [1] && ! boolValues [0])\n" +
					"\t\t\t\t{\n\t\t\t\t\tintValue = intValues [1];\n\t\t\t\t}\n",		
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Get the value corresponding of the checked box,",
						"if noth boxes have the same value, the node will not compute",
						"and it will conserve it's old output",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.readItFromPlayerPrefs.ToString (),
					"\n\t\t\t\tDrawLogicNodeLabel (\"With key\");\n" +
					InOutWs.InWs._string, 
					tab4 + "intValue = PlayerPrefs.GetInt (stringValues [0]);",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.intValue,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Returns the value corresponding to key in the preference file if it exists.",
					},
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.GetInt.html",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.saveItInPlayerPrefs.ToString (),
					tab4 + InOutWs.InWs._int + "\n\t\t\t\tDrawLogicNodeLabel (\"With key\");\n" +
					InOutWs.InWs._string, 
					tab4 + "PlayerPrefs.SetInt (stringValues [0], intValues [0]);" + 
					"\n\t\t\t\tPlayerPrefs.Save ();",
					"",
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.IntValues (this) + ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Sets the value of the preference identified by key.",
					},
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.SetInt.html",
					""),


				new EnumInputComputeOutput (
					ComputeIntType.isEqualTo.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "boolValue = intValues [0] == intValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Returns true if the first value is equal to the second one, false otherwise",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeIntType.isNotEqualTo.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "boolValue = intValues [0] != intValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Returns true if the first value is not equal to the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.isGreaterThan.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "boolValue = intValues [0] > intValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Returns true if the first value is greater than the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.isGreaterOrEqualThan.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "boolValue = intValues [0] >= intValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Returns true if the first value is greater or equal than the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.isSmallerOrEqualThan.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "boolValue = intValues [0] <= intValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Returns true if the first value is smaller or equal than the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.isSmallerThan.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "boolValue = intValues [0] < intValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Returns true if the first value is smaller than the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.toString.ToString (),
					InOutWs.InWs._int,
					tab4 + "stringValue = intValues [0].ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.intValues + ExprWs.Gv.stringValue,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Get a string (phrase) version of the number",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.subtract.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "intValue = intValues [0] - intValues [1];",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Subtract two integer values",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.random.ToString (),
					InOutWs.InWs._int_and_1,
					"\t\t\t\tintValue = UnityEngine.Random.Range (intValues [0], intValues [1]);\n",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this) + 
					ExprWs.ConstructorExpr.unityEngineRandomInitState,
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"Returns a random integer number between min [inclusive] and",
						"max [exclusive] (Read Only).",
						"Note that max is exclusive, so using Random.Range( 0, 10 )",
						"will return values between 0 and 9. If max equals min, min will",
						"be returned.",
					},
					"https://docs.unity3d.com/ScriptReference/Random.Range.html",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.multiply.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "intValue = intValues [0] * intValues [1];",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Multiply two integere values",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.divide.ToString (),
					InOutWs.InWs._int_and_1,
					"\t\t\t\tif (intValues [1] == 0)\n\t\t\t\t{\n\t\t\t\t\tintValue = intValues [0];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tintValue = intValues [0] / intValues [1];\n\t\t\t\t}",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Divide the first integere by the second",
						"If the second integer is zero, the node returns the first value",
						"Note that divide with integeres gives rounded values.",
						"To obtain decimale precision use divide on float variable type",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.clamp.ToString (),
					InOutWs.InWs._int_all,
					tab4 + "intValue = Mathf.Clamp (intValues [0], intValues [1], intValues [2]);",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Clamp the first value by the second and the third values",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeIntType.add.ToString (),
					InOutWs.InWs._int_and_1,
					tab4 + "intValue = intValues [0] + intValues [1];",
					InOutWs.OutWs.int_,
					ExprWs.Gv.doIt + ExprWs.Gv.intAll,
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.computeInt,
					new string []
					{
						"",
						"Add two integer values",
					},
					"",
					""),
			};
		}

		//IEnumerator RunAnimationCurve_color ()
		//{
		//	if ( ! boolValues [0])
		//	{
		//		boolValues [0] = true;
		//
		//		float t = 0f;
		//
		//		float rate = 1f / floatValues [2];
		//
		//		while (t < 1f)
		//		{
		//			t += Time.deltaTime * rate;
		//
		//			colorValue = Color.Lerp (colorValues [0], colorValues [1], animationCurve_.Evaluate (t));
		//
		//			yield return 0;
		//		}
		//
		//		boolValues [0] = false;
		//	}
		//	yield return 0;
		//}


		EnumInputComputeOutput [] EnumInputComputeOutput_Color ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeColorType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondColorNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._color + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\tcolorValue = MezanixDiamondGetColor (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\tMezanixDiamondRemoveColor (stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.color_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.colorAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.ColorValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetColor + ExprWs.UMDecl.MezanixDiamondRemoveColor +
					ExprWs.UMDecl.computeColorNoPreparation,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._color + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetColor (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.colorValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetColor + ExprWs.UMDecl.computeColorNoPreparation,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeColorType.toString.ToString (),
					InOutWs.InWs._color,
					"\t\t\t\tstringValue = colorValues [0].ToString ();\n",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorValues + ExprWs.Gv.stringValue,
					ExprWs.ConstructorExpr.ColorValues (this),
					ExprWs.UMDecl.computeColorNoPreparation,
					new string []
					{
						"",
						"Output the string expression of the color",
						"(r, g, b, a)",
						"color values in unity C# are normalized ",
						"between 0 and 1",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.vividLight.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.VividLight (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The vividLight blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.Switch.ToString (),
					InOutWs.InWs._bool + ret + InOutWs.InWs._color + ret +
					InOutWs.InWs._bool_1 + ret + InOutWs.InWs._color_1,
					"\t\t\t\tif (boolValues [0] && ! boolValues [1])\n\t\t\t\t{\n" +
					"\t\t\t\t\tcolorValue = colorValues [0];\n" +
					"\t\t\t\t}\n\t\t\t\tif (boolValues [1] && ! boolValues [0])\n" +
					"\t\t\t\t{\n\t\t\t\t\tcolorValue = colorValues [1];\n\t\t\t\t}",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.computeColorNoPreparation,
					new string []
					{
						"",
						"Get the value corresponding of the checked box,",
						"if noth boxes have the same value, the node will not compute",
						"and it will conserve it's old output",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.subtract.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Subtract (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The subtract blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.softLight.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.SoftLight (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The softLight blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.screen.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Screen (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The screen blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.saturation.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Saturation (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The saturation blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.randomHsv.ToString (),
					InOutWs.InWs._color_and_1_OpacityLabel,
					"\t\t\t\tcolorValue = UnityEngine.Random.ColorHSV (\n" +
					"\t\t\t\t\tColorsArithmetic.RGBToHSV (colorValues [0]) [0], ColorsArithmetic.RGBToHSV (colorValues [1]) [0],\n" +
					"\t\t\t\t\tColorsArithmetic.RGBToHSV (colorValues [0]) [1], ColorsArithmetic.RGBToHSV (colorValues [1]) [1],\n" +
					"\t\t\t\t\tColorsArithmetic.RGBToHSV (colorValues [0]) [2], ColorsArithmetic.RGBToHSV (colorValues [1]) [2]);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll,
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.computeColorNoPreparation,
					new string []
					{
						"",
						"Generates a random color from HSV and alpha ranges.",
						"The 2 input colors are used as min and max for the random",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.pinLight.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.PinLight (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The pinLight blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.overlay.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Overlay (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The overlay blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.multiply.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Multiply (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The multiply blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.luminosity.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Luminosity (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The Luminosity blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.linearLight.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearLight (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The LinearLight blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.linearDodge.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearDodge (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The LinearDodge blend mode",
					},
					"",
					""),
				

				new EnumInputComputeOutput (
					ComputeColorType.linearBurn.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearBurn (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The LinearBurn blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.lighten.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Lighten (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The Lighten blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.hue.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Hue (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The Hue blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.hardMix.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardMix (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The HardMix blend mode",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeColorType.hardLight.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardLight (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The HardLight blend mode",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeColorType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_color_DrawInputs ();",
					"\t\t\t\tForGet_color_Compute ();",
					"\t\t\t\tForGet_color_DrawOutputs ();",
					ExprWs.Gv.colorAll + 
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.ColorValue (this) +
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_color_Compute +
					ExprWs.UMDecl.computeColorNoPreparation_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.exclusion.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Exclusion (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The Exclusion blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.difference.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Difference (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The Difference blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.darken.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Darken (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The Darken blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.colorDodge.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorDodge (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The color dodge blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.colorBurn.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorBurn (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The color burn blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.color.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Color_ (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The 'Color' color blend mode",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.animationCurvePickValue.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._color + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._color_1 +
					"\t\t\t\tDrawLogicNodeLabel (\"Pick curve value of this time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);\n",
					"\t\t\t\tcolorValue = Color.Lerp (colorValues [0], colorValues [1], animationCurve_.Evaluate (floatValues [2]));",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve +
					ExprWs.Gv.colorAll ,
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this) + ExprWs.ConstructorExpr.AnimationCurve (this),
					ExprWs.UMDecl.computeColorNoPreparation,
					new string []
					{
						"",
						"Pick a color value on a curve,",
						"between the start and the end value.",
						"You have to choose the time corresponding to your value",
						"The time is the horizontal axis of the curve.",
						"The 'picked' color, the start and the end colors are on the",
						"vertical axis of the curve",
						"",
						"About the horizontal axis:",
						"This axis is commonly called time, but in the case of this node",
						"it is an axis having values from 0 to 1 (normalized),",
						"so this node is usful for drawing any curves shape and 'picking'",
						"a color value (vertical axis) on the curve corresponding of any",
						"position in the horizontal axis, 0 is the left of the horizontal axis,",
						"1 is its right and between them is a value on the axis.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeColorType.animationCurve.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._color + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._color_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve animation time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Max (0.1f, floatValues [2]);\n",
					"\t\t\t\t" + CsScriptWriter.FromLogicNodeToMonoBehaviour (logic.node.graph, logic.node, logic) + "." +
					"StartCoroutine (RunAnimationCurve_color ());",
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve + ExprWs.Gv.boolValues + 
					ExprWs.Gv.colorAll,
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tboolValues [0] = false;\n" + 
					ExprWs.ConstructorExpr.AnimationCurve (this) + ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					"\t\tIEnumerator RunAnimationCurve_color ()\n\t\t{\n\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tboolValues [0] = true;\n\n\t\t\t\tfloat t = 0f;\n\n\t\t\t\tfloat rate = 1f / floatValues [2];\n\n\t\t\t\twhile (t < 1f)\n\t\t\t\t{\n\t\t\t\t\tt += Time.deltaTime * rate;\n\n\t\t\t\t\tcolorValue = Color.Lerp (colorValues [0], colorValues [1], animationCurve_.Evaluate (t));\n\n\t\t\t\t\tyield return 0;\n\t\t\t\t}\n\n\t\t\t\tboolValues [0] = false;\n\t\t\t}\n\t\t\tyield return 0;\n\t\t}\n\n" +
					ExprWs.UMDecl.computeColorNoPreparation,
					new string []
					{
						"",
						"Animate a color on a curve,",
						"between the start and the end value.",
						"You have to define the animation time (duration).",
						"The time is the horizontal axis of the curve.",
						"The animated color, the start and the end colors are on the",
						"vertical axis of the curve",
					},
					"",
					""),
				
				new EnumInputComputeOutput (
					ComputeColorType.add.ToString (),
					InOutWs.InWs._color_and_1_OpacityNumber,
					"\t\t\t\tPrepareToColorCompute (ref c0, ref o, ref o1, ref cm1, ref c1o); \n" +
					"\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Add (c0, c1o), c1o, o);",
					InOutWs.OutWs.color_,
					ExprWs.Gv.doIt + ExprWs.Gv.colorAll + ExprWs.Gv.floatValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.ColorValues (this) +
					ExprWs.ConstructorExpr.ColorValue (this),
					ExprWs.UMDecl.colorArithmetic + ExprWs.UMDecl.prepareToColorCompute_computeColor,
					new string []
					{
						"",
						"The Add color blend mode",
					},
					"",
					""),
			};
		}

		//IEnumerator RunAnimationCurve_float ()
		//{
		//	if ( ! boolValues [0])
		//	{
		//		boolValues [0] = true;
		//
		//		float t = 0f;
		//
		//		float rate = 1f / floatValues [2];
		//
		//		while (t < 1f)
		//		{
		//			t += Time.deltaTime * rate;
		//
		//			floatValue = Mathf.Lerp (floatValues [0], floatValues [1], animationCurve_.Evaluate (t));
		//
		//			yield return 0;
		//		}
		//
		//		boolValues [0] = false;
		//	}
		//	yield return 0;
		//}

		EnumInputComputeOutput [] EnumInputComputeOutput_Float ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeFloatType.listenToTransferredData.ToString (),
					"\t\t\t\tDrawStringListMenuToString_0 (\"Data Name\", " +
					"MezanixDiamondFloatNames (), noTransferredDataFound);\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Default value\");\n" +
					InOutWs.InWs._float + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Consume the data?\");\n" +
					InOutWs.InWs._bool + ret,
					"\t\t\t\t" + "floatValue = MezanixDiamondGetFloat (stringValues [0]);\n" +
					"\t\t\t\tif (boolValues [0])\n\t\t\t\t{\n" +
					"\t\t\t\t\t" + "MezanixDiamondRemoveFloat(stringValues [0]);\n\t\t\t\t}",
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n
					InOutWs.OutWs.float_,
					ExprWs.Gv.stringValues + ExprWs.Gv.boolValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.BoolValues (this) + 
					ExprWs.ConstructorExpr.mddtGameObjectHolder + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondGetFloat + ExprWs.UMDecl.MezanixDiamondRemoveFloat +
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Listen to (read) a value by its name.",
						"If you want to read this value at this moment",
						"and no need to read it later, it's recommended",
						"to consume it.",
						"",
						"If the transferred data is not found,",
						"the default value will be used",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.sendMeAsTransferredData.ToString (),
					"DrawLogicNodeLabel (\"Data Name\");\n" +
					InOutWs.InWs._string + ret +
					"DrawLogicNodeLabel (\"Data Value to transfer\");\n" +
					InOutWs.InWs._float + ret +
					"\t\t\t\tDrawInNodeInfo (\"Play logic, name data, click doIT\");\n",
					"\t\t\t\tMezanixDiamondSetFloat (stringValues [0]);\n", 
					//"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" + 
					"",
					ExprWs.Gv.stringValues + ExprWs.Gv.floatValues + ExprWs.Gv.doIt +
					ExprWs.Gv.mddtGameObjectHolder,
					ExprWs.ConstructorExpr.StringValues (this) + ExprWs.ConstructorExpr.FloattValues (this) +
					ExprWs.ConstructorExpr.mddtGameObjectHolder,
					ExprWs.UMDecl.getmddt +
					ExprWs.UMDecl.MezanixDiamondSetFloat + ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Send a value by its name. The name can be used",
						"by another graph (script) to listen to (read) this value.",
					},
					"",
					""),



				new EnumInputComputeOutput (
					ComputeFloatType.animationCurvePickValue.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._float + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._float_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Pick curve value of this time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Clamp (floatValues [2], 0f, 1f);\n",
					"\t\t\t\tfloatValue = Mathf.Lerp (floatValues [0], floatValues [1], animationCurve_.Evaluate (floatValues [2]));",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll + ExprWs.Gv.animationCurve,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.AnimationCurve (this) +
					ExprWs.ConstructorExpr.FloattValue (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Pick a float value on a curve,",
						"between the start and the end value.",
						"You have to choose the time corresponding to your value",
						"The time is the horizontal axis of the curve.",
						"The picked float, the start and the end floats are on the",
						"vertical axis of the curve",
						"",
						"About the horizontal axis:",
						"This axis is commonly called time, but in the case of this node",
						"it is an axis having values from 0 to 1 (normalized),",
						"so this node is usful for drawing any curves shape and picking",
						"a float value (vertical axis) on the curve corresponding of any",
						"position in the horizontal axis, 0 is the left of the horizontal axis,",
						"1 is its right and between them is a value on the axis.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.animationCurve.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._float + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._float_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve animation time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Max (0.1f, floatValues [2]);\n",
					"\t\t\t\t" + CsScriptWriter.FromLogicNodeToMonoBehaviour (logic.node.graph, logic.node, logic) + "." +
					"StartCoroutine (RunAnimationCurve_float ());",
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll + ExprWs.Gv.animationCurve + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tboolValues [0] = false;\n" + 
					ExprWs.ConstructorExpr.AnimationCurve (this) +
					ExprWs.ConstructorExpr.FloattValue (this),
					"\t\tIEnumerator RunAnimationCurve_float ()\n\t\t{\n\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tboolValues [0] = true;\n\n\t\t\t\tfloat t = 0f;\n\n\t\t\t\tfloat rate = 1f / floatValues [2];\n\n\t\t\t\twhile (t < 1f)\n\t\t\t\t{\n\t\t\t\t\tt += Time.deltaTime * rate;\n\n\t\t\t\t\tfloatValue = Mathf.Lerp (floatValues [0], floatValues [1], animationCurve_.Evaluate (t));\n\n\t\t\t\t\tyield return 0;\n\t\t\t\t}\n\n\t\t\t\tboolValues [0] = false;\n\t\t\t}\n\t\t\tyield return 0;\n\t\t}\n" +
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Animate a float value on a curve,",
						"between the start and the end value.",
						"You have to define the animation time (duration).",
						"The time is the horizontal axis of the curve.",
						"The animated float, the start and the end floats are on the",
						"vertical axis of the curve",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.MultiplicativeInverse.ToString (),
					InOutWs.InWs._float,
					"\t\t\t\tif (floatValues [0] != 0f)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = 1f / floatValues [0];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfloatValue = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Multiplicative Inverse (One over) of the float value.",
						"The result type is float.",
						"If the float value is zero, ",
						"the result will be a zero of type float.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.modulo.ToString (),
					InOutWs.InWs._float_and_1,
					"\t\t\t\tif (floatValues [1] != 0f)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = floatValues [0] % floatValues [1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfloatValue = floatValues [0];\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Compute the remainder after dividing the first float by the second one.",
						"If the second one is zero, the first float will be the result.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.max.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "floatValue = Mathf.Max (floatValues [0], floatValues [1]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Returns the largest of two values",
					},
					"https://docs.unity3d.com/ScriptReference/Mathf.Max.html",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.min.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "floatValue = Mathf.Min (floatValues [0], floatValues [1]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Returns the smallest of two values",
					},
					"https://docs.unity3d.com/ScriptReference/Mathf.Min.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeFloatType.get.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Get from input\");" + "\n" +
					InOutWs.InWs._bool + "\n" +
					"\t\t\t\tForGet_float_DrawInputs ();",
					"\t\t\t\tForGet_float_Compute ();",
					"\t\t\t\tForGet_float_DrawOutputs ();",
					ExprWs.Gv.floatAll + 
					ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.FloattValue (this) +
					ExprWs.ConstructorExpr.FloattValues (this) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.ForGet_float_Compute +
					ExprWs.UMDecl.computeFloat_NoDoIt,
					new string []
					{
						"",
						"Get this",
						"",
						"If you choose 'Get from input'",
						"you can get from the input list that",
						"is turnable to public, so it can appear",
						"in the inspector of the game object holding",
						"the genrated script",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.Switch.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Want this value?\");" + ret +
					InOutWs.InWs._bool + ret +
					InOutWs.InWs._float + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Or this One?\");" + ret +
					InOutWs.InWs._bool_1 + ret +
					InOutWs.InWs._float_1,
					"\t\t\t\tif (boolValues [0] && ! boolValues [1])\n" +
					"\t\t\t\t{\n\t\t\t\t\tfloatValue = floatValues [0];\n" +
					"\t\t\t\t}\n\t\t\t\tif (boolValues [1] && ! boolValues [0])\n" +
					"\t\t\t\t{\n\t\t\t\t\tfloatValue = floatValues [1];\n\t\t\t\t}\n",		
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll + ExprWs.Gv.boolValues,
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Get the value corresponding of the checked box,",
						"if noth boxes have the same value, the node will not compute",
						"and it will conserve it's old output",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.readItFromPlayerPrefs.ToString (),
					"\n\t\t\t\tDrawLogicNodeLabel (\"With key\");\n" +
					InOutWs.InWs._string, 
					tab4 + "floatValue = PlayerPrefs.GetFloat (stringValues [0]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.stringValues + ExprWs.Gv.floatValue,
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Returns the value corresponding to key in the preference file if it exists.",
					},
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.GetFloat.html",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.saveItInPlayerPrefs.ToString (),
					tab4 + InOutWs.InWs._float + "\n\t\t\t\tDrawLogicNodeLabel (\"With key\");\n" +
					InOutWs.InWs._string, 
					tab4 + "PlayerPrefs.SetFloat (stringValues [0], floatValues [0]);" + 
					"\n\t\t\t\tPlayerPrefs.Save ();",
					"",
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.stringValues,
					ExprWs.ConstructorExpr.FloattValues (this) + ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Sets the value of the preference identified by key.",
					},
					"https://docs.unity3d.com/ScriptReference/PlayerPrefs.SetFloat.html",
					""),


				new EnumInputComputeOutput (
					ComputeFloatType.isEqualTo.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "boolValue = floatValues [0] == floatValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Returns true if the first value is equal to the second one, false otherwise",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeFloatType.isNotEqualTo.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "boolValue = floatValues [0] != floatValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Returns true if the first value is not equal to the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.isGreaterThan.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "boolValue = floatValues [0] > floatValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Returns true if the first value is greater than the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.isGreaterOrEqualThan.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "boolValue = floatValues [0] >= floatValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Returns true if the first value is greater or equal than the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.isSmallerOrEqualThan.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "boolValue = floatValues [0] <= floatValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Returns true if the first value is smaller or equal than the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.isSmallerThan.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "boolValue = floatValues [0] < floatValues [1];",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.boolValue,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Returns true if the first value is smaller than the second one, false otherwise",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.toString.ToString (),
					InOutWs.InWs._float,
					tab4 + "stringValue = floatValues [0].ToString ();",
					InOutWs.OutWs.string_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatValues + ExprWs.Gv.stringValue,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Get a string (phrase) version of the number",
					},
					"",
					""),


				new EnumInputComputeOutput (
					ComputeFloatType.repeat.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Value to Repeat\");\n" + 
					InOutWs.InWs._float + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"Length\");\n" + 
					InOutWs.InWs._float_1,
					tab4 + "floatValue = Mathf.Repeat (floatValues [0], floatValues [1]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Loops the value t, so that it is never larger than length and never smaller than 0.",
					},
					"https://docs.unity3d.com/ScriptReference/Mathf.Repeat.html",
					""),


				new EnumInputComputeOutput (
					ComputeFloatType.sigmoid.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Value to map between 0 and 1\");" + ret +
					InOutWs.InWs._float + ret +
					"\t\t\t\tDrawLogicNodeLabel (\"The Sigmoid speed, default 1\");" + ret +
					InOutWs.InWs._float_1 + ret + "\t\t\t\tfloatValues [1] = Mathf.Max (floatValues [1], 0f);\n",
					tab4 + "floatValue = 1f / (1f + Mathf.Exp ((-1f)*floatValues[0]*floatValues[1]));",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Every 'decimal' value is mapped to the zero : one interval.",
						"negative infinity mapped to zero, infinity mapped to One,",
						"and zero is mapped to 0.5",
						"Putting the Sigmoid speed to 0 will always return 0.5",
					},
					"",
					"http://mezanix.com/portfolio/sigmoid/"),

				new EnumInputComputeOutput (
					ComputeFloatType.subtract.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "floatValue = floatValues [0] - floatValues [1];",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Subtract two decimal values",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.random.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "floatValue = UnityEngine.Random.Range (floatValues [0], floatValues [1]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll + ExprWs.Gv.intValues,
					ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.IntValues (this) + 
					ExprWs.ConstructorExpr.unityEngineRandomInitState,
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"Returns a random float number between and min [inclusive] and max [inclusive]",
						"(Read Only).",
						"Note that max is inclusive, so using Random.Range( 0.0f, 1.0f )",
						"could return 1.0 as a value.",
					},
					"https://docs.unity3d.com/ScriptReference/Random.Range.html",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.multiply.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "floatValue = floatValues [0] * floatValues [1];",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Multiply two decimal values",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.divide.ToString (),
					InOutWs.InWs._float_and_1,
					"\t\t\t\tif (floatValues [1] == 0f)\n\t\t\t\t{\n\t\t\t\t\tfloatValue = floatValues [0];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfloatValue = floatValues [0] / floatValues [1];\n\t\t\t\t}",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Divide the first decimal by the second",
						"If the second decimal is zero, the node returns the first value",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.clamp.ToString (),
					InOutWs.InWs._float_all,
					tab4 + "floatValue = Mathf.Clamp (floatValues [0], floatValues [1], floatValues [2]);",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Clamp the first value by the second and the third values",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeFloatType.add.ToString (),
					InOutWs.InWs._float_and_1,
					tab4 + "floatValue = floatValues [0] + floatValues [1];",
					InOutWs.OutWs.float_,
					ExprWs.Gv.doIt + ExprWs.Gv.floatAll,
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.computeFloat,
					new string []
					{
						"",
						"Add two decimal values",
					},
					"",
					""),
			};
		}


		EnumInputComputeOutput [] EnumInputComputeOutput_AudioSource ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeAudioSourceType.UnPause.ToString (),
					"",
					tab4 + "audioSource_.UnPause ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Unpause the paused playback of this AudioSource.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource.UnPause.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.stop.ToString (),
					"",
					tab4 + "audioSource_.Stop ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Stops playing the clip.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource.Stop.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setVolume.ToString (),
					InOutWs.InWs._float,
					tab4 + "audioSource_.volume = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"The volume of the audio source (0.0 to 1.0).",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-volume.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setTime.ToString (),
					InOutWs.InWs._float,
					tab4 + "audioSource_.time = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"Playback position in seconds.",
						"Use this to read current playback time or to seek to a new playback time.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-time.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setSpatialize.ToString (),
					InOutWs.InWs._bool,
					tab4 + "audioSource_.spatialize = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Enables or disables spatialization.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-spatialize.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setSpatialBlend.ToString (),
					InOutWs.InWs._float,
					tab4 + "audioSource_.spatialBlend = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"Sets how much this AudioSource is affected by 3D spatialisation ",
						"calculations (attenuation, doppler etc).",
						" 0.0 makes the sound full 2D, 1.0 makes it full 3D.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-spatialBlend.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setPriority.ToString (),
					InOutWs.InWs._int,
					tab4 + "audioSource_.priority = intValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Sets the priority of the AudioSource.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-priority.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setPitch.ToString (),
					InOutWs.InWs._float,
					tab4 + "audioSource_.pitch = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"The pitch of the audio source.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-pitch.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setPanStereo.ToString (),
					InOutWs.InWs._float,
					tab4 + "audioSource_.panStereo = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Pans a playing sound in a stereo way (left or right). This only applies to sounds that are Mono or Stereo.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-panStereo.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setMute.ToString (),
					InOutWs.InWs._bool,
					tab4 + "audioSource_.mute = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Un- / Mutes the AudioSource. Mute sets the volume=0, Un-Mute restore the original volume.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-mute.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setMinDistance.ToString (),
					InOutWs.InWs._float,
					tab4 + "audioSource_.minDistance = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{						
						"Within the Min distance the AudioSource will cease to grow louder in volume.",
						"Outside the min distance the volume starts to attenuate.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-minDistance.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setMaxDistance.ToString (),
					InOutWs.InWs._float,
					tab4 + "audioSource_.maxDistance = floatValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"(Logarithmic rolloff) MaxDistance is the distance a sound stops attenuating at.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-maxDistance.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.setLoop.ToString (),
					InOutWs.InWs._bool,
					tab4 + "audioSource_.loop = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Is the audio clip looping?",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-loop.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.PlayScheduled.ToString (),
					"\t\t\t\tDrawDoubleInputField ();",
					tab4 + "audioSource_.PlayScheduled (doubleValue);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					"\t\tpublic double doubleValue = 0.0;\n\n",
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					"\t\t\tdoubleValue = " + doubleValue.ToString () + ";\n",
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Plays the clip at a specific time on the absolute time-line that AudioSettings.dspTime reads from.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.playOneShot.ToString (),
					"\t\t\t\tDrawAudioClipFieldInput_Local ();\n" + 
					"\t\t\t\tDrawLogicNodeLabel (\"Volume Scale\");\n" +
					InOutWs.InWs._float,
					"\t\t\t\tif (audioClipValue_Local != null)\n" +
					tab4 + "\taudioSource_.PlayOneShot (audioClipValue_Local, floatValues [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues + ExprWs.Gv.audioClip_local,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID, Enums.audioClip_LocalID}) + 
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Plays an AudioClip, and scales the AudioSource volume by volumeScale.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.PlayDelayed.ToString (),
					InOutWs.InWs._float,
					tab4 + "audioSource_.PlayDelayed (floatValues [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Plays the clip with a delay specified in seconds.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource.PlayDelayed.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.play.ToString (),
					"",
					tab4 + "audioSource_.Play ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Plays the clip.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource.Play.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.pause.ToString (),
					"",
					tab4 + "audioSource_.Pause ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Pauses playing the clip.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource.Pause.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getVolume.ToString (),
					"",
					tab4 + "floatValue = audioSource_.volume;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"The volume of the audio source (0.0 to 1.0).",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-volume.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getTime.ToString (),
					"",
					tab4 + "floatValue = audioSource_.time;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"Playback position in seconds.",
						"Use this to read current playback time or to seek to a new playback time.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-time.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getSpatialize.ToString (),
					"",
					tab4 + "boolValue = audioSource_.spatialize;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Enables or disables spatialization.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-spatialize.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getSpatialBlend.ToString (),
					"",
					tab4 + "floatValue = audioSource_.spatialBlend;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"Sets how much this AudioSource is affected by 3D spatialisation ",
						"calculations (attenuation, doppler etc).",
						" 0.0 makes the sound full 2D, 1.0 makes it full 3D.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-spatialBlend.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getPriority.ToString (),
					"",
					tab4 + "intValue = audioSource_.priority;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Sets the priority of the AudioSource.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-priority.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getPitch.ToString (),
					"",
					tab4 + "floatValue = audioSource_.pitch;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"The pitch of the audio source.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-pitch.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getPanStereo.ToString (),
					"",
					tab4 + "floatValue = audioSource_.panStereo;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Pans a playing sound in a stereo way (left or right). This only applies to sounds that are Mono or Stereo.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-panStereo.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getMute.ToString (),
					"",
					tab4 + "boolValue = audioSource_.mute;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Un- / Mutes the AudioSource. Mute sets the volume=0, Un-Mute restore the original volume.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-mute.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getMinDistance.ToString (),
					"",
					tab4 + "floatValue = audioSource_.minDistance;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{						
						"Within the Min distance the AudioSource will cease to grow louder in volume.",
						"Outside the min distance the volume starts to attenuate.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-minDistance.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getMaxDistance.ToString (),
					"",
					tab4 + "floatValue = audioSource_.maxDistance;",
					InOutWs.OutWs.float_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"(Logarithmic rolloff) MaxDistance is the distance a sound stops attenuating at.",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-maxDistance.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getLoop.ToString (),
					"",
					tab4 + "boolValue = audioSource_.loop;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Is the audio clip looping?",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-loop.html",
					""),

				new EnumInputComputeOutput (
					ComputeAudioSourceType.getIsPlaying.ToString (),
					"",
					tab4 + "boolValue = audioSource_.isPlaying;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.audioSource_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.audioSourceCheck + ExprWs.UMDecl.computeAudioSource,
					new string []
					{
						"",
						"Is the clip playing right now (Read Only)?",
					},
					"https://docs.unity3d.com/ScriptReference/AudioSource-isPlaying.html",
					""),
				
			};
		}

		//IEnumerator RunAnimationCurve_transformPosition ()
		//{
		//	if ( ! boolValues [0])
		//	{
		//		boolValues [0] = true;
		//
		//		float t = 0f;
		//
		//		float rate = 1f / floatValues [2];
		//
		//		while (t < 1f)
		//		{
		//			t += Time.deltaTime * rate;
		//
		//			transform_.position = Vector3.Lerp (vector3Values [0], vector3Values [1], animationCurve_.Evaluate (t));
		//
		//			yield return 0;
		//		}
		//
		//		boolValues [0] = false;
		//	}
		//	yield return 0;
		//}

		EnumInputComputeOutput [] EnumInputComputeOutput_Transform ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeTransformType.animationCurveLocalScale.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._vector3 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._vector3_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve animation time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Max (0.1f, floatValues [2]);\n",
					"\t\t\t\t" + CsScriptWriter.FromLogicNodeToMonoBehaviour (logic.node.graph, logic.node, logic) + "." +
					"StartCoroutine (RunAnimationCurve_transformRotation ());",
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve + ExprWs.Gv.boolValues + 
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tboolValues [0] = false;\n" + 
					ExprWs.ConstructorExpr.AnimationCurve (this) + ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.Vector3Value (this),
					"\t\tIEnumerator RunAnimationCurve_transformRotation ()\n\t\t{\n" +
					"\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tboolValues [0] = true;\n" +
					"\t\t\n\t\t\t\tfloat t = 0f;\n\t\t\n\t\t\t\tfloat rate = 1f / floatValues [2];\n\t\t\n" +
					"\t\t\t\twhile (t < 1f)\n\t\t\t\t{\n\t\t\t\t\tt += Time.deltaTime * rate;\n" +
					"\t\t\n\t\t\t\t\ttransform_.localScale = Vector3.Lerp (vector3Values [0], vector3Values [1], animationCurve_.Evaluate (t));\n\t\t\n\t\t\t\t\tyield return 0;\n\t\t\t\t}\n\t\t\n\t\t\t\tboolValues [0] = false;\n\t\t\t}\n\t\t\tyield return 0;\n\t\t}\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"",
						"Animate a scale value on a curve,",
						"between the start and the end value.",
						"You have to define the animation time (duration).",
						"The time is the horizontal axis of the curve.",
						"The animated scale, the start and the end scales are on the",
						"vertical axis of the curve",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.animationCurveRotation.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._vector3 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._vector3_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve animation time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Max (0.1f, floatValues [2]);\n",
					"\t\t\t\t" + CsScriptWriter.FromLogicNodeToMonoBehaviour (logic.node.graph, logic.node, logic) + "." +
					"StartCoroutine (RunAnimationCurve_transformRotation ());",
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve + ExprWs.Gv.boolValues + 
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tboolValues [0] = false;\n" + 
					ExprWs.ConstructorExpr.AnimationCurve (this) + ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.Vector3Value (this),
					"\t\tIEnumerator RunAnimationCurve_transformRotation ()\n\t\t{\n" +
					"\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tboolValues [0] = true;\n" +
					"\t\t\n\t\t\t\tfloat t = 0f;\n\t\t\n\t\t\t\tfloat rate = 1f / floatValues [2];\n\t\t\n" +
					"\t\t\t\twhile (t < 1f)\n\t\t\t\t{\n\t\t\t\t\tt += Time.deltaTime * rate;\n" +
					"\t\t\n\t\t\t\t\ttransform_.rotation = Quaternion.Euler (Vector3.Lerp (vector3Values [0], vector3Values [1], animationCurve_.Evaluate (t)));\n\t\t\n\t\t\t\t\tyield return 0;\n\t\t\t\t}\n\t\t\n\t\t\t\tboolValues [0] = false;\n\t\t\t}\n\t\t\tyield return 0;\n\t\t}\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"",
						"Animate a rotation value on a curve,",
						"between the start and the end value.",
						"You have to define the animation time (duration).",
						"The time is the horizontal axis of the curve.",
						"The animated rotation, the start and the end rotations are on the",
						"vertical axis of the curve",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.animationCurvePosition.ToString (),
					"\t\t\t\tDrawAnimationCurveInputField ();\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Curve start value\");\n" +
					InOutWs.InWs._vector3 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve end value\");\n" +
					InOutWs.InWs._vector3_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Curve animation time\");\n" +
					InOutWs.InWs._float_2 +
					"\t\t\t\tfloatValues [2] = Mathf.Max (0.1f, floatValues [2]);\n",
					"\t\t\t\t" + CsScriptWriter.FromLogicNodeToMonoBehaviour (logic.node.graph, logic.node, logic) + "." +
					"StartCoroutine (RunAnimationCurve_transformPosition ());",
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.floatValues + ExprWs.Gv.animationCurve + ExprWs.Gv.boolValues + 
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tboolValues [0] = false;\n" + 
					ExprWs.ConstructorExpr.AnimationCurve (this) + ExprWs.ConstructorExpr.Vector3Values (this) +
					ExprWs.ConstructorExpr.Vector3Value (this),
					"\t\tIEnumerator RunAnimationCurve_transformPosition ()\n\t\t{\n\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tboolValues [0] = true;\n\t\t\n\t\t\t\tfloat t = 0f;\n\t\t\n\t\t\t\tfloat rate = 1f / floatValues [2];\n\t\t\n\t\t\t\twhile (t < 1f)\n\t\t\t\t{\n\t\t\t\t\tt += Time.deltaTime * rate;\n\t\t\n\t\t\t\t\ttransform_.position = Vector3.Lerp (vector3Values [0], vector3Values [1], animationCurve_.Evaluate (t));\n\t\t\n\t\t\t\t\tyield return 0;\n\t\t\t\t}\n\t\t\n\t\t\t\tboolValues [0] = false;\n\t\t\t}\n\t\t\tyield return 0;\n\t\t}\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"",
						"Animate a position value on a curve,",
						"between the start and the end value.",
						"You have to define the animation time (duration).",
						"The time is the horizontal axis of the curve.",
						"The animated position, the start and the end positions are on the",
						"vertical axis of the curve",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.keplerOrbit.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Focus Point\");\n" +
					InOutWs.InWs._vector3 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Orbit Normal\");\n" +
					InOutWs.InWs._vector3_1 +
					"\t\t\t\tDrawLogicNodeLabel (\"Big Axis direction and Eccentricity value\");\n" +
					InOutWs.InWs._vector4 +
					"\t\t\t\tDrawLogicNodeLabel (\"Big Axis mid-Length\");\n" +
					InOutWs.InWs._float + 
					"\t\t\t\tDrawLogicNodeLabel (\"Triangle Surface Speed\");\n" +
					InOutWs.InWs._float_1,
					tab4 + "KeplerOrbit ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values + ExprWs.Gv.vector4Values + ExprWs.Gv.floatValues + 
					ExprWs.Gv.intValue + ret + "\t\tfloat keplerRadius = 1f;\n",
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.Vector4Values (this) +
					ExprWs.ConstructorExpr.FloattValues (this) + "\t\t\tintValue = -1;\n",
					"\t\tvoid KeplerOrbit ()\n\t\t{\n\t\t\tintValue++;\n\n\t\t\tif (intValue > 10)\n\t\t\t\tintValue = 1;\n\n\t\t\tVector3 focus = vector3Values [0];\n\n\t\t\tVector3 pseudoNormal = vector3Values [1].normalized;\n\n\t\t\tVector3 aAVu = new Vector3 (vector4Values [0].x, vector4Values [0].y, vector4Values [0].z).normalized;\n\n\t\t\tfloat aA = floatValues [0];\n\n\t\t\tfloat ecc = Mathf.Clamp (vector4Values [0].w, 0f, 0.9f);\n\n\t\t\tVector3 bAV = Vector3.Cross (aAVu, pseudoNormal);\n\n\t\t\tif (bAV.magnitude == 0f)\n\t\t\t\tVector3.Cross (new Vector3 (aAVu.x, aAVu.y, aAVu.z + 10f), pseudoNormal);\n\n\t\t\tVector3 bAVu = bAV.normalized;\n\n\n\t\t\tif (intValue == 0)\n\t\t\t{\n\t\t\t\tfloatValues [2] = 0f;\n\n\t\t\t\tkeplerRadius = PolarEllipticEquation (floatValues [2], aA, ecc);\n\t\t\t}\n\n\n\t\t\tfloat dT = 0.02f;\n\n\t\t\tfloat tetha_dot = floatValues [1] / (100f * (keplerRadius == 0f?1f:keplerRadius) * dT );\n\n\t\t\tfloatValues [2] = tetha_dot == 0f?1f:tetha_dot * dT + floatValues [2];\n\n\n\t\t\tkeplerRadius = PolarEllipticEquation (floatValues [2], aA, ecc);\n\n\t\t\tVector3 dir = (aAVu * Mathf.Cos (floatValues [2]) + bAVu * Mathf.Sin (floatValues [2])).normalized;\n\n\t\t\ttransform_.position = focus + dir * keplerRadius;\n\t\t}\n\t\tfloat PolarEllipticEquation (float angle, float a, float ecc)\n\t\t{\n\t\t\tfloat ecc_2 = ecc*ecc;\n\n\t\t\tfloat num = a * (1f - ecc_2);\n\n\t\t\tfloat den = 1f + ecc * Mathf.Cos (angle);\n\n\n\t\t\treturn num / den;\n\t\t}\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"",
						"Kepler Orbit",
						"",
						"About the 'Big Axis direction and Eccentricity value':",
						"x, y and, z are the big axis direction and w is the Eccentricity",
						"Eccentricity = 0 -> circle",
						"Eccentricity =>[0, 0.9] -> ellipse",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.parallaxScrollingEnhanced.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Target\");\n" + 
					InOutWs.InWs._gameObject_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Distance\");\n" + 
					InOutWs.InWs._float + 
					"\t\t\t\tfloatValues [0] = Mathf.Clamp (floatValues [0], 0f, 100f);\n" +
					"\t\t\t\tDrawLogicNodeLabel (\"Background's First Position\");\n" + 
					InOutWs.InWs._vector3_1 + 
					"\t\t\t\tDrawLogicNodeLabel (\"Target's First Position\");\n" + 
					InOutWs.InWs._vector3 + 
					"\t\t\t\tDrawStringListMenuToString_0 (\"Scrolling Direction\", new String [] {\"x\", \"y\", \"z\",}, new String [] {\"\",});\n" +
					"\t\t\t\tDrawLogicNodeLabel (stringValues [0]);\n",
					tab4 + "ParallaxScrollingEnhanced ();",
					"\t\t\t\tDrawInNodeInfo (workOnlyOnGeneratedScripts);\n" +
					InOutWs.OutWs.gameObject_,
					//	"\t\tVector3 firstParallaxScrollingPos;\n" +
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll
					+ ExprWs.Gv.floatValues + ExprWs.Gv.vector3Values + ExprWs.Gv.stringValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,
						Enums.gameObjectValues_1_ID}) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this) + 
					ExprWs.ConstructorExpr.StringValues (this),
					"\t\tvoid ParallaxScrollingEnhanced ()\n\t\t{\n\t\t\tif (gameObjectValues [1] == null)\n\t\t\t\treturn;\n\n\t\t\tfloatValues [0] = Mathf.Clamp (floatValues [0], 0f, 100f);\n\n\t\t\tfloat distNorm = floatValues [0] / 100f;\n\n\t\t\tVector3 targetToMeFirstGap = vector3Values [1] - vector3Values [0];\n\n\t\t\tVector3 scrollPos =\n\t\t\t\tvector3Values [1] * (1f - distNorm) + \n\t\t\t\t(targetToMeFirstGap + gameObjectValues [1].transform.position) * distNorm;\n\n\t\t\tswitch (stringValues [0])\n\t\t\t{\n\t\t\tcase \"x\":\n\t\t\t\ttransform_.position = new Vector3 (scrollPos.x, transform_.position.y, transform_.position.z);\n\t\t\t\tbreak;\n\n\t\t\tcase \"y\":\n\t\t\t\ttransform_.position = new Vector3 (transform_.position.x, scrollPos.y, transform_.position.z);\n\t\t\t\tbreak;\n\n\t\t\tcase \"z\":\n\t\t\t\ttransform_.position = new Vector3 (transform_.position.x, transform_.position.y, scrollPos.z);\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\ttransform_.position = new Vector3 (scrollPos.x, transform_.position.y, transform_.position.z);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n" +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Parallax Scrolling is mostly used in 2D games.",
						"2D platformers and top down shooters usually.",
						"Parallax Scrolling move a background relative to the target (Player).",
						"It simulate the distance of the background.",
						"Far backgrounds follow the target, nearest ones don't.",
						"The distance is clamped between 0 and 100.",
						"0 for most nearest backgrounds that don't move.",
						"100 for most farest backgrounds that have the same movment of the target",
						"between 0 and 100 for backgrounds that move relativly to the target.",
						"greater is the distance, closer is the background's movment to the target's movment.",
						"",
						"Put your background in the first game object field.",
						"'Background's First Position' is the background first position, it's recommended that you fill it",
						"with the background initial position.",
						"Put your moving target (usually the player) in the second game object field.",
						"'Target's First Position' is the target first position, it's recommended that you fill it",
						"with the target initial position.",
						"",
						"'Scrolling Direction' is x, y or z, If another value is choosen,",
						"the default axe will be used i.e the x axe.",
					},
					"",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.parallaxScrolling.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Scroll Speed\");\n" +
					InOutWs.InWs._float +
					"\t\t\t\tDrawLogicNodeLabel (\"Tile Size\");\n" +
					InOutWs.InWs._float_1 + "\n\t\t\t\tfloatValues [1] = MathM.NotZero (floatValues [1]);\n\n" + 			
					"\t\t\t\tDrawLogicNodeLabel (\"Start Position\");\n" +
					InOutWs.InWs._vector3 +
					"\t\t\t\tDrawLogicNodeLabel (\"Direction\");\n" +
					InOutWs.InWs._vector3_1,
					tab4 + "ParallaxScrolling ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values + ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.notZero + ExprWs.UMDecl.transformParallaxScrolling +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Scroll the transform position in the direction, ",
						"you can define the scrolling speed and the tile size," +
						"the tile size is the repeating distance.",
					},
					"https://unity3d.com/learn/tutorials/topics/2d-game-creation/2d-scrolling-backgrounds",
					""),



				new EnumInputComputeOutput (
					ComputeTransformType.SmoothDamp.ToString (),
					"\t\t\t\tDrawLogicNodeLabel (\"Target Position\");\n" +
					InOutWs.InWs._vector3 +
					"\t\t\t\tDrawLogicNodeLabel (\"Time to reach the Target\");\n" +
					InOutWs.InWs._float + 			
					"\t\t\t\tDrawLogicNodeLabel (\"Max Speed reaching the Target\");\n" +
					InOutWs.InWs._float_1,
					tab4 + "transform_.position = Vector3.SmoothDamp (" +
					"transform_.position, vector3Values [0], ref vector3Value, " +
					"floatValues [0], floatValues [1]);",
					"\t\t\t\tDrawLogicNodeLabel (\"The current velocity\");\n" +
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3All + ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Gradually changes a vector towards a desired goal over time.",
						"The vector is smoothed by some spring-damper like function,",
						"which will never overshoot. The most common use is for smoothing a follow camera.",
					},
					"https://docs.unity3d.com/ScriptReference/Vector3.SmoothDamp.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.translate.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.Translate (vector3Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Moves the transform in the direction and distance of translation.",
						"If relativeTo is left out or set to Space.Self the movement is applied relative",
						"to the transform's local axes.",
						"(the x, y and z axes shown when selecting the object inside the Scene View.)",
						"If relativeTo is Space.World the movement is applied relative to the world",
						"coordinate system.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.Translate.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.TransformVector.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = transform_.TransformVector (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Transforms vector from local space to world space.",
						"This operation is not affected by position of the transform, but is is affected",
						"by scale. The returned vector may have a different length than vector.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.TransformVector.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.TransformPoint.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = transform_.TransformPoint (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Transforms position from local space to world space.",
						"Note that the returned position is affected by scale.",
						"Use Transform.TransformDirection if you are dealing with direction vectors.",
						"You can perform the opposite conversion, from world to local space using",
						"Transform.InverseTransformPoint.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.TransformPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.TransformDirection.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = transform_.TransformDirection (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Transforms direction from local space to world space.",
						"This operation is not affected by scale or position of the transform.",
						"The returned vector has the same length as direction.",
						"You should use Transform.TransformPoint for the conversion if the vector represents",
						"a position rather than a directio",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.setUp.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.up = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The green axis of the transform in world space.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-up.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.SetSiblingIndex.ToString (),
					InOutWs.InWs._int,
					tab4 + "transform_.SetSiblingIndex (intValues [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Sets the sibling index.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.SetSiblingIndex.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.setRotationOnTransform.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.rotation = Quaternion.Euler (vector3Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The rotation of the transform in world space stored as a Quaternion.",
						"Unity stores rotations as Quaternions internally. To rotate an object,",
						"use Transform.Rotate. Use Transform.eulerAngles for setting the rotation as",
						"euler angles.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-rotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.setRight.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.right = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The red axis of the transform in world space.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-right.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.setPositionOnTransform.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.position = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The position of the transform in world space.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-position.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.setLocalScaleOnTransform.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.localScale = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The scale of the transform relative to the parent.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-localScale.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.setLocalRotationOnTransform.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.localRotation = Quaternion.Euler (vector3Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The rotation of the transform relative to the parent transform's rotation.",
						"Unity stores rotations as Quaternions internally.",
						"To rotate an object, use Transform.Rotate. Use Transform.localEulerAngles",
						"for modifying the rotation as euler angles.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-localRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.setLocalPositionOnTransform.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.localPosition = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Position of the transform relative to the parent transform.",
						"If the transform has no parent, it is the same as Transform.position.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-localPosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.setHasChanged.ToString (),
					InOutWs.InWs._bool,
					tab4 + "transform_.hasChanged = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Has the transform changed since the last time the flag was set to 'false'?",
						"A change to the transform can be anything that can cause its matrix to be",
						"recalculated: any adjustment to its position, rotation or scale. Note that",
						"operations which can change the transform will not actually check if the old",
						"and new value are different before setting this flag.",
						"So setting, for instance, transform.position will always set hasChanged on",
						"the transform, regardless of there being any actual change.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-hasChanged.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.setForward.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.forward = vector3Values [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll + 
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The blue axis of the transform in world space.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-forward.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.SetAsLastSibling.ToString (),
					"",
					tab4 + "transform_.SetAsLastSibling ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Move the transform to the end of the local transform list.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.SetAsLastSibling.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.SetAsFirstSibling.ToString (),
					"",
					tab4 + "transform_.SetAsFirstSibling ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Move the transform to the start of the local transform list.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.SetAsFirstSibling.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.RotateAround.ToString (),
					"DrawLogicNodeLabel (\"Point\");" + ret + InOutWs.InWs._vector3 + ret +
					"DrawLogicNodeLabel (\"Axis\");" + ret + InOutWs.InWs._vector3_1 + ret +
					"DrawLogicNodeLabel (\"Angle\");" + ret + InOutWs.InWs._float,
					tab4 + "transform_.RotateAround (vector3Values [0], vector3Values [1], floatValues [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values + ExprWs.Gv.floatValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this) + ExprWs.ConstructorExpr.FloattValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Rotates the transform about axis passing through point in world coordinates by angle",
						"degrees.",
						"This modifies both the position and the rotation of the transform.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.RotateAround.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.rotate.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.Rotate (vector3Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Applies a rotation of eulerAngles.z degrees around the z axis,",
						"eulerAngles.x degrees around",
						"the x axis, and eulerAngles.y degrees around the y axis (in that order).",
						"If relativeTo is not specified or set to Space.Self the rotation is applied",
						"around the transform's local axes. If relativeTo is set to Space.World the",
						"rotation is applied around the world x, y, z axes.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.Rotate.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.makeMeChildOf.ToString (),
					InOutWs.InWs._gameObject_1 + InOutWs.InWs._gameObject_1_check,
					"\t\t\t\tif (gameObjectValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\ttransform_.parent = gameObjectValues [1].transform;\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) ,
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The parent of the transform.",
						"Changing the parent will modify the parent-relative position,",
						"scale and rotation but keep the world space position, rotation and scale the same.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-parent.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.LookAt.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "transform_.LookAt (vector3Values [0]);",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Values,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Rotates the transform so the forward vector points at /target/'s current position.",
						"Then it rotates the transform to point its up direction vector in the direction",
						"hinted at by the worldUp vector. If you leave out the worldUp parameter,",
						"the function will use the world y axis. worldUp is only a hint vector.",
						"The up vector of the rotation will only match the worldUp vector",
						"if the forward direction is perpendicular to worldUp.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.LookAt.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.InverseTransformVector.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = transform_.InverseTransformVector (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Transforms a vector from world space to local space.",
						"The opposite of Transform.TransformVector.",
						"This operation is affected by scale.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.InverseTransformVector.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.InverseTransformPoint.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = transform_.InverseTransformPoint (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Transforms position from world space to local space.",
						"This function is essentially the opposite of Transform.TransformPoint,",
						"which is used to convert from local to world space.",
						"Note that the returned position is affected by scale.",
						"Use Transform.InverseTransformDirection if you are dealing with",
						"direction vectors rather than positions.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.InverseTransformPoint.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.InverseTransformDirection.ToString (),
					InOutWs.InWs._vector3,
					tab4 + "vector3Value = transform_.InverseTransformDirection (vector3Values [0]);",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3All,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.Vector3Values (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Transforms a direction from world space to local space.",
						"The opposite of Transform.TransformDirection.",
						"This operation is unaffected by scale.",
						"You should use Transform.InverseTransformPoint if the vector represents a position",
						"in space rather than a direction.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.InverseTransformDirection.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getParent.ToString (),
					"",
					"\t\t\t\tif (transform_.parent !=null)\n\t\t\t\t{\n\t\t\t\t\tgameObjectValue = transform_.parent.gameObject;\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) ,
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The parent of the transform.",
						"Changing the parent will modify the parent-relative position,",
						"scale and rotation but keep the world space position, rotation and scale the same.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-parent.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getWorldToLocalMatrix.ToString (),
					"",
					CodeOfSetM44EntierAndValues ("transform_.worldToLocalMatrix"),
					InOutWs.OutWs.m44_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.m44Value_entier + ExprWs.Gv.m44ValueAndProperties,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) ,
					ExprWs.UMDecl.SetM44Value +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Matrix that transforms a point from world space into local space (Read Only).",
						"If you're not familiar with using matrices for coordinate transformations,",
						"use Transform.InverseTransformPoint instead.",
						"IMPORTANT: If you're setting shader parameters you MUST use",
						"Renderer.worldToLocalMatrix instead.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-worldToLocalMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getUp.ToString (),
					"",
					tab4 + "vector3Value = transform_.up;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The green axis of the transform in world space.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-up.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.GetSiblingIndex.ToString (),
					"",
					tab4 + "intValue = transform_.GetSiblingIndex ();",
					InOutWs.OutWs.int_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Gets the sibling index.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.GetSiblingIndex.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getRotation.ToString (),
					"",
					tab4 + "vector3Value = transform_.rotation.eulerAngles;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The rotation of the transform in world space stored as a Quaternion.",
						"Unity stores rotations as Quaternions internally. To rotate an object,",
						"use Transform.Rotate. Use Transform.eulerAngles for setting the rotation as",
						"euler angles.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-rotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getRootParent.ToString (),
					"",
					"\t\t\t\tif (transform_.root != null)\n\t\t\t\t{\n\t\t\t\t\tgameObjectValue = transform_.root.gameObject;\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Returns the topmost transform in the hierarchy.",
						"(This never returns null, if this Transform doesn't have a parent it returns itself.)",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-root.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getRight.ToString (),
					"",
					tab4 + "vector3Value = transform_.right;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The red axis of the transform in world space.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-right.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getPosition.ToString (),
					"",
					tab4 + "vector3Value = transform_.position;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The position of the transform in world space.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-position.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getLocalToWorldMatrix.ToString (),
					"",
					CodeOfSetM44EntierAndValues ("transform_.localToWorldMatrix"),
					InOutWs.OutWs.m44_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.m44Value_entier + ExprWs.Gv.m44ValueAndProperties,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.SetM44Value +
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Matrix that transforms a point from local space into world space (Read Only).",
						"If you're not familiar with using matrices for coordinate transformations,",
						"use Transform.TransformPoint instead.",
						"IMPORTANT: If you're setting shader",
						"parameters you MUST use Renderer.localToWorldMatrix instead.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-localToWorldMatrix.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getLocalScale.ToString (),
					"",
					tab4 + "vector3Value = transform_.localScale;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The scale of the transform relative to the parent.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-localScale.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getLocalRotation.ToString (),
					"",
					tab4 + "vector3Value = transform_.localRotation.eulerAngles;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The rotation of the transform relative to the parent transform's rotation.",
						"Unity stores rotations as Quaternions internally.",
						"To rotate an object, use Transform.Rotate. Use Transform.localEulerAngles",
						"for modifying the rotation as euler angles.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-localRotation.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getLocalPosition.ToString (),
					"",
					tab4 + "vector3Value = transform_.localPosition;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Position of the transform relative to the parent transform.",
						"If the transform has no parent, it is the same as Transform.position.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-localPosition.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getHasChanged.ToString (),
					"",
					tab4 + "boolValue = transform_.hasChanged;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Has the transform changed since the last time the flag was set to 'false'?",
						"A change to the transform can be anything that can cause its matrix to be",
						"recalculated: any adjustment to its position, rotation or scale. Note that",
						"operations which can change the transform will not actually check if the old",
						"and new value are different before setting this flag.",
						"So setting, for instance, transform.position will always set hasChanged on",
						"the transform, regardless of there being any actual change.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-hasChanged.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getForward.ToString (),
					"",
					tab4 + "vector3Value = transform_.forward;",
					InOutWs.OutWs.vector3_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.vector3Value,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The blue axis of the transform in world space.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-forward.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.getChildCount.ToString (),
					"",
					tab4 + "intValue = transform_.childCount;",
					InOutWs.OutWs.int_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The number of children the Transform has.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-childCount.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.FindChildOfName.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\tif (transform_.Find (stringValues [0]) != null)\n\t\t\t\t{\n\t\t\t\t\tgameObjectValue = transform_.Find (stringValues [0]).gameObject;\n\t\t\t\t}",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.stringValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Finds a child by name and returns it.",
						"If no child with name can be found, null is returned.",
						"If name contains a '/' character it will traverse the hierarchy like a path name.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.Find.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.FindChildOfIndex.ToString (),
					InOutWs.InWs._int,
					"\t\t\t\tif (transform_.childCount > 0)\n\t\t\t\t{\n\t\t\t\t\tintValues [0] = Mathf.Clamp (intValues [0], 0, transform_.childCount-1);\n\n\t\t\t\t\tif (transform_.GetChild (intValues [0]) != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tgameObjectValue = transform_.GetChild (intValues [0]).gameObject;\n\t\t\t\t\t}\n\t\t\t\t}",		
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.intValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.IntValues (this),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Returns a transform child by index.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.GetChild.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.DetachChildren.ToString (),
					"",
					tab4 + "transform_.DetachChildren ();",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"Unparents all children.",
						"Useful if you want to destroy the root of a hierarchy without destroying",
						"the children.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform.DetachChildren.html",
					""),

				new EnumInputComputeOutput (
					ComputeTransformType.AmIChildOf.ToString (),
					InOutWs.InWs._gameObject_1 + InOutWs.InWs._gameObject_1_check,
					"\t\t\t\tif (gameObjectValues [1] != null)\n\t\t\t\t{\n\t\t\t\t\tif (transform_.parent == gameObjectValues [1].transform)\n\t\t\t\t\t{\n\t\t\t\t\t\tboolValue = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tboolValue = false;\n\t\t\t\t\t}\n\t\t\t\t}",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.transform_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.gameObjectCheck + ExprWs.UMDecl.transformCheck2D + ExprWs.UMDecl.computeTransform,
					new string []
					{
						"The parent of the transform.",
						"Changing the parent will modify the parent-relative position,",
						"scale and rotation but keep the world space position, rotation and scale the same.",
					},
					"https://docs.unity3d.com/ScriptReference/Transform-parent.html",
					""),
			};
		}

		static string CodeOfSetM44EntierAndValues (string rightEqualExpr)
		{
			return "\t\t\t\tm44Value_entier = " + rightEqualExpr + ";\n\t\t\t\tSetM44Value (m44Value_entier);";
		}

		string ConstructorGetIdentifiedObject (string [] arrayInOutIDs)
		{
			string r = "";
			r += ExprWs.ConstructorExpr.identifiedObjects;
			r += identifiedObjectsNotNull;
			for (int i = 0; i < arrayInOutIDs.Length; i++)
			{
				r += ConstructorGetIdentifiedObject (VariableStruct.singleOrArray, -1, arrayInOutIDs [i]);
			}
			r += "\t\t\t}\n";
			r += "\n";

			return r;
		}

		string ConstructorGetIdentifiedObject (VariableStruct vs, int vc, string inOutID)
		{
			string r = "";

			string fieldUID = "";

			string varType = CsScriptWriter.InOutIdOfObjectToDeclarationString (inOutID);

			string varName = "";

			string func = "identifiedObjects.GetIdentifiedObject (";


			switch (vs)
			{
			case VariableStruct.singleOrArray:

				fieldUID = FieldUniqueID (inOutID);

				varName = CsScriptWriter.InOutIdToVarName(StringTreatment.AfterThat(fieldUID, '.'), false);

				r += tab4 + varName + " = (" + varType + ")" + func + "\"" + fieldUID + "\"" + ");\n"; 
				break;

			case VariableStruct.list:
				r += ExprWs.ConstructorExpr.identifiedObjects;
				r += identifiedObjectsNotNull;
				for (int i = 0; i < vc; i++)
				{
					fieldUID = FieldUniqueID (inOutID, i);

					varName = CsScriptWriter.InOutIdToVarName (StringTreatment.AfterThat (fieldUID, '.'), true);

					r += tab4 + varName + ".Add ((" + varType + ")" + func + "\"" + fieldUID + "\"" + "));\n"; 
				}
				r += "\t\t\t}\n";
				r += "\n";
				break;
			}


			return r;
		}

		class ExprWs
		{
			public class Gv
			{
				public const string mddtGameObjectHolder = "\t\tGameObject mddtGameObjectHolder = null;\n";

				public const string mdeGameObjectHolder =
					"\t\tGameObject mdeGameObjectHolder = null;\n\n";
				
				public const string light = "\t\tLight lightComp = null;\n"; 

				public const string light_doIt_identifiedObjects_gameObjectAll = 
					light + doIt + identifiedObjects + gameObjectAll;
				

				public const string uiInputField = "\t\tUnityEngine.UI.InputField uiInputField = null;\n"; 

				public const string uiInputField_doIt_identifiedObjects_gameObjectAll = 
					uiInputField + doIt + identifiedObjects + gameObjectAll;

				public const string accelerationEvents = "\t\tAccelerationEvent [] accelerationEvents;\n";

				public const string Touch = "\t\tpublic float touch_altitudeAngle;\n\n\t\tpublic float touch_azimuthAngle;\n\n\t\tpublic Vector2 touch_deltaPosition;\n\n\t\tpublic float touch_deltaTime;\n\n\n\n\t\tpublic int touch_fingerId;\n\n\t\tpublic float touch_maximumPossiblePressure;\n\n\t\tpublic string touch_phase;\n\n\t\tpublic Vector2 touch_position;\n\n\t\tpublic float touch_pressure;\n\n\n\n\t\tpublic float touch_radius;\n\n\t\tpublic float touch_radiusVariance ;\n\n\t\tpublic Vector2 touch_rawPosition ;\n\n\t\tpublic int touch_tapCount;\n\n\t\tpublic string touch_type;\n\n";


				public const string downTimeCounterForBoolImpulse = 
					"\t\tfloat downCounterForBoolImpulse;\n\t\tbool startCounting = false;\n\n";


				public const string spriteTileMode = "\t\tSpriteTileMode spriteTileMode;\n\n";

				public const string spriteDrawMode = "\t\tSpriteDrawMode spriteDrawMode;\n\n";

				public const string loadSceneMode = "\t\tpublic UnityEngine.SceneManagement.LoadSceneMode " +
					"loadSceneMode;\n\n";

				public const string inventoryListAction = 
					"\t\tpublic enum InventoryListAction\n\t\t{\n\t\t\tAdd,\n\n\t\t\tRemove,\n\n\t\t\tmakeObjectOfFollowingIndexReady,\n\n\t\t\tnameEntireList,\n\n\t\t\tRemoveAtThisIndex,\n\t\t}\n" +
					"\t\tpublic InventoryListAction inventoryListAction;\n\n";

				public const string downTimeCounter = "\t\tint downTimeCounterInt;\n";

				public const string foundByOnTriggerExit = "\t\tpublic GameObject foundByOnTriggerExit = null;\n\n";

				public const string foundByOnTriggerEnter = "\t\tpublic GameObject foundByOnTriggerEnter = null;\n\n";

				public const string camera_StereoscopicEye = 
					"\t\tpublic Camera.StereoscopicEye camera_StereoscopicEye;\n\n";

				public const string colorBlendMode = "\t\tpublic enum ColorBlendMode\n\t\t{\n\t\t\trandomHsv,\n\n\t\t\tdarken,\n\n\t\t\tlighten,\n\n\t\t\tmultiply,\n\n\t\t\tscreen,\n\n\t\t\tcolorDodge,\n\n\t\t\tcolorBurn,\n\n\t\t\tlinearDodge,\n\n\t\t\tlinearBurn,\n\n\t\t\toverlay,\n\n\t\t\thardLight,\n\n\t\t\tsoftLight,\n\n\t\t\tvividLight,\n\n\t\t\tlinearLight,\n\n\t\t\tpinLight,\n\n\t\t\thardMix,\n\n\t\t\tdifference,\n\n\t\t\texclusion,\n\n\t\t\thue,\n\n\t\t\tsaturation,\n\n\t\t\tcolor,\n\n\t\t\tluminosity,\n\n\t\t\tadd,\n\n\t\t\tsubtract\n\t\t}\n\t\tColorBlendMode colorBlendMode;\n\n";

				public const string fillMethod = "\t\tpublic UnityEngine.UI.Image.FillMethod fillMethod;\n\n";


				public const string identifiedObjects = "\t\tScriptsCreatedByDiamond.IdentifiedObjects identifiedObjects = null;\n\n";

				public const string ListOperationsClass_MergeGameObject =
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <GameObject> to, List <GameObject> from_0, List <GameObject> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<GameObject> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";


				public const string ListOperationsClass_MergeShader =
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <Shader> to, List <Shader> from_0, List <Shader> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<Shader> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";


				public const string ListOperationsClass_MergeTexture2D =
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <Texture2D> to, List <Texture2D> from_0, List <Texture2D> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<Texture2D> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";

				public const string ListOperationsClass_MergeMaterial = 
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <Material> to, List <Material> from_0, List <Material> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<Material> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";


				public const string ListOperationsClass_MergeRect = 
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <Rect> to, List <Rect> from_0, List <Rect> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<Rect> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";


				public const string ListOperationsClass_MergeVector4 = 
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <Vector4> to, List <Vector4> from_0, List <Vector4> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<Vector4> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";


				public const string ListOperationsClass_MergeVector3 = 
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <Vector3> to, List <Vector3> from_0, List <Vector3> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<Vector3> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";


				public const string ListOperationsClass_MergeVector2 = 
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <Vector2> to, List <Vector2> from_0, List <Vector2> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<Vector2> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n" +
					"\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n" +
					"\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n" +
					"\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n" +
					"\t\t}\n\n";

				public const string ListOperationsClass_MergeColor = 
					"\t\tpublic class ListOperations \n\t\t{\n" +
					"\t\tpublic static void Merge (ref List <Color> to, List <Color> from_0, List <Color> from_1)\n\t\t{\n\t\t\tto = new List<Color> ();\n\n\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t{\n\t\t\t\tto.Add (from_0 [i]);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t{\n\t\t\t\tto.Add (from_1 [i]);\n\t\t\t}\n\t\t}\n" +
					"\t\t}\n\n";


				public const string ListOperationsClass_MergeStringt = 
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <string> to, List <string> from_0, List <string> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<string> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";


				public const string ListOperationsClass_MergeInt = 
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <int> to, List <int> from_0, List <int> from_1)\n\t\t\t" +
					"{\n\t\t\t\tto = new List<int> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";


				public const string ListOperationsClass_MergeBool = 
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <bool> to, List <bool> from_0, List <bool> from_1)\n\t\t\t"+
					"{\n\t\t\t\tto = new List<bool> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";


				public const string ListOperationsClass_MergeFloat = 
					"\t\tpublic class ListOperations \n\t\t{\n\t\t\tpublic static void Merge " +
					"(ref List <float> to, List <float> from_0, List <float> from_1)\n\t\t\t{\n\t\t\t\tto = new List<float> ();\n\n\t\t\t\tfor (int i = 0; i < from_0.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_0 [i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < from_1.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tto.Add (from_1 [i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n";




				public const string uiToggle = "\t\tUnityEngine.UI.Toggle uiToggle = null;\n";

				//UnityEngine.UI.Text unityText = null;

				public const string unityText = "\t\tUnityEngine.UI.Text unityText = null;\n\n";

				public const string uiImage = "\t\tUnityEngine.UI.Image uiImage = null;\n\n";

				public const string uiButton = "\t\tUnityEngine.UI.Button uiButton = null;\n\n";

				public const string uiToggle_doIt_identifiedObjects_gameObjectAll = 
					uiToggle + doIt + identifiedObjects + gameObjectAll;


				public const string boolsListValue = "\t\tpublic List <bool> boolsListValue = new List <bool> ();\n\n";
				public const string boolsListValues = "\t\tpublic List <bool>[] boolsListValues = new List<bool>[2];\n\n";
				public const string boolListAll = boolsListValue + boolsListValues;

				public const string shaderListValue = "\t\tpublic List <Shader> shaderListValue = new List <Shader> ();\n\n";
				public const string shaderListValues = "\t\tpublic List<Shader>[] shaderListValues = new List<Shader>[2];\n\n";
				public const string shaderListAll = shaderListValue + shaderListValues;

				public const string texture2DListValue = "\t\tpublic List <Texture2D> texture2DListValue = new List <Texture2D> ();\n\n";
				public const string texture2DListValues = "\t\tpublic List<Texture2D>[] texture2DListValues = new List<Texture2D>[2];\n\n";
				public const string texture2DListAll = texture2DListValue + texture2DListValues;

				public const string gameObjectListValue = "\t\tpublic List <GameObject> gameObjectsListValue = new List <GameObject> ();\n\n";
				public const string gameObjectListValues = "\t\tpublic List <GameObject>[] gameObjectsListValues = new List<GameObject>[2];\n\n";
				public const string gameObjectListAll = gameObjectListValue + gameObjectListValues;

				public const string materialListValue = "\t\tpublic List <Material> materialsListValue = new List <Material> ();\n\n";
				public const string materialListValues = "\t\tpublic List <Material>[] materialsListValues = new List<Material>[2];\n\n"; 
				public const string materialListAll = materialListValue + materialListValues;

				public const string rectListValue = "\t\tpublic List <Rect> rectListValue = new List <Rect> ();\n\n";
				public const string rectListValues = "\t\tpublic List <Rect>[] rectListValues = new List<Rect>[2];\n\n"; 
				public const string rectListAll = rectListValue + rectListValues;

				public const string vector4ListValue = "\t\tpublic List <Vector4> vector4ListValue = new List <Vector4> ();\n\n";
				public const string vector4ListValues = "\t\tpublic List <Vector4>[] vector4ListValues = new List<Vector4>[2];\n\n"; 
				public const string vector4ListAll = vector4ListValue + vector4ListValues;

				public const string vector3ListValue = "\t\tpublic List <Vector3> vector3ListValue = new List <Vector3> ();\n\n";
				public const string vector3ListValues = "\t\tpublic List <Vector3>[] vector3ListValues = new List<Vector3>[2];\n\n"; 
				public const string vector3ListAll = vector3ListValue + vector3ListValues;

				public const string vector2ListValue = "\t\tpublic List <Vector2> vector2ListValue = new List <Vector2> ();\n\n";
				public const string vector2ListValues = "\t\tpublic List <Vector2>[] vector2ListValues = new List<Vector2>[2];\n\n"; 
				public const string vector2ListAll = vector2ListValue + vector2ListValues;

				public const string colorListValue = "\t\tpublic List <Color> colorsListValue = new List<Color> ();\n";
				public const string colorListValues = "\t\tpublic List <Color> [] colorsListValues = new List<Color>[2];\n";
				public const string colorListAll = colorListValue + colorListValues;

				public const string stringListValue = "\t\tpublic List <string> stringsListValue = new List <string> ();\n\n";
				public const string stringListValues = "\t\tpublic List <string>[] stringsListValues = new List<string>[2];\n\n"; 
				public const string stringListAll = stringListValue + stringListValues;

				public const string intsListValue = "\t\tpublic List <int> intsListValue = new List <int> ();\n\n";
				public const string intsListValues = "\t\tpublic List <int>[] intsListValues = new List<int>[2];\n\n"; 
				public const string intListAll = intsListValue + intsListValues;

				public const string floatsListValue = "\t\tpublic List <float> floatsListValue = new List <float> ();\n\n";
				public const string floatsListValues = "\t\tpublic List <float>[] floatsListValues = new List<float>[2];\n\n"; 
				public const string floatListAll = floatsListValue + floatsListValues;


				public const string switchColorsType = "\t\tpublic TextureComputer.SwitchColorsType switchColorsType;\n";

				public const string textureWrapMode = "\t\tpublic TextureWrapMode textureWrapMode;";

				public const string filtermode = "\t\tpublic FilterMode filterMode;\n\n";

				public const string mirrorTexture2D_Direction =
					"\t\tpublic TextureComputer.MirrorTexture2D_Direction mirrorTexture2D_Direction;\n";

				public const string extractResultType = "\t\tpublic TextureComputer.ExtractResultType extractResultType;\n\n"; 

				public const string textureComputer = "\t\tpublic class TextureComputer \n\t\t{\n\t\t\tpublic static int minTextureSize = 8;\n\n\t\t\tpublic enum ComputeOn\n\t\t\t{\n\t\t\t\tred,\n\n\t\t\t\tgreen,\n\n\t\t\t\tblue,\n\n\t\t\t\talpha,\n\n\n\t\t\t\thue,\n\n\t\t\t\tsaturation,\n\n\t\t\t\tvalue,\n\t\t\t}\n\n\t\t\t//switch (cO)\n\t\t\t//{\n\t\t\t//case ComputeOn.alpha:\n\t\t\t//\tbreak;\n\t\t\t//\n\t\t\t//case ComputeOn.blue:\n\t\t\t//\tbreak;\n\t\t\t//\n\t\t\t//case ComputeOn.green:\n\t\t\t//\tbreak;\n\t\t\t//\n\t\t\t//case ComputeOn.hue:\n\t\t\t//\tbreak;\n\t\t\t//\n\t\t\t//case ComputeOn.red:\n\t\t\t//\tbreak;\n\t\t\t//\n\t\t\t//case ComputeOn.saturation:\n\t\t\t//\tbreak;\n\t\t\t//\n\t\t\t//case ComputeOn.value:\n\t\t\t//\tbreak;\n\t\t\t//}\n\n\t\t\tpublic enum Direction\n\t\t\t{\n\t\t\t\tx,\n\n\t\t\t\ty,\n\n\t\t\t\tz,\n\t\t\t}\n\n\n\t\t\tpublic static float [] FiniteDifference (Direction dir, ComputeOn cO, int order, Texture2D tex,\n\t\t\t\tfloat amplifier)\n\t\t\t{\n\t\t\t\tfloat amplifierMax = 20f;\n\n\t\t\t\tamplifier = (amplifierMax/100f)*amplifier;\n\n\n\n\t\t\t\tList <float> rL = new List<float> ();\n\n\t\t\t\tfor (int y = 0; y < tex.height; y++)\n\t\t\t\t{\n\t\t\t\t\tfor (int x = 0; x < tex.width; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\trL.Add (FiniteDifference (x, y, dir, cO, order, tex, amplifier));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn rL.ToArray ();\n\t\t\t}\n\n\t\t\tpublic static float FiniteDifference (int x, int y, Direction dir, ComputeOn cO, int order, Texture2D tex,\n\t\t\tfloat amplifier)\n\t\t\t{\n\t\t\t\tfloat r = 0.5f;\n\n\t\t\t\tx = Mathf.Clamp (x, 1, tex.width-2);\n\n\t\t\t\ty = Mathf.Clamp (y, 1, tex.height-2);\n\n\n\t\t\t\tColor cL_1 = tex.GetPixel (x-1, y);\n\n\t\t\t\tColor cR_1 = tex.GetPixel (x+1, y);\n\n\n\t\t\t\tColor cD_1 = tex.GetPixel (x, y-1);\n\n\t\t\t\tColor cU_1 = tex.GetPixel (x, y+1);\n\n\n\t\t\t\tColor c = tex.GetPixel (x, y);\n\n\t\t\t\tfloat vL_1 = 0.5f;\n\t\t\t\tfloat v = 0.5f;\n\t\t\t\tfloat vR_1 = 0.5f;\n\t\t\t\tfloat vD_1 = 0.5f;\n\t\t\t\tfloat vU_1 = 0.5f;\n\n\t\t\t\tswitch (cO)\n\t\t\t\t{\n\t\t\t\tcase ComputeOn.alpha:\n\t\t\t\t\tvL_1 = cL_1.a;\n\t\t\t\t\tv = c.a;\n\t\t\t\t\tvR_1 = cR_1.a;\n\t\t\t\t\tvD_1 = cD_1.a;\n\t\t\t\t\tvU_1 = cU_1.a;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase ComputeOn.blue:\n\t\t\t\t\tvL_1 = cL_1.b;\n\t\t\t\t\tv = c.b;\t\n\t\t\t\t\tvR_1 = cR_1.b;\n\t\t\t\t\tvD_1 = cD_1.b;\n\t\t\t\t\tvU_1 = cU_1.b;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase ComputeOn.green:\n\t\t\t\t\tvL_1 = cL_1.g;\n\t\t\t\t\tv = c.g;\n\t\t\t\t\tvR_1 = cR_1.g;\n\t\t\t\t\tvD_1 = cD_1.g;\n\t\t\t\t\tvU_1 = cU_1.g;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase ComputeOn.hue:\n\t\t\t\t\tvL_1 = ColorsArithmetic.RGBToHSV (cL_1) [0];\n\t\t\t\t\tv = ColorsArithmetic.RGBToHSV (c) [0];\n\t\t\t\t\tvR_1 = ColorsArithmetic.RGBToHSV (cR_1) [0];\n\t\t\t\t\tvD_1 = ColorsArithmetic.RGBToHSV (cD_1) [0];\n\t\t\t\t\tvU_1 = ColorsArithmetic.RGBToHSV (cU_1) [0];\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase ComputeOn.red:\n\t\t\t\t\tvL_1 = cL_1.r;\n\t\t\t\t\tv = c.r;\n\t\t\t\t\tvR_1 = cR_1.r;\n\t\t\t\t\tvD_1 = cD_1.r;\n\t\t\t\t\tvU_1 = cU_1.r;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase ComputeOn.saturation:\n\t\t\t\t\tvL_1 = ColorsArithmetic.RGBToHSV (cL_1) [1];\n\t\t\t\t\tv = ColorsArithmetic.RGBToHSV (c) [1];   \n\t\t\t\t\tvR_1 = ColorsArithmetic.RGBToHSV (cR_1) [1];\n\t\t\t\t\tvD_1 = ColorsArithmetic.RGBToHSV (cD_1) [1];\n\t\t\t\t\tvU_1 = ColorsArithmetic.RGBToHSV (cU_1) [1];\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase ComputeOn.value:\n\t\t\t\t\tvL_1 = ColorsArithmetic.RGBToHSV (cL_1) [2];\n\t\t\t\t\tv = ColorsArithmetic.RGBToHSV (c) [2];   \n\t\t\t\t\tvR_1 = ColorsArithmetic.RGBToHSV (cR_1) [2];\n\t\t\t\t\tvD_1 = ColorsArithmetic.RGBToHSV (cD_1) [2];\n\t\t\t\t\tvU_1 = ColorsArithmetic.RGBToHSV (cU_1) [2];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (order == 1)\n\t\t\t\t{\n\t\t\t\t\tswitch (dir)\n\t\t\t\t\t{\n\t\t\t\t\tcase Direction.x:\n\t\t\t\t\t\tr = 0.5f * (vL_1 - vR_1);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Direction.y:\n\t\t\t\t\t\tr = 0.5f * (vD_1 - vU_1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (order == 2)\n\t\t\t\t{\n\t\t\t\t\tswitch (dir)\n\t\t\t\t\t{\n\t\t\t\t\tcase Direction.x:\n\t\t\t\t\t\tr = 1f * (vL_1 - 2f*v + vR_1);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Direction.y:\n\t\t\t\t\t\tr = 1f * (vD_1 - 2f*v + vU_1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Debug.LogError (\"Order not 1 or 2\");\n\t\t\t\t}\n\n\t\t\t\treturn r * amplifier;\n\t\t\t}\n\n\t\t\tpublic static Color [] NormalColors (Texture2D tex, bool yInvert, ComputeOn cO, float amplifier)\n\t\t\t{\n\t\t\t\tint order = 1;\n\n\t\t\t\tfloat [] xS = FiniteDifference (Direction.y, cO, order, tex, amplifier);\n\n\t\t\t\tfloat [] yS = FiniteDifference (Direction.x, cO, order, tex, amplifier);\n\n\t\t\t\tColor [] r = new Color [xS.Length];\n\n\t\t\t\tfloat yMult = yInvert? -1f: 1f;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tr [i] = new Color (\n\t\t\t\t\t\t0.55f + xS [i], \n\t\t\t\t\t\t0.55f + yMult * yS [i], 1f, 1f);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tpublic static Color [] MirrorAndRotate (Texture2D tex, MirrorTexture2D_Direction mtd)\n\t\t\t{\n\t\t\t\tList <Color> rL = new List<Color> ();\n\n\t\t\t\tfor (int x = 0; x < tex.width; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 0; y < tex.height; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (mtd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase MirrorTexture2D_Direction.rotate90:\n\t\t\t\t\t\t\trL.Add (tex.GetPixel (tex.width-1 - x, y));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MirrorTexture2D_Direction.rotateMinus90:\n\t\t\t\t\t\t\trL.Add (tex.GetPixel (x, tex.height-1 - y));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MirrorTexture2D_Direction.mirrorXAndY:\n\t\t\t\t\t\t\trL.Add (tex.GetPixel (tex.width-1 - x, tex.height-1 - y));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int y = 0; y < tex.height; y++)\n\t\t\t\t{\n\t\t\t\t\tfor (int x = 0; x < tex.width; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (mtd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase MirrorTexture2D_Direction.mirrorY: \n\t\t\t\t\t\t\trL.Add (tex.GetPixel (x, tex.height-1 - y));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MirrorTexture2D_Direction.mirrorX: \n\t\t\t\t\t\t\trL.Add (tex.GetPixel (tex.width-1 - x, y));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\treturn \trL.ToArray ();\n\t\t\t}\n\n\n\t\t\tpublic enum ExtractResultType\n\t\t\t{\n\t\t\t\tAsIt,\n\n\t\t\t\tGrayscale,\n\t\t\t}\n\n\t\t\tpublic enum MirrorTexture2D_Direction\n\t\t\t{\n\t\t\t\trotate90,\n\n\t\t\t\trotateMinus90,\n\n\t\t\t\tmirrorXAndY,\n\n\t\t\t\tmirrorY,\n\n\t\t\t\tmirrorX,\n\t\t\t}\n\n\t\t\tpublic enum SwitchColorsType\n\t\t\t{\n\t\t\t\tRedGreen,\n\n\t\t\t\tRedBlue,\n\n\t\t\t\tGreenBlue,\n\t\t\t}\n\n\n\n\n\t\t\tpublic static Color [] SetPixelAccordingToAChannelValue (ComputeOn channelToRead,\n\t\t\t\tint valueToRead, int readTolerance, \n\t\t\t\tTexture2D tex_1, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat valueToRead_F = (float)valueToRead / 255f;\n\n\t\t\t\tfloat halfReadTolerance_F = ((float)readTolerance / 255f) * 0.5f;\n\n\t\t\t\tswitch (channelToRead)\n\t\t\t\t{\n\t\t\t\tcase ComputeOn.alpha:\n\t\t\t\t\tr = SetPixelAccordingToAlphaValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.blue:\n\t\t\t\t\tr = SetPixelAccordingToBlueValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.green:\n\t\t\t\t\tr = SetPixelAccordingToGreenValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.hue:\n\t\t\t\t\tr = SetPixelAccordingToHueValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.red:\n\t\t\t\t\tr = SetPixelAccordingToRedValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.saturation:\n\t\t\t\t\tr = SetPixelAccordingToSaturationValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.value:\n\t\t\t\t\tr = SetPixelAccordingToValueValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetPixelAccordingToValueValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tTexture2D tex_1, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tColor [] r_1 = tex_1.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat vR = hsvR [2];\n\n\t\t\t\t\tif (vR >= minTol && vR <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = r_1 [i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetPixelAccordingToSaturationValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tTexture2D tex_1, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tColor [] r_1 = tex_1.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat vR = hsvR [1];\n\n\t\t\t\t\tif (vR >= minTol && vR <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = r_1 [i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetPixelAccordingToHueValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tTexture2D tex_1, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tColor [] r_1 = tex_1.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat vR = hsvR [0];\n\n\t\t\t\t\tif (vR >= minTol && vR <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = r_1 [i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetPixelAccordingToBlueValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tTexture2D tex_1, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tColor [] r_1 = tex_1.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].b >= minTol && r [i].b <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = r_1 [i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetPixelAccordingToGreenValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tTexture2D tex_1, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tColor [] r_1 = tex_1.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].g >= minTol && r [i].g <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = r_1 [i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetPixelAccordingToRedValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tTexture2D tex_1, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tColor [] r_1 = tex_1.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].r >= minTol && r [i].r <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = r_1 [i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetPixelAccordingToAlphaValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tTexture2D tex_1, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tColor [] r_1 = tex_1.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].a >= minTol && r [i].a <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = r_1 [i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\n\n\n\n\t\t\tpublic static Color [] SetColorAccordingToAChannelValue (ComputeOn channelToRead,\n\t\t\t\tint valueToRead, int readTolerance, \n\t\t\t\tColor colorToSet, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat valueToRead_F = (float)valueToRead / 255f;\n\n\t\t\t\tfloat halfReadTolerance_F = ((float)readTolerance / 255f) * 0.5f;\n\n\t\t\t\tswitch (channelToRead)\n\t\t\t\t{\n\t\t\t\tcase ComputeOn.alpha:\n\t\t\t\t\tr = SetColorAccordingToAlphaValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.blue:\n\t\t\t\t\tr = SetColorAccordingToBlueValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.green:\n\t\t\t\t\tr = SetColorAccordingToGreenValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.hue:\n\t\t\t\t\tr = SetColorAccordingToHueValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.red:\n\t\t\t\t\tr = SetColorAccordingToRedValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.saturation:\n\t\t\t\t\tr = SetColorAccordingToSaturationValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.value:\n\t\t\t\t\tr = SetColorAccordingToValueValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetColorAccordingToValueValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tColor colorToSet, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat vR = hsvR [2];\n\n\t\t\t\t\tif (vR >= minTol && vR <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = colorToSet;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetColorAccordingToSaturationValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tColor colorToSet, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat vR = hsvR [1];\n\n\t\t\t\t\tif (vR >= minTol && vR <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = colorToSet;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetColorAccordingToHueValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tColor colorToSet, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat vR = hsvR [0];\n\n\t\t\t\t\tif (vR >= minTol && vR <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = colorToSet;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetColorAccordingToBlueValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tColor colorToSet, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].b >= minTol && r [i].b <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = colorToSet;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetColorAccordingToGreenValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tColor colorToSet, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].g >= minTol && r [i].g <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = colorToSet;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetColorAccordingToRedValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tColor colorToSet, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].r >= minTol && r [i].r <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = colorToSet;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetColorAccordingToAlphaValue (float valueToRead_F, float halfReadTolerance_F, \n\t\t\t\tColor colorToSet, Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].a >= minTol && r [i].a <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = colorToSet;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\n\n\n\n\n\t\t\tpublic static Color [] SetChannelAccordingToAnotherChannelValue (ComputeOn channetToSet, ComputeOn channelToRead,\n\t\t\t\tint valueToRead, int readTolerance, int valueToSet, Texture2D tex, bool keepOtherChannels, bool keepAlpha)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat valueToSet_F = (float)valueToSet / 255f;\n\n\t\t\t\tfloat valueToRead_F = (float)valueToRead / 255f;\n\n\t\t\t\tfloat halfReadTolerance_F = ((float)readTolerance / 255f) * 0.5f;\n\n\t\t\t\tswitch (channelToRead)\n\t\t\t\t{\n\t\t\t\tcase ComputeOn.alpha:\n\t\t\t\t\tr = SetChannelAccordingToAlphaValue (channetToSet, \n\t\t\t\t\t\tvalueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.blue:\n\t\t\t\t\tr = SetChannelAccordingToBlueValue (channetToSet, \n\t\t\t\t\t\tvalueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.green:\n\t\t\t\t\tr = SetChannelAccordingToGreenValue (channetToSet, \n\t\t\t\t\t\tvalueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.hue:\n\t\t\t\t\tr = SetChannelAccordingToHueValue (channetToSet, \n\t\t\t\t\t\tvalueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.red:\n\t\t\t\t\tr = SetChannelAccordingToRedValue (channetToSet, \n\t\t\t\t\t\tvalueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.saturation:\n\t\t\t\t\tr = SetChannelAccordingToSaturationValue (channetToSet, \n\t\t\t\t\t\tvalueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.value:\n\t\t\t\t\tr = SetChannelAccordingToValueValue (channetToSet, \n\t\t\t\t\t\tvalueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetChannelAccordingToValueValue (ComputeOn channetToSet, \n\t\t\t\tfloat valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels, \n\t\t\t\tbool keepAlpha)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat vR = hsvR [2];\n\n\t\t\t\t\tif (vR >= minTol && vR <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], \n\t\t\t\t\t\t\tkeepOtherChannels,\n\t\t\t\t\t\t\tkeepAlpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetChannelAccordingToSaturationValue (ComputeOn channetToSet, \n\t\t\t\tfloat valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,\n\t\t\t\tbool keepAlpha)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat vR = hsvR [1];\n\n\t\t\t\t\tif (vR >= minTol && vR <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], \n\t\t\t\t\t\t\tkeepOtherChannels,\n\t\t\t\t\t\t\tkeepAlpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetChannelAccordingToHueValue (ComputeOn channetToSet, \n\t\t\t\tfloat valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,\n\t\t\t\tbool keepAlpha)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat vR = hsvR [0];\n\n\t\t\t\t\tif (vR >= minTol && vR <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], \n\t\t\t\t\t\t\tkeepOtherChannels,\n\t\t\t\t\t\t\tkeepAlpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetChannelAccordingToGreenValue (ComputeOn channetToSet, \n\t\t\t\tfloat valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,\n\t\t\t\tbool keepAlpha)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].g >= minTol && r [i].g <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], \n\t\t\t\t\t\t\tkeepOtherChannels,\n\t\t\t\t\t\t\tkeepAlpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetChannelAccordingToBlueValue (ComputeOn channetToSet, \n\t\t\t\tfloat valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,\n\t\t\t\tbool keepAlpha)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].b >= minTol && r [i].b <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], \n\t\t\t\t\t\t\tkeepOtherChannels,\n\t\t\t\t\t\t\tkeepAlpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetChannelAccordingToRedValue (ComputeOn channetToSet, \n\t\t\t\tfloat valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,\n\t\t\t\tbool keepAlpha)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].r >= minTol && r [i].r <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], \n\t\t\t\t\t\t\tkeepOtherChannels,\n\t\t\t\t\t\t\tkeepAlpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color [] SetChannelAccordingToAlphaValue (ComputeOn channetToSet, \n\t\t\t\tfloat valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,\n\t\t\t\tbool keepAlpha)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat minTol = valueToRead_F - halfReadTolerance_F;\n\n\t\t\t\tfloat maxTol = valueToRead_F + halfReadTolerance_F;\n\n\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r [i].a >= minTol && r [i].a <= maxTol)\n\t\t\t\t\t{\n\t\t\t\t\t\tr [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], \n\t\t\t\t\t\t\tkeepOtherChannels,\n\t\t\t\t\t\t\tkeepAlpha);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tstatic Color SetChannelAccordingTo (ComputeOn channetToSet, float valueToSet_F, Color r, \n\t\t\t\tbool keepOtherChannels,\n\t\t\t\tbool keepAlpha)\n\t\t\t{\n\t\t\t\tswitch (channetToSet)\n\t\t\t\t{\n\t\t\t\tcase ComputeOn.alpha:\n\t\t\t\t\tif (keepOtherChannels)\n\t\t\t\t\t\tr = new Color (r.r, r.g, r.b, valueToSet_F);\n\t\t\t\t\telse\n\t\t\t\t\t\tr = new Color (0f, 0f, 0f, valueToSet_F);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.blue:\n\t\t\t\t\tif (keepOtherChannels)\n\t\t\t\t\t\tr = new Color (r.r, r.g, valueToSet_F, r.a);\n\t\t\t\t\telse\n\t\t\t\t\t\tif (keepAlpha)\n\t\t\t\t\t\t\tr = new Color (0f, 0f, valueToSet_F, r.a);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tr = new Color (0f, 0f, valueToSet_F, 0f);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.green:\n\t\t\t\t\tif (keepOtherChannels)\n\t\t\t\t\t\tr = new Color (r.r, valueToSet_F, r.b, r.a);\n\t\t\t\t\telse\n\t\t\t\t\t\tif (keepAlpha)\n\t\t\t\t\t\t\tr = new Color (0f, valueToSet_F, 0f, r.a);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tr = new Color (0f, valueToSet_F, 0f, 0f);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.hue:\n\t\t\t\t\tif (keepOtherChannels)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat a = r.a;\n\n\t\t\t\t\t\tfloat [] hsv = ColorsArithmetic.RGBToHSV (r);\n\n\t\t\t\t\t\tr = Color.HSVToRGB (valueToSet_F, hsv [1], hsv [2]);\n\n\t\t\t\t\t\tr = new Color (r.r, r.g, r.b, a);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat a = r.a;\n\n\t\t\t\t\t\tr = Color.HSVToRGB (valueToSet_F, 1f, 1f);\n\n\n\t\t\t\t\t\tr = new Color (r.r, r.g, r.b, a);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.red:\t\t\n\t\t\t\t\tif (keepOtherChannels)\n\t\t\t\t\t\tr = new Color (valueToSet_F, r.g, r.b, r.a);\n\n\t\t\t\t\telse\n\n\t\t\t\t\t\tif (keepAlpha)\n\t\t\t\t\t\t\tr = new Color (valueToSet_F, 0f, 0f, r.a);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tr = new Color (valueToSet_F, 0f, 0f, 0f);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.saturation:\n\t\t\t\t\tif (keepOtherChannels)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat a = r.a;\n\n\t\t\t\t\t\tfloat [] hsv = ColorsArithmetic.RGBToHSV (r);\n\n\t\t\t\t\t\tr = Color.HSVToRGB (hsv [0], valueToSet_F, hsv [2]);\n\n\t\t\t\t\t\tr = new Color (r.r, r.g, r.b, a);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat a = r .a;\n\n\t\t\t\t\t\tr = Color.HSVToRGB (1f, valueToSet_F, 1f);\n\n\n\t\t\t\t\t\tr = new Color (r.r, r.g, r.b, a);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.value:\n\t\t\t\t\tif (keepOtherChannels)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat a = r.a;\n\n\t\t\t\t\t\tfloat [] hsv = ColorsArithmetic.RGBToHSV (r);\n\n\t\t\t\t\t\tr = Color.HSVToRGB (hsv [0], hsv [1], valueToSet_F);\n\n\t\t\t\t\t\tr = new Color (r.r, r.g, r.b, a);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat a = r.a;\n\n\t\t\t\t\t\tr = Color.HSVToRGB (1f, 1f, valueToSet_F);\n\n\t\t\t\t\t\tr = new Color (r.r, r.g, r.b, a);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\n\n\n\t\t\tpublic static Color [] SetChannel (Texture2D tex, ComputeOn cO, int v)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfloat vF = (float)v / 255f;\n\n\t\t\t\tswitch (cO)\n\t\t\t\t{\n\t\t\t\tcase ComputeOn.alpha:\n\t\t\t\t\tr = SetAlphaColors (tex, vF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.blue:\n\t\t\t\t\tr = SetBlueColors (tex, vF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.green:\n\t\t\t\t\tr = SetGreenColors (tex, vF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.hue:\n\t\t\t\t\tr = SetHueColors (tex, vF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.red:\n\t\t\t\t\tr = SetRedColors (tex, vF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.saturation:\n\t\t\t\t\tr = SetSaturationColors (tex, vF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.value:\n\t\t\t\t\tr = SetValueColors (tex, vF);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetRedColors (Texture2D tex, float v)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tr [i] = new Color (v, r [i].g, r [i].b, r [i].a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetGreenColors (Texture2D tex, float v)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tr [i] = new Color (r [i].r, v, r [i].b, r [i].a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetBlueColors (Texture2D tex, float v)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, v, r [i].a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetAlphaColors (Texture2D tex, float v)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, v);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetHueColors (Texture2D tex, float v)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat a = r [i].a;\n\n\t\t\t\t\tfloat [] hsv = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tr [i] = Color.HSVToRGB (v, hsv [1], hsv [2]);\n\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetSaturationColors (Texture2D tex, float v)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat a = r [i].a;\n\n\t\t\t\t\tfloat [] hsv = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tr [i] = Color.HSVToRGB (hsv [0], v, hsv [2]);\n\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetValueColors (Texture2D tex, float v)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat a = r [i].a;\n\n\t\t\t\t\tfloat [] hsv = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tr [i] = Color.HSVToRGB (hsv [0], hsv [1], v);\n\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tpublic static Color [] SetChannel (Texture2D tex, ComputeOn cO, Texture2D tex_0)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tColor [] c_0 = tex_0.GetPixels ();\n\n\t\t\t\tswitch (cO)\n\t\t\t\t{\n\t\t\t\tcase ComputeOn.alpha:\n\t\t\t\t\tr = SetAlphaColors (tex, c_0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.blue:\n\t\t\t\t\tr = SetBlueColors (tex, c_0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.green:\n\t\t\t\t\tr = SetGreenColors (tex, c_0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.hue:\n\t\t\t\t\tr = SetHueColors (tex, c_0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.red:\n\t\t\t\t\tr = SetRedColors (tex, c_0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.saturation:\n\t\t\t\t\tr = SetSaturationColors (tex, c_0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.value:\n\t\t\t\t\tr = SetValueColors (tex, c_0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetRedColors (Texture2D tex, Color [] c_0)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tr [i] = new Color (c_0 [i].r, r [i].g, r [i].b, r [i].a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetGreenColors (Texture2D tex, Color [] c_0)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tr [i] = new Color (r [i].r, c_0 [i].g, r [i].b, r [i].a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetBlueColors (Texture2D tex, Color [] c_0)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, c_0 [i].b, r [i].a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetAlphaColors (Texture2D tex, Color [] c_0)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, c_0 [i].a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetHueColors (Texture2D tex, Color [] c_0)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat a = r [i].a;\n\n\t\t\t\t\tfloat [] hsv = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat v = ColorsArithmetic.RGBToHSV (c_0 [i]) [0];\n\n\t\t\t\t\tr [i] = Color.HSVToRGB (v, hsv [1], hsv [2]);\n\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetSaturationColors (Texture2D tex, Color [] c_0)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat a = r [i].a;\n\n\t\t\t\t\tfloat [] hsv = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat v = ColorsArithmetic.RGBToHSV (c_0 [i]) [1];\n\n\t\t\t\t\tr [i] = Color.HSVToRGB (hsv [0], v, hsv [2]);\n\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SetValueColors (Texture2D tex, Color  [] c_0)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat a = r [i].a;\n\n\t\t\t\t\tfloat [] hsv = ColorsArithmetic.RGBToHSV (r [i]);\n\n\t\t\t\t\tfloat v = ColorsArithmetic.RGBToHSV (c_0 [i]) [2];\n\n\t\t\t\t\tr [i] = Color.HSVToRGB (hsv [0], hsv [1], v);\n\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, a);\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\n\n\t\t\tpublic static Color [] ExtractChannel (Texture2D tex, ComputeOn cO, ExtractResultType ert)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tswitch (cO)\n\t\t\t\t{\n\t\t\t\tcase ComputeOn.alpha:\n\t\t\t\t\tr = AlphaColors (tex, ert);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.blue:\n\t\t\t\t\tr = BlueColors (tex, ert);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.green:\n\t\t\t\t\tr = GreenColors (tex, ert);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.hue:\n\t\t\t\t\tr = HueColors (tex, ert);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.red:\n\t\t\t\t\tr = RedColors (tex, ert);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.saturation:\n\t\t\t\t\tr = SaturationColors (tex, ert);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ComputeOn.value:\n\t\t\t\t\tr = ValueColors (tex, ert);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] RedColors (Texture2D tex, ExtractResultType ert)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat v = r [i].r;\n\n\t\t\t\t\tswitch (ert)\n\t\t\t\t\t{\n\t\t\t\t\tcase ExtractResultType.AsIt:\n\t\t\t\t\t\tr [i] = new Color (v, 0f, 0f, r [i].a);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ExtractResultType.Grayscale:\n\t\t\t\t\t\tr [i] = new Color (v, v, v, r [i].a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] GreenColors (Texture2D tex, ExtractResultType ert)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat v = r [i].g;\n\n\t\t\t\t\tswitch (ert)\n\t\t\t\t\t{\n\t\t\t\t\tcase ExtractResultType.AsIt:\n\t\t\t\t\t\tr [i] = new Color (0f, v, 0f, r [i].a);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ExtractResultType.Grayscale:\n\t\t\t\t\t\tr [i] = new Color (v, v, v, r [i].a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] BlueColors (Texture2D tex, ExtractResultType ert)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat v = r [i].b;\n\n\t\t\t\t\tswitch (ert)\n\t\t\t\t\t{\n\t\t\t\t\tcase ExtractResultType.AsIt:\n\t\t\t\t\t\tr [i] = new Color (0f, 0f, v, r [i].a);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ExtractResultType.Grayscale:\n\t\t\t\t\t\tr [i] = new Color (v, v, v, r [i].a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] AlphaColors (Texture2D tex, ExtractResultType ert)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat v = r [i].a;\n\n\t\t\t\t\tswitch (ert)\n\t\t\t\t\t{\n\t\t\t\t\tcase ExtractResultType.AsIt:\n\t\t\t\t\t\tr [i] = new Color (0f, 0f, 0f, v);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ExtractResultType.Grayscale:\n\t\t\t\t\t\tr [i] = new Color (v, v, v, 1f);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] ValueColors (Texture2D tex, ExtractResultType ert)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat a = r [i].a;\n\n\t\t\t\t\tfloat v = ColorsArithmetic.RGBToHSV (r [i]) [2];\n\n\t\t\t\t\tswitch (ert)\n\t\t\t\t\t{\n\t\t\t\t\tcase ExtractResultType.AsIt:\n\t\t\t\t\t\tr [i] = Color.HSVToRGB (1f, 1f, v);\n\n\t\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, a);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ExtractResultType.Grayscale:\n\t\t\t\t\t\tr [i] = new Color (v, v, v, a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SaturationColors (Texture2D tex, ExtractResultType ert)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat a = r [i].a;\n\n\t\t\t\t\tfloat v = ColorsArithmetic.RGBToHSV (r [i]) [1];\n\n\t\t\t\t\tswitch (ert)\n\t\t\t\t\t{\n\t\t\t\t\tcase ExtractResultType.AsIt:\n\t\t\t\t\t\tr [i] = Color.HSVToRGB (1f, v, 1f);\n\n\t\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, a);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ExtractResultType.Grayscale:\n\t\t\t\t\t\tr [i] = new Color (v, v, v, a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] HueColors (Texture2D tex, ExtractResultType ert)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat a = r [i].a;\n\n\t\t\t\t\tfloat v = ColorsArithmetic.RGBToHSV (r [i]) [0];\n\n\t\t\t\t\tswitch (ert)\n\t\t\t\t\t{\n\t\t\t\t\tcase ExtractResultType.AsIt:\n\t\t\t\t\t\tr [i] = Color.HSVToRGB (v, 1f, 1f);\n\n\t\t\t\t\t\tr [i] = new Color (r [i].r, r [i].g, r [i].b, a);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ExtractResultType.Grayscale:\n\t\t\t\t\t\tr [i] = new Color (v, v, v, a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\n\t\t\n\t\t\tpublic static Color [] SwitchColors (Texture2D tex, SwitchColorsType sct)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tswitch (sct)\n\t\t\t\t{\n\t\t\t\tcase TextureComputer.SwitchColorsType.GreenBlue:\n\t\t\t\t\tr = SwitchGreenBlueColors (tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TextureComputer.SwitchColorsType.RedBlue:\n\t\t\t\t\tr = SwitchRedBlueColors (tex);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TextureComputer.SwitchColorsType.RedGreen:\n\t\t\t\t\tr = SwitchRedGreenColors (tex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\t\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SwitchRedGreenColors (Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\n\t\t\t\t\tr [i] = new Color (r [i].g, r [i].r, r [i].b, r [i].a);\n\n\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SwitchRedBlueColors (Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\t\t\t\n\n\t\t\t\t\tr [i] = new Color (r [i].b, r [i].g, r [i].r, r [i].a);\n\n\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tstatic Color [] SwitchGreenBlueColors (Texture2D tex)\n\t\t\t{\n\t\t\t\tColor [] r = tex.GetPixels ();\n\n\t\t\t\tfor (int i = 0; i < r.Length; i++)\n\t\t\t\t{\n\n\n\t\t\t\t\tr [i] = new Color (r [i].r, r [i].b, r [i].g, r [i].a);\n\n\n\t\t\t\t}\n\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\n\t\t\n\t\t\n\n\t\t}\n\n";


				public const string colorArithmeticClass = "\t\tpublic class ColorsArithmetic \n\t\t{\t\n\t\t\tpublic static Color RGB_255_To_Normalized (float r, float g, float b, float a)\n\t\t\t{\n\t\t\t\tfloat _255 = 255f;\n\t\t\t\t\n\t\t\t\treturn new Color (r/_255, g/_255, b/_255, a);\n\t\t\t}\n\n\t\t\tpublic static Color Opacity (Color c0, Color c1, float o)\n\t\t\t{\n\t\t\t\to = Mathf.Clamp (o, 0f, 1f);\n\t\t\t\t\n\t\t\t\treturn o * c0 + (1f - o) * c1;\n\t\t\t}\n\n\t\t\tpublic static Color Darken (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tMathf.Min (c0.r, c1.r), \n\t\t\t\t\tMathf.Min (c0.g, c1.g), \n\t\t\t\t\tMathf.Min (c0.b, c1.b), \n\t\t\t\t\tMathf.Min (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tpublic static Color Lighten (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tMathf.Max (c0.r, c1.r), \n\t\t\t\t\tMathf.Max (c0.g, c1.g), \n\t\t\t\t\tMathf.Max (c0.b, c1.b), \n\t\t\t\t\tMathf.Max (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tpublic static Color Multiply (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tc0.r * c1.r, \n\t\t\t\t\tc0.g * c1.g, \n\t\t\t\t\tc0.b * c1.b, \n\t\t\t\t\tc0.a * c1.a);\n\t\t\t}\n\n\t\t\tpublic static Color Screen (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\t1f - (1f-c0.r) * (1f-c1.r), \n\t\t\t\t\t1f - (1f-c0.g) * (1f-c1.g), \n\t\t\t\t\t1f - (1f-c0.b) * (1f-c1.b), \n\t\t\t\t\t1f - (1f-c0.a) * (1f-c1.a));\n\t\t\t}\n\n\t\t\tpublic static Color ColorDodge (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tColorDodge (c0.r, c1.r), \n\t\t\t\t\tColorDodge (c0.g, c1.g), \n\t\t\t\t\tColorDodge (c0.b, c1.b), \n\t\t\t\t\tColorDodge (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float ColorDodge (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 == 1f)\n\t\t\t\t\tf = 1f;\n\t\t\t\telse\n\t\t\t\t\tf = Mathf.Min (1f, f1 / (1f - f0));\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\t\t\tpublic static Color ColorBurn (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tColorBurn (c0.r, c1.r), \n\t\t\t\t\tColorBurn (c0.g, c1.g), \n\t\t\t\t\tColorBurn (c0.b, c1.b), \n\t\t\t\t\tColorBurn (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float ColorBurn (float f0, float f1)\n\t\t\t{\n\t\t\t\treturn f0 == 0f ? 0f : Mathf.Max (0f, (1f - (1f - f1)) / f0); \n\t\t\t}\n\n\t\t\tpublic static Color LinearDodge (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tc0.r + c1.r, \n\t\t\t\t\tc0.g + c1.g, \n\t\t\t\t\tc0.b + c1.b, \n\t\t\t\t\tc0.a + c1.a);\n\t\t\t}\n\n\t\t\tpublic static Color LinearBurn (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tc0.r + c1.r - 1f, \n\t\t\t\t\tc0.g + c1.g - 1f, \n\t\t\t\t\tc0.b + c1.b - 1f, \n\t\t\t\t\tc0.a + c1.a - 1f);\n\t\t\t}\n\n\t\t\tpublic static Color Overlay (Color c0, Color c1)\n\t\t\t{\t\t\n\t\t\t\treturn new Color (\n\t\t\t\t\tOverlay (c0.r, c1.r),\n\t\t\t\t\tOverlay (c0.g, c1.g),\n\t\t\t\t\tOverlay (c0.b, c1.b),\n\t\t\t\t\tOverlay (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float Overlay (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\t\t\t\t\n\t\t\t\tif (f1 <= 0.5f)\n\t\t\t\t\tf = 2f * f0 * f1;\n\t\t\t\telse\n\t\t\t\t\tf = 1f - 2f * (1f - f0) * (1f - f1);\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\t\t\tpublic static Color HardLight (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tHardLight (c0.r, c1.r),\n\t\t\t\t\tHardLight (c0.g, c1.g),\n\t\t\t\t\tHardLight (c0.b, c1.b),\n\t\t\t\t\tHardLight (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float HardLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 <= 0.5f)\n\t\t\t\t\tf = 2f * f0 * f1;\n\t\t\t\telse\n\t\t\t\t\tf = 1f - 2f * (1f - f0) * (1f - f1);\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\t\t\tpublic static Color SoftLight (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tSoftLight (c0.r, c1.r),\n\t\t\t\t\tSoftLight (c0.g, c1.g),\n\t\t\t\t\tSoftLight (c0.b, c1.b),\n\t\t\t\t\tSoftLight (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float SoftLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 <= 0.5f)\n\t\t\t\t\tf = (2f * f0 - 1f) * (f1 - f1*f1) + f1;\n\t\t\t\telse\n\t\t\t\t\tf = (2f * f0 - 1f) * (Mathf.Pow(f1,0.5f) - f1) + f1;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\t\t\tpublic static Color VividLight (Color c0, Color c1)\n\t\t\t{\n\n\t\t\t\treturn new Color (\n\t\t\t\t\tVividLight (c0.r, c1.r),\n\t\t\t\t\tVividLight (c0.g, c1.g),\n\t\t\t\t\tVividLight (c0.b, c1.b),\n\t\t\t\t\tVividLight (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float VividLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 <= 0.5f) \n\t\t\t\t{\n\t\t\t\t\tif (f0 == 0f)\n\t\t\t\t\t\tf = 0f;\n\t\t\t\t\telse\n\t\t\t\t\t\tf = 1f - (0.5f * (1f - f1) / f0);\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tif (f0 == 1f)\n\t\t\t\t\t\tf = 1f;\n\t\t\t\t\telse\n\t\t\t\t\t\tf = 0.5f * (f1 / (1f - f0));\n\t\t\t\t}\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color LinearLight (Color c0, Color c1)\n\t\t\t{\n\t\t\t\t\n\t\t\t\treturn new Color (\n\t\t\t\t\tLinearLight (c0.r, c1.r),\n\t\t\t\t\tLinearLight (c0.g, c1.g),\n\t\t\t\t\tLinearLight (c0.b, c1.b),\n\t\t\t\t\tLinearLight (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float LinearLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tf = f1 + 2f*f0 - 1f;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color PinLight (Color c0, Color c1)\n\t\t\t{\n\t\t\t\t\n\t\t\t\treturn new Color (\n\t\t\t\t\tPinLight (c0.r, c1.r),\n\t\t\t\t\tPinLight (c0.g, c1.g),\n\t\t\t\t\tPinLight (c0.b, c1.b),\n\t\t\t\t\tPinLight (c0.a, c1.a));\n\n\t\t\t}\n\n\t\t\tstatic float PinLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f = 0f;\n\n\t\t\t\tif (f1 <= 2f * f0 - 1f)\n\t\t\t\t\tf = 2f * f0 - 1f;\n\t\t\t\telse if (f1 > 2f * f0 - 1f && f1 <= 2f * f0)\n\t\t\t\t\tf = f1;\n\t\t\t\telse if (f1 > 2f * f0)\n\t\t\t\t\tf = 2 * f0;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color HardMix (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tHardMix (c0.r, c1.r),\n\t\t\t\t\tHardMix (c0.g, c1.g),\n\t\t\t\t\tHardMix (c0.b, c1.b),\n\t\t\t\t\tHardMix (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float HardMix (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 < 1f - f1)\n\t\t\t\t\tf = 0f;\n\t\t\t\telse\n\t\t\t\t\tf = 1f;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color Difference (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tDifference (c0.r, c1.r),\n\t\t\t\t\tDifference (c0.g, c1.g),\n\t\t\t\t\tDifference (c0.b, c1.b),\n\t\t\t\t\tDifference (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float Difference (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tf = Mathf.Abs (f0 - f1);\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color Exclusion (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tExclusion (c0.r, c1.r),\n\t\t\t\t\tExclusion (c0.g, c1.g),\n\t\t\t\t\tExclusion (c0.b, c1.b),\n\t\t\t\t\tExclusion (c0.a, c1.a));\n\n\t\t\t}\n\n\t\t\tstatic float Exclusion (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tf = f0 + f1 - 2f * f0 * f1;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color Hue (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn Color.HSVToRGB (RGBToHSV (c0) [0], RGBToHSV (c1) [1], RGBToHSV (c1) [2]);\n\t\t\t}\n\n\t\t\tpublic static Color Saturation (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn Color.HSVToRGB (RGBToHSV (c1) [0], RGBToHSV (c0) [1], RGBToHSV (c1) [2]);\n\t\t\t}\n\n\t\t\tpublic static Color Color_ (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn Color.HSVToRGB (RGBToHSV (c0) [0], RGBToHSV (c0) [1], RGBToHSV (c1) [2]);\n\t\t\t}\n\n\t\t\tpublic static Color Luminosity (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn Color.HSVToRGB (RGBToHSV (c1) [0], RGBToHSV (c1) [1], RGBToHSV (c0) [2]);\n\t\t\t}\n\n\t\t\tpublic static float [] RGBToHSV (Color c)\n\t\t\t{\n\t\t\t\tfloat [] retVal = new float[3];\n\n\t\t\t\tColor.RGBToHSV (c, out retVal [0], out retVal [1], out retVal [2]);\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\n\n\t\t\tpublic static Color Add (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tc0.r + c1.r, \n\t\t\t\t\tc0.g + c1.g, \n\t\t\t\t\tc0.b + c1.b, \n\t\t\t\t\tc0.a + c1.a);\n\t\t\t}\n\n\t\t\tpublic static Color Subtract (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn c0 - c1;\n\t\t\t} \n\t\t}\n\n";


				public const string channel = "\t\tpublic TextureComputer.ComputeOn channel;\n\n";

				public const string channels =
					"\t\tpublic TextureComputer.ComputeOn[] channels = new TextureComputer.ComputeOn[2];\n\n";

				public const string channelAll = channel + "\n" + channels;


				public const string computeColorType =
					"\t\tpublic enum ComputeColorType\n\t\t{\n\t\t\tget,\n\n\n\t\t\trandomHsv,\n\n\t\t\tdarken,\n\n\t\t\tlighten,\n\n\t\t\tmultiply,\n\n\t\t\tscreen,\n\n\t\t\tcolorDodge,\n\n\t\t\tcolorBurn,\n\n\t\t\tlinearDodge,\n\n\t\t\tlinearBurn,\n\n\t\t\toverlay,\n\n\t\t\thardLight,\n\n\t\t\tsoftLight,\n\n\t\t\tvividLight,\n\n\t\t\tlinearLight,\n\n\t\t\tpinLight,\n\n\t\t\thardMix,\n\n\t\t\tdifference,\n\n\t\t\texclusion,\n\n\t\t\thue,\n\n\t\t\tsaturation,\n\n\t\t\tcolor,\n\n\t\t\tluminosity,\n\n\t\t\tadd,\n\n\t\t\tsubtract\n\t\t}\n\n" +
					"\t\tComputeColorType computeColorType;\n\n";

				public const string textureEncodeType = 
					"\t\tpublic enum TextureEncodeType\n\t\t{\n\t\t\tpng,\n\t\t\t\n\t\t\tjpg,\n\t\t}\n\n" +
					"\t\tTextureEncodeType textureEncodeType;\n\n";

				public const string WriteTextureFormat = 
					"\t\tpublic enum WriteTextureFormat\n\t\t{\n\t\t\tARGB32,\n\n\t\t\tRGBA32,\n\n\t\t\tRGB24, \n\n\t\t\tAlpha8,\n\n\n\t\t\tRHalf,\n\n\t\t\tRGHalf,\n\n\t\t\tRGBAHalf,\n\n\n\t\t\tRFloat,\n\n\t\t\tRGFloat,\n\n\t\t\tRGBAFloat\n\t\t}" +
					"\n\t\tWriteTextureFormat writeTextureFormat;\n\n";


				public const string shadersGetGlobalPropertieMode = "\t\tpublic enum ShadersGetGlobalPropertieMode\n\t\t{\n\t\t\tbyName,\n\n\t\t\tbyNameID,\n\t\t}\n\n\t\tpublic ShadersGetGlobalPropertieMode shadersGetGlobalPropertieMode;\n\n";



				public const string audioClip_local = "\t\tpublic AudioClip audioClipValue_Local = null;\n";


				public const string keyCode = "\t\tpublic KeyCode keyCode;" + "\n\n";


				public const string boolValue = "\t\tpublic bool boolValue = false;" + "\n\n";
				public const string boolValues = "\t\tpublic bool [] boolValues = new bool[2];" + "\n\n";
				public const string boolAll = boolValue + boolValues;

				public const string colorValue = "\t\tpublic Color colorValue;" + "\n\n";
				public const string colorValues = "\t\tpublic Color[] colorValues = new Color[2];" + "\n\n";
				public const string colorAll = colorValue + "\n" + colorValues;

				public const string texture2DValue = "\t\tpublic Texture2D texture2DValue;" + "\n\n";
				public const string texture2DValues = "\t\tpublic Texture2D[] texture2DValues = new Texture2D[2];" + "\n\n";
				public const string texture2DAll = texture2DValue + "\n" + texture2DValues;


				public const string materialValue = "\t\tpublic Material materialValue;" + "\n\n";
				public const string materialValues = "\t\tpublic Material[] materialValues = new Material[2];" + "\n\n";
				public const string materialAll = materialValue + "\n" + materialValues;

				public const string floatValue = "\t\tpublic float floatValue = 0f;" + "\n\n";
				public const string floatValues = "\t\tpublic float [] floatValues = new float[3];" + "\n\n";
				public const string floatAll = floatValue + floatValues;

				public const string vector4Value = "\t\tpublic Vector4 vector4Value;" + "\n\n";
				public const string vector4Values = "\t\tpublic Vector4 [] vector4Values = new Vector4[2];" + "\n\n";
				public const string vector4All = vector4Value + vector4Values;

				public const string vector3Value = "\t\tpublic Vector3 vector3Value = new Vector3 ();" + "\n\n";
				public const string vector3Values = "\t\tpublic Vector3 [] vector3Values = new Vector3[2];" + "\n\n";
				public const string vector3All = vector3Value + vector3Values;

				public const string vector2Value = "\t\tpublic Vector2 vector2Value = new Vector2 ();" + "\n\n";
				public const string vector2Values = "\t\tpublic Vector2 [] vector2Values = new Vector2[2];" + "\n\n";
				public const string vector2All = vector2Value + vector2Values;

				public const string intValue = "\t\tpublic int intValue = 0;" + "\n\n";
				public const string intValues = "\t\tpublic int [] intValues = new int[3];" +"\n\n";
				public const string intAll = intValue + intValues;


				public const string rectValue = "\t\tpublic Rect rectValue;" + "\n\n";
				public const string rectValues = "\t\tpublic Rect [] rectValues = new Rect[2];" + "\n\n";
				public const string rectAll = rectValue + rectValues;

				public const string stringValue = "\t\tpublic string stringValue;" + "\n\n";
				public const string stringValues = "\t\tpublic string [] stringValues = new string[2];" + "\n\n";
				public const string stringAll = stringValue + stringValues;

				public const string StringOperations = 
					"\t\tpublic enum StringOperations \n\t\t{\n\t\t\tContains,\n\n\t\t\tEndsWith,\n\n\t\t\tGetHashCode,\n\n\t\t\tGetIndexOf,\n\n\t\t\tInsert,\n\n\t\t\tLastIndexOf,\n\n\t\t\tGetLength,\n\n\t\t\tPadLeft,\n\n\t\t\tPadRight,\n\n\t\t\tRemove,\n\n\t\t\tStartsWith,\n\n\t\t\tSubstring,\n\n\t\t\tToLower,\n\n\t\t\tToLowerInvariant,\n\n\t\t\tToUpper,\n\n\t\t\tToUpperInvariant,\n\n\t\t\tTrim,\n\n\t\t\tTrimEnd,\n\n\t\t\tTrimStart,\n\n\t\t\ttoFloat,\n\n\t\t\ttoInt,\n\t\t}; \n\t\tpublic StringOperations stringOperations;\n";
				
				public const string textAnchor = "\t\tpublic TextAnchor textAnchor;\n\n";


				public const string raycastHit = "\t\tRaycastHit hit;\n\n";

				public const string raycast_2D_hit = "\t\tRaycastHit2D hit2D;\n\n";

				public const string raycastHits = "\t\tRaycastHit [] hits;\n\n";

				public const string raycastHitValues = "\t\tpublic Vector3 raycastHitBarycentricCoordinate;\n\n\t\tpublic int raycastHitTriangleIndex;\n\n\n\t\tpublic Vector3 raycastHitPoint;\n\n\t\tpublic Vector3 raycastHitNormal;\n\n\t\tpublic float raycastHitDistance;\n\n\n\t\tpublic GameObject raycastHitGameObject;\n\n\n\t\tpublic Vector2 raycastHitLightmapCoord;\n\n\t\tpublic Vector2 raycastHittextureCoord;\n\n\t\tpublic Vector2 raycastHittextureCoord2;\n\n";

				public const string raycast_2D_hitValues = "\t\tpublic GameObject hit2D_gameObject;\n\n\t\tpublic Vector2 hit2D_centroid;\n\n\t\tpublic float hit2D_distance;\n\n\t\tpublic float hit2D_fraction;\n\n\t\tpublic Vector2 hit2D_normal;\n\n\t\tpublic Vector2 hit2D_point;\n\n";

				public const string shaderValue = "\t\tpublic Shader shaderValue;" + "\n\n";
				public const string shaderValues = "\t\tpublic Shader[] shaderValues = new Shader[2];" + "\n\n";
				public const string shaderAll = shaderValue + shaderValues;

				public const string m44Value_entier = "\t\tpublic Matrix4x4 m44Value_entier;" + "\n\n";
				public const string m44Value_Input_entier = "\t\tpublic Matrix4x4 [] m44Value_Input_entier = new Matrix4x4[2];" + "\n\n";
				public const string m44ValueAndProperties = "\t\tpublic float [] m44Value = new float[16];\n\n\t\tpublic float m44ValueDeterminant;\n\n\t\tpublic bool m44ValueIsIdentity;\n\n\t\tpublic bool m44ValueInvertible;" + "\n\n";
				public const string m44Value = "\t\tpublic float [] m44Value = new float[16];" + "\n\n";


				public const string cam = "\t\tCamera cam;" + "\n\n";
				public const string cam_1 = "\t\tCamera cam_1;" + "\n\n";

				public const string cam_doIt_identifiedObjects_gameObjectAll = 
					cam + doIt + identifiedObjects + gameObjectAll;

				public const string opaqueSortMode = "\t\tpublic UnityEngine.Rendering.OpaqueSortMode opaqueSortMode;" + "\n\n";
				public const string depthTextureMode = "\t\tpublic DepthTextureMode depthTextureMode;" + "\n\n";
				public const string transparencySortMode = "\t\tpublic TransparencySortMode transparencySortMode;" + "\n\n";
				public const string renderingPath = "\t\tpublic RenderingPath renderingPath;" + "\n\n";
				public const string computeCameraType = "\t\tpublic enum ComputeCameraType\n\t\t{\n\t\t\tScreenPointToRay,\n\n\t\t\tScreenToViewportPoint,\n\n\n\t\t\tViewportPointToRay,\n\n\t\t\tViewportToScreenPoint,\n\n\n\t\t\tViewportToWorldPoint,\n\n\t\t\tWorldToViewportPoint,\n\n\n\t\t\tScreenToWorldPoint,\n\n\t\t\tWorldToScreenPoint,\n\n\n\n\n\n\t\t\tgetActualRenderingPath,\n\n\t\t\tgetRenderingPath,\n\n\t\t\tsetRenderingPath,\n\n\n\t\t\tgetAspectRatio,\n\n\t\t\tsetAspectRatio,\n\n\t\t\tResetAspect,\n\n\n\t\t\tgetFarClipPlane,\n\n\t\t\tsetFarClipPlane,\n\n\n\t\t\tgetNearClipPlane,\n\n\t\t\tsetNearClipPlane,\n\n\n\t\t\tgetFieldOfView,\n\n\t\t\tsetFieldOfView,\n\n\t\t\tResetFieldOfView,\n\n\n\t\t\tgetBackgroundColor,\n\n\t\t\tsetBackgroundColor,\n\n\n\t\t\tgetPixelHeight,\n\n\t\t\tgetPixelWidth,\n\n\n\t\t\tgetPixelRect,\n\n\t\t\tsetPixelRect,\n\n\n\t\t\tgetProjectionMatrix,\n\n\t\t\tsetProjectionMatrix,\n\n\t\t\tResetProjectionMatrix,\n\n\n\t\t\tCalculateObliqueMatrix,\n\n\n\t\t\tSetStereoProjectionMatrices,\n\n\t\t\tResetStereoProjectionMatrices,\n\n\n\t\t\tSetStereoViewMatrices,\n\n\t\t\tResetStereoViewMatrices,\n\n\n\n\t\t\tgetStereoEnabled,\n\n\n\t\t\tgetStereoConvergence,\n\n\t\t\tsetStereoConvergence,\n\n\n\t\t\tgetIsStereoMirrorMode,\n\n\t\t\tsetIsStereoMirrorMode,\n\n\n\t\t\tgetStereoSeparation,\n\n\t\t\tsetStereoSeparation,\n\n\n\n\n\n\t\t\tgetCameraToWorldMatrix,\n\n\n\t\t\tgetWorldToCameraMatrix,\n\n\t\t\tResetWorldToCameraMatrix,\n\n\n\t\t\tgetCullingMask,\n\n\t\t\tsetCullingMask,\n\n\n\t\t\tgetTransparencySortMode,\n\n\t\t\tsetTransparencySortMode,\n\n\n\t\t\tgetUseOcclusionCulling,\n\n\t\t\tsetUseOcclusionCulling,\n\n\n\t\t\tgetVelocity,\n\n\n\t\t\tgetDepth,\n\n\t\t\tsetDepth,\n\n\n\t\t\tgetDepthTextureMode,\n\n\t\t\tsetDepthTextureMode,\n\n\n\t\t\tgetEnabled,\n\n\t\t\tsetEnabled,\n\n\n\t\t\tCopySettingsToTheCamera,\n\n\n\t\t\tgetEventMask,\n\n\t\t\tsetEventMask,\n\n\n\n\n\n\t\t\tgetHdr,\n\n\t\t\tsetHdr,\n\n\n\t\t\tgetOpaqueSortMode,\n\n\t\t\tsetOpaqueSortMode,\n\n\n\t\t\tgetOrthographic,\n\n\t\t\tsetOrthographic,\n\n\n\t\t\tgetOrthographicSize,\n\n\t\t\tsetOrthographicSize,\n\n\n\n\n\n\t\t\tgetRectNormalizedToTheScreen,\n\n\t\t\tsetRectNormalizedToTheScreen,\n\n\n\t\t\tRenderManually,\n\n\t\t\tSetReplacementShader,\n\n\t\t\tRenderWithShader,\n\n\t\t\tResetReplacementShader,\n\n\n\t\t\tgetTargetDisplay,\n\n\t\t\tsetTargetDisplay,\n\t\t}" + "\n";
				public const string computeCameraTypeVariable = "\t\tpublic ComputeCameraType computeCameraType;" + "\n\n";

				public const string navMeshAgent = "\t\tUnityEngine.AI.NavMeshAgent navMeshAgent = null;" + "\n\n";
				public const string NavMeshHit = "\t\tNavMeshHit navMeshHit;\n\t\tpublic float NavMeshHit_distance;\n\t\tpublic bool NavMeshHit_hit;\n\t\tpublic int NavMeshHit_mask;\n\t\tpublic Vector3 NavMeshHit_normal;\n\t\tpublic Vector3 NavMeshHit_position;" + "\n\n";
				public const string offMeshLinkData = "\t\tpublic bool OffMeshLinkData_activated;\n\t\tpublic Vector3 OffMeshLinkData_startPosition;\n\t\tpublic Vector3 OffMeshLinkData_endPosition;\n\t\tpublic OffMeshLinkType OffMeshLinkData_Type;\n\t\tpublic bool OffMeshLinkData_valid;" + "\n\n";
				public const string navMeshAgentGv = "\t\tNavMeshAgent navMeshAgent = null;\n\t\tNavMeshHit navMeshHit;\n\t\tpublic float NavMeshHit_distance;\n\t\tpublic bool NavMeshHit_hit;\n\t\tpublic int NavMeshHit_mask;\n\t\tpublic Vector3 NavMeshHit_normal;\n\t\tpublic Vector3 NavMeshHit_position;\n\t\tpublic bool OffMeshLinkData_activated;\n\t\tpublic Vector3 OffMeshLinkData_startPosition;\n\t\tpublic Vector3 OffMeshLinkData_endPosition;\n\t\tpublic OffMeshLinkType OffMeshLinkData_Type;\n\t\tpublic bool OffMeshLinkData_valid;" + "\n\n";
				public const string computeNavMeshAgentType = "\t\tpublic enum ComputeNavMeshAgentType\n\t\t{\n\t\t\tgetRadius,\n\n\t\t\tsetRadius,\n\n\n\t\t\tgetHeight,\n\n\t\t\tsetHeight,\n\n\n\t\t\tgetBaseOffset,\n\n\t\t\tsetBaseOffset,\n\n\n\n\n\n\t\t\tgetAcceleration,\n\n\t\t\tsetAcceleration,\n\n\n\t\t\tActivateCurrentOffMeshLink,\n\n\n\t\t\tgetAngularSpeed,\n\n\t\t\tsetAngularSpeed,\n\n\t\t\tgetSpeed,\n\n\t\t\tsetSpeed,\n\n\n\t\t\tgetCurrentVelocity,\n\n\t\t\tsetCurrentVelocity,\n\n\n\t\t\tgetAreaMask,\n\n\t\t\tsetAreaMask,\n\n\n\t\t\tgetAutoBraking,\n\n\t\t\tsetAutoBraking,\n\n\n\t\t\tgetAutoRepath,\n\n\t\t\tsetAutoRepath,\n\n\n\t\t\tgetAutoTraverseOffMeshLink,\n\n\t\t\tsetAutoTraverseOffMeshLink,\n\n\n\t\t\tgetAvoidancePriority,\n\n\t\t\tsetAvoidancePriority,\n\n\n\n\n\n\t\t\t//CalculatePath,\n\n\n\t\t\tCompleteOffMeshLink,\n\n\n\t\t\tgetCurrentOffMeshLinkData,\n\n\t\t\tgetNextOffMeshLinkData,\n\n\n\t\t\tgetDesiredVelocity,\n\n\n\t\t\tgetDestination,\n\n\t\t\tsetDestination,\n\n\t\t\tSetDestinationWithReturn,\n\n\n\t\t\tFindClosestEdge,\n\n\n\t\t\tGetAreaCost,\n\n\t\t\tSetAreaCost,\n\n\n\t\t\tgetHasPath,\n\n\n\n\n\n\n\t\t\tgetIsOnNavMesh,\n\n\t\t\tgetIsOnOffMeshLink,\n\n\t\t\tgetIsPathStale,\n\n\n\t\t\tMove,\n\n\n\t\t\tgetNextPosition,\n\n\t\t\tsetNextPosition,\n\n\n\t\t\tsetObstacleAvoidanceType,\n\n\n\t\t\tgetIsPathPending,\n\n\n\t\t\tgetPathStatus,\n\n\n\t\t\tRayCast,\n\n\t\t\tgetRemainingDistance,\n\n\n\t\t\tResetPath,\n\n\t\t\tResume,\n\n\t\t\tStop,\n\n\n\t\t\tgetStoppingDistance,\n\n\t\t\tsetStoppingDistance,\n\n\n\t\t\tSamplePathPositionGetInfoFacingTheAgent,\n\n\n\t\t\tgetSteeringTarget,\n\n\n\t\t\tshouldTheAgentUpdateTheTransformPosition,\n\n\t\t\tisAgentUpdatingTransformPosition,\n\n\n\t\t\tshouldTheAgentUpdateTheTransformRotation,\n\n\t\t\tisAgentUpdatingTransformRotation,\n\n\n\t\t\tWarp,\n\t\t}" + "\n";
				public const string computeNavMeshAgentTypeVariable = "\t\tComputeNavMeshAgentType computeNavMeshAgentType;" + "\n\n";
				public const string obstacleAvoidanceType = "\t\tUnityEngine.AI.ObstacleAvoidanceType obstacleAvoidanceType;" + "\n\n";

				public const string navMeshAgent_doIt_identifiedObjects_gameObjectAll = 
					navMeshAgent + doIt + identifiedObjects + gameObjectAll;

				public const string rayValueOriginAndNNDirection = "\t\tpublic Ray rayValue;\n\n\t\tpublic Vector3 rayValueOrigin;\n\n\t\tpublic Vector3 rayDirectionValueNotNormalized;" + "\n\n";




				const string collider = "\t\tCollider collider = null;\n\n";
				const string boxCollider = "\t\tBoxCollider boxCollider = null;\n\n";
				const string capsuleCollider = "\t\tCapsuleCollider capsuleCollider = null;\n\n";
				const string meshCollider = "\t\tMeshCollider meshCollider = null;\n\n";
				const string sphereCollider = "\t\tSphereCollider sphereCollider = null;\n\n";

				const string collider2D = "\t\tCollider2D collider2D = null;\n\n";
				const string boxCollider2D = "\t\tBoxCollider2D boxCollider2D = null;\n\n";
				const string circleCollider2D = "\t\tCircleCollider2D circleCollider2D = null;\n\n";
				public const string collider2D_1 = "\t\tCollider2D collider2D_1 = null;\n\n";

				public const string sphereCollider_doIt_identifiedObjects_gameObjectAll = 
					sphereCollider + doIt + identifiedObjects + gameObjectAll;

				public const string meshCollider_doIt_identifiedObjects_gameObjectAll = 
					meshCollider + doIt + identifiedObjects + gameObjectAll;

				public const string collider_doIt_identifiedObjects_gameObjectAll = 
					collider + doIt + identifiedObjects + gameObjectAll;

				public const string boxCollider_doIt_identifiedObjects_gameObjectAll = 
					boxCollider + doIt + identifiedObjects + gameObjectAll;

				public const string capsuleCollider_doIt_identifiedObjects_gameObjectAll = 
					capsuleCollider + doIt + identifiedObjects + gameObjectAll;


				public const string collider2D_doIt_identifiedObjects_gameObjectAll = 
					collider2D + doIt + identifiedObjects + gameObjectAll;

				public const string boxCollider2D_doIt_identifiedObjects_gameObjectAll = 
					boxCollider2D + doIt + identifiedObjects + gameObjectAll;

				public const string circleCollider2D_doIt_identifiedObjects_gameObjectAll = 
					circleCollider2D + doIt + identifiedObjects + gameObjectAll;

				public const string unityText_doIt_identifiedObjects_gameObjectAll = 
					unityText + doIt + identifiedObjects + gameObjectAll;

				public const string uiImage_doIt_identifiedObjects_gameObjectAll = 
					uiImage + doIt + identifiedObjects + gameObjectAll;

				public const string uiButton_doIt_identifiedObjects_gameObjectAll = 
					uiButton + doIt + identifiedObjects + gameObjectAll;

				public const string bounds = "\t\tpublic Vector3 boundsCenterValue = new Vector3 ();\n\n\t\tpublic Vector3 boundsExtentsValue = new Vector3 ();\n\n\t\tpublic Vector3 boundsMaxValue = new Vector3 ();\n\n\t\tpublic Vector3 boundsMinValue = new Vector3 ();\n\n\t\tpublic Vector3 boundsSizeValue = new Vector3 ();\n\n";

				public const string physicMaterialCombine = "\t\tPhysicMaterialCombine physicMaterialCombine;\n\n";


				public const string particleSystem = "\t\tParticleSystem particleSystem = null;\n\n";

				public const string particleSystemScalingMode = "\t\tParticleSystemScalingMode particleSystemScalingMode;\n\n";

				public const string particleSystemSimulationSpace = "\t\tParticleSystemSimulationSpace particleSystemSimulationSpace;\n\n";

				public const string psMain = "\t\tpublic ParticleSystem.MainModule psMain;\n\n";

				public const string particleSystem_doIt_identifiedObjects_gameObjectAll = 
					particleSystem + doIt + identifiedObjects + gameObjectAll + psMain;




				const string renderer = "\t\tRenderer renderer = null;\n\n";
				const string lineRenderer = "\t\tLineRenderer lineRenderer = null;\n\n";
				const string canvasRenderer = "\t\tCanvasRenderer canvasRenderer = null;\n\n";
				const string spriteRenderer = "\t\tSpriteRenderer spriteRenderer = null;\n\n";

				public const string renderer_doIt_identifiedObjects_gameObjectAll = 
					renderer + doIt + identifiedObjects + gameObjectAll;

				public const string lineRenderer_doIt_identifiedObjects_gameObjectAll = 
					lineRenderer + doIt + identifiedObjects + gameObjectAll;

				public const string canvasRenderer_doIt_identifiedObjects_gameObjectAll = 
					canvasRenderer + doIt + identifiedObjects + gameObjectAll;

				public const string spriteRenderer_doIt_identifiedObjects_gameObjectAll = 
					spriteRenderer + doIt + identifiedObjects + gameObjectAll;



				public const string forceMode = "\t\tForceMode forceMode;\n\n";

				public const string forceMode2D = "\t\tForceMode2D forceMode2D;\n\n";

				const string rigidBody = "\t\tRigidbody rigidBody = null;\n\n";

				const string rigidBody2D = "\t\tRigidbody2D rigidBody2D = null;\n\n";

				public const string rigidBody_doIt_identifiedObjects_gameObjectAll = 
					rigidBody + doIt + identifiedObjects + gameObjectAll;

				public const string rigidBody2D_doIt_identifiedObjects_gameObjectAll = 
					rigidBody2D + doIt + identifiedObjects + gameObjectAll;



				const string transform = "\t\tTransform transform_ = null;\n\n";

				public const string transform_doIt_identifiedObjects_gameObjectAll = 
					transform + doIt + identifiedObjects + gameObjectAll;


				const string audioSource = "\t\tAudioSource audioSource_ = null;\n\n";

				public const string audioSource_doIt_identifiedObjects_gameObjectAll = 
					audioSource + doIt + identifiedObjects + gameObjectAll;



				public const string materialGlobalIlluminationFlags = "\t\tMaterialGlobalIlluminationFlags materialGlobalIlluminationFlags;";



				public const string doIt_identifiedObjects_gameObjectAll = 
					doIt + identifiedObjects + gameObjectAll;

				public const string doIt = "\t\tpublic bool doIT = false;" + "\n\n";

				//public const string identifiedObjects = "\t\tIdentifiedAssets identifiedObjects;" + "\n\n";
				//public const string identifiedObjects = "\t\tGameObject [] identifiedObjects;" + "\n\n";

				public const string gameObjectValue = "\t\tpublic GameObject gameObjectValue = null;" + "\n\n";
				public const string gameObjectValues = "\t\tpublic GameObject [] gameObjectValues = new GameObject[2];" + "\n\n";
				public const string gameObjectAll = gameObjectValue + gameObjectValues;

				public const string animationCurve = "\t\tAnimationCurve animationCurve_;\n";
			}

			public class ConstructorExpr
			{
				public const string unityEngineRandomInitState = 
					"\t\t\tUnityEngine.Random.InitState (intValues [2]);\n";

				public const string mddtGameObjectHolder = 
					"\t\t\tmddtGameObjectHolder = GameObject.Find (\n" +
					"\t\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer.gameObjectHolderName);\n\n";

				public const string mdeGameObjectHolder = 
					"\t\t\tmdeGameObjectHolder = GameObject.Find (\n" +
					"\t\t\t\tScriptsCreatedByDiamond.MezanixDiamondEvents.gameObjectHolderName);\n\n";

				public const string downTimeCountForBoolImpulse = "\t\t\tfloatValues [0] = Mathf.Max (0f, floatValues [0]);\n\t\t\tdownCounterForBoolImpulse = floatValues [0];\n\n";

				public const string downTimeCounter = "\t\t\tdownTimeCounterInt = Mathf.CeilToInt (floatValues [0]);\n";

				public const string identifiedObjects = "\t\t\tidentifiedObjects = GameObject.Find (ScriptsCreatedByDiamond.IdentifiedObjectsActions.gameObjectHolderName).GetComponent<ScriptsCreatedByDiamond.IdentifiedObjects>();\n\n";


				public static string BoolValues (LogicNode logicNode)
				{
					return
						"\t\t\tboolValues [0] = " 
						+ StringTreatment.FirstToLower (
							logicNode.boolValues [0].ToString ()) + ";" + "\n" 
						+
						"\t\t\tboolValues [1] = " 
						+ StringTreatment.FirstToLower (
							logicNode.boolValues [1].ToString ()) + ";" + "\n";
				}

				public static string BoolValue (LogicNode logicNode)
				{
					return
						"\t\t\tboolValue = " 
						+ StringTreatment.FirstToLower (
							logicNode.boolValue.ToString ()) + ";" + "\n" ;

				}

				public const string boolValueEqualTrue = "\t\t\tboolValue = true;\n\n";


				public static string ColorValues (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.colorValues.Length; i++)
					{
						r += "\t\t\t" + "colorValues [" + i.ToString () + "] = " +
							LogicNode.ColorToScriptWrite (logicNode.colorValues [i]) + ";\n";

					}
					r += "\n";

					return r;
				}

				public static string Vector3Values (LogicNode logicNode)
				{
					return
						"\t\t\t" +  "vector3Values [0] = " + 
						LogicNode.Vector3ToScriptWrite (logicNode.vector3Values [0]) 
						+ ";\n" +
						"\t\t\t" +  "vector3Values [1] = " + 
						LogicNode.Vector3ToScriptWrite (logicNode.vector3Values [1]) 
						+ ";\n\n";
				}
				public static string Vector3Value (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\t" +  "vector3Value = " + 
						LogicNode.Vector3ToScriptWrite (logicNode.vector3Value) 
						+ ";\n";

					return r;
				}

				public static string Vector2Values (LogicNode logicNode)
				{
					return
						"\t\t\t" +  "vector2Values [0] = " + 
						LogicNode.Vector2ToScriptWrite (logicNode.vector2Values [0]) 
						+ ";\n" +
						"\t\t\t" +  "vector2Values [1] = " + 
						LogicNode.Vector2ToScriptWrite (logicNode.vector2Values [1]) 
						+ ";\n\n";
				}
				public static string Vector2Value (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\t" +  "vector2Value = " + 
						LogicNode.Vector2ToScriptWrite (logicNode.vector2Value) 
						+ ";\n";

					return r;
				}

				public static string Vector4Values (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.vector4Values.Length; i++)
					{
						r += "\t\t\t" +  "vector4Values [" + i.ToString () + "] = " + 
							LogicNode.Vector4ToScriptWrite (logicNode.vector4Values [i]) 
							+ ";\n";
					}
					r += "\n";

					return r;
				}
				public static string Vector4Value (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\t" +  "vector4Value = " + 
						LogicNode.Vector4ToScriptWrite (logicNode.vector4Value) 
						+ ";\n";

					return r;
				}

				public static string RectValues (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.rectValues.Length; i++)
					{
						r += "\t\t\trectValues [" + i.ToString () + "] = " +
							LogicNode.RectToScriptWrite (logicNode.rectValues [i]) + 
							";\n";
					}
					r += "\n";

					return r;
				}
				public static string RectValue (LogicNode logicNode)
				{
					string r = "";
					r += "\t\t\trectValue = " +
						LogicNode.RectToScriptWrite (logicNode.rectValue) + 
						";\n";

					return r;
				}

				public static string RayValue (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\trayValueOrigin = " + logicNode.rayValueOrigin + ";\n";
					r += "\t\t\trayDirectionValueNotNormalized = " + logicNode.rayDirectionValueNotNormalized + ";\n";
					r += "\n";

					return r;
				}

				public static string Ray2DValue (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tray2DValueOrigin = " + logicNode.ray2DValueOrigin + ";\n";
					r += "\t\t\ray2DDirectionValueNotNormalized = " + logicNode.ray2DDirectionValueNotNormalized + ";\n";
					r += "\n";

					return r;
				}

				public static string AnimationCurve (LogicNode logicNode)
				{
					string r = "";

					string newKeyFrame = "\t\t\t\t\tnew Keyframe (";

					r += "\t\t\tanimationCurve_ = new AnimationCurve (\n";

					r += "\t\t\t\tnew Keyframe []\n";

					r += "\t\t\t\t{\n";

					for (int i = 0; i < logicNode.animationCurve_.length; i++)
					{
						r += newKeyFrame + logicNode.animationCurve_.keys [i].time.ToString () + "f, ";
						r += logicNode.animationCurve_.keys [i].value.ToString () + "f, ";
						r += logicNode.animationCurve_.keys [i].inTangent.ToString () + "f, ";
						r += logicNode.animationCurve_.keys [i].outTangent.ToString () + "f)";

						r += (i < logicNode.animationCurve_.length - 1)? ",\n": "\n";
					}

					r += "\t\t\t\t});\n\n";

					return r;
				}

				public static string FloattValues (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.floatValues.Length; i++)
					{
						r += "\t\t\tfloatValues [" + i.ToString () + "] = " +
							logicNode.floatValues [i].ToString () + "f" +
							";" + "\n";
					}
					r += "\n";

					return r;
				}
				public static string FloattValue (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tfloatValue = " +
						logicNode.floatValue.ToString () + "f" +
						";" + "\n";


					return r;
				}

				public static string ColorValue (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tcolorValue = " +
						LogicNode.ColorToScriptWrite (logicNode.colorValue) +
						";" + "\n";

					return r;
				}



				public static string BoolListValue (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.boolsListValue.Count; i++)
					{
						r += "\t\t\t" + "boolsListValue.Add " +
							"(" + StringTreatment.FirstToLower (logicNode.boolsListValue [i].ToString ()) + ");\n";
					}
					r += "\n";

					return r;
				}

				public static string gameObjectListValues(LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tgameObjectsListValues [0] = new List<GameObject> ();\n";
					r += "\t\t\tgameObjectsListValues [1] = new List<GameObject> ();" + "\n";

					return r;
				}

				public static string shaderListValues(LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tshaderListValues [0] = new List<Shader> ();\n";
					r += "\t\t\tshaderListValues [1] = new List<Shader> ();" + "\n";

					return r;
				}

				public static string Textur2DListValues(LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\ttexture2DListValues [0] = new List<Texture2D> ();\n";
					r += "\t\t\ttexture2DListValues [1] = new List<Texture2D> ();" + "\n";

					return r;
				}

				public static string MaterialListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tmaterialsListValues [0] = new List<Material> ();\n";
					r += "\t\t\tmaterialsListValues [1] = new List<Material> ();" + "\n";

					return r;
				}



				public static string RectListValue (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.rectListValue.Count; i++)
					{
						r += "\t\t\t" + "rectListValue.Add " +
							"(" + LogicNode.RectToScriptWrite (logicNode.rectListValue [i]) + ");\n";
					}
					r += "\n";

					return r;
				}

				public static string RectListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\trectListValues [0] = new List<Rect> ();\n";
					r += "\t\t\trectListValues [1] = new List<Rect> ();" + "\n";

					return r;
				}


				public static string Vector4ListValue (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.vector4ListValue.Count; i++)
					{
						r += "\t\t\t" + "vector4ListValue.Add " +
							"(" + LogicNode.Vector4ToScriptWrite (logicNode.vector4ListValue [i]) + ");\n";
					}
					r += "\n";

					return r;
				}

				public static string Vector4ListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tvector4ListValues [0] = new List<Vector4> ();\n";
					r += "\t\t\tvector4ListValues [1] = new List<Vector4> ();" + "\n";

					return r;
				}



				public static string Vector3ListValue (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.vector3ListValue.Count; i++)
					{
						r += "\t\t\t" + "vector3ListValue.Add " +
							"(" + LogicNode.Vector3ToScriptWrite (logicNode.vector3ListValue [i]) + ");\n";
					}
					r += "\n";

					return r;
				}

				public static string Vector3ListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tvector3ListValues [0] = new List<Vector3> ();\n";
					r += "\t\t\tvector3ListValues [1] = new List<Vector3> ();" + "\n";

					return r;
				}

				public static string ColorListValue (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.colorsListValue.Count; i++)
					{
						r += "\t\t\t" + "colorsListValue.Add " +
							"(" + LogicNode.ColorToScriptWrite (logicNode.colorsListValue [i]) + ");\n";
					}
					r += "\n";

					return r;
				}

				public static string Vector2ListValue (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.vector2ListValue.Count; i++)
					{
						r += "\t\t\t" + "vector2ListValue.Add " +
							"(" + LogicNode.Vector2ToScriptWrite (logicNode.vector2ListValue [i]) + ");\n";
					}
					r += "\n";

					return r;
				}

				public static string Vector2ListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tvector2ListValues [0] = new List<Vector2> ();\n";
					r += "\t\t\tvector2ListValues [1] = new List<Vector2> ();" + "\n";

					return r;
				}

				public static string ColorListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tcolorsListValues [0] = new List<Color> ();\n";
					r += "\t\t\tcolorsListValues [1] = new List<Color> ();" + "\n";

					return r;
				}


				public static string StringListValue (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.stringsListValue.Count; i++)
					{
						r += "\t\t\t" + "stringsListValue.Add " +
							"(" + "\"" + logicNode.stringsListValue [i] + "\"" + ");\n";
					}
					r += "\n";

					return r;
				}

				public static string StringListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tstringsListValues [0] = new List<string> ();\n";
					r += "\t\t\tstringsListValues [1] = new List<string> ();" + "\n";

					return r;
				}



				public static string IntListValue (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.intsListValue.Count; i++)
					{
						r += "\t\t\t" + "intsListValue.Add " +
							"(" + logicNode.intsListValue [i].ToString () + ");\n";
					}
					r += "\n";

					return r;
				}

				public static string IntListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tintsListValues [0] = new List<int> ();\n";
					r += "\t\t\tintsListValues [1] = new List<int> ();" + "\n";

					return r;
				}


				public static string BoolListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tboolsListValues [0] = new List<bool> ();\n";
					r += "\t\t\tboolsListValues [1] = new List<bool> ();" + "\n";

					return r;
				}


				public static string FloatListValue (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.floatsListValue.Count; i++)
					{
						r += "\t\t\t" + "floatsListValue.Add " +
							"(" + logicNode.floatsListValue [i].ToString () + "f" + ");\n";
					}
					r += "\n";

					return r;
				}

				public static string FloatListValues (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tfloatsListValues [0] = new List<float> ();\n";
					r += "\t\t\tfloatsListValues [1] = new List<float> ();" + "\n";

					return r;
				}



				public static string IntValue (LogicNode logicNode)
				{

					return "\t\t\tintValue = " + logicNode.intValue.ToString () + ";" + "\n";

				}

				public static string IntValues (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.intValues.Length; i++)
					{
						r += "\t\t\tintValues [" + i.ToString () + "] = " +
							logicNode.intValues [i].ToString () +
							";" + "\n";
					}
					r += "\n";

					return r;
				}

				public static string keyCode (LogicNode logicNode)
				{
					return "\t\t\tkeyCode = KeyCode." +
						logicNode.keyCode.ToString () +
						";" + "\n";;
				}


				public static string StringOperations (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tstringOperations = StringOperations." + 
						logicNode.stringOperations.ToString () +
						";\n"; 

					return r;
				}

				public static string StringValues (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.stringValues.Length; i++)
					{
						r += "\t\t\tstringValues [" + i.ToString () + "] = " + 
							StringTreatment.gwm +
							logicNode.stringValues [i] +
							StringTreatment.gwm +
							";\n"; 
					}

					return r;
				}
				public static string StringValue (LogicNode logicNode)
				{
					string r = "";

					r += "\t\t\tstringValue = " + 
						StringTreatment.gwm +
						logicNode.stringValue +
						StringTreatment.gwm +
						";\n"; 

					return r;
				}


				public static string camera_StereoscopicEye (LogicNode logicNode)
				{
					return "\t\t\tcamera_StereoscopicEye = Camera.StereoscopicEye." + 
						logicNode.camera_StereoscopicEye.ToString () + ";\n\n";
				}

				public static string TextAnchor (LogicNode logicNode)
				{
					return "\t\t\ttextAnchor = TextAnchor." + 
						logicNode.textAnchor.ToString () + ";\n\n";
				}

				public static string ShaderGetGlobalPropertyMode (LogicNode logicNode)
				{
					return "\t\t\tshadersGetGlobalPropertieMode = ShadersGetGlobalPropertieMode." + 
						logicNode.shadersGetGlobalPropertieMode.ToString () + ";\n\n";
				}


				public static string MaterialGlobalIlluminationFlags (LogicNode logicNode)
				{
					return "\t\t\tmaterialGlobalIlluminationFlags = MaterialGlobalIlluminationFlags." + 
						logicNode.materialGlobalIlluminationFlags.ToString () + ";\n\n";
				}

				public static string TransparencySortMode (LogicNode logicNode)
				{
					return "\t\t\ttransparencySortMode = TransparencySortMode." + 
						logicNode.transparencySortMode.ToString () + ";\n\n";
				}

				public static string InventoryListAction (LogicNode logicNode)
				{
					return "\t\t\tinventoryListAction = InventoryListAction." + 
						logicNode.inventoryListAction.ToString () + ";\n\n";
				}

				public static string RenderingPath (LogicNode logicNode)
				{
					return "\t\t\trenderingPath = RenderingPath." +
						logicNode.renderingPath.ToString () + ";\n\n";
				}

				public static string OpaqueSortMode (LogicNode logicNode)
				{
					return "opaqueSortMode = UnityEngine.Rendering.OpaqueSortMode." +
						logicNode.opaqueSortMode.ToString () + ";\n\n";
				}

				public static string DepthTextureMode (LogicNode logicNode)
				{
					return "depthTextureMode = DepthTextureMode." +
						logicNode.depthTextureMode.ToString () + ";\n\n";
				}

				public static string ObstacleAvoidanceType (LogicNode logicNode)
				{
					return "\t\t\tobstacleAvoidanceType = UnityEngine.AI.ObstacleAvoidanceType." +
						logicNode.obstacleAvoidanceType.ToString () + ";\n\n";
				}

				public static string PhysicMaterialCombine (LogicNode logicNode)
				{
					return "\t\t\tphysicMaterialCombine = PhysicMaterialCombine." +
						logicNode.physicMaterialCombine.ToString () + ";\n\n";
				}

				public static string ParticleSystemScalingMode (LogicNode logicNode)
				{
					return "\t\t\tparticleSystemScalingMode = ParticleSystemScalingMode." +
						logicNode.particleSystemScalingMode.ToString () + ";\n\n";
				}

				public static string ParticleSystemSimulationSpace (LogicNode logicNode)
				{
					return "\t\t\tparticleSystemSimulationSpace = ParticleSystemSimulationSpace." +
						logicNode.particleSystemSimulationSpace.ToString () + ";\n\n";
				}


				public static string ForceMode (LogicNode logicNode)
				{
					return "\t\t\tforceMode = ForceMode." +
						logicNode.forceMode.ToString () + ";\n\n";
				}

				public static string ForceMode2D (LogicNode logicNode)
				{
					return "\t\t\tforceMode2D = ForceMode2D." +
						logicNode.forceMode2D.ToString () + ";\n\n";
				}

				//
				public static string QueryTriggerInteraction (LogicNode logicNode)
				{
					return "\t\t\tqueryTriggerInteraction = QueryTriggerInteraction." +
						logicNode.queryTriggerInteraction.ToString () + ";\n\n";
				}

				public static string ComputeColorType (LogicNode logicNode)
				{
					return "\t\t\tcomputeColorType = ComputeColorType." +
						logicNode.computeColorType.ToString () + ";\n\n";
				}

				public static string colorBlendMode (LogicNode logicNode)
				{
					return "\t\t\tcolorBlendMode = ColorBlendMode." +
						logicNode.colorBlendMode.ToString () + ";\n\n";
				}

				//
				public static string TextureEncodeType (LogicNode logicNode)
				{
					return "\t\t\ttextureEncodeType = TextureEncodeType." +
						logicNode.textureEncodeType.ToString () + ";\n\n";
				}

				public static string WriteTextureFormat (LogicNode logicNode)
				{
					return "\t\t\twriteTextureFormat = WriteTextureFormat." +
						logicNode.writeTextureFormat.ToString () + ";\n\n";
				}





				public static string Channels (LogicNode logicNode)
				{
					string r = "";

					for (int i = 0; i < logicNode.stringValues.Length; i++)
					{
						r += "\t\t\tchannels [" + i.ToString () + "] = TextureComputer.ComputeOn." +
							logicNode.channels [i].ToString () +
							";\n"; 
					}

					return r;
				}

				public static string Channel (LogicNode logicNode)
				{
					return "\t\t\tchannel = TextureComputer.ComputeOn." +
						logicNode.channel.ToString () +
						";\n"; ;
				}

				public static string ExtractResultType (LogicNode logicNode)
				{
					return "\t\t\textractResultType = TextureComputer.ExtractResultType." +
						logicNode.extractResultType.ToString () +
						";\n"; ;
				}


				public static string MirrorTexture2D_Direction (LogicNode logicNode)
				{
					return "\t\t\tmirrorTexture2D_Direction = TextureComputer.MirrorTexture2D_Direction." +
						logicNode.mirrorTexture2D_Direction.ToString () +
						";\n"; ;
				}
				//
				public static string normalMapComputeIntensity (LogicNode logicNode)
				{
					return "\t\t\tnormalMapComputeIntensity = NormalMapComputeIntensity." +
						logicNode.normalMapComputeIntensity.ToString () +
						";\n"; 
				}

				//
				public static string filtermode (LogicNode logicNode)
				{
					return "\t\t\tfilterMode = FilterMode." +
						logicNode.filterMode.ToString () +
						";\n"; 
				}

				//
				public static string textureWrapMode (LogicNode logicNode)
				{
					return "\t\t\ttextureWrapMode = TextureWrapMode." +
						logicNode.textureWrapMode.ToString () +
						";\n"; 
				}

				//
				public static string switchColorsType (LogicNode logicNode)
				{
					return "\t\t\tswitchColorsType = TextureComputer.SwitchColorsType." +
						logicNode.switchColorsType.ToString () +
						";\n"; 
				}

				//public UnityEngine.UI.Image.FillMethod fillMethod;
				public static string fillMethod (LogicNode logicNode)
				{
					return "\t\t\tfillMethod = UnityEngine.UI.Image.FillMethod." +
						logicNode.fillMethod.ToString () +
						";\n"; 
				}

				public static string loadSceneMode (LogicNode logicNode)
				{
					return "\t\t\tloadSceneMode = UnityEngine.SceneManagement.LoadSceneMode." +
						logicNode.loadSceneMode.ToString () +
						";\n"; 
				}

				public static string spriteDrawMode (LogicNode logicNode)
				{
					return "\t\t\tspriteDrawMode = SpriteDrawMode." +
						logicNode.spriteDrawMode.ToString () +
						";\n"; 
				}

				public static string spriteTileMode (LogicNode logicNode)
				{
					return "\t\t\tspriteTileMode = SpriteTileMode." +
						logicNode.spriteTileMode.ToString () +
						";\n"; 
				}
			}

			public class UMcall
			{
				public const string computeAds = "\t\t\tComputeAds ();\n";

				public const string computeUiToggle = "\t\t\tComputeUiToggle ();\n";

				public const string computeUiInputField = "\t\t\tComputeUiInputField ();\n";


				public const string computeLineRenderer = "\t\t\tComputeLineRenderer ();\n";

				public const string computeSpriteRenderer = "\t\t\tComputeSpriteRenderer ();\n";

				public const string computeCamera = "\t\t\tComputeCamera ();\n";

				public const string getCam_1 = "\t\t\tGetCam_1 ();\n";




				public const string computeNavMeshAgent = "\t\t\tComputeNavMeshAgent ();\n";

				public const string computeCollider = "\t\t\tComputeCollider ();\n";
				//
				public const string computeMouseInput = "\t\t\tComputeMouseInput ();\n";

				public const string computeUnityInputClassAndCrossPlatform = 
					"\t\t\tComputeUnityInputClassAndCrossPlatform ();\n";


				public const string computeLight = "\t\t\tComputeLight ();\n";

				public const string computeCollider2D = "\t\t\tComputeCollider2D ();\n";

				public const string computeParticleSystem = "\t\t\tComputeParticleSystem ();\n"; 

				public const string computeRenderer = "\t\t\tComputeRenderer ();\n";

				public const string computeRigidbody = "\t\t\tComputeRigidbody ();\n";

				public const string computeRigidbody2D = "\t\t\tComputeRigidbody2D ();\n";

				public const string computeTransform = "\t\t\tComputeTransform ();\n";

				public const string computeFloat = "\t\t\tComputeFloat ();\n";

				public const string computeInt = "\t\t\tComputeInt ();\n";

				public const string computeString = "\t\t\tComputeString ();\n";

				public const string computeVector2 = "\t\t\tComputeVector2 ();\n";

				public const string computeVector3 = "\t\t\tComputeVector3 ();\n";

				public const string computeVector4 = "\t\t\tComputeVector4 ();\n";

				public const string computeRect = "\t\t\tComputeRect ();\n";

				public const string computeMatrix44 = "\t\t\tComputeMatrix44 ();\n";


				public const string computeBoolList = "\t\t\tComputeBoolsList ();\n";

				public const string computeFloatList = "\t\t\tComputeFloatsList ();\n";

				public const string computeInttList = "\t\t\tComputeIntList ();\n";
				//
				public const string computeStringtList = "\t\t\tComputeStringList ();\n";

				public const string computeVector2tList = "\t\t\tComputeVector2List ();\n";

				public const string computeVector3tList = "\t\t\tComputeVector3List ();\n";

				public const string computeVector4tList = "\t\t\tComputeVector4List ();\n";

				//
				public const string computeRectList = "\t\t\tComputeRectList ();\n";

				public const string computeColor = "\t\t\tComputeColor ();\n";

				public const string computeColorList = "\t\t\tComputeColorList ();\n";

				public const string computeShaderList = "\t\t\tComputeShaderList ();\n";

				public const string computeTexture2DList = "\t\t\tComputeTexture2DList ();\n";

				public const string computeMaterialList = "\t\t\tComputeMaterialList ();\n";

				public const string computeGameObject = "\t\t\tComputeGameObject ();\n";

				public const string computeRay = "\t\t\tComputeRay ();\n";

				public const string computeRay2D = "\t\t\tComputeRay2D ();\n";

				//
				public const string computeGameObjectList = "\t\t\tComputeGameObjectList ();\n";

				public const string computeMaterial = "\t\t\tComputeMaterial ();\n";

				public const string computeShader = "\t\t\tComputeShader ();\n";

				public const string computeTexture2D = "\t\t\tComputeTexture2D ();\n";

				public const string computeUnityText = "\t\t\tComputeUnityText ();\n";
				//
				public const string computeUiImage = "\t\t\tComputeUiImage ();\n";

				public const string computeUiButton = "\t\t\tComputeUiButton ();\n";

				public const string computeAudioSource = "\t\t\tComputeAudioSource ();\n";

				public const string gotostate = "\t\t\tvoid GoToState ();" + "\n";
			}

			public class UMDecl
			{
				public const string colorArithmetic = 
					"\t\tpublic class ColorsArithmetic \n\t\t{\t\n\t\t\tpublic static Color RGB_255_To_Normalized (float r, float g, float b, float a)\n\t\t\t{\n\t\t\t\tfloat _255 = 255f;\n\n\t\t\t\treturn new Color (r/_255, g/_255, b/_255, a);\n\t\t\t}\n\n\t\t\tpublic static Color Opacity (Color c0, Color c1, float o)\n\t\t\t{\n\t\t\t\to = Mathf.Clamp (o, 0f, 1f);\n\n\t\t\t\treturn o * c0 + (1f - o) * c1;\n\t\t\t}\n\n\t\t\tpublic static Color Darken (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tMathf.Min (c0.r, c1.r), \n\t\t\t\t\tMathf.Min (c0.g, c1.g), \n\t\t\t\t\tMathf.Min (c0.b, c1.b), \n\t\t\t\t\tMathf.Min (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tpublic static Color Lighten (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tMathf.Max (c0.r, c1.r), \n\t\t\t\t\tMathf.Max (c0.g, c1.g), \n\t\t\t\t\tMathf.Max (c0.b, c1.b), \n\t\t\t\t\tMathf.Max (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tpublic static Color Multiply (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tc0.r * c1.r, \n\t\t\t\t\tc0.g * c1.g, \n\t\t\t\t\tc0.b * c1.b, \n\t\t\t\t\tc0.a * c1.a);\n\t\t\t}\n\n\t\t\tpublic static Color Screen (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\t1f - (1f-c0.r) * (1f-c1.r), \n\t\t\t\t\t1f - (1f-c0.g) * (1f-c1.g), \n\t\t\t\t\t1f - (1f-c0.b) * (1f-c1.b), \n\t\t\t\t\t1f - (1f-c0.a) * (1f-c1.a));\n\t\t\t}\n\n\t\t\tpublic static Color ColorDodge (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tColorDodge (c0.r, c1.r), \n\t\t\t\t\tColorDodge (c0.g, c1.g), \n\t\t\t\t\tColorDodge (c0.b, c1.b), \n\t\t\t\t\tColorDodge (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float ColorDodge (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 == 1f)\n\t\t\t\t\tf = 1f;\n\t\t\t\telse\n\t\t\t\t\tf = Mathf.Min (1f, f1 / (1f - f0));\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\t\t\tpublic static Color ColorBurn (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tColorBurn (c0.r, c1.r), \n\t\t\t\t\tColorBurn (c0.g, c1.g), \n\t\t\t\t\tColorBurn (c0.b, c1.b), \n\t\t\t\t\tColorBurn (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float ColorBurn (float f0, float f1)\n\t\t\t{\n\t\t\t\treturn f0 == 0f ? 0f : Mathf.Max (0f, (1f - (1f - f1)) / f0); \n\t\t\t}\n\n\t\t\tpublic static Color LinearDodge (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tc0.r + c1.r, \n\t\t\t\t\tc0.g + c1.g, \n\t\t\t\t\tc0.b + c1.b, \n\t\t\t\t\tc0.a + c1.a);\n\t\t\t}\n\n\t\t\tpublic static Color LinearBurn (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tc0.r + c1.r - 1f, \n\t\t\t\t\tc0.g + c1.g - 1f, \n\t\t\t\t\tc0.b + c1.b - 1f, \n\t\t\t\t\tc0.a + c1.a - 1f);\n\t\t\t}\n\n\t\t\tpublic static Color Overlay (Color c0, Color c1)\n\t\t\t{\t\t\n\t\t\t\treturn new Color (\n\t\t\t\t\tOverlay (c0.r, c1.r),\n\t\t\t\t\tOverlay (c0.g, c1.g),\n\t\t\t\t\tOverlay (c0.b, c1.b),\n\t\t\t\t\tOverlay (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float Overlay (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f1 <= 0.5f)\n\t\t\t\t\tf = 2f * f0 * f1;\n\t\t\t\telse\n\t\t\t\t\tf = 1f - 2f * (1f - f0) * (1f - f1);\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\t\t\tpublic static Color HardLight (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tHardLight (c0.r, c1.r),\n\t\t\t\t\tHardLight (c0.g, c1.g),\n\t\t\t\t\tHardLight (c0.b, c1.b),\n\t\t\t\t\tHardLight (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float HardLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 <= 0.5f)\n\t\t\t\t\tf = 2f * f0 * f1;\n\t\t\t\telse\n\t\t\t\t\tf = 1f - 2f * (1f - f0) * (1f - f1);\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\t\t\tpublic static Color SoftLight (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tSoftLight (c0.r, c1.r),\n\t\t\t\t\tSoftLight (c0.g, c1.g),\n\t\t\t\t\tSoftLight (c0.b, c1.b),\n\t\t\t\t\tSoftLight (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float SoftLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 <= 0.5f)\n\t\t\t\t\tf = (2f * f0 - 1f) * (f1 - f1*f1) + f1;\n\t\t\t\telse\n\t\t\t\t\tf = (2f * f0 - 1f) * (Mathf.Pow(f1,0.5f) - f1) + f1;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\t\t\tpublic static Color VividLight (Color c0, Color c1)\n\t\t\t{\n\n\t\t\t\treturn new Color (\n\t\t\t\t\tVividLight (c0.r, c1.r),\n\t\t\t\t\tVividLight (c0.g, c1.g),\n\t\t\t\t\tVividLight (c0.b, c1.b),\n\t\t\t\t\tVividLight (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float VividLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 <= 0.5f) \n\t\t\t\t{\n\t\t\t\t\tif (f0 == 0f)\n\t\t\t\t\t\tf = 0f;\n\t\t\t\t\telse\n\t\t\t\t\t\tf = 1f - (0.5f * (1f - f1) / f0);\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tif (f0 == 1f)\n\t\t\t\t\t\tf = 1f;\n\t\t\t\t\telse\n\t\t\t\t\t\tf = 0.5f * (f1 / (1f - f0));\n\t\t\t\t}\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color LinearLight (Color c0, Color c1)\n\t\t\t{\n\n\t\t\t\treturn new Color (\n\t\t\t\t\tLinearLight (c0.r, c1.r),\n\t\t\t\t\tLinearLight (c0.g, c1.g),\n\t\t\t\t\tLinearLight (c0.b, c1.b),\n\t\t\t\t\tLinearLight (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float LinearLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tf = f1 + 2f*f0 - 1f;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color PinLight (Color c0, Color c1)\n\t\t\t{\n\n\t\t\t\treturn new Color (\n\t\t\t\t\tPinLight (c0.r, c1.r),\n\t\t\t\t\tPinLight (c0.g, c1.g),\n\t\t\t\t\tPinLight (c0.b, c1.b),\n\t\t\t\t\tPinLight (c0.a, c1.a));\n\n\t\t\t}\n\n\t\t\tstatic float PinLight (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f = 0f;\n\n\t\t\t\tif (f1 <= 2f * f0 - 1f)\n\t\t\t\t\tf = 2f * f0 - 1f;\n\t\t\t\telse if (f1 > 2f * f0 - 1f && f1 <= 2f * f0)\n\t\t\t\t\tf = f1;\n\t\t\t\telse if (f1 > 2f * f0)\n\t\t\t\t\tf = 2 * f0;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color HardMix (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tHardMix (c0.r, c1.r),\n\t\t\t\t\tHardMix (c0.g, c1.g),\n\t\t\t\t\tHardMix (c0.b, c1.b),\n\t\t\t\t\tHardMix (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float HardMix (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tif (f0 < 1f - f1)\n\t\t\t\t\tf = 0f;\n\t\t\t\telse\n\t\t\t\t\tf = 1f;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color Difference (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tDifference (c0.r, c1.r),\n\t\t\t\t\tDifference (c0.g, c1.g),\n\t\t\t\t\tDifference (c0.b, c1.b),\n\t\t\t\t\tDifference (c0.a, c1.a));\n\t\t\t}\n\n\t\t\tstatic float Difference (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tf = Mathf.Abs (f0 - f1);\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color Exclusion (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tExclusion (c0.r, c1.r),\n\t\t\t\t\tExclusion (c0.g, c1.g),\n\t\t\t\t\tExclusion (c0.b, c1.b),\n\t\t\t\t\tExclusion (c0.a, c1.a));\n\n\t\t\t}\n\n\t\t\tstatic float Exclusion (float f0, float f1)\n\t\t\t{\n\t\t\t\tfloat f;\n\n\t\t\t\tf = f0 + f1 - 2f * f0 * f1;\n\n\t\t\t\treturn f;\n\t\t\t}\n\n\n\t\t\tpublic static Color Hue (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn Color.HSVToRGB (RGBToHSV (c0) [0], RGBToHSV (c1) [1], RGBToHSV (c1) [2]);\n\t\t\t}\n\n\t\t\tpublic static Color Saturation (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn Color.HSVToRGB (RGBToHSV (c1) [0], RGBToHSV (c0) [1], RGBToHSV (c1) [2]);\n\t\t\t}\n\n\t\t\tpublic static Color Color_ (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn Color.HSVToRGB (RGBToHSV (c0) [0], RGBToHSV (c0) [1], RGBToHSV (c1) [2]);\n\t\t\t}\n\n\t\t\tpublic static Color Luminosity (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn Color.HSVToRGB (RGBToHSV (c1) [0], RGBToHSV (c1) [1], RGBToHSV (c0) [2]);\n\t\t\t}\n\n\t\t\tpublic static float [] RGBToHSV (Color c)\n\t\t\t{\n\t\t\t\tfloat [] retVal = new float[3];\n\n\t\t\t\tColor.RGBToHSV (c, out retVal [0], out retVal [1], out retVal [2]);\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\n\n\t\t\tpublic static Color Add (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn new Color (\n\t\t\t\t\tc0.r + c1.r, \n\t\t\t\t\tc0.g + c1.g, \n\t\t\t\t\tc0.b + c1.b, \n\t\t\t\t\tc0.a + c1.a);\n\t\t\t}\n\n\t\t\tpublic static Color Subtract (Color c0, Color c1)\n\t\t\t{\n\t\t\t\treturn c0 - c1;\n\t\t\t} \n\t\t}\n";

				public const string prepareToColorCompute = "" +
					"\t\tvoid PrepareToColorCompute (ref Color c0,  ref float o, ref float o1, ref Color cm1, ref Color c1o)\n\t\t{\n\t\t\tc0 = colorValues [0];\n\n\t\t\t//Color c1 = \n\n\t\t\to = floatValues [0];\n\n\n\t\t\to1 = floatValues [1];\n\n\t\t\tcm1 = new Color (0f, 0f, 0f, 0f);\n\n\t\t\tc1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);\n\t\t}\n";


				public const string getmde = 
					"\t\tScriptsCreatedByDiamond.MezanixDiamondEvents Getmde ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t\treturn null;\n\n\t\t\tif (mdeGameObjectHolder == null)\n" +
					"\t\t\t\tmdeGameObjectHolder = " +
					"GameObject.Find (ScriptsCreatedByDiamond.MezanixDiamondEvents.gameObjectHolderName);\n" +
					"\n\t\t\tif (mdeGameObjectHolder == null)\n\t\t\t\treturn null;" +
					"\n\n\t\t\treturn mdeGameObjectHolder.GetComponent " +
					"<ScriptsCreatedByDiamond.MezanixDiamondEvents> ();\n\t\t}\n\n";

				public const string mezanixDiamondRemoveEvent = 
					"\t\tvoid MezanixDiamondRemoveEvent (string eName)\n" +
					"\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondEvents mde = Getmde ();\n\n" +
					"\t\t\tif (mde == null)\n\t\t\t\treturn;\n\n\t\t\tmde.RemoveEvent (eName);\n\t\t}\n\n";
				
				public const string mezanixDiamondGetEvent = 
					"\t\tbool MezanixDiamondGetEvent (string eName)\n\t\t{\n" +
					"\t\t\tScriptsCreatedByDiamond.MezanixDiamondEvents mde = Getmde ();\n\n" +
					"\t\t\tif (mde == null)\n\t\t\t\treturn false;\n\n\t\t\treturn mde.GetEvent (eName);\n" +
					"\t\t}\n\n";
				
				public const string mezanixDiamondSetEvent = 
					"\t\tvoid MezanixDiamondSetEvent (string eName)\n" +
					"\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondEvents mde = Getmde ();\n\n" +
					"\t\t\tif (mde == null)\n\t\t\t\treturn;\n\n\t\t\tmde.SetEvent (eName);\n\t\t}\n\n";



				public const string getmddt =
					"\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer Getmddt ()\n" +
					"\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t\treturn null;\n\n" +
					"\t\t\tif (mddtGameObjectHolder == null)\n" +
					"\t\t\t\tmddtGameObjectHolder = " +
					"GameObject.Find (ScriptsCreatedByDiamond.MezanixDiamondDataTransfer.gameObjectHolderName);\n\n" +
					"\t\t\tif (mddtGameObjectHolder == null)\n\t\t\t\treturn null;\n\n" +
					"\t\t\treturn mddtGameObjectHolder.GetComponent " +
					"<ScriptsCreatedByDiamond.MezanixDiamondDataTransfer> ();\n\t\t}\n\n";

				public const string mezanixDiamondRemoveBool =
					"\t\tvoid MezanixDiamondRemoveBool (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveBool (eName);\n\t\t}\n\n";
				
				public const string mezanixDiamondGetBool = 
					"\t\tbool MezanixDiamondGetBool (string eName)\n\t\t{\n" +
					"\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n" +
					"\t\t\tif (mddt == null)\n\t\t\t\treturn boolValues [1];\n\n" +
					"\t\t\treturn mddt.GetBool (eName, boolValues [1]);\n\t\t}\n\n";

				public const string mezanixDiamondSetBool =
					"\t\tvoid MezanixDiamondSetBool (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetBool (eName, boolValues [0]);\n\t\t}\n\n";



				public const string mezanixDiamondGetBoolList =
					"\t\tList<bool> MezanixDiamondGetBoolList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn boolsListValues [0];\n\n\t\t\treturn mddt.GetBoolList (eName, boolsListValues [0]);\n\t\t}\n\n";

				public const string mezanixDiamondRemoveBoolList =
					"\t\tvoid MezanixDiamondRemoveBoolList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveBoolList (eName);\n\t\t}\n\n";

				public const string mezanixDiamondSetBoolList =
					"\t\tvoid MezanixDiamondSetBoolList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetBoolList (eName, boolsListValues [0]);\n\t\t}\n\n";


				public const string MezanixDiamondGetColor = 
					"\t\tColor MezanixDiamondGetColor (string eName)\n" +
					"\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n" +
					"\t\t\tif (mddt == null)\n\t\t\t\treturn colorValues [0];\n\n" +
					"\t\t\treturn mddt.GetColor (eName, colorValues [0]);\n\t\t}\n\n";

				public const string MezanixDiamondRemoveColor = 
					"\t\tvoid MezanixDiamondRemoveColor (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveColor (eName);\n\t\t}\n\n";

				public const string MezanixDiamondSetColor =
					"\t\tvoid MezanixDiamondSetColor (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetColor (eName, colorValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetColorList =
					"\t\tList<Color> MezanixDiamondGetColorList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn colorsListValues [0];\n\n\t\t\treturn mddt.GetColorList (eName, colorsListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveColorList =
					"\t\tvoid MezanixDiamondRemoveColorList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveColorList (eName);\n\t\t}\n";

				public const string MezanixDiamondSetColorList =
					"\t\tvoid MezanixDiamondSetColorList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetColorList (eName, colorsListValues [0]);\n\t\t}\n";
				
				public const string MezanixDiamondGetFloat =
					"\t\tfloat MezanixDiamondGetFloat (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn floatValues [0];\n\n\t\t\treturn mddt.GetFloat (eName, floatValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveFloat =
					"\t\tvoid MezanixDiamondRemoveFloat (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveFloat (eName);\n\t\t}\n";

				public const string MezanixDiamondSetFloat = 
					"\t\tvoid MezanixDiamondSetFloat (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetFloat (eName, floatValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetFloatList =
					"\t\tList<float> MezanixDiamondGetFloatList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn floatsListValues [0];\n\n\t\t\treturn mddt.GetFloatList (eName, floatsListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveFloatList =
					"\t\tvoid MezanixDiamondRemoveFloatList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveFloatList (eName);\n\t\t}\n";

				public const string MezanixDiamondSetFloatList =
					"\t\tvoid MezanixDiamondSetFloatList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetFloatList (eName, floatsListValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetGameObject =
					"\t\tGameObject MezanixDiamondGetGameObject (string eName)\n" +
					"\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n" +
					"\t\t\tif (mddt == null)\n\t\t\t\treturn gameObjectValues [0];\n\n" +
					"\t\t\treturn mddt.GetGameObject (eName, gameObjectValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveGameObject =
					"\t\tvoid MezanixDiamondRemoveGameObject (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveGameObject (eName);\n\t\t}\n";

				public const string MezanixDiamondSetGameObject =
					"\t\tvoid MezanixDiamondSetGameObject (string eName)\n" +
					"\t\t{\n" +
					"\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n" +
					"\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n" +
					"\t\t\tmddt.SetGameObject (eName, gameObjectValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetGameObjectList =
					"\t\tList<GameObject> MezanixDiamondGetGameObjectList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn gameObjectsListValues [0];\n\n\t\t\treturn mddt.GetGameObjectList (eName, gameObjectsListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveGameObjectList =
					"\t\tvoid MezanixDiamondRemoveGameObjectList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveGameObjectList (eName);\n\t\t}\n";

				public const string MezanixDiamondSetGameObjectList =
					"\t\tvoid MezanixDiamondSetGameObjectList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetGameObjectList (eName, gameObjectsListValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetInt =
					"\t\tint MezanixDiamondGetInt (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn intValues [0];\n\n\t\t\treturn mddt.GetInt (eName, intValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveInt =
					"\t\tvoid MezanixDiamondRemoveInt (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveInt (eName);\n\t\t}\n";

				public const string MezanixDiamondSetInt =
					"\t\tvoid MezanixDiamondSetInt (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetInt (eName, intValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetIntList =
					"\t\tList<int> MezanixDiamondGetIntList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn intsListValues [0];\n\n\t\t\treturn mddt.GetIntList (eName, intsListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveIntList =
					"\t\tvoid MezanixDiamondRemoveIntList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveIntList (eName);\n\t\t}\n";

				public const string MezanixDiamondSetIntList =
					"\t\tvoid MezanixDiamondSetIntList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetIntList (eName, intsListValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetString =
					"\t\tstring MezanixDiamondGetString (string eName)\n\t\t{\n" +
					"\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n" +
					"\t\t\tif (mddt == null)\n\t\t\t\treturn stringValues [1];\n\n" +
					"\t\t\treturn mddt.GetString (eName, stringValues [1]);\n\t\t}\n";

				public const string MezanixDiamondRemoveString =
					"\t\tvoid MezanixDiamondRemoveString (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveString (eName);\n\t\t}\n";


				public const string MezanixDiamondSetString =
					"\t\tvoid MezanixDiamondSetString (string eName)\n" +
					"\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n" +
					"\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n" +
					"\t\t\tmddt.SetString (eName, stringValues [1]);\n\t\t}\n";



				public const string MezanixDiamondGetStringList =
					"\t\tList<string> MezanixDiamondGetStringList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn stringsListValues [0];\n\n\t\t\treturn mddt.GetStringList (eName, stringsListValues [0]);\n\t\t}\n";


				public const string MezanixDiamondRemoveStringList =
					"\t\tvoid MezanixDiamondRemoveStringList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveStringList (eName);\n\t\t}\n";

				public const string MezanixDiamondSetStringList =
					"\t\tvoid MezanixDiamondSetStringList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetStringList (eName, stringsListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondGetVector2 =
					"\t\tVector2 MezanixDiamondGetVector2 (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn vector2Values [0];\n\n\t\t\treturn mddt.GetVector2 (eName, vector2Values [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveVector2 =
					"\t\tvoid MezanixDiamondRemoveVector2 (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveVector2 (eName);\n\t\t}\n";

				public const string MezanixDiamondSetVector2 =
					"\t\tvoid MezanixDiamondSetVector2 (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetVector2 (eName, vector2Values [0]);\n\t\t}\n";



				public const string MezanixDiamondGetVector2List =
					"\t\tList<Vector2> MezanixDiamondGetVector2List (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn vector2ListValues [0];\n\n\t\t\treturn mddt.GetVector2List (eName, vector2ListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveVector2List =
					"\t\tvoid MezanixDiamondRemoveVector2List (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveVector2List (eName);\n\t\t}\n";

				public const string MezanixDiamondSetVector2List =
					"\t\tvoid MezanixDiamondSetVector2List (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetVector2List (eName, vector2ListValues [0]);\n\t\t}\n";



				public const string MezanixDiamondGetVector3 =
					"\t\tVector3 MezanixDiamondGetVector3 (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn vector3Values [0];\n\n\t\t\treturn mddt.GetVector3 (eName, vector3Values [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveVector3 =
					"\t\tvoid MezanixDiamondRemoveVector3 (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveVector3 (eName);\n\t\t}\n";

				public const string MezanixDiamondSetVector3 =
					"\t\tvoid MezanixDiamondSetVector3 (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetVector3 (eName, vector3Values [0]);\n\t\t}\n";


				public const string MezanixDiamondGetVector3List =
					"\t\tList<Vector3> MezanixDiamondGetVector3List (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn vector3ListValues [0];\n\n\t\t\treturn mddt.GetVector3List (eName, vector3ListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveVector3List =
					"\t\tvoid MezanixDiamondRemoveVector3List (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveVector3List (eName);\n\t\t}\n";

				public const string MezanixDiamondSetVector3List =
					"\t\tvoid MezanixDiamondSetVector3List (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetVector3List (eName, vector3ListValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetVector4 =
					"\t\tVector4 MezanixDiamondGetVector4 (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn vector4Values [0];\n\n\t\t\treturn mddt.GetVector4 (eName, vector4Values [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveVector4 =
					"\t\tvoid MezanixDiamondRemoveVector4 (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveVector4 (eName);\n\t\t}\n";

				public const string MezanixDiamondSetVector4 =
					"\t\tvoid MezanixDiamondSetVector4 (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetVector4 (eName, vector4Values [0]);\n\t\t}\n";


				public const string MezanixDiamondGetVector4List =
					"\t\tList<Vector4> MezanixDiamondGetVector4List (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn vector4ListValues [0];\n\n\t\t\treturn mddt.GetVector4List (eName, vector4ListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveVector4List =
					"\t\tvoid MezanixDiamondRemoveVector4List (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveVector4List (eName);\n\t\t}\n";

				public const string MezanixDiamondSetVector4List =
					"\t\tvoid MezanixDiamondSetVector4List (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetVector4List (eName, vector4ListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondGetRect =
					"\t\tRect MezanixDiamondGetRect (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn rectValues [0];\n\n\t\t\treturn mddt.GetRect (eName, rectValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveRect =
					"\t\tvoid MezanixDiamondRemoveRect (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveRect (eName);\n\t\t}\n";

				public const string MezanixDiamondSetRect =
					"\t\tvoid MezanixDiamondSetRect (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetRect (eName, rectValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetRectList =
					"\t\tList<Rect> MezanixDiamondGetRectList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn rectListValues [0];\n\n\t\t\treturn mddt.GetRectList (eName, rectListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveRectList =
					"\t\tvoid MezanixDiamondRemoveRectList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveRectList (eName);\n\t\t}\n";

				public const string MezanixDiamondSetRectList =
					"\t\tvoid MezanixDiamondSetRectList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetRectList (eName, rectListValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetMaterial =
					"\t\tMaterial MezanixDiamondGetMaterial (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn materialValues [0];\n\n\t\t\treturn mddt.GetMaterial (eName, materialValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveMaterial =
					"\t\tvoid MezanixDiamondRemoveMaterial (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveMaterial (eName);\n\t\t}\n";

				public const string MezanixDiamondSetMaterial =
					"\t\tvoid MezanixDiamondSetMaterial (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetMaterial (eName, materialValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetMaterialList =
					"\t\tList<Material> MezanixDiamondGetMaterialList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn materialsListValues [0];\n\n\t\t\treturn mddt.GetMaterialList (eName, materialsListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveMaterialList =
					"\t\tvoid MezanixDiamondRemoveMaterialList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveMaterialList (eName);\n\t\t}\n";

				public const string MezanixDiamondSetMaterialList =
					"\t\tvoid MezanixDiamondSetMaterialList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetMaterialList (eName, materialsListValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetTexture2D =
					"\t\tTexture2D MezanixDiamondGetTexture2D (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn texture2DValues [0];\n\n\t\t\treturn mddt.GetTexture2D (eName, texture2DValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveTexture2D =
					"\t\tvoid MezanixDiamondRemoveTexture2D (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveTexture2D (eName);\n\t\t}\n";

				public const string MezanixDiamondSetTexture2D =
					"\t\tvoid MezanixDiamondSetTexture2D (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetTexture2D (eName, texture2DValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetTexture2DList =
					"\t\tList<Texture2D> MezanixDiamondGetTexture2DList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn texture2DListValues [0];\n\n\t\t\treturn mddt.GetTexture2DList (eName, texture2DListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveTexture2DList =
					"\t\tvoid MezanixDiamondRemoveTexture2DList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveTexture2DList (eName);\n\t\t}\n";

				public const string MezanixDiamondSetTexture2DList =
					"\t\tvoid MezanixDiamondSetTexture2DList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetTexture2DList (eName, texture2DListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondGetShader =
					"\t\tShader MezanixDiamondGetShader (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn shaderValues [0];\n\n\t\t\treturn mddt.GetShader (eName, shaderValues [0]);\n\t\t}\n";


				public const string MezanixDiamondRemoveShader =
					"\t\tvoid MezanixDiamondRemoveShader (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveShader (eName);\n\t\t}\n";

				public const string MezanixDiamondSetShader =
					"\t\tvoid MezanixDiamondSetShader (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetShader (eName, shaderValues [0]);\n\t\t}\n";


				public const string MezanixDiamondGetShaderList =
					"\t\tList<Shader> MezanixDiamondGetShaderList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn shaderListValues [0];\n\n\t\t\treturn mddt.GetShaderList (eName, shaderListValues [0]);\n\t\t}\n";

				public const string MezanixDiamondRemoveShaderList =
					"\t\tvoid MezanixDiamondRemoveShaderList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.RemoveShaderList (eName);\n\t\t}\n";

				public const string MezanixDiamondSetShaderList =
					"\t\tvoid MezanixDiamondSetShaderList (string eName)\n\t\t{\n\t\t\tScriptsCreatedByDiamond.MezanixDiamondDataTransfer mddt = Getmddt ();\n\n\t\t\tif (mddt == null)\n\t\t\t\treturn;\n\n\t\t\tmddt.SetShaderList (eName, shaderListValues [0]);\n\t\t}\n";


				public const string computeAds = 
					"\t\tvoid ComputeAds ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";
				

				const string uiInputFieldCheck = "\t\tvoid UiInputFieldCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tuiInputField = gameObjectValues [0].GetComponent <UnityEngine.UI.InputField> ();\n\n\t\t\tif (uiInputField == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";
				const string computeUiInputField = "\t\tvoid ComputeUiInputField ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tUiInputFieldCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";
				public const string GameObjectCheck_uiInputFieldCheck_computeUiInputField = gameObjectCheck + uiInputFieldCheck + computeUiInputField;

				const string lightCheck = "\t\tvoid LightCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlightComp = gameObjectValues [0].GetComponent <Light> ();\n\n\t\t\tif (lightComp == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";
				const string computeLight = "\t\tvoid ComputeLight ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tLightCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";
				public const string GameObjectCheck_lightCheck_computeLight = gameObjectCheck + lightCheck + computeLight;


				public const string tileSprite =
					"\t\tvoid TileSprite ()\n\t\t{\n\t\t\tVector3 startPosition = vector3Values [0];\n\n\t\t\tfloat startRotation = floatValues [0];\n\n\n\t\t\tVector2 rotationOverTiling_v2 = vector2Values [1];\n\n\t\t\tfloat rotationOverTiling = floatValues [1];\n\n\n\t\t\tVector3 tilePosition = Vector3.zero;\n\n\t\t\tfloat tileRotation = 0f;\n\n\n\t\t\tVector2 finalSpriteSize = new Vector2 (\n\t\t\t\tMathf.Abs (spriteRenderer.size.x*spriteRenderer.transform.localScale.x), \n\t\t\t\tMathf.Abs (spriteRenderer.size.y*spriteRenderer.transform.localScale.y));\n\n\t\t\tVector2 finalSpriteSizeNotNull = new Vector2 (\n\t\t\t\tfinalSpriteSize.x != 0f? finalSpriteSize.x: 1f,\n\t\t\t\tfinalSpriteSize.y != 0f? finalSpriteSize.y: 1f);\t\n\n\t\t\tVector2 totalSizeNotNull = new Vector2 (Mathf.Abs (vector2Values [0].x), Mathf.Abs (vector2Values [0].y));\n\n\t\t\tint tile_x = Mathf.FloorToInt (totalSizeNotNull.x / finalSpriteSizeNotNull.x);\n\n\t\t\tint tile_y = Mathf.FloorToInt (totalSizeNotNull.y / finalSpriteSizeNotNull.y);\n\n\t\t\tVector2 resid = new Vector2 (\n\t\t\t\tMathf.Abs (totalSizeNotNull.x - (float)tile_x*finalSpriteSizeNotNull.x),\n\t\t\t\tMathf.Abs (totalSizeNotNull.y - (float)tile_y*finalSpriteSizeNotNull.y));\n\n\n\t\t\tGameObject spritesParent = new GameObject (\"SpriteTiles\");\n\t\t\tspritesParent.transform.position = startPosition;\n\t\t\tspritesParent.transform.rotation = Quaternion.Euler (Vector3.zero);\n\t\t\tspritesParent.transform.localScale = Vector3.one;\n\t\t\tGameObject newSprite = null;\n\t\t\tfor (int j = 0; j < tile_y; j++)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < tile_x; i++)\n\t\t\t\t{\n\t\t\t\t\ttilePosition = startPosition + new Vector3 (finalSpriteSizeNotNull.x*(float)i, \n\t\t\t\t\t\tfinalSpriteSizeNotNull.y*(float)j);\n\n\t\t\t\t\ttileRotation = startRotation;\n\n\t\t\t\t\tTileRotation (ref tileRotation, startRotation, rotationOverTiling, rotationOverTiling_v2,\n\t\t\t\t\t\ttile_x, i, j);\n\n\t\t\t\t\tnewSprite = MonoBehaviour.Instantiate (spriteRenderer.gameObject, tilePosition,\n\t\t\t\t\t\tQuaternion.Euler (new Vector3 (0f, 0f, tileRotation)), spritesParent.transform);\n\n\t\t\t\t\tnewSprite.name = spriteRenderer.name + \"_\" + i.ToString () + \"_x_\" + j.ToString ();\n\n\t\t\t\t\tif (i == tile_x-1 && resid.x > 0f)\n\t\t\t\t\t{\n\t\t\t\t\t\ttilePosition = startPosition + new Vector3 (\n\t\t\t\t\t\t\tfinalSpriteSizeNotNull.x*(float)i+0.5f*(1f+resid.x)*finalSpriteSizeNotNull.x, \n\t\t\t\t\t\t\tfinalSpriteSizeNotNull.y*(float)j);\n\n\t\t\t\t\t\tTileRotation (ref tileRotation, startRotation, rotationOverTiling, rotationOverTiling_v2,\n\t\t\t\t\t\t\ttile_x, i, j);\n\n\t\t\t\t\t\tnewSprite = MonoBehaviour.Instantiate (spriteRenderer.gameObject, tilePosition,\n\t\t\t\t\t\t\tQuaternion.Euler (new Vector3 (0f, 0f, tileRotation)), spritesParent.transform);\n\n\t\t\t\t\t\tnewSprite.transform.localScale = new Vector3 (spriteRenderer.transform.localScale.x*resid.x,\n\t\t\t\t\t\t\tspriteRenderer.transform.localScale.y, spriteRenderer.transform.localScale.z);\n\n\t\t\t\t\t\tnewSprite.name = spriteRenderer.name + \"_\" + \"residual\" + \"_x_\" + j.ToString ();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif (j == tile_y-1 && resid.y > 0f)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < tile_x; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttilePosition = startPosition + new Vector3 (finalSpriteSizeNotNull.x*(float)i, \n\t\t\t\t\t\t\tfinalSpriteSizeNotNull.y*(float)j+0.5f*(1f+resid.y)*finalSpriteSizeNotNull.y);\n\n\t\t\t\t\t\ttileRotation = startRotation;\n\n\t\t\t\t\t\tTileRotation (ref tileRotation, startRotation, rotationOverTiling, rotationOverTiling_v2,\n\t\t\t\t\t\t\ttile_x, i, j);\n\n\t\t\t\t\t\tnewSprite = MonoBehaviour.Instantiate (spriteRenderer.gameObject, tilePosition,\n\t\t\t\t\t\t\tQuaternion.Euler (new Vector3 (0f, 0f, tileRotation)), spritesParent.transform);\n\n\t\t\t\t\t\tnewSprite.transform.localScale = new Vector3 (spriteRenderer.transform.localScale.x,\n\t\t\t\t\t\t\tspriteRenderer.transform.localScale.y*resid.y, spriteRenderer.transform.localScale.z);\n\n\t\t\t\t\t\tnewSprite.name = spriteRenderer.name + \"_\" + i.ToString () + \"_x_\" + \"residual\";\n\n\t\t\t\t\t\tif (i == tile_x-1 && resid.x > 0f)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttilePosition = startPosition + new Vector3 (\n\t\t\t\t\t\t\t\tfinalSpriteSizeNotNull.x*(float)i+0.5f*(1f+resid.x)*finalSpriteSizeNotNull.x, \n\t\t\t\t\t\t\t\tfinalSpriteSizeNotNull.y*(float)j+0.5f*(1f+resid.y)*finalSpriteSizeNotNull.y);\n\n\t\t\t\t\t\t\tTileRotation (ref tileRotation, startRotation, rotationOverTiling, rotationOverTiling_v2,\n\t\t\t\t\t\t\t\ttile_x, i, j);\n\n\t\t\t\t\t\t\tnewSprite = MonoBehaviour.Instantiate (spriteRenderer.gameObject, tilePosition,\n\t\t\t\t\t\t\t\tQuaternion.Euler (new Vector3 (0f, 0f, tileRotation)), spritesParent.transform);\n\n\t\t\t\t\t\t\tnewSprite.transform.localScale = new Vector3 (spriteRenderer.transform.localScale.x*resid.x,\n\t\t\t\t\t\t\t\tspriteRenderer.transform.localScale.y*resid.y, spriteRenderer.transform.localScale.z);\n\n\t\t\t\t\t\t\tnewSprite.name = spriteRenderer.name + \"_\" + \"residual\" + \"_x_\" + \"residual\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgameObjectValue = spritesParent;\n\t\t}\n\n\t\tvoid TileRotation (ref float tileRotation, float startRotation, float rotationOverTiling, Vector2 rotationOverTiling_v2,\n\t\t\tint tile_x, int i, int j)\n\t\t{\n\t\t\tif ( ! boolValues [0])\n\t\t\t{\n\t\t\t\tif (boolValues [1])\n\t\t\t\t{\n\t\t\t\t\ttileRotation = startRotation + (float)i*rotationOverTiling_v2.x + (float)j*rotationOverTiling_v2.y;\n\t\t\t\t}\n\t\t\t\telse if ( ! boolValues [1])\n\t\t\t\t{\n\t\t\t\t\ttileRotation = startRotation + (float)(i+j*tile_x)*rotationOverTiling;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (boolValues [0])\n\t\t\t{\n\t\t\t\ttileRotation = UnityEngine.Random.Range (0f, 359.9f);\n\t\t\t}\n\t\t}\n\n";

				public const string notZero = 
					"\t\tfloat NotZero (float v, float eps = 0.001f)\n\t\t{\n\t\t\tif (v > -eps && v <= 0f)\n\t\t\t\treturn -eps;\n\n\t\t\tif (v >= 0f && v < eps)\n\t\t\t\treturn eps;\n\n\t\t\treturn v;\n\t\t}\n";

				public const string transformParallaxScrolling = 
					"\t\tvoid ParallaxScrolling ()\n\t\t{\n\t\t\tfloat newScrolling = Mathf.Repeat(Time.time * (-1f)*floatValues [0], NotZero (floatValues [1]));\n\n\t\t\ttransform_.position = vector3Values [0] + vector3Values [1].normalized * newScrolling;\n\t\t}\n\n";



				public const string inventoryListAction_gameobject_compute =
					"\t\tvoid InventoryListAction_gameobject_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tgameObjectsListValue = gameObjectsListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tgameObjectsListValue.Add (gameObjectValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (gameObjectsListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > gameObjectsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tgameObjectValue = gameObjectsListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tgameObjectsListValue.Remove (gameObjectValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > gameObjectsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tgameObjectsListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = gameObjectsListValue.Count;\n\t\t}\n\n";

				public const string ForGet_gameObjectList_Compute =
					"\t\tvoid ForGet_gameObjectList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tgameObjectsListValue = gameObjectsListValues [0];\n\t\t\t}\n\n\t\t\tintValue = gameObjectsListValue.Count;\n\t\t}\n";


				public const string inventoryListAction_material_compute =
					"\t\tvoid InventoryListAction_material_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tmaterialsListValue = materialsListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tmaterialsListValue.Add (materialValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (materialsListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > materialsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tmaterialValue = materialsListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tmaterialsListValue.Remove (materialValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > materialsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tmaterialsListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = materialsListValue.Count;\n\t\t}\n\n";

				public const string ForGet_materialList_Compute =
					"\t\tvoid ForGet_materialList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tmaterialsListValue = materialsListValues [0];\n\t\t\t}\n\n\t\t\tintValue = materialsListValue.Count;\n\t\t}\n";


				public const string inventoryListAction_shader_compute = 
					"\t\tvoid InventoryListAction_shader_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tshaderListValue = shaderListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tshaderListValue.Add (shaderValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (shaderListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > shaderListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tshaderValue = shaderListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tshaderListValue.Remove (shaderValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > shaderListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tshaderListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = shaderListValue.Count;\n\t\t}\n\n";

				public const string ForGet_shaderList_Compute =
					"\t\tvoid ForGet_shaderList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tshaderListValue = shaderListValues [0];\n\t\t\t}\n\n\t\t\tintValue = shaderListValue.Count;\n\t\t}\n";

				public const string inventoryListAction_texture2D_compute =
					"\t\tvoid InventoryListAction_texture2D_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\ttexture2DListValue = texture2DListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\ttexture2DListValue.Add (texture2DValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (texture2DListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > texture2DListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\ttexture2DValue = texture2DListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\ttexture2DListValue.Remove (texture2DValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > texture2DListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\ttexture2DListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = texture2DListValue.Count;\n\t\t}\n\n";

				public const string ForGet_texture2DList_Compute =
					"\t\tvoid ForGet_texture2DList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\ttexture2DListValue = texture2DListValues [0];\n\t\t\t}\n\n\t\t\tintValue = texture2DListValue.Count;\n\t\t}\n";

				public const string inventoryListAction_bool_compute =
					"\t\tvoid InventoryListAction_bool_Compute ()\n\t\t{\n\t\t\tif (boolValues [1])\n\t\t\t{\n\t\t\t\tboolsListValue = boolsListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tboolsListValue.Add (boolValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (boolsListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > boolsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tboolValue = boolsListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tboolsListValue.Remove (boolValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > boolsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tboolsListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = boolsListValue.Count;\n\t\t}\n\n";

				public const string ForGet_boolList_Compute =
					"\t\tvoid ForGet_boolList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tboolsListValue = boolsListValues [0];\n\t\t\t}\n\n\t\t\tintValue = boolsListValue.Count;\n\t\t}\n";
	
				public const string ForGet_bool_Compute =
					"\t\tvoid ForGet_bool_Compute ()\n\t\t{\n" +
					"\t\t\tif (boolValues [1])\n\t\t\t{\n\t\t\t\tboolValue = boolValues [0];\n\t\t\t}\n\t\t}\n\n";


				public const string inventoryListAction_color_compute =
					"\t\tvoid InventoryListAction_color_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tcolorsListValue = colorsListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tcolorsListValue.Add (colorValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (colorsListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > colorsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tcolorValue = colorsListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tcolorsListValue.Remove (colorValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > colorsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tcolorsListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = colorsListValue.Count;\n\t\t}\n\n";

				public const string ForGet_colorList_Compute = 
					"\t\tvoid ForGet_colorList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tcolorsListValue = colorsListValues [0];\n\t\t\t}\n\n\t\t\tintValue = colorsListValue.Count;\n\t\t}\n";

				public const string inventoryListAction_float_compute =
					"\t\tvoid InventoryListAction_float_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tfloatsListValue = floatsListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tfloatsListValue.Add (floatValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (floatsListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > floatsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tfloatValue = floatsListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tfloatsListValue.Remove (floatValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > floatsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tfloatsListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = floatsListValue.Count;\n\t\t}\n\n";

				public const string ForGet_floatList_Compute =
					"\t\tvoid ForGet_floatList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tfloatsListValue = floatsListValues [0];\n\t\t\t}\n\n\t\t\tintValue = floatsListValue.Count;\n\t\t}\n";


				public const string inventoryListAction_rect_compute =
					"\t\tvoid InventoryListAction_rect_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\trectListValue = rectListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\trectListValue.Add (rectValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (rectListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > rectListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\trectValue = rectListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\trectListValue.Remove (rectValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > rectListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\trectListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = rectListValue.Count;\n\t\t}\n\n";

				public const string inventoryListAction_vector4_compute =
					"\t\tvoid InventoryListAction_vector4_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tvector4ListValue = vector4ListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tvector4ListValue.Add (vector4Values [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (vector4ListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > vector4ListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tvector4Value = vector4ListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tvector4ListValue.Remove (vector4Values [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > vector4ListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tvector4ListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = vector4ListValue.Count;\n\t\t}\n\n";

				public const string inventoryListAction_vector3_compute =
					"\t\tvoid InventoryListAction_vector3_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tvector3ListValue = vector3ListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tvector3ListValue.Add (vector3Values [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (vector3ListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > vector3ListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tvector3Value = vector3ListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tvector3ListValue.Remove (vector3Values [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > vector3ListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tvector3ListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = vector3ListValue.Count;\n\t\t}\n\n";


				public const string inventoryListAction_int_compute =
					"\t\tvoid InventoryListAction_int_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tintsListValue = intsListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tintsListValue.Add (intValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (intsListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > intsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tintValue = intsListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tintsListValue.Remove (intValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > intsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tintsListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (inventoryListAction != InventoryListAction.makeObjectOfFollowingIndexReady)\n\t\t\t\tintValue = intsListValue.Count;\n\t\t}\n\n";

				public const string ForGet_intList_Compute =
					"\t\tvoid ForGet_intList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tintsListValue = intsListValues [0];\n\t\t\t}\n\n\t\t\tintValue = intsListValue.Count;\n\t\t}\n";

				public const string inventoryListAction_string_compute =
					"\t\tvoid InventoryListAction_string_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tstringsListValue = stringsListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tstringsListValue.Add (stringValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (stringsListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > stringsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tstringValue = stringsListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tstringsListValue.Remove (stringValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > stringsListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tstringsListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = stringsListValue.Count;\n\t\t}\n\n";

				public const string ForGet_stringList_Compute =
					"\t\tvoid ForGet_stringList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tstringsListValue = stringsListValues [0];\n\t\t\t}\n\n\t\t\tintValue = stringsListValue.Count;\n\t\t}\n";

				public const string inventoryListAction_vector2_compute =
					"\t\tvoid InventoryListAction_vector2_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tvector2ListValue = vector2ListValues [0];\n\t\t\t}\n\n\t\t\tswitch (inventoryListAction)\n\t\t\t{\n\t\t\tcase InventoryListAction.Add:\n\t\t\t\tvector2ListValue.Add (vector2Values [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.makeObjectOfFollowingIndexReady:\n\t\t\t\tif (vector2ListValue.Count == 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > vector2ListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tvector2Value = vector2ListValue [intValues [0]];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.nameEntireList:\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.Remove:\n\t\t\t\tvector2ListValue.Remove (vector2Values [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase InventoryListAction.RemoveAtThisIndex:\n\t\t\t\tif (intValues [0] < 0 || intValues [0] > vector2ListValue.Count -1)\n\t\t\t\t\treturn;\n\n\t\t\t\tvector2ListValue.RemoveAt (intValues [0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintValue = vector2ListValue.Count;\n\t\t}\n\n";

				public const string ForGet_vector2List_Compute =
					"\t\tvoid ForGet_vector2List_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tvector2ListValue = vector2ListValues[0];\n\t\t\t}\n\n\t\t\tintValue = vector2ListValue.Count;\n\t\t}\n";

				public const string ForGet_vector3List_Compute =
					"\t\tvoid ForGet_vector3List_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tvector3ListValue = vector3ListValues[0];\n\t\t\t}\n\n\t\t\tintValue = vector3ListValue.Count;\n\t\t}\n";
				
				public const string ForGet_vector4List_Compute = 
					"\t\tvoid ForGet_vector4List_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tvector4ListValue = vector4ListValues[0];\n\t\t\t}\n\n\t\t\tintValue = vector4ListValue.Count;\n\t\t}\n";

				public const string ForGet_RectList_Compute =
					"\t\tvoid ForGet_RectList_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\trectListValue = rectListValues[0];\n\t\t\t}\n\n\t\t\tintValue = rectListValue.Count;\n\t\t}\n";

				public const string ForGet_color_Compute =
					"\t\tvoid ForGet_color_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tcolorValue = colorValues [0];\n\t\t\t}\n\t\t}\n\n";


				public const string ForGet_float_Compute =
					"\t\tvoid ForGet_float_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tfloatValue = floatValues [0];\n\t\t\t}\n\t\t}\n\n";

				public const string ForGet_int_Compute =
					"\t\tvoid ForGet_int_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tintValue = intValues [0];\n\t\t\t}\n\t\t}";

				public const string ForGet_vector2_Compute =
					"\t\tvoid ForGet_vector2_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tvector2Value = vector2Values [0];\n\t\t\t}\n\t\t}\n\n";

				public const string ForGet_vector3_Compute =
					"\t\tvoid ForGet_vector3_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tvector3Value = vector3Values [0];\n\t\t\t}\n\t\t}\n\n";

				public const string ForGet_vector4_Compute =
					"\t\tvoid ForGet_vector4_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tvector4Value = vector4Values [0];\n\t\t\t}\n\t\t}\n\n";

				public const string ForGet_rect_Compute =
					"\t\tvoid ForGet_rect_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\trectValue = rectValues [0];\n\t\t\t}\n\t\t}\n\n";

				public const string ForGet_string_Compute =
					"\t\tvoid ForGet_string_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tstringValue = stringValues [0];\n\t\t\t}\n\t\t}\n\n";


				public const string ForGet_gameObject_Compute =
					"\t\tvoid ForGet_gameObject_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tgameObjectValue = gameObjectValues [0];\n\t\t\t}\n\t\t}\n\n";

				public const string ForGet_material_Compute =
					"\t\tvoid ForGet_material_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tmaterialValue = materialValues [0];\n\t\t\t}\n\t\t}\n\n";

				public const string ForGet_texture2D_Compute =
					"\t\tvoid ForGet_texture2D_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\ttexture2DValue = texture2DValues [0];\n\t\t\t}\n\t\t}\n\n";

				public const string ForGet_shader_Compute =
					"\t\tvoid ForGet_shader_Compute ()\n\t\t{\n\t\t\tif (boolValues [0])\n\t\t\t{\n\t\t\t\tshaderValue = shaderValues [0];\n\t\t\t}\n\t\t}\n\n";


				public const string applyComputeColorNoGui = "\t\tvoid ApplyComputeColorNoGUI ()\n\t\t{\n\t\t\tColor c0 = colorValues [0];\n\n\t\t\t//Color c1 = \n\n\t\t\tfloat o = floatValues [0];\n\n\n\t\t\tfloat o1 = floatValues [1];\n\n\t\t\tColor cm1 = new Color (0f, 0f, 0f, 0f);\n\n\t\t\tColor c1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);\n\n\n\t\t\tswitch (colorBlendMode)\n\t\t\t{\n\t\t\tcase ColorBlendMode.add:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Add (c0, c1o), c1o, o);\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.color:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Color_ (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.colorBurn:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorBurn (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.colorDodge:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.ColorDodge (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.darken:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Darken (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\n\n\n\t\t\tcase ColorBlendMode.difference:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Difference (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.exclusion:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Exclusion (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.hardLight:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardLight (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.hardMix:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.HardMix (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.hue:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Hue (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\n\n\n\n\t\t\tcase ColorBlendMode.lighten:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Lighten (c0, c1o), c1o, o);\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.linearBurn:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearBurn (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.linearDodge:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearDodge (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.linearLight:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.LinearLight (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.luminosity:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Luminosity (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\n\n\n\n\t\t\tcase ColorBlendMode.multiply:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Multiply (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.overlay:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Overlay (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.pinLight:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.PinLight (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.randomHsv:\n\t\t\t\tcolorValue = UnityEngine.Random.ColorHSV (\n\t\t\t\t\tColorsArithmetic.RGBToHSV (colorValues [0]) [0], ColorsArithmetic.RGBToHSV (colorValues [1]) [0],\n\t\t\t\t\tColorsArithmetic.RGBToHSV (colorValues [0]) [1], ColorsArithmetic.RGBToHSV (colorValues [1]) [1],\n\t\t\t\t\tColorsArithmetic.RGBToHSV (colorValues [0]) [2], ColorsArithmetic.RGBToHSV (colorValues [1]) [2]);\n\t\t\t\t\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.saturation:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Saturation (c0, c1o), c1o, o);\n\n\t\t\t\tbreak;\n\n\n\n\n\n\t\t\tcase ColorBlendMode.screen:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Screen (c0, c1o), c1o, o);\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.softLight:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.SoftLight (c0, c1o), c1o, o);\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.subtract:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.Subtract (c0, c1o), c1o, o);\n\t\t\t\tbreak;\n\n\t\t\tcase ColorBlendMode.vividLight:\n\t\t\t\tcolorValue = ColorsArithmetic.Opacity (ColorsArithmetic.VividLight (c0, c1o), c1o, o);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n";

				const string taskOnClick_boolValueTofalse = boolValueTofalse + taskOnClick;

				const string boolValueTofalse = "\t\tvoid BoolValueToFalse ()\n\t\t{\n\t\t\tboolValue = false;\n\t\t}\n\n";

				public const string taskOnClick = "\t\tvoid TaskOnClick()\n\t\t{\n\t\t\tboolValue = true;\n\t\t}\n\n";

				public const string spriteToTexture2D = "\t\tTexture2D SpriteToTexture2D (Sprite s)\n\t\t{\n\t\t\tTexture2D t = new Texture2D ((int)s.rect.width, (int)s.rect.height);\n\n\t\t\tColor [] c = s.texture.GetPixels ((int)s.rect.x, (int)s.rect.y, (int)s.rect.width, (int)s.rect.height);\n\n\t\t\tt.SetPixels (c);\n\n\t\t\tt.Apply ();\n\n\t\t\treturn t;\n\t\t}\n\n";

				public const string GetM44 = "\t\tMatrix4x4 GetM44 (float [] m44Vs)\n\t\t{\n\t\t\tMatrix4x4 r = new Matrix4x4 ();\n\n\t\t\tr.m00 = m44Vs [0];\n\t        r.m01 = m44Vs [1];\n\t        r.m02 = m44Vs [2];\n\t        r.m03 = m44Vs [3];\n\n\t        r.m10 = m44Vs [4];\n\t        r.m11 = m44Vs [5];\n\t        r.m12 = m44Vs [6];\n\t        r.m13 = m44Vs [7];\n\n\t        r.m20 = m44Vs [8];\n\t        r.m21 = m44Vs [9];\n\t        r.m22 = m44Vs [10];\n\t        r.m23 = m44Vs [11];\n\n\t        r.m30 = m44Vs [12];\n\t        r.m31 = m44Vs [13];\n\t        r.m32 = m44Vs [14];\n\t        r.m33 = m44Vs [15];\n\n\t\t\treturn r;\n\t\t}\n";

				public const string SetM44ValueToArray = "\t\tfloat [] SetM44ValueToArray (Matrix4x4 m44)\n\t\t{\n\t\t\tfloat [] r = new float[16];\n\n\n\t\t\tr [0] =  m44.m00;\n\t\t\tr [1] =  m44.m01;\n\t\t\tr [2] =  m44.m02;\n\t\t\tr [3] =  m44.m03;\n\n\t\t\tr [4] =  m44.m10;\n\t\t\tr [5] =  m44.m11;\n\t\t\tr [6] =  m44.m12;\n\t\t\tr [7] =  m44.m13;\n\n\t\t\tr [8] =  m44.m20;\n\t\t\tr [9] =  m44.m21;\n\t\t\tr [10] = m44.m22;\n\t\t\tr [11] = m44.m23;\n\n\t\t\tr [12] = m44.m30;\n\t\t\tr [13] = m44.m31;\n\t\t\tr [14] = m44.m32;\n\t\t\tr [15] = m44.m33;\n\n\t\t\treturn r;\n\t\t}\n\n";

				public const string texture2D_0_check_block = "\t\t\t\tif (texture2DValues [0] == null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n";

				public const string gameObjectCheck = "\t\tvoid GameObjectCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (gameObjectValues [0] == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string gameObjectCheck_1 = "\t\tvoid GameObjectCheck_1 ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (gameObjectValues [1] == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";


				public const string computeMaterial = "\t\tvoid ComputeMaterial ()\n\t\t{\n\t\t\tif ( ! doIT)\n" +
					"\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeMaterial_NoDoIt =
					"\t\tvoid ComputeMaterial ()\n\t\t{\n";
				


				public const string computeShader = "\t\tvoid ComputeShader ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";

				public const string computeShader_NoDoIt = 
					"\t\tvoid ComputeShader ()\n\t\t{\n";


				public const string computeTexture2D = "\t\tvoid ComputeTexture2D ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";

				public const string computeTexture2D_NoDoIt =
					"\t\tvoid ComputeTexture2D ()\n\t\t{\n";





				public const string navMeshAgentCheck = "\t\tvoid NavMeshAgentCheck ()\n" +
					"\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n" +
					"\t\t\t}\n\n\t\t\tnavMeshAgent = gameObjectValues [0].GetComponent <UnityEngine.AI.NavMeshAgent> ();\n\n\t\t\tif (navMeshAgent == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}" + "\n\n";
				public const string extractNavMeshHitValues = "\t\tvoid ExtractNavMeshHitValues ()\n\t\t{\n\t\t\tNavMeshHit_distance = navMeshHit.distance;\n\n\t\t\tNavMeshHit_hit = navMeshHit.hit;\n\n\t\t\tNavMeshHit_mask = navMeshHit.mask;\n\n\t\t\tNavMeshHit_normal = navMeshHit.normal;\n\n\t\t\tNavMeshHit_position = navMeshHit.position;\n\t\t}" + "\n\n";


				public const string computeNavMeshAgent = "\t\tvoid ComputeNavMeshAgent ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tNavMeshAgentCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";



				public const string cameraCheck = "\t\tvoid CameraCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcam = gameObjectValues [0].GetComponent <Camera>();\n\n\t\t\tif (cam == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}" + "\n\n";
				public const string getCam_1 = "\t\tvoid GetCam_1 ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tif (gameObjectValues [1] != null)\n\t\t\t{\n\t\t\t\tcam_1 = gameObjectValues [1].GetComponent <Camera> ();\n\t\t\t}\n\t\t}" + "\n\n";


				public const string computeCamera = "\t\tvoid ComputeCamera ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tCameraCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";



				public const string SetRayValueOriginAndDirection = "\t\tvoid SetRayValueOrigine (Vector3 v)\n\t\t{\n\t\t\trayValueOrigin = v; \n\n\t\t\trayValue.origin = v;\n\t\t}\n\n\t\tvoid SetRayDirectionValue (Vector3 v)\n\t\t{\n\t\t\trayDirectionValueNotNormalized = v;\n\n\t\t\trayValue.direction = v.normalized;\n\t\t}\n\n";



				public const string colliderCheck = "\t\tvoid ColliderCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcollider = gameObjectValues [0].GetComponent <Collider> ();\n\n\t\t\tif (collider == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string boxColliderCheck = "\t\tvoid ColliderCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tboxCollider = gameObjectValues [0].GetComponent <BoxCollider> ();\n\n\t\t\tif (boxCollider == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string capsuleColliderCheck = "\t\tvoid ColliderCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcapsuleCollider = gameObjectValues [0].GetComponent <CapsuleCollider> ();\n\n\t\t\tif (capsuleCollider == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string meshColliderCheck = "\t\tvoid ColliderCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeshCollider = gameObjectValues [0].GetComponent <MeshCollider> ();\n\n\t\t\tif (meshCollider == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string sphereColliderCheck = "\t\tvoid ColliderCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsphereCollider = gameObjectValues [0].GetComponent <SphereCollider> ();\n\n\t\t\tif (sphereCollider == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string computeCollider = "\t\tvoid ComputeCollider ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tColliderCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";



				//UnityEngine.UI.Text unityText
				public const string collider2DCheck = "\t\tvoid Collider2DCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcollider2D = gameObjectValues [0].GetComponent <Collider2D> ();\n\n\t\t\tif (collider2D == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";
				public const string boxCollider2DCheck = "\t\tvoid Collider2DCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tboxCollider2D = gameObjectValues [0].GetComponent <BoxCollider2D> ();\n\n\t\t\tif (boxCollider2D == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";
				public const string circleCollider2DCheck = "\t\tvoid Collider2DCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcircleCollider2D = gameObjectValues [0].GetComponent <CircleCollider2D> ();\n\n\t\t\tif (circleCollider2D == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string computeCollider2D = "\t\tvoid ComputeCollider2D ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tCollider2DCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";

				public const string computeMouseInput = "\t\tvoid ComputeMouseInput ()\n\t\t{\n";

				//
				public const string computeUnityInputClassAndCrossPlatform = 
					"\t\tvoid ComputeUnityInputClassAndCrossPlatform ()\n\t\t{\n";


				const string unityTextCheck = "\t\tvoid UnityTextCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tunityText = gameObjectValues [0].GetComponent <UnityEngine.UI.Text> ();\n\n\t\t\tif (unityText == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";
				const string computeUnityText = "\t\tvoid ComputeUnityText ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tUnityTextCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";
				public const string GameObjectCheck_unityTextCheck_computeUnityText = gameObjectCheck + unityTextCheck + computeUnityText;

				const string uiImageCheck = "\t\tvoid UiImageCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tuiImage = gameObjectValues [0].GetComponent <UnityEngine.UI.Image> ();\n\n\t\t\tif (uiImage == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";
				const string computeUiImage = "\t\tvoid ComputeUiImage ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tUiImageCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";
				public const string GameObjectCheck_uiImageCheck_computeUiImage = gameObjectCheck + uiImageCheck + computeUiImage;


				const string uiButtonCheck = "\t\tvoid UiButtonCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tuiButton = gameObjectValues [0].GetComponent <UnityEngine.UI.Button> ();\n\n\t\t\tif (uiButton == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";
				const string computeUiButton = "\t\tvoid ComputeUiButton ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tUiButtonCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";
				public const string GameObjectCheck_uiButtonCheck_computeUiButton = 
					gameObjectCheck + uiButtonCheck + computeUiButton;

				const string uiToggleCheck = "\t\tvoid UiToggleCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tuiToggle = gameObjectValues [0].GetComponent <UnityEngine.UI.Toggle> ();\n\n\t\t\tif (uiToggle == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";
				const string computeUiToggle = "\t\tvoid ComputeUiToggle ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tUiToggleCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";
				public const string GameObjectCheck_uiToggleCheck_computeUiToggle = gameObjectCheck + uiToggleCheck + computeUiToggle;



				public const string particleSystemCheck =
					"\t\tvoid ParticleSystemCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tparticleSystem = gameObjectValues [0].GetComponent <ParticleSystem> ();\n\n\t\t\tif (particleSystem == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpsMain = particleSystem.main;\n\t\t\t}\n\t\t}\n\n";

				public const string computeParticleSystem = "\t\tvoid ComputeParticleSystem ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tParticleSystemCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";



				public const string rendererCheck = "\t\tvoid RendererCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trenderer = gameObjectValues [0].GetComponent <Renderer> ();\n\n\t\t\tif (renderer == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string canvasRendererCheck = "\t\tvoid RendererCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcanvasRenderer = gameObjectValues [0].GetComponent <CanvasRenderer> ();\n\n\t\t\tif (canvasRenderer == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string lineRendererCheck = "\t\tvoid RendererCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlineRenderer = gameObjectValues [0].GetComponent <LineRenderer> ();\n\n\t\t\tif (lineRenderer == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string spriteRendererCheck = "\t\tvoid RendererCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tspriteRenderer = gameObjectValues [0].GetComponent <SpriteRenderer> ();\n\n\t\t\tif (spriteRenderer == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string computeRenderer = "\t\tvoid ComputeRenderer ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tRendererCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";





				public const string rigidbodyCheck = "\t\tvoid RigidbodyCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trigidBody = gameObjectValues [0].GetComponent <Rigidbody> ();\n\n\t\t\tif (rigidBody == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string computeRigidbody = "\t\tvoid ComputeRigidbody ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tRigidbodyCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";



				public const string assignRayCastHitInfos = "\t\tvoid AssignRayCasthitInfos ()\n\t\t{\n\t\t\tif ( ! boolValue)\n\t\t\t{\n\t\t\t\tResetRayCastHitInfos ();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\traycastHitGameObject = hit.transform.gameObject;\n\n\t\t\tif (raycastHitGameObject == null)\n\t\t\t\traycastHitGameObject = hit.collider.gameObject;\n\n\t\t\tif (raycastHitGameObject == null)\n\t\t\t\traycastHitGameObject = hit.rigidbody.gameObject;\n\n\n\n\t\t\traycastHitBarycentricCoordinate = hit.barycentricCoordinate;\n\n\t\t\traycastHitTriangleIndex = hit.triangleIndex;\n\n\n\t\t\traycastHitPoint = hit.point;\n\n\t\t\traycastHitNormal = hit.normal;\n\n\t\t\traycastHitDistance = hit.distance;\n\n\n\t\t\traycastHitLightmapCoord = hit.lightmapCoord;\n\n\t\t\traycastHittextureCoord = hit.textureCoord;\n\n\t\t\traycastHittextureCoord2 =  hit.textureCoord2;\n\t\t}\n\n";

				public const string assignRaycast_2D_hitInfos = 
					"\n\t\tvoid AssignRayCasthit_2D_Infos ()\n\t\t{\n\t\t\tif (hit2D.collider == null)\n\t\t\t{\n\t\t\t\tResetRayCasthit_2D_Infos ();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\n\n\t\t\thit2D_gameObject = hit2D.transform.gameObject;\n\n\t\t\tif (hit2D_gameObject == null)\n\t\t\t\thit2D_gameObject = hit2D.collider.gameObject;\n\n\t\t\tif (hit2D_gameObject == null)\n\t\t\t\thit2D_gameObject = hit2D.rigidbody.gameObject;\n\n\n\n\t\t\tboolValue = true;\n\n\t\t\thit2D_centroid = hit2D.centroid;\n\n\t\t\thit2D_fraction = hit2D.fraction;\n\n\n\t\t\thit2D_point = hit2D.point;\n\n\t\t\thit2D_normal = hit2D.normal;\n\n\t\t\thit2D_distance = hit2D.distance;\n\t\t}\n\n\t";

				public const string assignRayCastHitInfosByIndex = "\t\tvoid AssignRayCasthitInfos (int wantedHit)\n\t\t{\n\t\t\tif (hits.Length == 0)\n\t\t\t{\n\t\t\t\tResetRayCastHitInfos ();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tif (wantedHit < 0 || wantedHit > hits.Length-1)\n\t\t\t{\n\t\t\t\tResetRayCastHitInfos ();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tboolValue = true;\n\n\t\t\traycastHitGameObject = hits [wantedHit].transform.gameObject;\n\n\t\t\tif (raycastHitGameObject == null)\n\t\t\t\traycastHitGameObject = hits [wantedHit].collider.gameObject;\n\n\t\t\tif (raycastHitGameObject == null)\n\t\t\t\traycastHitGameObject = hits [wantedHit].rigidbody.gameObject;\n\n\n\n\t\t\traycastHitBarycentricCoordinate = hits [wantedHit].barycentricCoordinate;\n\n\t\t\traycastHitTriangleIndex = hits [wantedHit].triangleIndex;\n\n\n\t\t\traycastHitPoint = hits [wantedHit].point;\n\n\t\t\traycastHitNormal = hits [wantedHit].normal;\n\n\t\t\traycastHitDistance = hits [wantedHit].distance;\n\n\n\t\t\traycastHitLightmapCoord = hits [wantedHit].lightmapCoord;\n\n\t\t\traycastHittextureCoord = hits [wantedHit].textureCoord;\n\n\t\t\traycastHittextureCoord2 =  hits [wantedHit].textureCoord2;\n\t\t}\n\n";

				public const string resetRayCastHitInfos = "\t\tvoid ResetRayCastHitInfos ()\n\t\t{\n\t\t\tboolValue = false;\n\n\t\t\traycastHitGameObject = null;\n\n\n\n\t\t\traycastHitBarycentricCoordinate = new Vector3 ();\n\n\t\t\traycastHitTriangleIndex = -1;\n\n\n\t\t\traycastHitPoint = new Vector3 ();\n\n\t\t\traycastHitNormal = new Vector3 ();\n\n\t\t\traycastHitDistance = 0f;\n\n\n\t\t\traycastHitLightmapCoord = new Vector2 ();\n\n\t\t\traycastHittextureCoord = new Vector2 ();\n\n\t\t\traycastHittextureCoord2 =  new Vector2 ();\n\t\t}\n\n";

				public const string resetRaycast_2D_hitInfos = 
					"\t\tvoid ResetRayCasthit_2D_Infos ()\n\t\t{\n\t\t\tboolValue = false;\n\n\t\t\thit2D_gameObject = null;\n\n\n\n\t\t\thit2D_centroid = new Vector2 ();\n\n\t\t\thit2D_fraction = 0f;\n\n\n\t\t\thit2D_point = new Vector2 ();\n\n\t\t\thit2D_normal = new Vector2 ();\n\n\t\t\thit2D_distance = 0f;\n\t\t}\n";

				public const string rigidbodyCheck2D = "\t\tvoid Rigidbody2DCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trigidBody2D = gameObjectValues [0].GetComponent <Rigidbody2D> ();\n\n\t\t\tif (rigidBody2D == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string computeRigidbody2D = "\t\tvoid ComputeRigidbody2D ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tRigidbody2DCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";




				public const string transformCheck2D = 
					"\t\tvoid TransformCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttransform_ = gameObjectValues [0].GetComponent <Transform> ();\n\n\t\t\tif (transform_ == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string computeTransform = "\t\tvoid ComputeTransform ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tTransformCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";



				public const string audioSourceCheck = 
					"\t\tvoid AudioSourceCheck ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taudioSource_ = gameObjectValues [0].GetComponent <AudioSource> ();\n\n\t\t\tif (audioSource_ == null)\n\t\t\t{\n\t\t\t\tdoIT = false;\n\t\t\t}\n\t\t}\n\n";

				public const string computeAudioSource = "\t\tvoid ComputeAudioSource ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tAudioSourceCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n";


				public const string computeColorNoPreparation = "\t\tvoid ComputeColor ()\n\t\t{\n\t\t\tif ( ! doIT)\n" +
					"\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";

				public const string computeColorNoPreparation_NoDoIt = 
					"\t\tvoid ComputeColor ()\n\t\t{\n";
				

				public const string computeColor = "\t\tvoid ComputeColor ()\n\t\t{\n\t\t\tif ( ! doIT)\n" +
					"\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n" + 
					"\t\t\tColor c0 = colorValues [0];\n\t\t\t\n\t\t\t//Color c1 = \n\t\t\t\n\t\t\tfloat o = floatValues [0];\n\t\t\t\n\t\t\t\n\t\t\tfloat o1 = floatValues [1];\n\t\t\t\n\t\t\tColor cm1 = new Color (0f, 0f, 0f, 0f);\n\t\t\t\n\t\t\tColor c1o = ColorsArithmetic.Opacity (colorValues [1], cm1, o1);\n\n";

				public const string prepareToColorCompute_computeColor = prepareToColorCompute + computeColor;

				public const string computeFloat = "\t\tvoid ComputeFloat ()\n\t\t{\n\t\t\tif ( ! doIT)\n" +
					"\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";

				public const string computeFloat_NoDoIt = 
					"\t\tvoid ComputeFloat ()\n\t\t{\n";
				

				public const string computeGameObjectNoGameObjectAssign = 
					"\t\tvoid ComputeGameObject ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";

				public const string computeGameObject = "\t\tvoid ComputeGameObject ()\n\t\t{\n\t\t\tGameObjectCheck ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n\n";

				public const string computeGameObject_NoDoIT_NoCheck = 
					"\t\tvoid ComputeGameObject ()\n" +
					"\t\t{\n";

				public const string computeGameObject_NoCheck = 
					"\t\tvoid ComputeGameObject ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n" +
					"\t\t\tgameObjectValue = gameObjectValues [0];\n\n";

				public const string computeGameObject_NoCheck_NoAssign = 
					"\t\tvoid ComputeGameObject ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";


				public const string computeGameObject_1 = 
					"\t\tvoid ComputeGameObject ()\n\t\t{\n" +
					"\t\t\tGameObjectCheck ();\n\n\t\t\tGameObjectCheck_1 ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgameObjectValue = gameObjectValues [0];\n\n";





				public const string computeInt = "\t\tvoid ComputeInt ()\n\t\t{\n\t\t\tif ( ! doIT)\n" +
					"\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";

				public const string computeInt_NoDoIt = 
					"\t\tvoid ComputeInt ()\n\t\t{\n";
				


	
				public const string StringOperations_Compute = 
					"\t\tvoid StringOperations_Compute ()\n\t\t{\n\t\t\tswitch (stringOperations)\n\t\t\t{\n\t\t\tcase StringOperations.toInt:\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tintValue = int.Parse (stringValues [0]);\n\t\t\t\t}\n\t\t\t\tcatch\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning (\"invalid string format\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.toFloat:\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tfloatValue = float.Parse (stringValues [0]);\n\t\t\t\t}\n\t\t\t\tcatch\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning (\"invalid string format\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.TrimEnd:\n\t\t\t\tstringValue = stringValues [0].TrimEnd ();\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.TrimStart:\n\t\t\t\tstringValue = stringValues [0].TrimStart ();\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.Trim:\n\t\t\t\tstringValue = stringValues [0].Trim ();\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.ToUpperInvariant:\n\t\t\t\tstringValue = stringValues [0].ToUpperInvariant ();\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.ToUpper:\n\t\t\t\tstringValue = stringValues [0].ToUpper ();\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.ToLowerInvariant:\n\t\t\t\tstringValue = stringValues [0].ToLowerInvariant ();\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.ToLower:\n\t\t\t\tstringValue = stringValues [0].ToLower ();\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.Substring:\n\t\t\t\tstringValue = stringValues [0].Substring (intValues [0], intValues [1]);\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.StartsWith:\n\t\t\t\tboolValue = stringValues [0].StartsWith (stringValues [1]);\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.Remove:\n\t\t\t\tstringValue = stringValues [0].Remove (intValues [0], intValues [1]);\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.PadRight:\n\t\t\t\tstringValue = stringValues [0].PadRight (intValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.PadLeft:\n\t\t\t\tstringValue = stringValues [0].PadLeft (intValues [0]);\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.GetLength:\n\t\t\t\tintValue = stringValues [0].Length;\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.LastIndexOf:\n\t\t\t\tintValue = stringValues [0].LastIndexOf (stringValues [1]);\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.Insert:\n\t\t\t\tstringValue = stringValues [0].Insert (intValues [0], stringValues [1]);\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.GetIndexOf:\n\t\t\t\tintValue = stringValues [0].IndexOf (stringValues [1]);\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.GetHashCode:\n\t\t\t\tintValue = stringValues [0].GetHashCode ();\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.EndsWith:\n\t\t\t\tboolValue = stringValues [0].EndsWith (stringValues [1]);\n\t\t\t\tbreak;\n\n\t\t\tcase StringOperations.Contains:\n\t\t\t\tboolValue = stringValues [0].Contains (stringValues [1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n";
				
				public const string computeString = "\t\tvoid ComputeString ()\n\t\t{\n\t\t\tif ( ! doIT)\n" +
					"\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";

				public const string computeString_NoDoIt = 
					"\t\tvoid ComputeString ()\n\t\t{\n";
				

				public const string computeString_InitBoolIfNotDoIT = 
					"\t\tvoid ComputeString ()\n\t\t{\n\t\t\tif ( ! doIT)\n" +
					"\t\t\t{\n\t\t\t\tboolValue = false;\n\t\t\t\treturn;\n\t\t\t}\n\n";


				public const string computeVector2 = "\t\tvoid ComputeVector2 ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeVector2_NoDoIt = "\t\tvoid ComputeVector2 ()\n\t\t{\n";
				

				public const string computeVector3 = "\t\tvoid ComputeVector3 ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeVector3_NoDoIt = "\t\tvoid ComputeVector3 ()\n\t\t{\n";
				

				public const string computeVector4 = "\t\tvoid ComputeVector4 ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeVector4_NoDoIt = "\t\tvoid ComputeVector4 ()\n\t\t{\n";
				

				public const string computeRect = "\t\tvoid ComputeRect ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeRect_NoDoIt = "\t\tvoid ComputeRect ()\n\t\t{\n";
				


				public const string computeMatrix44 = "\t\tvoid ComputeMatrix44 ()\n\t\t{\n";


				public const string computeBoolList = "\t\tvoid ComputeBoolsList ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeBoolList_NoDoIt = 
					"\t\tvoid ComputeBoolsList ()\n\t\t{\n";
				


				public const string computeFloatList = "\t\tvoid ComputeFloatsList ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeFloatList_NoDoIT = 
					"\t\tvoid ComputeFloatsList ()\n\t\t{\n";
				


				public const string computeIntList = "\t\tvoid ComputeIntList ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeIntList_NoDoIt = 
					"\t\tvoid ComputeIntList ()\n\t\t{\n";
				

				public const string computeStringList = "\t\tvoid ComputeStringList ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeStringList_NoDoIt = 
					"\t\tvoid ComputeStringList ()\n\t\t{\n";
				

				public const string computeVector4List = "\t\tvoid ComputeVector4List ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeVector4List_NoDoIT =
					"\t\tvoid ComputeVector4List ()\n\t\t{\n";
				

				public const string computeGameObjectList = 
					"\t\tvoid ComputeGameObjectList ()\n\t\t{\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeGameObjectList_NoDoIT = 
					"\t\tvoid ComputeGameObjectList ()\n" +
					"\t\t{\n";
				


				public const string computeShaderList = "\t\tvoid ComputeShaderList ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeShaderList_NoDoIT =
					"\t\tvoid ComputeShaderList ()\n\t\t{\n";
				


				public const string computeTexture2DList = "\t\tvoid ComputeTexture2DList ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeTexture2DList_NoDoIT =
					"\t\tvoid ComputeTexture2DList ()\n\t\t{\n";


				public const string computeMaterialList = "\t\tvoid ComputeMaterialList ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeMaterialList_NoDoIt = 
					"\t\tvoid ComputeMaterialList ()\n\t\t{\n";
				


				public const string computeRectList = "\t\tvoid ComputeRectList ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeRectList_NoDoIt = 
					"\t\tvoid ComputeRectList ()\n\t\t{\n";



				public const string computeVector3List = "\t\tvoid ComputeVector3List ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeVector3List_NoDoIt = 
					"\t\tvoid ComputeVector3List ()\n\t\t{\n";
				


				public const string computeVector2List = "\t\tvoid ComputeVector2List ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeVector2List_NoDoIt =
					"\t\tvoid ComputeVector2List ()\n\t\t{\n";


				public const string computeColorList = "\t\tvoid ComputeColorList ()\n\t\t{\n" +
					"\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n";

				public const string computeColorList_NoDoIt =
					"\t\tvoid ComputeColorList ()\n\t\t{\n";
				


				public const string computeRay = 
					"\t\tvoid ComputeRay ()\n\t\t{\n\t\t\tResetRayCastHitInfos ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";

				public const string computeRay2D = 
					"\t\tvoid ComputeRay2D ()\n\t\t{\n\t\t\tResetRayCasthit_2D_Infos ();\n\n\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n";

				public static string GoToState (LogicNode logicNode)
				{
					return
						"\t\tvoid GoToState ()" 
						+ "\n\t\t{\n\t\t\tif ( ! boolValues [0])" 
						+ "\n\t\t\t{\n\t\t\t\treturn; \n\t\t\t}\n\n"
						+ "\t\t\t" + logicNode.GoToStateCommand () 
						+ "\n\t\t}" + "\n\n";
				}

				public const string SetM44Value = "\t\tvoid SetM44Value (Matrix4x4 m44)\n\t\t{\n\t\t\tm44Value_entier = m44;\n\n\n\t\t\tm44ValueDeterminant = m44.determinant;\n\n\t\t\tm44ValueIsIdentity = m44.isIdentity;\n\n\t\t\tm44ValueInvertible = (m44.determinant == 0f)? false: true;\n\n\n\t\t\tm44Value [0] = m44.m00;\n\t\t\tm44Value [1] = m44.m01;\n\t\t\tm44Value [2] = m44.m02;\n\t\t\tm44Value [3] = m44.m03;\n\n\t\t\tm44Value [4] = m44.m10;\n\t\t\tm44Value [5] = m44.m11;\n\t\t\tm44Value [6] = m44.m12;\n\t\t\tm44Value [7] = m44.m13;\n\n\t\t\tm44Value [8] = m44.m20;\n\t\t\tm44Value [9] = m44.m21;\n\t\t\tm44Value [10] = m44.m22;\n\t\t\tm44Value [11] = m44.m23;\n\n\t\t\tm44Value [12] = m44.m30;\n\t\t\tm44Value [13] = m44.m31;\n\t\t\tm44Value [14] = m44.m32;\n\t\t\tm44Value [15] = m44.m33;\n\t\t}" + "\n"; 
			}
		}

		class InOutWs
		{
			public class InWs
			{

				//
				public const string __loadSceneModeEnum =
					"\t\t\t\tloadSceneMode = (UnityEngine.SceneManagement.LoadSceneMode)DrawEnum (loadSceneMode,\n" +
					"\t\t\t\t\t\"Load Scene Mode\", Skins.logicNodeLabel);";


				public const string _DrawChooseSceneFromBuildScenes = "\t\t\t\tDrawChooseSceneFromBuildScenes ();\n\n";


				public const string _invetoryListAction = "\t\t\t\t" + 
					"inventoryListAction = (InventoryListAction)DrawEnum (" +
					"inventoryListAction, \"Inventory List Action\", Skins.logicNodeLabel);\n";


				public const string inventoryListAction_GameObject_DrawInputs =
					"\t\t\t\tInventoryListAction_gameobject_DrawInputs ();\n";

				public const string _invetoryListAction_and_gameobject_DrawInput = 
					_invetoryListAction + inventoryListAction_GameObject_DrawInputs;


				public const string inventoryListAction_material_DrawInputs =
					"\t\t\t\tInventoryListAction_material_DrawInputs ();\n";

				public const string _invetoryListAction_and_material_DrawInput = 
					_invetoryListAction + inventoryListAction_material_DrawInputs;


				public const string inventoryListAction_shader_DrawInputs =
					"\t\t\t\tInventoryListAction_shader_DrawInputs ();\n";

				public const string _invetoryListAction_and_shader_DrawInput = 
					_invetoryListAction + inventoryListAction_shader_DrawInputs;


				public const string inventoryListAction_texture2D_DrawInputs =
					"\t\t\t\tInventoryListAction_texture2D_DrawInputs ();\n";

				public const string _invetoryListAction_and_texture2D_DrawInput = 
					_invetoryListAction + inventoryListAction_texture2D_DrawInputs;



				public const string inventoryListAction_bool_DrawInputs =
					"\t\t\t\tInventoryListAction_bool_DrawInputs ();\n";

				public const string _invetoryListAction_and_bool_DrawInput = 
					_invetoryListAction + inventoryListAction_bool_DrawInputs;


				public const string inventoryListAction_color_DrawInputs =
					"\t\t\t\tInventoryListAction_color_DrawInputs ();\n";

				public const string _invetoryListAction_and_color_DrawInput = 
					_invetoryListAction + inventoryListAction_color_DrawInputs;


				public const string inventoryListAction_float_DrawInputs =
					"\t\t\t\tInventoryListAction_float_DrawInputs ();\n";

				public const string _invetoryListAction_and_float_DrawInput = 
					_invetoryListAction + inventoryListAction_float_DrawInputs;


				public const string inventoryListAction_rect_DrawInputs =
					"\t\t\t\tInventoryListAction_rect_DrawInputs ();\n";

				public const string _invetoryListAction_and_rect_DrawInput = 
					_invetoryListAction + inventoryListAction_rect_DrawInputs;


				public const string inventoryListAction_vector4_DrawInputs =
					"\t\t\t\tInventoryListAction_vector4_DrawInputs ();\n";

				public const string _invetoryListAction_and_vector4_DrawInput = 
					_invetoryListAction + inventoryListAction_vector4_DrawInputs;
				


				public const string inventoryListAction_vector3_DrawInputs =
					"\t\t\t\tInventoryListAction_vector3_DrawInputs ();\n";

				public const string _invetoryListAction_and_vector3_DrawInput = 
					_invetoryListAction + inventoryListAction_vector3_DrawInputs;



				public const string inventoryListAction_int_DrawInputs =
					"\t\t\t\tInventoryListAction_int_DrawInputs ();\n";

				public const string _invetoryListAction_and_int_DrawInput = 
					_invetoryListAction + inventoryListAction_int_DrawInputs;


				public const string inventoryListAction_string_DrawInputs =
					"\t\t\t\tInventoryListAction_string_DrawInputs ();\n";

				public const string _invetoryListAction_and_string_DrawInput = 
					_invetoryListAction + inventoryListAction_string_DrawInputs;


				public const string inventoryListAction_vector2_DrawInputs =
					"\t\t\t\tInventoryListAction_vector2_DrawInputs ();\n";

				public const string _invetoryListAction_and_vector2_DrawInput = 
					_invetoryListAction + inventoryListAction_vector2_DrawInputs;
				

				// camera_StereoscopicEye = (Camera.StereoscopicEye)DrawEnum (camera_StereoscopicEye, "Stereoscopic Eye", Skins.logicNodeLabel);
				public const string _camera_StereoscopicEye = 
					"\t\t\t\tcamera_StereoscopicEye = (Camera.StereoscopicEye)DrawEnum " +
					"(camera_StereoscopicEye, \"Stereoscopic Eye\", Skins.logicNodeLabel);\n\n";

				public const string _gameObjectList = "\t\t\t\tDrawGameObjectListFieldInput (0);\n\n";
				public const string _gameObjectList_1 = "\t\t\t\tDrawGameObjectListFieldInput (1);\n\n";
				public const string _gameObjectList_and_1 = _gameObjectList + "\n" + _gameObjectList_1;


				public const string _shaderList = "\t\t\t\tDrawShaderListFieldInput (0);\n\n";
				public const string _shaderList_1 = "\t\t\t\tDrawShaderListFieldInput (1);\n\n";
				public const string _shaderList_and_1 = _shaderList + "\n" + _shaderList_1;

				public const string _texture2DList = "\t\t\t\tDrawTexture2DListFieldInput (0);\n\n";
				public const string _texture2DList_1 = "\t\t\t\tDrawTexture2DListFieldInput (1);\n\n";
				public const string _texture2DList_and_1 = _texture2DList + "\n" + _texture2DList_1;


				public const string _materialList = "\t\t\t\tDrawMaterialListFieldInput (0);\n\n";
				public const string _materialList_1 = "\t\t\t\tDrawMaterialListFieldInput (1);\n\n";
				public const string _materialList_and_1 = _materialList + "\n" + _materialList_1;


				public const string _rectList = "\t\t\t\tDrawRectListFieldInput (0);\n\n";
				public const string _rectList_1 = "\t\t\t\tDrawRectListFieldInput (1);\n\n";
				public const string _rectList_and_1 = _rectList + "\n" + _rectList_1;


				public const string _vector4List = "\t\t\t\tDrawVector4ListFieldInput (0);\n\n";
				public const string _vector4List_1 = "\t\t\t\tDrawVector4ListFieldInput (1);\n\n";
				public const string _vector4List_and_1 = _vector4List + "\n" + _vector4List_1;


				public const string _vector3List = "\t\t\t\tDrawVector3ListFieldInput (0);\n\n";
				public const string _vector3List_1 = "\t\t\t\tDrawVector3ListFieldInput (1);\n\n";
				public const string _vector3List_and_1 = _vector3List + "\n" + _vector3List_1;


				public const string _vector2List = "\t\t\t\tDrawVector2ListFieldInput (0);\n\n";
				public const string _vector2List_1 = "\t\t\t\tDrawVector2ListFieldInput (1);\n\n";
				public const string _vector2List_and_1 = _vector2List + "\n" + _vector2List_1;

				public const string _colorList = "\t\t\t\tDrawColorListFieldInput (0);\n";
				public const string _colorList_1 = "\t\t\t\tDrawColorListFieldInput (1);\n";
				public const string _colorList_and_1 = _colorList + _colorList_1;

				public const string _stringList = "\t\t\t\tDrawStringsListFieldInput (0);\n\n";
				public const string _stringList_1 = "\t\t\t\tDrawStringsListFieldInput (1);\n\n";
				public const string _stringList_and_1 = _stringList + "\n" + _stringList_1;


				public const string _intsList = "\t\t\t\tDrawIntListFieldInput (0);\n\n";
				public const string _intsList_1 = "\t\t\t\tDrawIntListFieldInput (1);\n\n";
				public const string _intsList_and_1 = _intsList + "\n" + _intsList_1;

				public const string _floatsList = "\t\t\t\tDrawFloatListFieldInput (0);\n\n";
				public const string _floatsList_1 = "\t\t\t\tDrawFloatListFieldInput (1);\n\n";
				public const string _floatsList_and_1 = _floatsList + "\n" + _floatsList_1;

				public const string _boolList = "\t\t\t\tDrawBoolListFieldInput (0);\n";
				public const string _boolList_1 = "\t\t\t\tDrawBoolListFieldInput (1);\n";
				public const string _boolList_and_1 = _boolList + "\n" + _boolList_1;

				public const string _cameraCopyCameraSettings = "\t\t\t\tDrawLabelFields (new string[] {\"from this gameObject's Camera\",});\n\n\t\t\t\tDrawGameObjectFieldInput (1);\n\n\t\t\t\tif (gameObjectValues [1] == null)\n\t\t\t\t{\n\t\t\t\t\tDrawGameObject_0_isNullInfo ();\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcam_1 = gameObjectValues [1].GetComponent <Camera> ();\n\t\t\t\tif (cam_1 == null)\n\t\t\t\t{\n\t\t\t\t\tDrawInNodeInfo (\"Add Camera To GameObject\");\n\n\t\t\t\t\treturn;\n\t\t\t\t}";

				public const string _cameraCalculateOblicMatrix = "\t\t\t\tDrawLabelFields (new string[] {\"projection matrix for this near-plane\",});\n\t\t\t\tDrawVector4InputField (0);";

				public const string _cameraRenderWithShader = "\t\t\t\tDrawShaderFieldInput (0);\n\n\t\t\t\tDrawLabelFields (new string[] {\"Replacement Tag\",});\n\t\t\t\tDrawStringInputField (0, stringInputFieldForWhat.general);";

				public const string _cameraSetDEpthTextureMode = "\t\t\t\tdepthTextureMode = (DepthTextureMode)DrawEnum (\n\t\t\t\t\tdepthTextureMode, \"Depth Texture Mode\", Skins.logicNodeLabel);";

				public const string _cameraSetOpaqueSortMode = "\t\t\t\topaqueSortMode = (OpaqueSortMode)DrawEnum (\n\t\t\t\t\topaqueSortMode, \"Opaque Sort Mode\", Skins.logicNodeLabel);\n";

				public const string _cameraSetRenderingPath = "\t\t\t\trenderingPath = (RenderingPath)DrawEnum (\n\t\t\t\t\trenderingPath, \"RenderingPath\", Skins.logicNodeLabel);";


				public const string _cameraSetStereoProjectionMAtrix_0 = 
					"\t\t\t\tDrawLabelFields (new string[]{\"Matrix\"});\n\t\t\t\tDrawM44EntierInputField (0);\n\n";

				public const string _cameraSetStereoProjectionMAtrices = "\t\t\t\tDrawLabelFields (new string[]{\"Left Matrix\"});\n\t\t\t\tDrawM44EntierInputField (0);\n\n\t\t\t\tDrawLabelFields (new string[]{\"Right Matrix\"});\n\t\t\t\tDrawM44EntierInputField (1);\n";


				public const string _cameraSetTransparencySortMode = "\t\t\t\ttransparencySortMode = (TransparencySortMode)DrawEnum (\n\t\t\t\t\ttransparencySortMode, \"Transparency Sort Mode\", Skins.logicNodeLabel);";

				public const string _cameraViewportPointToRay = "\t\t\t\tDrawLabelFields (new string[] {\"Viewport Point (normalized), z ignored\",});\n\t\t\t\tDrawVector3InputField (0);\n";

				public const string _cameraViewportToScreenPoint = "\t\t\t\tDrawLabelFields (new string[] {\"Viewport Point (normalized)\",});\n\t\t\t\tDrawVector3InputField (0);\n";

				public const string _cameraWorldToScreenPoint = "\t\t\t\tDrawLabelFields (new string[] {\"World Point\",});\n\t\t\t\tDrawVector3InputField (0);\n";


				public const string _float = "\t\t\t\tDrawFloatInputField (0);";

				public const string _float_1 = "\t\t\t\tDrawFloatInputField (1);";

				public const string _float_2 = "\t\t\t\tDrawFloatInputField (2);";

				public const string _float_and_1 = _float + "\n" + _float_1;

				public const string _float_all = _float_and_1 + "\n" + _float_2;


				//
				public const string _material = "\t\t\t\tDrawMaterialFieldInput (0);";
				public const string _material_1 = "\t\t\t\tDrawMaterialFieldInput (1);";
				public const string _material_and_1 = _material + "\n" + _material_1;


				public const string _color = "\t\t\t\tDrawColorInputField (0);";

				public const string _color_1 = "\t\t\t\tDrawColorInputField (1);";

				public const string _color_and_1 = _color + "\n" + _color_1;


				public const string _color_OpacityLabel = "\t\t\t\tDrawColorInputField (0, true, 1f);";
				public const string _color_1_OpacityLabel = "\t\t\t\tDrawColorInputField (1, true, 1f);";
				public const string _color_and_1_OpacityLabel = _color_OpacityLabel + "\n" + _color_1_OpacityLabel;

				public const string _color_OpacityNumber = "\t\t\t\tDrawColorInputField (0, false, 1f);";
				public const string _color_1_OpacityNumber = "\t\t\t\tDrawColorInputField (1, false, 1f);";
				public const string _color_and_1_OpacityNumber = _color_OpacityNumber + "\n" + _color_1_OpacityNumber;



				public const string _texture2D = "\t\t\t\tDrawTexture2DFieldInput (0);";

				public const string _texture2D_1 = "\t\t\t\tDrawTexture2DFieldInput (1);";

				public const string _texture2D_and_1 = _texture2D + "\n" + _texture2D_1;


				public const string _shader = "\t\t\t\tDrawShaderFieldInput (0);";

				public const string _shader_1 = "\t\t\t\tDrawShaderFieldInput (1);";

				public const string _shader_and_1 = _shader + "\n" + _shader_1;


				public const string _cullingMask = "\n\t\t\t\tDrawLabelFields (new string[]\n\t\t\t\t\t{\n\t\t\t\t\t\t\"-1\" + StringTreatment.rArrow + \"everything\",\n\t\t\t\t\t\t\"0\" + StringTreatment.rArrow + \"nothing\",\n\t\t\t\t\t\t\"1\" + StringTreatment.rArrow + \"default\",\n\t\t\t\t\t\t\"2\" + StringTreatment.rArrow + \"transparentFx\",\n\t\t\t\t\t\t\"3\" + StringTreatment.rArrow + \"default + transparentFx\",\n\t\t\t\t\t\t\"4\" + StringTreatment.rArrow + \"ignore raycast\",\n\t\t\t\t\t\t\"5\" + StringTreatment.rArrow + \"default + ignore raycast\",\n\t\t\t\t\t\t\"6\" + StringTreatment.rArrow + \"transparentFx + ignore raycast\",\n\t\t\t\t\t\t\"7\" + StringTreatment.rArrow + \"default + transparentFx + ignore raycast\",\n\t\t\t\t\t\t\"16\" + StringTreatment.rArrow + \"water\",\n\t\t\t\t\t\t\"32\" + StringTreatment.rArrow + \"UI\",\n\t\t\t\t\t\t\"48\" + StringTreatment.rArrow + \"water + UI\",\n\t\t\t\t\t});\n\n\t\t\t\tDrawIntInputField (0);";

				public const string _bool = "\t\t\t\tDrawBoolInputField (0);";

				public const string _bool_1 = "\t\t\t\tDrawBoolInputField (1);";

				public const string _bool_and_1 = "\t\t\t\tDrawBoolInputField (0);" +
					"\n\t\t\t\tDrawBoolInputField (1);";

				public const string _gotoState = "\t\t\t\tDrawGoToStateInputs ();";

				public const string _int = "\t\t\t\tDrawIntInputField (0);";
				public const string _int_1 = "\t\t\t\tDrawIntInputField (1);";
				public const string _int_2 = "\t\t\t\tDrawIntInputField (2);";
				public const string _int_and_1 = _int + "\n" + _int_1;
				public const string _int_all = _int_and_1 + "\n" + _int_2;

				public const string _string = 
					"\t\t\t\tDrawStringInputField (0, stringInputFieldForWhat.general);";

				public const string _string_1 = 
					"\t\t\t\tDrawStringInputField (1, stringInputFieldForWhat.general);";

				public const string _string_and_1 = _string + "\n" + _string_1;


				public const string _tagfield = 
					"\t\t\t\tDrawTagField (0);";



				public const string _rect = "\t\t\t\tDrawRectInputField (0);";


				public const string _m44 = "\t\t\t\tDrawM44EntierInputField (0);";		
				public const string _m44_1 = "\t\t\t\tDrawM44EntierInputField (1);";
				public const string _m44_and_1  = _m44 + "\n" + _m44_1;

				public const string _vector4 = "\t\t\t\tDrawVector4InputField (0);";

				public const string _vector4_1 = "\t\t\t\tDrawVector4InputField (1);";

				public const string _vector4_and_1 = _vector4 + "\n" + _vector4_1;


				public const string _vector3 = "\t\t\t\tDrawVector3InputField (0);";

				public const string _vector3_1 = "\t\t\t\tDrawVector3InputField (1);";

				public const string _vector3_and_1 = _vector3 + "\n" + _vector3_1;


				public const string _vector2 = "\t\t\t\tDrawVector2InputField (0);";

				public const string _vector2_1 = "\t\t\t\tDrawVector2InputField (1);";

				public const string _vector2_and_1 = _vector2 + "\n" + _vector2_1;


				public const string _forceMode2D = "\t\t\t\tforceMode2D = (ForceMode2D)DrawEnum (forceMode2D, \"Force Mode 2D\", Skins.logicNodeLabel);";


				public const string _circleCollider2DCheck = "\t\t\t\tcircleCollider2D = gameObjectValues [0].GetComponent<CircleCollider2D> ();\n\n\t\t\t\tif (circleCollider2D == null)\n\t\t\t\t{\n\t\t\t\t\tDrawInNodeInfo (\"Add CircleCollider2D To GameObject\");\n\n\t\t\t\t\treturn;\n\t\t\t\t}";

				public const string _boxCollider2DCheck = "\t\t\t\tboxCollider2D = gameObjectValues [0].GetComponent<BoxCollider2D> ();\n\n\t\t\t\tif (boxCollider2D == null)\n\t\t\t\t{\n\t\t\t\t\tDrawInNodeInfo (\"Add BoxCollider2D To GameObject\");\n\n\t\t\t\t\treturn;\n\t\t\t\t}";


				public const string _gameObject_1 = "\t\t\t\tDrawGameObjectFieldInput (1);";

				public const string _gameObject_1_check = "\t\t\t\tif (gameObjectValues [1] == null)\n\t\t\t\t{\n\t\t\t\t\tDrawInNodeInfo (\"Fill in GameObject field\");\n\n\t\t\t\t\treturn;\n\t\t\t\t}";

				public const string _collider2D_1_Check = "\t\t\t\tcollider2D_1 = gameObjectValues [1].GetComponent<Collider2D> ();\n\n\t\t\t\tif (collider2D_1 == null)\n\t\t\t\t{\n\t\t\t\t\tDrawInNodeInfo (\"Add Collider2D To GameObject\");\n\n\t\t\t\t\treturn;\n\t\t\t\t}";


				public const string _canvasRendererCheck = "\t\t\t\tcanvasRenderer = gameObjectValues [0].GetComponent<CanvasRenderer> ();\n\n\t\t\t\tif (canvasRenderer == null)\n\t\t\t\t{\n\t\t\t\t\tDrawInNodeInfo (\"Add CanvasRenderer To GameObject\");\n\n\t\t\t\t\treturn;\n\t\t\t\t}";

				public const string _lineRendererCheck = "\t\t\t\tlineRenderer = gameObjectValues [0].GetComponent<LineRenderer> ();\n\n\t\t\t\tif (lineRenderer == null)\n\t\t\t\t{\n\t\t\t\t\tDrawInNodeInfo (\"Add LineRenderer To GameObject\");\n\n\t\t\t\t\treturn;\n\t\t\t\t}";

				public const string _spriteRendererCheck = "\t\t\t\tspriteRenderer = gameObjectValues [0].GetComponent<SpriteRenderer> ();\n\n\t\t\t\tif (spriteRenderer == null)\n\t\t\t\t{\n\t\t\t\t\tDrawInNodeInfo (\"Add SpriteRenderer To GameObject\");\n\n\t\t\t\t\treturn;\n\t\t\t\t}";


				public const string _materialGlobalIlluminationFlags = "DrawMaterialGlobalIlluminationFlagsEnum ();";


				//public const string _DrawMessageBoxUpLeftToPutAdvacedReadableTextures = "\t\t\t\tDrawMessageBoxUpLeftToPutAdvacedReadableTextures ();\n";

				//public const string _DrawMessageBoxUpLeftToPutAdvacedReadableTextures_slider = "\t\t\t\tDrawMessageBoxUpLeftToPutAdvacedReadableTextures (new string[] {\"\\n\", sliderInfo});" + "\n";

				public const string _InNodeReadableTextureInfo = "\t\tDrawInNodeInfo (textureReadableInNode);\n";


				public const string CheckAxisNameSetup = "\t\t\t\tCheckAxisNameSetup ();\n";

			}

			public class OutWs
			{
				//
				public const string GameObjectList_ = "\t\t\t\tDrawGameObjectListResultField (false, false);\n";

				public const string GameObjectList_AddButton_GetFromIdentified_ =
					"\t\t\t\tDrawGameObjectListResultField (true, true);\n";


				public const string ShaderList_ = "\t\t\t\tDrawShaderListResultField (false);\n";

				public const string ShaderList_AddButton_ = "\t\t\t\tDrawShaderListResultField (true);\n";


				public const string texture2DList_ = "\t\t\t\tDrawTexture2DListResultField (false);\n";

				public const string texture2DList_AddButton_ = "\t\t\t\tDrawTexture2DListResultField (true);\n";


				public const string materialList_ = "\t\t\t\tDrawMaterialListResultField (false);\n";

				public const string materialList_AddButton_ = "\t\t\t\tDrawMaterialListResultField (true);\n";


				public const string rectList_ = "\t\t\t\tDrawRectListResultField (false);\n";

				public const string rectList_AddButton_ = "\t\t\t\tDrawRectListResultField (true);\n";

				//
				public const string vector4List_ = "\t\t\t\tDrawVector4ListResultField (false);\n";

				public const string vector4List_AddButton_ = "\t\t\t\tDrawVector4ListResultField (true);\n";


				public const string vector3List_ = "\t\t\t\tDrawVector3ListResultField (false);\n";

				public const string vector3List_AddButton_ = "\t\t\t\tDrawVector3ListResultField (true);\n";


				public const string vector2List_ = "\t\t\t\tDrawVector2ListResultField (false);\n";

				public const string vector2List_AddButton_ = "\t\t\t\tDrawVector2ListResultField (true);\n";


				public const string colorList_ = "DrawColorListResultField (false);\n";

				public const string colorList_AddButton_ = "DrawColorListResultField (true);\n";


				public const string stringList_ = "\t\t\t\tDrawStringsListResultField (false);\n";

				public const string stringList_AddButton_ = "\t\t\t\tDrawStringsListResultField (true);\n";





				public const string intsList_ = "\t\t\t\tDrawIntListResultField (false);\n";

				public const string intsList_AddButton_ = "\t\t\t\tDrawIntListResultField (true);\n";


				public const string floatsList_ = "\t\t\t\tDrawFloatListResultField (false);\n";

				public const string floatsList_AddButton_ = "\t\t\t\tDrawFloatListResultField (true);\n";


				public const string boolList_ = "\t\t\t\tDrawBoolListResultField (false);\n";

				public const string boolList_AddButton_ = "\t\t\t\tDrawBoolListResultField (true);\n";


				public const string color_ = "\t\t\t\tDrawColorResultField ();";

				public const string m44_ = "\t\t\t\tDrawM44ResultField ();";



				public const string gameObject_ = "\t\t\t\tDrawGameObjectResultField (ObjectResultDrawChoice.itsName);";

				public const string gameObject_itself_ = "\t\t\t\tDrawGameObjectResultField (ObjectResultDrawChoice.itself);";



				public const string shader_ = "\t\t\t\tDrawShaderResultField (true);";

				public const string material_ = "\t\t\t\tDrawMaterialResultField (true);";

				public const string texture2D_ = "\t\t\t\tDrawTexture2DResultField (true);";

				public const string DrawTexture2DViewerForTextureTransform_ = "\t\t\t\tDrawTexture2DViwersForTextureTransform ();\n";

				public const string DrawTexture2DViewerForTextureBlend_ = "\t\t\t\tDrawTexture2DViwersForBlend ();\n";



				public const string shader_itself_ = "\t\t\t\tDrawShaderResultField (false);";

				public const string material_itself_ = "\t\t\t\tDrawMaterialResultField (false);";

				public const string texture2D_itself_ = "\t\t\t\tDrawTexture2DResultField (false);";



				public const string rect_ = "\t\t\t\tDrawRectResultField (true);";

				public const string rect_itself_ = "\t\t\t\tDrawRectResultField (false);";


				public const string vector4_ = "\t\t\t\tDrawVector4ResultField (true);";

				public const string vector4_itself_ = "\t\t\t\tDrawVector4ResultField (false);";


				public const string vector3_ = "\t\t\t\tDrawVector3ResultField (true);";

				public const string vector3_itself_ = "\t\t\t\tDrawVector3ResultField (false);";


				public const string vector2_ = "\t\t\t\tDrawVector2ResultField (true);";

				public const string vector2_itself_ = "\t\t\t\tDrawVector2ResultField (false);";


				public const string string_ = "\t\t\t\tDrawStringResultField (true);"; 

				public const string float_ = "\t\t\t\tDrawFloatResultField (true);";

				public const string int_ = "\t\t\t\tDrawIntResultField (true);";


				public const string string_itself_ = "\t\t\t\tDrawStringResultField (false);"; 

				public const string float_itself_ = "\t\t\t\tDrawFloatResultField (false);";

				public const string int_itself_ = "\t\t\t\tDrawIntResultField (false);";



				public const string bool_ = "\t\t\t\tDrawBoolResultField ();";
				public const string bool_toggle_ = "\t\t\t\tDrawBoolResultField (Enums.boolValue_ID);";



				public const string ray_ = "\t\t\t\tDrawRayResultField ();";

				public const string ray_itself_ = "\t\t\t\tDrawRay();";
			}

			public class CodeWs
			{
				public class Cam
				{
					public const string setReplacementShader = "\t\t\t\tif (shaderValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tcam.SetReplacementShader (shaderValues [0], stringValues [0]);\n\t\t\t\t}" + "\n";

					public const string renderWithShader = "\t\t\t\tif (shaderValues [0] != null)\n\t\t\t\t{\n\t\t\t\t\tcam.RenderWithShader (shaderValues [0], stringValues [0]);\n\t\t\t\t}" + "\n";

					public const string copyFromCam_1 = "\t\t\t\tif (cam_1 != null)\n\t\t\t\t{\n\t\t\t\t\tcam.CopyFrom (cam_1);\n\t\t\t\t}" + "\n";
				}

				public const string ifApplicationNotPlayingReturn = 
					"\t\t\t\tif ( ! Application.isPlaying)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n";
				
				public const string resetRayCastHitInfos = "\t\t\t\tResetRayCastHitInfos ();\n";

				public const string downTimeCounterCode = "\t\t\t\tif (boolValue)\n" +
					"\t\t\t\t{\n\t\t\t\t\t" +
					"downTimeCounterInt--;\n\n" +
					"\t\t\t\t\tif (" +
					"downTimeCounterInt" +
					" < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t" +
					"downTimeCounterInt" +
					" = " +
					"Mathf.CeilToInt (floatValues [0])" + ";" +
					"\n\n\t\t\t\t\t\tboolValue = false;\n\t\t\t\t\t}\n\t\t\t\t}\n";

				public const string boolValueEqualFalse = "\t\t\t\tboolValue = false;\n";



				public const string downTimeCounterCodeForBoolImpulse = 
					"\t\t\t\tboolValue = false;\n\n" +
					"\t\t\tif (boolValues [0])\n" +
					"\t\t\t{\n\t\t\t\tstartCounting = true;\n\t\t\t}\n\n\t\t\tif (startCounting)\n" +
					"\t\t\t{\n\t\t\t\tdownCounterForBoolImpulse -= Time.deltaTime;\n\n" +
					"\t\t\t\tif (downCounterForBoolImpulse < 0f)\n\t\t\t\t{\n" +
					"\t\t\t\t\tdownCounterForBoolImpulse = floatValues [0];\n\n" +
					"\t\t\t\t\tboolValue = true;\n\n\t\t\t\t\tstartCounting = false;\n\t\t\t\t}\n" +
					"\t\t\t}\n\n";
			}
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_UiToggle ()
		{
			return new EnumInputComputeOutput[]
			{			
				new EnumInputComputeOutput (
					ComputeUiToggleType.setEnabled.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "uiToggle.enabled = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiToggle_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiToggleCheck_computeUiToggle,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiToggleType.getIsActiveAndEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiToggle.isActiveAndEnabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiToggle_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiToggleCheck_computeUiToggle,
					new string []
					{
						"Has the Behaviour had enabled called.",
						"True while the behaviour is enabled, false when disabled.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-isActiveAndEnabled.html",
					""),
				
				new EnumInputComputeOutput (
					ComputeUiToggleType.getEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiToggle.enabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiToggle_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiToggleCheck_computeUiToggle,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiToggleType.isOn.ToString (),
					"",
					"\t\t\t\tboolValue = uiToggle.isOn;\n",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiToggle_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiToggleCheck_computeUiToggle,
					new string []
					{
						"",
						"Is the toggle on.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.Toggle-isOn.html",
					""),
			};
		}

		EnumInputComputeOutput [] EnumInputComputeOutput_UiInputField ()
		{
			return new EnumInputComputeOutput[]
			{
				new EnumInputComputeOutput (
					ComputeUiInputFieldType.setEnabled.ToString (),
					InOutWs.InWs._bool,
					"\t\t\t\t" + "uiInputField.enabled = boolValues [0];",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiInputField_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					ExprWs.ConstructorExpr.BoolValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiInputFieldCheck_computeUiInputField,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiInputFieldType.getIsActiveAndEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiInputField.isActiveAndEnabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiInputField_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiInputFieldCheck_computeUiInputField,
					new string []
					{
						"Has the Behaviour had enabled called.",
						"True while the behaviour is enabled, false when disabled.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-isActiveAndEnabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiInputFieldType.getEnabled.ToString (),
					"",
					"\t\t\t\t" + "boolValue = uiInputField.enabled;",
					InOutWs.OutWs.bool_,
					ExprWs.Gv.uiInputField_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.boolValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiInputFieldCheck_computeUiInputField,
					new string []
					{
						"Enabled Behaviours are Updated, disabled Behaviours are not.",
						"This is shown as the small checkbox in the inspector of the behaviour.",
					},
					"https://docs.unity3d.com/ScriptReference/Behaviour-enabled.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiInputFieldType.setText.ToString (),
					InOutWs.InWs._string,
					"\t\t\t\tuiInputField.text = stringValues [0];\n",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiInputField_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.stringValues,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) + 
					ExprWs.ConstructorExpr.StringValues (this),
					ExprWs.UMDecl.GameObjectCheck_uiInputFieldCheck_computeUiInputField,
					new string []
					{
						"",
						"The current value of the input field.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.InputField-text.html",
					""),

				new EnumInputComputeOutput (
					ComputeUiInputFieldType.getText.ToString (),
					"",
					"\t\t\t\tstringValue = uiInputField.text;\n",
					InOutWs.OutWs.string_,
					ExprWs.Gv.uiInputField_doIt_identifiedObjects_gameObjectAll +
					ExprWs.Gv.stringValue,
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}),
					ExprWs.UMDecl.GameObjectCheck_uiInputFieldCheck_computeUiInputField,
					new string []
					{
						"",
						"The current value of the input field.",
						"Note that null is invalid value for InputField.text.",
					},
					"https://docs.unity3d.com/ScriptReference/UI.InputField-text.html",
					""),


				new EnumInputComputeOutput (
					ComputeUiInputFieldType.setKeyboardType.ToString (),
					"\t\t\t\ttouchScreenKeyboardType = (TouchScreenKeyboardType)DrawEnum (touchScreenKeyboardType, \"Touch Screen Keyboard Type\", Skins.logicNodeLabel);\n",
					"\t\t\t\tuiInputField.keyboardType = touchScreenKeyboardType;\n",
					InOutWs.OutWs.gameObject_,
					ExprWs.Gv.uiInputField_doIt_identifiedObjects_gameObjectAll +
					"\t\tpublic TouchScreenKeyboardType touchScreenKeyboardType;\n",
					ConstructorGetIdentifiedObject (new string [] {Enums.gameObjectValues_0_ID,}) +
					"\t\t\ttouchScreenKeyboardType = TouchScreenKeyboardType." + touchScreenKeyboardType.ToString () + ";\n",
					ExprWs.UMDecl.GameObjectCheck_uiInputFieldCheck_computeUiInputField,
					new string []
					{
						"",
						"Describes the type of keyboard.",
					},
					"https://docs.unity3d.com/ScriptReference/TouchScreenKeyboardType.html",
					""),
			};
		}


		void WriteEnumInputComputeOutput()
		{
			//WriteEnumInputComputeOutput ("ComputeVector4Type",
			//	"computeVector4Type", "ComputeVector4",
			//	EnumInputComputeOutput_Vector4 (), 
			//	false, false,
			//	"texture2DValues [0]", "Texture2D", true);

			if (logicType == LogicType.Ads)
			{
				WriteEnumInputComputeOutput("ComputeAdsType",
					"computeAdsType", "ComputeAds",
					EnumInputComputeOutput_Ads(),
					true, false, false,
					"gameObject_", "GameObject", false);
			}
			else if (logicType == LogicType.mouseInput)
			{
				WriteEnumInputComputeOutput("ComputeMouseInputType",
					"computeMouseInputType", "ComputeMouseInput",
					EnumInputComputeOutput_MouseInput(),
					false, false, false,
					"gameObject_", "GameObject", false);
			}
			else if (logicType == LogicType.unityInputClassAndCrossPlatform)
			{
				WriteEnumInputComputeOutput("ComputeUnityInputClassAndCrossPlatformType",
					"computeUnityInputClassAndCrossPlatformType", "ComputeUnityInputClassAndCrossPlatform",
					EnumInputComputeOutput_unityInpuClassAndCrossPlatform(),
					false, false, false,
					"gameObject_", "GameObject", false);
			}
			else if (logicType == LogicType.computeOrOperation)
			{
				switch (variableType)
				{ 
				case VariableType.Bool:
					WriteEnumInputComputeOutput("ComputeBoolType",
						"computeBoolType", "ComputeBool",
						EnumInputComputeOutput_Bool(),
						false, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.boolsList:
					WriteEnumInputComputeOutput("ComputeBoolListType",
						"computeBoolListType", "ComputeBoolList",
						EnumInputComputeOutput_BoolsList(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;



				case VariableType.componentCircleCollider2D:
					WriteEnumInputComputeOutput("ComputeCircleCollider2DType",
						"computeCircleCollider2DType", "ComputeCircleCollider2D",
						EnumInputComputeOutput_CircleCollider_2D (),
						true, true, true,
						"circleCollider2D", "CircleCollider2D", false);
					break;

				case VariableType.componentBoxCollider2D:
					WriteEnumInputComputeOutput("ComputeBoxCollider2DType",
						"computeBoxCollider2DType", "ComputeBoxCollider2D",
						EnumInputComputeOutput_BoxCollider_2D (),
						true, true, true,
						"boxCollider2D", "BoxCollider2D", false);
					break;



				case VariableType.componentMeshCollider:
					WriteEnumInputComputeOutput("ComputeMeshColliderType",
						"computeMeshColliderType", "ComputeMeshCollider",
						EnumInputComputeOutput_MeshCollider (),
						true, true, true,
						"meshCollider", "MeshCollider", false);
					break;

				case VariableType.componentCapsuleCollider:
					WriteEnumInputComputeOutput("ComputeCapsuleColliderType",
						"computeCapsuleColliderType", "ComputeCapsuleCollider",
						EnumInputComputeOutput_CapsuleCollider (),
						true, true, true,
						"capsuleCollider", "CapsuleCollider", false);
					break;

				case VariableType.componentSphereCollider:
					WriteEnumInputComputeOutput("ComputeSphereColliderType",
						"computeSphereColliderType", "ComputeSphereCollider",
						EnumInputComputeOutput_SphereCollider (),
						true, true, true,
						"sphereCollider", "SphereCollider", false);
					break;

				case VariableType.componentBoxCollider:
					WriteEnumInputComputeOutput("ComputeBoxColliderType",
						"computeBoxColliderType", "computeBoxCollider",
						EnumInputComputeOutput_BoxCollider (),
						true, true, true,
						"boxCollider", "BoxCollider", false);
					break;




				case VariableType.componentLineRenderer:
					WriteEnumInputComputeOutput("ComputeLineRendererType",
						"computeLineRendererType", "ComputeLineRenderer",
						EnumInputComputeOutput_LineRenderer (),
						true, true, true,
						"lineRenderer", "LineRenderer", false);
					break;

				case VariableType.componentSpriteRenderer:
					WriteEnumInputComputeOutput("ComputeSpriteRendererType",
						"computeSpriteRendererType", "ComputeSpriteRenderer",
						EnumInputComputeOutput_SpriteRenderer (),
						true, true, true,
						"spriteRenderer", "SpriteRenderer", false);
					break;



				case VariableType.componentAudioSource:
					WriteEnumInputComputeOutput("ComputeAudioSourceType",
						"computeAudioSourceType", "ComputeAudioSource",
						EnumInputComputeOutput_AudioSource (),
						true, true, true,
						"audioSource_", "AudioSource", false);
					break;

				case VariableType.Camera:
					WriteEnumInputComputeOutput("ComputeCameraType",
						"computeCameraType", "ComputeCamera",
						EnumInputComputeOutput_Camera(),
						true, true, true,
						"cam", "Camera", false);
					break;

				case VariableType.Color:
					WriteEnumInputComputeOutput("ComputeColorType",
						"computeColorType", "ComputeColor",
						EnumInputComputeOutput_Color (),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.colorsList:
					WriteEnumInputComputeOutput("ComputeColorListType",
						"computeColorListType", "ComputeColorList",
						EnumInputComputeOutput_ColorList (),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.componentLight:
					WriteEnumInputComputeOutput("ComputeLightType",
						"computeLightType", "ComputeLight",
						EnumInputComputeOutput_Light(),
						true, true, true,
						"lightComp", "Light", false);
					break;

				case VariableType.componentCollider:
					WriteEnumInputComputeOutput("ComputeColliderType",
						"computeColliderType", "ComputeCollider",
						EnumInputComputeOutput_Collider(),
						true, true, true,
						"collider", "Collider", false);
					break;

				case VariableType.componentCollider2D:
					WriteEnumInputComputeOutput("ComputeCollider2DType",
						"computeCollider2DType", "ComputeCollider2D",
						EnumInputComputeOutput_Collider_2D(),
						true, true, true,
						"collider2D", "Collider2D", false);
					break;

				case VariableType.componentNavMeshAgent:
					WriteEnumInputComputeOutput("ComputeNavMeshAgentType",
						"computeNavMeshAgentType", "ComputeNavMeshAgent",
						EnumInputComputeOutput_NavMeshAgent(),
						true, true, true,
						"navMeshAgent", "UnityEngine.AI.NavMeshAgent", false);
					break;

				case VariableType.componentParticleSystem:
					WriteEnumInputComputeOutput("ComputeParticleSystemType",
						"computeParticleSystemType", "ComputeParticleSystem",
						EnumInputComputeOutput_ParticleSystem(),
						true, true, true,
						"particleSystem", "ParticleSystem", false);
					break;

				case VariableType.componentRenderer:
					WriteEnumInputComputeOutput("ComputeRendererType",
						"computeRendererType", "ComputeRenderer",
						EnumInputComputeOutput_Renderer(),
						true, true, true,
						"renderer", "Renderer", false);
					break;

				case VariableType.componentRigidBody:
					WriteEnumInputComputeOutput("ComputeRigidBodyType",
						"computeRigidBodyType", "ComputeRigidbody",
						EnumInputComputeOutput_Rigidbody(),
						true, true, true,
						"rigidBody", "Rigidbody", false);
					break;

				case VariableType.componentRigidBody2D:
					WriteEnumInputComputeOutput("ComputeRigidBody2DType",
						"computeRigidBody2DType", "ComputeRigidbody2D",
						EnumInputComputeOutput_Rigidbody2D(),
						true, true, true,
						"rigidBody2D", "Rigidbody2D", false);
					break;

				case VariableType.componentTransform:
					WriteEnumInputComputeOutput("ComputeTransformType",
						"computeTransformType", "ComputeTransform",
						EnumInputComputeOutput_Transform(),
						true, true, true,
						"transform_", "Transform", false);
					break;


				case VariableType.componentUIToggle:
					WriteEnumInputComputeOutput("ComputeUiToggleType",
						"computeUiToggleType", "ComputeUiToggle",
						EnumInputComputeOutput_UiToggle(),
						true, true, true,
						"uiToggle", "UnityEngine.UI.Toggle", false);
					break;

				case VariableType.componentUIInputField:
					WriteEnumInputComputeOutput("ComputeUiInputFieldType",
						"computeUiInputFieldType", "ComputeUiInputField",
						EnumInputComputeOutput_UiInputField(),
						true, true, true,
						"uiInputField", "UnityEngine.UI.InputField", false);
					break;

				case VariableType.componentUIUnityText:
					WriteEnumInputComputeOutput("ComputeUnityTextType",
						"computeUnityTextType", "ComputeUnityText",
						EnumInputComputeOutput_UnityText(),
						true, true, true,
						"unityText", "UnityEngine.UI.Text", false);
					break;

				case VariableType.componentUIImage:
					WriteEnumInputComputeOutput("ComputeUiImageType",
						"computeUiImageType", "ComputeUiImage",
						EnumInputComputeOutput_UiImage(),
						true, true, true,
						"uiImage", "UnityEngine.UI.Image", false);
					break;

				case VariableType.componentUIButton:
					WriteEnumInputComputeOutput("ComputeUiButtonType",
						"computeUiButtonType", "ComputeUiButton",
						EnumInputComputeOutput_UiButton(),
						true, true, true,
						"uiButton", "UnityEngine.UI.Button", false);
					break;

				case VariableType.Float:
					WriteEnumInputComputeOutput("ComputeFloatType",
						"computeFloatType", "ComputeFloat",
						EnumInputComputeOutput_Float(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.floatsList:
					WriteEnumInputComputeOutput("ComputeFloatsListType",
						"computeFloatsListType", "ComputeFloatsList",
						EnumInputComputeOutput_FloatsList(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.GameObject:
					WriteEnumInputComputeOutput("ComputeGameObjectType",
						"computeGameObjectType", "ComputeGameObject",
						EnumInputComputeOutput_GameObject(),
						true, true, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.GameObjectList:
					WriteEnumInputComputeOutput("ComputeGameObjectListType",
						"computeGameObjectListType", "ComputeGameObjectList",
						EnumInputComputeOutput_GameObjectList(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.Int:
					WriteEnumInputComputeOutput("ComputeIntType",
						"computeIntType", "ComputeInt",
						EnumInputComputeOutput_Int(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.intsList:
					WriteEnumInputComputeOutput("ComputeIntsListType",
						"computeIntListType", "ComputeIntList",
						EnumInputComputeOutput_IntsList(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.Material:
					WriteEnumInputComputeOutput ("ComputeMaterialType",
						"computeMaterialType", "ComputeMaterial",
						EnumInputComputeOutput_Material (), 
						true, true,
						"materialValues [0]", "Material", true);
					break;

				case VariableType.materialsList:
					WriteEnumInputComputeOutput("ComputeMaterialListType",
						"computeMaterialListType", "ComputeMaterialList",
						EnumInputComputeOutput_MaterialList(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.Matrix4x4:
					WriteEnumInputComputeOutput("ComputeMatrix44Type",
						"computeMatrix44Type", "ComputeMatrix44",
						EnumInputComputeOutput_Matrix44(),
						false, false, false,
						"gameObject_", "GameObject", false);
					break;

				case VariableType.Ray:
					WriteEnumInputComputeOutput("ComputeRayType",
						"computeRayType", "ComputeRay",
						EnumInputComputeOutput_Ray(),
						true, false, false,
						"gameObject_", "GameObject", false);
					break;

				case VariableType.Ray2D:
					WriteEnumInputComputeOutput("ComputeRay2DType",
						"computeRay2DType", "ComputeRay2D",
						EnumInputComputeOutput_Ray2D(),
						true, false, false,
						"gameObject_", "GameObject", false);
					break;

				case VariableType.rect:
					WriteEnumInputComputeOutput("ComputeRectType",
						"computeRectType", "ComputeRect",
						EnumInputComputeOutput_Rect(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.rectsList:
					WriteEnumInputComputeOutput("ComputeRectListType",
						"computeRectListType", "ComputeRectList",
						EnumInputComputeOutput_RectList(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.Shader:
					WriteEnumInputComputeOutput ("ComputeShaderType",
						"computeShaderType", "ComputeShader",
						EnumInputComputeOutput_Shader (), 
						true, true,
						"shaderValues [0]", "Shader", true);
					break;

				case VariableType.shadersList:
					WriteEnumInputComputeOutput("ComputeShaderListType",
						"computeShaderListType", "ComputeShaderList",
						EnumInputComputeOutput_ShaderList(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.String:
					WriteEnumInputComputeOutput("ComputeStringType",
						"computeStringType", "ComputeString",
						EnumInputComputeOutput_String(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.stringsList:
					WriteEnumInputComputeOutput("ComputeStringsListType",
						"computeStringsListType", "ComputeStringList",
						EnumInputComputeOutput_StringList(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.Texture2D:
					WriteEnumInputComputeOutput ("ComputeTexture2DType",
						"computeTexture2DType", "ComputeTexture2D",
						EnumInputComputeOutput_Texture2D (), 
						true, true,
						"texture2DValues [0]", "Texture2D", true);
					break;

				case VariableType.texture2DList:
					WriteEnumInputComputeOutput("ComputeTexture2DListType",
						"computeTexture2DListType", "ComputeTexture2DList",
						EnumInputComputeOutput_Texture2DList(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.Vector2:
					WriteEnumInputComputeOutput("ComputeVector2Type",
						"computeVector2Type", "ComputeVector2",
						EnumInputComputeOutput_Vector2(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.vector2List:
					WriteEnumInputComputeOutput("ComputeVector2ListType",
						"computeVector2ListType", "ComputeVector2List",
						EnumInputComputeOutput_Vector2List(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.Vector3:
					WriteEnumInputComputeOutput("ComputeVector3Type",
						"computeVector3Type", "ComputeVector3",
						EnumInputComputeOutput_Vector3(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.vector3List:
					WriteEnumInputComputeOutput("ComputeVector3ListType",
						"computeVector3ListType", "ComputeVector3List",
						EnumInputComputeOutput_Vector3List(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.Vector4:
					WriteEnumInputComputeOutput("ComputeVector4Type",
						"computeVector4Type", "ComputeVector4",
						EnumInputComputeOutput_Vector4(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;

				case VariableType.vector4List:
					WriteEnumInputComputeOutput("ComputeVector4ListType",
						"computeVector4ListType", "ComputeVector4List",
						EnumInputComputeOutput_Vector4List(),
						true, false, false,
						"gameObject_", "GameObject", true);
					break;


				}

			}

			Auxiliaries.SaveAndRefreshAssetsForced ();
		}

		void WriteEnumInputComputeOutput (string enumTypeName, string enumName,
			string functionBaseName,
			EnumInputComputeOutput [] enumInputComputeOutput,
			bool withDoIT, bool needGameObject_0, bool needComponent,
			string componentName, string componentTypeName, bool withGet)
		{
			List<string> lstCompute = new List<string> ();

			List<string> lstInput = new List<string> ();

			List<string> lstOutput = new List<string> ();


			string tab_1 = "\t";

			string tab_2 = tab_1 + tab_1;

			string tab_3 = tab_2 + tab_1;

			//string tab_4 = tab_3 + tab_1;


			string notGetCondition = "\t\t\tif (" + enumName + " != " + enumTypeName + ".get" +
				//" && " + enumName + " != " + enumTypeName + ".sendMeAsTransferredData" +
				//" && " + enumName + " != " + enumTypeName + ".listenToTransferredData" +
				")\n\t";
			if ( ! withGet)
			{
				notGetCondition = "";
			}



			string gameObject_0_inputField = "\t\t\tDrawGameObjectFieldInput (0);" + "\n\n";

			string enumInputFieldDraw = "\t\t\t" + enumName + " = (" +
				enumTypeName + ")DrawEnumComputeType (" + enumName + ");\n\n";

			string gameObject_0_existence = "\t\t\t\tif (gameObjectValues [0] == null)\n" + 
				"\t\t\t\t{\n\t\t\t\t\tDrawGameObject_0_isNullInfo ();\n\n" + 
				"\t\t" + enumInputFieldDraw +
				"\t\t\t\t\treturn;\n\t\t\t\t}" + "\n";


			string insNotAttachedToOrLinked = "\t\t\tlinkedOrAttachedTo = " +
				"(IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || \n" +
				"\t\t\tIsGameObject_0_AttachedTo () || \n" +
				"\t\t\tgameObjectValues [0] == null;\n\n";



			string openingIsNotAttachedToOrLinkedIf = "\t\t\tif ( ! linkedOrAttachedTo)\n\t\t\t{" + "\n";

			string isAttachedToOrLinkedNoRunInfo = "\t\t\tif (linkedOrAttachedTo)\n\t\t\t{\n\t\t\t\t" +
				"DrawInNodeInfo (noRunInEditorWithAttachedToOrLinked);\n\t\t\t}" + "\n";

			string componentExistence =
				"\t\t\t\t" + componentName + 
				" = gameObjectValues [0].GetComponent <" + componentTypeName
				+ ">();\n\n" +
				"\t\t\t\tif (" + componentName + " == null)\n" +
				"\t\t\t\t{\n" +
				"\t\t\t\t\tDrawInNodeInfo (\"Add " + componentTypeName +
				" To GameObject\");\n\n" +

				"\t\t\tlinkedOrAttachedTo = " +
				"(IsGameObject_0_InputLinked () && gameObjectValues [0] == null) || \n" +
				"\t\t\tIsGameObject_0_AttachedTo () || \n" +
				"\t\t\tgameObjectValues [0] == null ||\n" +
				"\t\t\t" + componentName + " == null;\n\n" +

				"\t\t\t\t\treturn;\n" +
				"\t\t\t\t}\n\n";




			string doITCondition = "\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}";
			doITCondition += "\n";

			string returnIfAttachedTo =
				"\t\t\tif (IsGameObject_0_AttachedTo ())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}" +
				"\n";


			string switchEnumOpen = "\t\t\tswitch (" + enumName + ")\n" + 
				"\t\t\t{\n";



			lstInput.Add (tab_2 + "void " + functionBaseName + "_InputFields ()\n");
			lstInput.Add (tab_2 + "{\n");
			if (needComponent || needGameObject_0)
				lstInput.Add (insNotAttachedToOrLinked);

			if (needGameObject_0)
			{
				lstInput.Add (notGetCondition);
				lstInput.Add (gameObject_0_inputField);

				lstInput.Add (notGetCondition);
				lstInput.Add (openingIsNotAttachedToOrLinkedIf);

				lstInput.Add (notGetCondition);
				lstInput.Add (gameObject_0_existence);


				lstInput.Add (tab_3 + "}\n");

				lstInput.Add (notGetCondition);
				lstInput.Add (isAttachedToOrLinkedNoRunInfo);
			}
			if (needComponent)
			{
				lstInput.Add (notGetCondition);
				lstInput.Add (openingIsNotAttachedToOrLinkedIf);

				lstInput.Add (notGetCondition);
				lstInput.Add (componentExistence);


				lstInput.Add (tab_3 + "}\n");
			}



			lstInput.Add (enumInputFieldDraw);

			lstInput.Add (switchEnumOpen);


			string notDataTransfer_decl = "\t\t\t" +
				"bool notDataTransfer = ! " +
				"(" + enumName + " == " + enumTypeName + ".sendMeAsTransferredData ||" +
				"\n\t\t\t\t" +
				enumName + " == " + enumTypeName + ".listenToTransferredData);\n";

			string noDataTransfer_cond = "\t\t\tif (notDataTransfer)\n";

			lstCompute.Add (tab_2 + "void " + functionBaseName + " ()\n");
			lstCompute.Add (tab_2 + "{\n");

			if (needComponent || needGameObject_0)
			{
				lstCompute.Add (notDataTransfer_decl);

				lstCompute.Add (noDataTransfer_cond);
				lstCompute.Add ("\t\t\tif (linkedOrAttachedTo)\n\t\t\t\treturn;");
			}

			if (withDoIT)
			{
				lstCompute.Add (doITCondition);
			}
			if (needGameObject_0)
			{
				lstCompute.Add (noDataTransfer_cond);
				lstCompute.Add (returnIfAttachedTo);
			}


			if (needGameObject_0)
			{
				lstCompute.Add ("\t\t\tAssignGameObjectField (ref gameObjectValue, ref gameObjectValueOld, gameObjectValues [0]);\n\n");
			}


			lstCompute.Add (switchEnumOpen);



			lstOutput.Add (tab_2 + "void " + functionBaseName + "_OutputFields ()\n");
			lstOutput.Add (tab_2 + "{\n");
			//if (withDoIT)
			//{
			//	lstOutput.Add (doITCondition);
			//}

			lstOutput.Add ("\n\t\t\tstring [] documentationMessage;\n\n");
			lstOutput.Add (switchEnumOpen);

			for (int i = 0; i < enumInputComputeOutput.Length; i++)
			{
				lstInput.Add ("\t\t\tcase " + enumTypeName + "." +
					enumInputComputeOutput [i].enumName + ":\n" +
					enumInputComputeOutput [i].input + "\n\t\t\t\tbreak;\n\n");

				lstCompute.Add ("\t\t\tcase " + enumTypeName + "." +
					enumInputComputeOutput [i].enumName + ":\n" +
					enumInputComputeOutput [i].compute + "\n\t\t\t\tbreak;\n\n");

				lstOutput.Add ("\t\t\tcase " + enumTypeName + "." +
					enumInputComputeOutput [i].enumName + ":\n" +
					enumInputComputeOutput [i].output + "\n\n" +
					"\t\t\t\tdocumentationMessage = \n" +
					StringTreatment.StringArrayToScriptInitialization (
						enumInputComputeOutput [i].embededDocumentation, 5, true) + 
					";\n\n" +
					"\t\t\t\tDrawDocumentationBoxUpRight (documentationMessage);\n" + 
					"\t\t\t\tDrawDocumentationUrlButtons (documentationMessage, " +
					"\n\t\t\t\t\t" +
					"\"" + enumInputComputeOutput [i].documentationUrl_0 + "\", " +
					"\n\t\t\t\t\t" +
					"\"" + enumInputComputeOutput [i].documentationUrl_1 + "\");" +
					"\n\t\t\t\tbreak;\n\n");
			}


			string drawDoITButton = "\t\t\tif (" + enumName + " == " + enumTypeName + ".get" + 
				//" || " + enumName + " == " + enumTypeName + ".sendMeAsTransferredData" +
				//" || " + enumName + " == " + enumTypeName + ".listenToTransferredData" +
				")\n" +
				"\t\t\t{\n\t\t\t\tdoIT = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDrawDoItButton();\n\t\t\t}\n";
			if ( ! withGet)
				drawDoITButton = tab3 + "DrawDoItButton();\n";


			lstInput.Add (tab_3 + "}\n");
			if (withDoIT)
			{
				lstInput.Add (drawDoITButton);
			}
			lstInput.Add (tab_2 + "}\n");



			lstCompute.Add (tab_3 + "}\n");
			//if (needGameObject_0)
			//{
			//	lstCompute.Add ("\t\t\tgameObjectValue = gameObjectValues [0];\n");
			//}
			lstCompute.Add (tab_2 + "}\n");

			lstOutput.Add (tab_3 + "}\n");
			lstOutput.Add (tab_2 + "}\n");



			List <string> lstInputCompute = new List<string> ();

			ListOperations.Merge (ref lstInputCompute, lstInput, lstCompute);


			List <string> lstInputComputeOutput = new List<string> ();

			ListOperations.Merge (ref lstInputComputeOutput, lstInputCompute,
				lstOutput);


			CsScriptWriter.CsScriptListToFile (Auxiliaries.projectFolderPath,
				"EnumInputComputeOutput.cs", lstInputComputeOutput, false);
		}

		void WriteEnumInputComputeOutput (string enumTypeName, string enumName,
			string functionBaseName,
			EnumInputComputeOutput [] enumInputComputeOutput,
			bool withDoIT, bool needAsset,
			string assetName, string assetTypeName, bool withGet)
		{
			List<string> lstCompute = new List<string> ();

			List<string> lstInput = new List<string> ();

			List<string> lstOutput = new List<string> ();


			string tab_1 = "\t";

			string tab_2 = tab_1 + tab_1;

			string tab_3 = tab_2 + tab_1;

			//string tab_4 = tab_3 + tab_1;


			//string gameObject_0_inputField = "\t\t\tDrawGameObjectFieldInput (0);" + "\n\n";

			//string gameObject_0_existence = "\t\t\t\tif (gameObjectValues [0] == null)\n\t\t\t\t{\n\t\t\t\t\tDrawGameObject_0_isNullInfo ();\n\n\t\t\t\t\treturn;\n\t\t\t\t}" + "\n";


			//string isAttachedToNoRunInfo = "\t\t\tif (IsGameObject_0_AttachedTo ())\n\t\t\t{\n\t\t\t\tDrawInNodeInfo (\"No run in Editor with Attached To\");\n\t\t\t}" + "\n";



			string insNotAttachedToOrLinked = "\t\t\tlinkedOrAttachedTo = " + assetName + " == null;\n\n";

			string openingIsNotAttachedToOrLinkedIf = "\t\t\tif ( ! linkedOrAttachedTo)\n\t\t\t{" + "\n";


			string notGetCondition = "\t\t\tif (" + enumName + " != " + enumTypeName + ".get)\n\t";
			if ( ! withGet)
				notGetCondition = "";

			string assetInputField = "";
			switch (assetTypeName)
			{
			case "Material":
				assetInputField = "\t\t\tDrawMaterialFieldInput (0);" + "\n\n";
				break;

			case "Shader":
				assetInputField = "\t\t\tDrawShaderFieldInput (0);" + "\n\n";
				break;

			case "Texture2D":
				assetInputField = "\t\t\tDrawTexture2DFieldInput (0);" + "\n\n";
				break;
			}

			string enumInputFieldDraw = "\t\t\t" + enumName + " = (" +
				enumTypeName + ")DrawEnumComputeType (" + enumName + ");\n\n";

			string assetExistence =
				"\t\t\t\tif (" + assetName + " == null)\n\t\t\t\t{\n\t\t\t\t\tDrawInNodeInfo" +
				" (\"Fill in the " + assetTypeName + " field\");\n\n" + 
				"\t\t" + enumInputFieldDraw +
				"\t\t\t\t\treturn;\n\t\t\t\t}\n\n";





			string doITCondition = "\t\t\tif ( ! doIT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}";
			doITCondition += "\n";


			string doITForThisFunctionBaseName = "doIT_" + functionBaseName;
			string doITForThisFunctionBaseNameDeclaration = tab_2 + "bool " + doITForThisFunctionBaseName + " = true;\n";
			string doITForThisFunctionBaseNameCondition = 
				"\t\t\tif ( ! " + doITForThisFunctionBaseName + ")\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}" + "\n";
			string doITForThisFunctionBaseNameAssignFalse = doITForThisFunctionBaseName + " = false;\n";
			string doITForThisFunctionBaseNameAssignTrue = doITForThisFunctionBaseName + " = true;\n";
			if ( ! withDoIT)
			{
				assetExistence =
					"\t\t\t\tif (" + assetName + " == null)\n\t\t\t\t{\n\t\t\t\t\t" + doITForThisFunctionBaseNameAssignFalse +
					"\t\t\t\t\tDrawInNodeInfo (\"Fill in the " + assetTypeName + " field\");\n\n" + 
					"\t\t" + enumInputFieldDraw +
					"\t\t\t\t\treturn;\n\t\t\t\t}\n" + 
					"\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t" + doITForThisFunctionBaseNameAssignTrue + "\t\t\t\t}\n\n";

			}

			//string returnIfAttachedTo =
			//	"\t\t\tif (IsGameObject_0_AttachedTo ())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}" +
			//	"\n";


			string switchEnumOpen = "\t\t\tswitch (" + enumName + ")\n" + 
				"\t\t\t{\n";

			if ( ! withDoIT)
			{
				lstInput.Add (doITForThisFunctionBaseNameDeclaration);
			}
			lstInput.Add (tab_2 + "void " + functionBaseName + "_InputFields ()\n");
			lstInput.Add (tab_2 + "{\n");
			if (needAsset)
				lstInput.Add (insNotAttachedToOrLinked);

			if (needAsset)
			{
				lstInput.Add (notGetCondition);
				lstInput.Add (assetInputField);

				lstInput.Add (notGetCondition);
				lstInput.Add (openingIsNotAttachedToOrLinkedIf);
				lstInput.Add (assetExistence);

				lstInput.Add (tab_3 + "}\n");
			}



			lstInput.Add (enumInputFieldDraw);

			lstInput.Add (switchEnumOpen);




			string notDataTransfer_decl = "\t\t\t" +
				"bool notDataTransfer = ! " +
				"(" + enumName + " == " + enumTypeName + ".sendMeAsTransferredData ||" +
				"\n\t\t\t\t" +
				enumName + " == " + enumTypeName + ".listenToTransferredData);\n";

			string noDataTransfer_cond = "\t\t\tif (notDataTransfer)\n";


			lstCompute.Add (tab_2 + "void " + functionBaseName + " ()\n");
			lstCompute.Add (tab_2 + "{\n");
			if (needAsset)
			{
				lstCompute.Add (notDataTransfer_decl);

				lstCompute.Add (noDataTransfer_cond);
				lstCompute.Add ("\t\t\tif (linkedOrAttachedTo)\n\t\t\t\treturn;");
			}

			if (withDoIT)
			{
				lstCompute.Add (doITCondition);
			}
			else if ( ! withDoIT)
			{
				lstCompute.Add (doITForThisFunctionBaseNameCondition);
			}




			lstCompute.Add (switchEnumOpen);



			lstOutput.Add (tab_2 + "void " + functionBaseName + "_OutputFields ()\n");
			lstOutput.Add (tab_2 + "{\n");
			//if (withDoIT)
			//{
			//	lstOutput.Add (doITCondition);
			//}
			//else if ( ! withDoIT)
			//{
			//	lstOutput.Add (doITForThisFunctionBaseNameCondition);
			//}

			lstOutput.Add ("\n\t\t\tstring [] documentationMessage;\n\n");
			lstOutput.Add (switchEnumOpen);

			for (int i = 0; i < enumInputComputeOutput.Length; i++)
			{
				lstInput.Add ("\t\t\tcase " + enumTypeName + "." +
					enumInputComputeOutput [i].enumName + ":\n" +
					enumInputComputeOutput [i].input + "\n\t\t\t\tbreak;\n\n");

				lstCompute.Add ("\t\t\tcase " + enumTypeName + "." +
					enumInputComputeOutput [i].enumName + ":\n" +
					enumInputComputeOutput [i].compute + "\n\t\t\t\tbreak;\n\n");

				lstOutput.Add ("\t\t\tcase " + enumTypeName + "." +
					enumInputComputeOutput [i].enumName + ":\n" +
					enumInputComputeOutput [i].output + "\n\n" +
					"\t\t\t\tdocumentationMessage = \n" +
					StringTreatment.StringArrayToScriptInitialization (
						enumInputComputeOutput [i].embededDocumentation, 5, true) + 
					";\n\n" +
					"\t\t\t\tDrawDocumentationBoxUpRight (documentationMessage);\n" + 
					"\t\t\t\tDrawDocumentationUrlButtons (documentationMessage, " +
					"\n\t\t\t\t\t" +
					"\"" + enumInputComputeOutput [i].documentationUrl_0 + "\", " +
					"\n\t\t\t\t\t" +
					"\"" + enumInputComputeOutput [i].documentationUrl_1 + "\");" +
					"\n\t\t\t\tbreak;\n\n");
			}



			string drawDoITButton = "\t\t\tif (" + enumName + " == " + enumTypeName + ".get" + ")\n" +
				"\t\t\t{\n\t\t\t\tdoIT = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDrawDoItButton();\n\t\t\t}\n";
			if ( ! withGet)
				drawDoITButton = tab3 + "DrawDoItButton();\n";

			lstInput.Add (tab_3 + "}\n");
			if (withDoIT)
			{
				lstInput.Add (drawDoITButton);
			}
			lstInput.Add (tab_2 + "}\n");


			lstCompute.Add (tab_3 + "}\n");
			//if (needGameObject_0)
			//{
			//	lstCompute.Add ("\t\t\tgameObjectValue = gameObjectValues [0];\n");
			//}
			lstCompute.Add (tab_2 + "}\n");

			lstOutput.Add (tab_3 + "}\n");
			lstOutput.Add (tab_2 + "}\n");


			List <string> lstInputCompute = new List<string> ();

			ListOperations.Merge (ref lstInputCompute, lstInput, lstCompute);


			List <string> lstInputComputeOutput = new List<string> ();

			ListOperations.Merge (ref lstInputComputeOutput, lstInputCompute,
				lstOutput);


			CsScriptWriter.CsScriptListToFile (Auxiliaries.projectFolderPath,
				"EnumInputComputeOutput.cs", lstInputComputeOutput, false);
		}

		#endregion script writers

		/// <summary>
		/// Colors arithmetic and textures computer.
		/// Bunch of functions for color and textures computation
		/// </summary>
		#region Colors Arithmetic
		public class ColorsArithmetic 
		{	
			public static Color RGB_255_To_Normalized (float r, float g, float b, float a)
			{
				float _255 = 255f;

				return new Color (r/_255, g/_255, b/_255, a);
			}

			public static Color Opacity (Color c0, Color c1, float o)
			{
				o = Mathf.Clamp (o, 0f, 1f);

				return o * c0 + (1f - o) * c1;
			}

			public static Color Darken (Color c0, Color c1)
			{
				return new Color (
					Mathf.Min (c0.r, c1.r), 
					Mathf.Min (c0.g, c1.g), 
					Mathf.Min (c0.b, c1.b), 
					Mathf.Min (c0.a, c1.a));
			}

			public static Color Lighten (Color c0, Color c1)
			{
				return new Color (
					Mathf.Max (c0.r, c1.r), 
					Mathf.Max (c0.g, c1.g), 
					Mathf.Max (c0.b, c1.b), 
					Mathf.Max (c0.a, c1.a));
			}

			public static Color Multiply (Color c0, Color c1)
			{
				return new Color (
					c0.r * c1.r, 
					c0.g * c1.g, 
					c0.b * c1.b, 
					c0.a * c1.a);
			}

			public static Color Screen (Color c0, Color c1)
			{
				return new Color (
					1f - (1f-c0.r) * (1f-c1.r), 
					1f - (1f-c0.g) * (1f-c1.g), 
					1f - (1f-c0.b) * (1f-c1.b), 
					1f - (1f-c0.a) * (1f-c1.a));
			}

			public static Color ColorDodge (Color c0, Color c1)
			{
				return new Color (
					ColorDodge (c0.r, c1.r), 
					ColorDodge (c0.g, c1.g), 
					ColorDodge (c0.b, c1.b), 
					ColorDodge (c0.a, c1.a));
			}

			static float ColorDodge (float f0, float f1)
			{
				float f;

				if (f0 == 1f)
					f = 1f;
				else
					f = Mathf.Min (1f, f1 / (1f - f0));

				return f;
			}

			public static Color ColorBurn (Color c0, Color c1)
			{
				return new Color (
					ColorBurn (c0.r, c1.r), 
					ColorBurn (c0.g, c1.g), 
					ColorBurn (c0.b, c1.b), 
					ColorBurn (c0.a, c1.a));
			}

			static float ColorBurn (float f0, float f1)
			{
				return f0 == 0f ? 0f : Mathf.Max (0f, (1f - (1f - f1)) / f0); 
			}

			public static Color LinearDodge (Color c0, Color c1)
			{
				return new Color (
					c0.r + c1.r, 
					c0.g + c1.g, 
					c0.b + c1.b, 
					c0.a + c1.a);
			}

			public static Color LinearBurn (Color c0, Color c1)
			{
				return new Color (
					c0.r + c1.r - 1f, 
					c0.g + c1.g - 1f, 
					c0.b + c1.b - 1f, 
					c0.a + c1.a - 1f);
			}

			public static Color Overlay (Color c0, Color c1)
			{		
				return new Color (
					Overlay (c0.r, c1.r),
					Overlay (c0.g, c1.g),
					Overlay (c0.b, c1.b),
					Overlay (c0.a, c1.a));
			}

			static float Overlay (float f0, float f1)
			{
				float f;

				if (f1 <= 0.5f)
					f = 2f * f0 * f1;
				else
					f = 1f - 2f * (1f - f0) * (1f - f1);

				return f;
			}

			public static Color HardLight (Color c0, Color c1)
			{
				return new Color (
					HardLight (c0.r, c1.r),
					HardLight (c0.g, c1.g),
					HardLight (c0.b, c1.b),
					HardLight (c0.a, c1.a));
			}

			static float HardLight (float f0, float f1)
			{
				float f;

				if (f0 <= 0.5f)
					f = 2f * f0 * f1;
				else
					f = 1f - 2f * (1f - f0) * (1f - f1);

				return f;
			}

			public static Color SoftLight (Color c0, Color c1)
			{
				return new Color (
					SoftLight (c0.r, c1.r),
					SoftLight (c0.g, c1.g),
					SoftLight (c0.b, c1.b),
					SoftLight (c0.a, c1.a));
			}

			static float SoftLight (float f0, float f1)
			{
				float f;

				if (f0 <= 0.5f)
					f = (2f * f0 - 1f) * (f1 - f1*f1) + f1;
				else
					f = (2f * f0 - 1f) * (Mathf.Pow(f1,0.5f) - f1) + f1;

				return f;
			}

			public static Color VividLight (Color c0, Color c1)
			{

				return new Color (
					VividLight (c0.r, c1.r),
					VividLight (c0.g, c1.g),
					VividLight (c0.b, c1.b),
					VividLight (c0.a, c1.a));
			}

			static float VividLight (float f0, float f1)
			{
				float f;

				if (f0 <= 0.5f) 
				{
					if (f0 == 0f)
						f = 0f;
					else
						f = 1f - (0.5f * (1f - f1) / f0);
				} 
				else 
				{
					if (f0 == 1f)
						f = 1f;
					else
						f = 0.5f * (f1 / (1f - f0));
				}

				return f;
			}


			public static Color LinearLight (Color c0, Color c1)
			{

				return new Color (
					LinearLight (c0.r, c1.r),
					LinearLight (c0.g, c1.g),
					LinearLight (c0.b, c1.b),
					LinearLight (c0.a, c1.a));
			}

			static float LinearLight (float f0, float f1)
			{
				float f;

				f = f1 + 2f*f0 - 1f;

				return f;
			}


			public static Color PinLight (Color c0, Color c1)
			{

				return new Color (
					PinLight (c0.r, c1.r),
					PinLight (c0.g, c1.g),
					PinLight (c0.b, c1.b),
					PinLight (c0.a, c1.a));

			}

			static float PinLight (float f0, float f1)
			{
				float f = 0f;

				if (f1 <= 2f * f0 - 1f)
					f = 2f * f0 - 1f;
				else if (f1 > 2f * f0 - 1f && f1 <= 2f * f0)
					f = f1;
				else if (f1 > 2f * f0)
					f = 2 * f0;

				return f;
			}


			public static Color HardMix (Color c0, Color c1)
			{
				return new Color (
					HardMix (c0.r, c1.r),
					HardMix (c0.g, c1.g),
					HardMix (c0.b, c1.b),
					HardMix (c0.a, c1.a));
			}

			static float HardMix (float f0, float f1)
			{
				float f;

				if (f0 < 1f - f1)
					f = 0f;
				else
					f = 1f;

				return f;
			}


			public static Color Difference (Color c0, Color c1)
			{
				return new Color (
					Difference (c0.r, c1.r),
					Difference (c0.g, c1.g),
					Difference (c0.b, c1.b),
					Difference (c0.a, c1.a));
			}

			static float Difference (float f0, float f1)
			{
				float f;

				f = Mathf.Abs (f0 - f1);

				return f;
			}


			public static Color Exclusion (Color c0, Color c1)
			{
				return new Color (
					Exclusion (c0.r, c1.r),
					Exclusion (c0.g, c1.g),
					Exclusion (c0.b, c1.b),
					Exclusion (c0.a, c1.a));

			}

			static float Exclusion (float f0, float f1)
			{
				float f;

				f = f0 + f1 - 2f * f0 * f1;

				return f;
			}


			public static Color Hue (Color c0, Color c1)
			{
				return Color.HSVToRGB (RGBToHSV (c0) [0], RGBToHSV (c1) [1], RGBToHSV (c1) [2]);
			}

			public static Color Saturation (Color c0, Color c1)
			{
				return Color.HSVToRGB (RGBToHSV (c1) [0], RGBToHSV (c0) [1], RGBToHSV (c1) [2]);
			}

			public static Color Color_ (Color c0, Color c1)
			{
				return Color.HSVToRGB (RGBToHSV (c0) [0], RGBToHSV (c0) [1], RGBToHSV (c1) [2]);
			}

			public static Color Luminosity (Color c0, Color c1)
			{
				return Color.HSVToRGB (RGBToHSV (c1) [0], RGBToHSV (c1) [1], RGBToHSV (c0) [2]);
			}

			public static float [] RGBToHSV (Color c)
			{
				float [] retVal = new float[3];

				Color.RGBToHSV (c, out retVal [0], out retVal [1], out retVal [2]);

				return retVal;
			}


			public static Color Add (Color c0, Color c1)
			{
				return new Color (
					c0.r + c1.r, 
					c0.g + c1.g, 
					c0.b + c1.b, 
					c0.a + c1.a);
			}

			public static Color Subtract (Color c0, Color c1)
			{
				return c0 - c1;
			} 
		}

		public class TextureComputer 
		{
			public static int minTextureSize = 8;

			public enum ComputeOn
			{
				red,

				green,

				blue,

				alpha,


				hue,

				saturation,

				value,
			}

			//switch (cO)
			//{
			//case ComputeOn.alpha:
			//	break;
			//
			//case ComputeOn.blue:
			//	break;
			//
			//case ComputeOn.green:
			//	break;
			//
			//case ComputeOn.hue:
			//	break;
			//
			//case ComputeOn.red:
			//	break;
			//
			//case ComputeOn.saturation:
			//	break;
			//
			//case ComputeOn.value:
			//	break;
			//}

			public enum Direction
			{
				x,

				y,

				z,
			}


			public static float [] FiniteDifference (Direction dir, ComputeOn cO, int order, Texture2D tex,
				float amplifier)
			{
				float amplifierMax = 20f;

				amplifier = (amplifierMax/100f)*amplifier;



				List <float> rL = new List<float> ();

				for (int y = 0; y < tex.height; y++)
				{
					for (int x = 0; x < tex.width; x++)
					{
						rL.Add (FiniteDifference (x, y, dir, cO, order, tex, amplifier));
					}
				}

				return rL.ToArray ();
			}

			public static float FiniteDifference (int x, int y, Direction dir, ComputeOn cO, int order, Texture2D tex,
				float amplifier)
			{
				float r = 0.5f;

				x = Mathf.Clamp (x, 1, tex.width-2);

				y = Mathf.Clamp (y, 1, tex.height-2);


				Color cL_1 = tex.GetPixel (x-1, y);

				Color cR_1 = tex.GetPixel (x+1, y);


				Color cD_1 = tex.GetPixel (x, y-1);

				Color cU_1 = tex.GetPixel (x, y+1);


				Color c = tex.GetPixel (x, y);

				float vL_1 = 0.5f;
				float v = 0.5f;
				float vR_1 = 0.5f;
				float vD_1 = 0.5f;
				float vU_1 = 0.5f;

				switch (cO)
				{
				case ComputeOn.alpha:
					vL_1 = cL_1.a;
					v = c.a;
					vR_1 = cR_1.a;
					vD_1 = cD_1.a;
					vU_1 = cU_1.a;
					break;

				case ComputeOn.blue:
					vL_1 = cL_1.b;
					v = c.b;	
					vR_1 = cR_1.b;
					vD_1 = cD_1.b;
					vU_1 = cU_1.b;
					break;

				case ComputeOn.green:
					vL_1 = cL_1.g;
					v = c.g;
					vR_1 = cR_1.g;
					vD_1 = cD_1.g;
					vU_1 = cU_1.g;
					break;

				case ComputeOn.hue:
					vL_1 = ColorsArithmetic.RGBToHSV (cL_1) [0];
					v = ColorsArithmetic.RGBToHSV (c) [0];
					vR_1 = ColorsArithmetic.RGBToHSV (cR_1) [0];
					vD_1 = ColorsArithmetic.RGBToHSV (cD_1) [0];
					vU_1 = ColorsArithmetic.RGBToHSV (cU_1) [0];
					break;

				case ComputeOn.red:
					vL_1 = cL_1.r;
					v = c.r;
					vR_1 = cR_1.r;
					vD_1 = cD_1.r;
					vU_1 = cU_1.r;
					break;

				case ComputeOn.saturation:
					vL_1 = ColorsArithmetic.RGBToHSV (cL_1) [1];
					v = ColorsArithmetic.RGBToHSV (c) [1];   
					vR_1 = ColorsArithmetic.RGBToHSV (cR_1) [1];
					vD_1 = ColorsArithmetic.RGBToHSV (cD_1) [1];
					vU_1 = ColorsArithmetic.RGBToHSV (cU_1) [1];
					break;

				case ComputeOn.value:
					vL_1 = ColorsArithmetic.RGBToHSV (cL_1) [2];
					v = ColorsArithmetic.RGBToHSV (c) [2];   
					vR_1 = ColorsArithmetic.RGBToHSV (cR_1) [2];
					vD_1 = ColorsArithmetic.RGBToHSV (cD_1) [2];
					vU_1 = ColorsArithmetic.RGBToHSV (cU_1) [2];
					break;
				}

				if (order == 1)
				{
					switch (dir)
					{
					case Direction.x:
						r = 0.5f * (vL_1 - vR_1);
						break;

					case Direction.y:
						r = 0.5f * (vD_1 - vU_1);
						break;
					}
				}
				else if (order == 2)
				{
					switch (dir)
					{
					case Direction.x:
						r = 1f * (vL_1 - 2f*v + vR_1);
						break;

					case Direction.y:
						r = 1f * (vD_1 - 2f*v + vU_1);
						break;
					}
				}
				else
				{
					Debug.LogError ("Order not 1 or 2");
				}

				return r * amplifier;
			}

			public static Color [] NormalColors (Texture2D tex, bool yInvert, ComputeOn cO, float amplifier)
			{
				int order = 1;

				float [] xS = FiniteDifference (Direction.y, cO, order, tex, amplifier);

				float [] yS = FiniteDifference (Direction.x, cO, order, tex, amplifier);

				Color [] r = new Color [xS.Length];

				float yMult = yInvert? -1f: 1f;

				for (int i = 0; i < r.Length; i++)
				{
					r [i] = new Color (
						0.55f + xS [i], 
						0.55f + yMult * yS [i], 1f, 1f);
				}

				return r;
			}

			public static Color [] MirrorAndRotate (Texture2D tex, MirrorTexture2D_Direction mtd)
			{
				List <Color> rL = new List<Color> ();

				for (int x = 0; x < tex.width; x++)
				{
					for (int y = 0; y < tex.height; y++)
					{
						switch (mtd)
						{
						case MirrorTexture2D_Direction.rotate90:
							rL.Add (tex.GetPixel (tex.width-1 - x, y));
							break;

						case MirrorTexture2D_Direction.rotateMinus90:
							rL.Add (tex.GetPixel (x, tex.height-1 - y));
							break;

						case MirrorTexture2D_Direction.mirrorXAndY:
							rL.Add (tex.GetPixel (tex.width-1 - x, tex.height-1 - y));
							break;
						}

					}
				}

				for (int y = 0; y < tex.height; y++)
				{
					for (int x = 0; x < tex.width; x++)
					{
						switch (mtd)
						{
						case MirrorTexture2D_Direction.mirrorY: 
							rL.Add (tex.GetPixel (x, tex.height-1 - y));
							break;

						case MirrorTexture2D_Direction.mirrorX: 
							rL.Add (tex.GetPixel (tex.width-1 - x, y));
							break;
						}
					}
				}


				return 	rL.ToArray ();
			}


			public enum ExtractResultType
			{
				AsIt,

				Grayscale,
			}

			public enum MirrorTexture2D_Direction
			{
				rotate90,

				rotateMinus90,

				mirrorXAndY,

				mirrorY,

				mirrorX,
			}

			public enum SwitchColorsType
			{
				RedGreen,

				RedBlue,

				GreenBlue,
			}




			public static Color [] SetPixelAccordingToAChannelValue (ComputeOn channelToRead,
				int valueToRead, int readTolerance, 
				Texture2D tex_1, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				float valueToRead_F = (float)valueToRead / 255f;

				float halfReadTolerance_F = ((float)readTolerance / 255f) * 0.5f;

				switch (channelToRead)
				{
				case ComputeOn.alpha:
					r = SetPixelAccordingToAlphaValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);
					break;

				case ComputeOn.blue:
					r = SetPixelAccordingToBlueValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);
					break;

				case ComputeOn.green:
					r = SetPixelAccordingToGreenValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);
					break;

				case ComputeOn.hue:
					r = SetPixelAccordingToHueValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);
					break;

				case ComputeOn.red:
					r = SetPixelAccordingToRedValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);
					break;

				case ComputeOn.saturation:
					r = SetPixelAccordingToSaturationValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);
					break;

				case ComputeOn.value:
					r = SetPixelAccordingToValueValue (valueToRead_F, halfReadTolerance_F, tex_1, tex);
					break;
				}

				return r;
			}

			static Color [] SetPixelAccordingToValueValue (float valueToRead_F, float halfReadTolerance_F, 
				Texture2D tex_1, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				Color [] r_1 = tex_1.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					float [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);

					float vR = hsvR [2];

					if (vR >= minTol && vR <= maxTol)
					{
						r [i] = r_1 [i];
					}
				}

				return r;
			}

			static Color [] SetPixelAccordingToSaturationValue (float valueToRead_F, float halfReadTolerance_F, 
				Texture2D tex_1, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				Color [] r_1 = tex_1.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					float [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);

					float vR = hsvR [1];

					if (vR >= minTol && vR <= maxTol)
					{
						r [i] = r_1 [i];
					}
				}

				return r;
			}

			static Color [] SetPixelAccordingToHueValue (float valueToRead_F, float halfReadTolerance_F, 
				Texture2D tex_1, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				Color [] r_1 = tex_1.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					float [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);

					float vR = hsvR [0];

					if (vR >= minTol && vR <= maxTol)
					{
						r [i] = r_1 [i];
					}
				}

				return r;
			}

			static Color [] SetPixelAccordingToBlueValue (float valueToRead_F, float halfReadTolerance_F, 
				Texture2D tex_1, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				Color [] r_1 = tex_1.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].b >= minTol && r [i].b <= maxTol)
					{
						r [i] = r_1 [i];
					}
				}

				return r;
			}

			static Color [] SetPixelAccordingToGreenValue (float valueToRead_F, float halfReadTolerance_F, 
				Texture2D tex_1, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				Color [] r_1 = tex_1.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].g >= minTol && r [i].g <= maxTol)
					{
						r [i] = r_1 [i];
					}
				}

				return r;
			}

			static Color [] SetPixelAccordingToRedValue (float valueToRead_F, float halfReadTolerance_F, 
				Texture2D tex_1, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				Color [] r_1 = tex_1.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].r >= minTol && r [i].r <= maxTol)
					{
						r [i] = r_1 [i];
					}
				}

				return r;
			}

			static Color [] SetPixelAccordingToAlphaValue (float valueToRead_F, float halfReadTolerance_F, 
				Texture2D tex_1, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				Color [] r_1 = tex_1.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].a >= minTol && r [i].a <= maxTol)
					{
						r [i] = r_1 [i];
					}
				}

				return r;
			}





			public static Color [] SetColorAccordingToAChannelValue (ComputeOn channelToRead,
				int valueToRead, int readTolerance, 
				Color colorToSet, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				float valueToRead_F = (float)valueToRead / 255f;

				float halfReadTolerance_F = ((float)readTolerance / 255f) * 0.5f;

				switch (channelToRead)
				{
				case ComputeOn.alpha:
					r = SetColorAccordingToAlphaValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);
					break;

				case ComputeOn.blue:
					r = SetColorAccordingToBlueValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);
					break;

				case ComputeOn.green:
					r = SetColorAccordingToGreenValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);
					break;

				case ComputeOn.hue:
					r = SetColorAccordingToHueValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);
					break;

				case ComputeOn.red:
					r = SetColorAccordingToRedValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);
					break;

				case ComputeOn.saturation:
					r = SetColorAccordingToSaturationValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);
					break;

				case ComputeOn.value:
					r = SetColorAccordingToValueValue (valueToRead_F, halfReadTolerance_F, colorToSet, tex);
					break;
				}

				return r;
			}

			static Color [] SetColorAccordingToValueValue (float valueToRead_F, float halfReadTolerance_F, 
				Color colorToSet, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					float [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);

					float vR = hsvR [2];

					if (vR >= minTol && vR <= maxTol)
					{
						r [i] = colorToSet;
					}
				}

				return r;
			}

			static Color [] SetColorAccordingToSaturationValue (float valueToRead_F, float halfReadTolerance_F, 
				Color colorToSet, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					float [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);

					float vR = hsvR [1];

					if (vR >= minTol && vR <= maxTol)
					{
						r [i] = colorToSet;
					}
				}

				return r;
			}

			static Color [] SetColorAccordingToHueValue (float valueToRead_F, float halfReadTolerance_F, 
				Color colorToSet, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					float [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);

					float vR = hsvR [0];

					if (vR >= minTol && vR <= maxTol)
					{
						r [i] = colorToSet;
					}
				}

				return r;
			}

			static Color [] SetColorAccordingToBlueValue (float valueToRead_F, float halfReadTolerance_F, 
				Color colorToSet, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].b >= minTol && r [i].b <= maxTol)
					{
						r [i] = colorToSet;
					}
				}

				return r;
			}

			static Color [] SetColorAccordingToGreenValue (float valueToRead_F, float halfReadTolerance_F, 
				Color colorToSet, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].g >= minTol && r [i].g <= maxTol)
					{
						r [i] = colorToSet;
					}
				}

				return r;
			}

			static Color [] SetColorAccordingToRedValue (float valueToRead_F, float halfReadTolerance_F, 
				Color colorToSet, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].r >= minTol && r [i].r <= maxTol)
					{
						r [i] = colorToSet;
					}
				}

				return r;
			}

			static Color [] SetColorAccordingToAlphaValue (float valueToRead_F, float halfReadTolerance_F, 
				Color colorToSet, Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;

				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].a >= minTol && r [i].a <= maxTol)
					{
						r [i] = colorToSet;
					}
				}

				return r;
			}






			public static Color [] SetChannelAccordingToAnotherChannelValue (ComputeOn channetToSet, ComputeOn channelToRead,
				int valueToRead, int readTolerance, int valueToSet, Texture2D tex, bool keepOtherChannels, bool keepAlpha)
			{
				Color [] r = tex.GetPixels ();

				float valueToSet_F = (float)valueToSet / 255f;

				float valueToRead_F = (float)valueToRead / 255f;

				float halfReadTolerance_F = ((float)readTolerance / 255f) * 0.5f;

				switch (channelToRead)
				{
				case ComputeOn.alpha:
					r = SetChannelAccordingToAlphaValue (channetToSet, 
						valueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);
					break;

				case ComputeOn.blue:
					r = SetChannelAccordingToBlueValue (channetToSet, 
						valueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);
					break;

				case ComputeOn.green:
					r = SetChannelAccordingToGreenValue (channetToSet, 
						valueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);
					break;

				case ComputeOn.hue:
					r = SetChannelAccordingToHueValue (channetToSet, 
						valueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);
					break;

				case ComputeOn.red:
					r = SetChannelAccordingToRedValue (channetToSet, 
						valueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);
					break;

				case ComputeOn.saturation:
					r = SetChannelAccordingToSaturationValue (channetToSet, 
						valueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);
					break;

				case ComputeOn.value:
					r = SetChannelAccordingToValueValue (channetToSet, 
						valueToRead_F, halfReadTolerance_F, valueToSet_F, tex, keepOtherChannels, keepAlpha);
					break;
				}

				return r;
			}

			static Color [] SetChannelAccordingToValueValue (ComputeOn channetToSet, 
				float valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels, 
				bool keepAlpha)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;



				for (int i = 0; i < r.Length; i++)
				{
					float [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);

					float vR = hsvR [2];

					if (vR >= minTol && vR <= maxTol)
					{
						r [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], 
							keepOtherChannels,
							keepAlpha);
					}
				}

				return r;
			}

			static Color [] SetChannelAccordingToSaturationValue (ComputeOn channetToSet, 
				float valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,
				bool keepAlpha)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;



				for (int i = 0; i < r.Length; i++)
				{
					float [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);

					float vR = hsvR [1];

					if (vR >= minTol && vR <= maxTol)
					{
						r [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], 
							keepOtherChannels,
							keepAlpha);
					}
				}

				return r;
			}

			static Color [] SetChannelAccordingToHueValue (ComputeOn channetToSet, 
				float valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,
				bool keepAlpha)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;



				for (int i = 0; i < r.Length; i++)
				{
					float [] hsvR = ColorsArithmetic.RGBToHSV (r [i]);

					float vR = hsvR [0];

					if (vR >= minTol && vR <= maxTol)
					{
						r [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], 
							keepOtherChannels,
							keepAlpha);
					}
				}

				return r;
			}

			static Color [] SetChannelAccordingToGreenValue (ComputeOn channetToSet, 
				float valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,
				bool keepAlpha)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;



				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].g >= minTol && r [i].g <= maxTol)
					{
						r [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], 
							keepOtherChannels,
							keepAlpha);
					}
				}

				return r;
			}

			static Color [] SetChannelAccordingToBlueValue (ComputeOn channetToSet, 
				float valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,
				bool keepAlpha)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;



				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].b >= minTol && r [i].b <= maxTol)
					{
						r [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], 
							keepOtherChannels,
							keepAlpha);
					}
				}

				return r;
			}

			static Color [] SetChannelAccordingToRedValue (ComputeOn channetToSet, 
				float valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,
				bool keepAlpha)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;



				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].r >= minTol && r [i].r <= maxTol)
					{
						r [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], 
							keepOtherChannels,
							keepAlpha);
					}
				}

				return r;
			}

			static Color [] SetChannelAccordingToAlphaValue (ComputeOn channetToSet, 
				float valueToRead_F, float halfReadTolerance_F, float valueToSet_F, Texture2D tex, bool keepOtherChannels,
				bool keepAlpha)
			{
				Color [] r = tex.GetPixels ();

				float minTol = valueToRead_F - halfReadTolerance_F;

				float maxTol = valueToRead_F + halfReadTolerance_F;



				for (int i = 0; i < r.Length; i++)
				{
					if (r [i].a >= minTol && r [i].a <= maxTol)
					{
						r [i] = SetChannelAccordingTo (channetToSet, valueToSet_F, r [i], 
							keepOtherChannels,
							keepAlpha);
					}
				}

				return r;
			}

			static Color SetChannelAccordingTo (ComputeOn channetToSet, float valueToSet_F, Color r, 
				bool keepOtherChannels,
				bool keepAlpha)
			{
				switch (channetToSet)
				{
				case ComputeOn.alpha:
					if (keepOtherChannels)
						r = new Color (r.r, r.g, r.b, valueToSet_F);
					else
						r = new Color (0f, 0f, 0f, valueToSet_F);
					break;

				case ComputeOn.blue:
					if (keepOtherChannels)
						r = new Color (r.r, r.g, valueToSet_F, r.a);
					else
						if (keepAlpha)
							r = new Color (0f, 0f, valueToSet_F, r.a);
						else
							r = new Color (0f, 0f, valueToSet_F, 0f);
					break;

				case ComputeOn.green:
					if (keepOtherChannels)
						r = new Color (r.r, valueToSet_F, r.b, r.a);
					else
						if (keepAlpha)
							r = new Color (0f, valueToSet_F, 0f, r.a);
						else
							r = new Color (0f, valueToSet_F, 0f, 0f);
					break;

				case ComputeOn.hue:
					if (keepOtherChannels)
					{
						float a = r.a;

						float [] hsv = ColorsArithmetic.RGBToHSV (r);

						r = Color.HSVToRGB (valueToSet_F, hsv [1], hsv [2]);

						r = new Color (r.r, r.g, r.b, a);
					}
					else
					{
						float a = r.a;

						r = Color.HSVToRGB (valueToSet_F, 1f, 1f);


						r = new Color (r.r, r.g, r.b, a);
					}
					break;

				case ComputeOn.red:		
					if (keepOtherChannels)
						r = new Color (valueToSet_F, r.g, r.b, r.a);

					else

						if (keepAlpha)
							r = new Color (valueToSet_F, 0f, 0f, r.a);
						else
							r = new Color (valueToSet_F, 0f, 0f, 0f);
					break;

				case ComputeOn.saturation:
					if (keepOtherChannels)
					{
						float a = r.a;

						float [] hsv = ColorsArithmetic.RGBToHSV (r);

						r = Color.HSVToRGB (hsv [0], valueToSet_F, hsv [2]);

						r = new Color (r.r, r.g, r.b, a);
					}
					else
					{
						float a = r .a;

						r = Color.HSVToRGB (1f, valueToSet_F, 1f);


						r = new Color (r.r, r.g, r.b, a);
					}
					break;

				case ComputeOn.value:
					if (keepOtherChannels)
					{
						float a = r.a;

						float [] hsv = ColorsArithmetic.RGBToHSV (r);

						r = Color.HSVToRGB (hsv [0], hsv [1], valueToSet_F);

						r = new Color (r.r, r.g, r.b, a);
					}
					else
					{
						float a = r.a;

						r = Color.HSVToRGB (1f, 1f, valueToSet_F);

						r = new Color (r.r, r.g, r.b, a);
					}
					break;
				}

				return r;
			}




			public static Color [] SetChannel (Texture2D tex, ComputeOn cO, int v)
			{
				Color [] r = tex.GetPixels ();

				float vF = (float)v / 255f;

				switch (cO)
				{
				case ComputeOn.alpha:
					r = SetAlphaColors (tex, vF);
					break;

				case ComputeOn.blue:
					r = SetBlueColors (tex, vF);
					break;

				case ComputeOn.green:
					r = SetGreenColors (tex, vF);
					break;

				case ComputeOn.hue:
					r = SetHueColors (tex, vF);
					break;

				case ComputeOn.red:
					r = SetRedColors (tex, vF);
					break;

				case ComputeOn.saturation:
					r = SetSaturationColors (tex, vF);
					break;

				case ComputeOn.value:
					r = SetValueColors (tex, vF);
					break;
				}

				return r;
			}
			static Color [] SetRedColors (Texture2D tex, float v)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					r [i] = new Color (v, r [i].g, r [i].b, r [i].a);
				}

				return r;
			}
			static Color [] SetGreenColors (Texture2D tex, float v)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					r [i] = new Color (r [i].r, v, r [i].b, r [i].a);
				}

				return r;
			}
			static Color [] SetBlueColors (Texture2D tex, float v)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					r [i] = new Color (r [i].r, r [i].g, v, r [i].a);
				}

				return r;
			}
			static Color [] SetAlphaColors (Texture2D tex, float v)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					r [i] = new Color (r [i].r, r [i].g, r [i].b, v);
				}

				return r;
			}
			static Color [] SetHueColors (Texture2D tex, float v)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float a = r [i].a;

					float [] hsv = ColorsArithmetic.RGBToHSV (r [i]);

					r [i] = Color.HSVToRGB (v, hsv [1], hsv [2]);

					r [i] = new Color (r [i].r, r [i].g, r [i].b, a);
				}

				return r;
			}
			static Color [] SetSaturationColors (Texture2D tex, float v)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float a = r [i].a;

					float [] hsv = ColorsArithmetic.RGBToHSV (r [i]);

					r [i] = Color.HSVToRGB (hsv [0], v, hsv [2]);

					r [i] = new Color (r [i].r, r [i].g, r [i].b, a);
				}

				return r;
			}
			static Color [] SetValueColors (Texture2D tex, float v)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float a = r [i].a;

					float [] hsv = ColorsArithmetic.RGBToHSV (r [i]);

					r [i] = Color.HSVToRGB (hsv [0], hsv [1], v);

					r [i] = new Color (r [i].r, r [i].g, r [i].b, a);
				}

				return r;
			}

			public static Color [] SetChannel (Texture2D tex, ComputeOn cO, Texture2D tex_0)
			{
				Color [] r = tex.GetPixels ();

				Color [] c_0 = tex_0.GetPixels ();

				switch (cO)
				{
				case ComputeOn.alpha:
					r = SetAlphaColors (tex, c_0);
					break;

				case ComputeOn.blue:
					r = SetBlueColors (tex, c_0);
					break;

				case ComputeOn.green:
					r = SetGreenColors (tex, c_0);
					break;

				case ComputeOn.hue:
					r = SetHueColors (tex, c_0);
					break;

				case ComputeOn.red:
					r = SetRedColors (tex, c_0);
					break;

				case ComputeOn.saturation:
					r = SetSaturationColors (tex, c_0);
					break;

				case ComputeOn.value:
					r = SetValueColors (tex, c_0);
					break;
				}

				return r;
			}
			static Color [] SetRedColors (Texture2D tex, Color [] c_0)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					r [i] = new Color (c_0 [i].r, r [i].g, r [i].b, r [i].a);
				}

				return r;
			}
			static Color [] SetGreenColors (Texture2D tex, Color [] c_0)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					r [i] = new Color (r [i].r, c_0 [i].g, r [i].b, r [i].a);
				}

				return r;
			}
			static Color [] SetBlueColors (Texture2D tex, Color [] c_0)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					r [i] = new Color (r [i].r, r [i].g, c_0 [i].b, r [i].a);
				}

				return r;
			}
			static Color [] SetAlphaColors (Texture2D tex, Color [] c_0)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					r [i] = new Color (r [i].r, r [i].g, r [i].b, c_0 [i].a);
				}

				return r;
			}
			static Color [] SetHueColors (Texture2D tex, Color [] c_0)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float a = r [i].a;

					float [] hsv = ColorsArithmetic.RGBToHSV (r [i]);

					float v = ColorsArithmetic.RGBToHSV (c_0 [i]) [0];

					r [i] = Color.HSVToRGB (v, hsv [1], hsv [2]);

					r [i] = new Color (r [i].r, r [i].g, r [i].b, a);
				}

				return r;
			}
			static Color [] SetSaturationColors (Texture2D tex, Color [] c_0)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float a = r [i].a;

					float [] hsv = ColorsArithmetic.RGBToHSV (r [i]);

					float v = ColorsArithmetic.RGBToHSV (c_0 [i]) [1];

					r [i] = Color.HSVToRGB (hsv [0], v, hsv [2]);

					r [i] = new Color (r [i].r, r [i].g, r [i].b, a);
				}

				return r;
			}
			static Color [] SetValueColors (Texture2D tex, Color  [] c_0)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float a = r [i].a;

					float [] hsv = ColorsArithmetic.RGBToHSV (r [i]);

					float v = ColorsArithmetic.RGBToHSV (c_0 [i]) [2];

					r [i] = Color.HSVToRGB (hsv [0], hsv [1], v);

					r [i] = new Color (r [i].r, r [i].g, r [i].b, a);
				}

				return r;
			}


			public static Color [] ExtractChannel (Texture2D tex, ComputeOn cO, ExtractResultType ert)
			{
				Color [] r = tex.GetPixels ();

				switch (cO)
				{
				case ComputeOn.alpha:
					r = AlphaColors (tex, ert);
					break;

				case ComputeOn.blue:
					r = BlueColors (tex, ert);
					break;

				case ComputeOn.green:
					r = GreenColors (tex, ert);
					break;

				case ComputeOn.hue:
					r = HueColors (tex, ert);
					break;

				case ComputeOn.red:
					r = RedColors (tex, ert);
					break;

				case ComputeOn.saturation:
					r = SaturationColors (tex, ert);
					break;

				case ComputeOn.value:
					r = ValueColors (tex, ert);
					break;
				}

				return r;
			}
			static Color [] RedColors (Texture2D tex, ExtractResultType ert)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float v = r [i].r;

					switch (ert)
					{
					case ExtractResultType.AsIt:
						r [i] = new Color (v, 0f, 0f, r [i].a);
						break;

					case ExtractResultType.Grayscale:
						r [i] = new Color (v, v, v, r [i].a);
						break;
					}


				}

				return r;
			}
			static Color [] GreenColors (Texture2D tex, ExtractResultType ert)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float v = r [i].g;

					switch (ert)
					{
					case ExtractResultType.AsIt:
						r [i] = new Color (0f, v, 0f, r [i].a);
						break;

					case ExtractResultType.Grayscale:
						r [i] = new Color (v, v, v, r [i].a);
						break;
					}


				}

				return r;
			}
			static Color [] BlueColors (Texture2D tex, ExtractResultType ert)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float v = r [i].b;

					switch (ert)
					{
					case ExtractResultType.AsIt:
						r [i] = new Color (0f, 0f, v, r [i].a);
						break;

					case ExtractResultType.Grayscale:
						r [i] = new Color (v, v, v, r [i].a);
						break;
					}


				}

				return r;
			}
			static Color [] AlphaColors (Texture2D tex, ExtractResultType ert)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float v = r [i].a;

					switch (ert)
					{
					case ExtractResultType.AsIt:
						r [i] = new Color (0f, 0f, 0f, v);
						break;

					case ExtractResultType.Grayscale:
						r [i] = new Color (v, v, v, 1f);
						break;
					}


				}

				return r;
			}
			static Color [] ValueColors (Texture2D tex, ExtractResultType ert)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float a = r [i].a;

					float v = ColorsArithmetic.RGBToHSV (r [i]) [2];

					switch (ert)
					{
					case ExtractResultType.AsIt:
						r [i] = Color.HSVToRGB (1f, 1f, v);

						r [i] = new Color (r [i].r, r [i].g, r [i].b, a);
						break;

					case ExtractResultType.Grayscale:
						r [i] = new Color (v, v, v, a);
						break;
					}
				}

				return r;
			}
			static Color [] SaturationColors (Texture2D tex, ExtractResultType ert)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float a = r [i].a;

					float v = ColorsArithmetic.RGBToHSV (r [i]) [1];

					switch (ert)
					{
					case ExtractResultType.AsIt:
						r [i] = Color.HSVToRGB (1f, v, 1f);

						r [i] = new Color (r [i].r, r [i].g, r [i].b, a);
						break;

					case ExtractResultType.Grayscale:
						r [i] = new Color (v, v, v, a);
						break;
					}


				}

				return r;
			}
			static Color [] HueColors (Texture2D tex, ExtractResultType ert)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{
					float a = r [i].a;

					float v = ColorsArithmetic.RGBToHSV (r [i]) [0];

					switch (ert)
					{
					case ExtractResultType.AsIt:
						r [i] = Color.HSVToRGB (v, 1f, 1f);

						r [i] = new Color (r [i].r, r [i].g, r [i].b, a);
						break;

					case ExtractResultType.Grayscale:
						r [i] = new Color (v, v, v, a);
						break;
					}
				}

				return r;
			}


			public static Color [] SwitchColors (Texture2D tex, SwitchColorsType sct)
			{
				Color [] r = tex.GetPixels ();

				switch (sct)
				{
				case TextureComputer.SwitchColorsType.GreenBlue:
					r = SwitchGreenBlueColors (tex);
					break;

				case TextureComputer.SwitchColorsType.RedBlue:
					r = SwitchRedBlueColors (tex);
					break;

				case TextureComputer.SwitchColorsType.RedGreen:
					r = SwitchRedGreenColors (tex);
					break;
				}		

				return r;
			}
			static Color [] SwitchRedGreenColors (Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{

					r [i] = new Color (r [i].g, r [i].r, r [i].b, r [i].a);


				}

				return r;
			}
			static Color [] SwitchRedBlueColors (Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{


					r [i] = new Color (r [i].b, r [i].g, r [i].r, r [i].a);


				}

				return r;
			}
			static Color [] SwitchGreenBlueColors (Texture2D tex)
			{
				Color [] r = tex.GetPixels ();

				for (int i = 0; i < r.Length; i++)
				{


					r [i] = new Color (r [i].r, r [i].b, r [i].g, r [i].a);


				}

				return r;
			}

		}

		#endregion Colors Arithmetic


		/// <summary>
		/// Methods to receive and handle events
		/// </summary>
		#region events
		void MoveNodeAndLinkExtremity (Vector2 d, Rect elRect)
		{
			if (string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
			{
				Move (d, elRect);
			}
			else if ( ! string.IsNullOrEmpty (logic.inOutAdressCurrentToLink))
			{
				linkExtemityMoveSmother = 1f;

				if (eGlobal.shift)
				{
					linkExtemityMoveSmother = 0.1f;
				}

				logic.linkExtremity += d * linkExtemityMoveSmother;
			}
		}

		void EventProcess (Event e, Rect editLogicRect)
		{
			if (e == null)
				return;

			eGlobal = e;


			SelectionStateUpdate (e, editLogicRect);


			if (e.button == 0 && selectionState == SelectionState.selected)
			{
				if (editLogicRect.Contains (e.mousePosition))
				{
					if (e.type == EventType.MouseDrag)
					{
						Move (e.delta, editLogicRect);
					}
				}
				float arrowMoveDelta = 5f;
				if (e.alt)
				{
					if (e.keyCode == KeyCode.RightArrow)
					{
						MoveNodeAndLinkExtremity (new Vector2 (arrowMoveDelta, 0f), editLogicRect);
					}
					else if (e.keyCode == KeyCode.LeftArrow)
					{
						MoveNodeAndLinkExtremity (new Vector2 (-arrowMoveDelta, 0f), editLogicRect);
					}
					if (e.keyCode == KeyCode.UpArrow)
					{
						MoveNodeAndLinkExtremity (new Vector2 (0f, -arrowMoveDelta), editLogicRect);
					}
					else if (e.keyCode == KeyCode.DownArrow)
					{
						MoveNodeAndLinkExtremity (new Vector2 (0f, arrowMoveDelta), editLogicRect);
					}
				}
			}				
			else if (e.button == 2)
			{				
				if (e.type == EventType.MouseDrag)
				{
					Move (e.delta, editLogicRect);
				}
			}
		}

		void SelectionStateUpdate (Event e, Rect editLogicRect)
		{
			//if (editLogicRect.Contains (e.mousePosition))
			//{
			if (e.type == EventType.MouseDown)
			{
				if (e.button == 0)
				{
					if (rect.Contains (e.mousePosition))
					{
						bool hidenByLogicEditor = false;

						for (int i = 0; i < logic.node.graph.nodes.Count; i++)
						{
							if (logic.node.graph.nodes [i] == logic.node)
								continue;

							if ( ! logic.node.graph.nodes [i].callEditLogic)
								continue;

							if (logic.node.graph.nodes [i].callEditLogic)
							{
								if (logic.node.graph.nodes [i].editingLogic)
								{
									if (logic.node.graph.nodes [i].editLogicRect.Contains (e.mousePosition))
									{
										hidenByLogicEditor = true;				
									}
								}
							}
						}

						if ( ! hidenByLogicEditor)
							ChangeSelectionState (SelectionState.selected);
					}
					else
					{
						ChangeSelectionState (SelectionState.notSelected);

						//if (logic != null)
						//	logic.logicNodeSelected = null;
					}
				}
				else if (e.button == 1)
				{
					if ( ! rect.Contains (e.mousePosition))
					{
						ChangeSelectionState (SelectionState.notSelected);

						//if (logic != null)
						//	logic.logicNodeSelected = null;
					}
				}
			}
			//}
		}

		public void ChangeSelectionState (SelectionState newState)
		{
			switch (selectionState)
			{
			case SelectionState.notSelected:
				switch (newState)
				{
				case SelectionState.notSelected:
					break;

				case SelectionState.selected:
					selectionState = newState;

					if (logic != null)
						logic.LogicNodeSelected (this);
					break;
				}
				break;

			case SelectionState.selected:
				switch (newState)
				{
				case SelectionState.notSelected:
					selectionState = newState;
					break;

				case SelectionState.selected:
					break;
				}
				break;
			}
		}

		public void ChangeSelectionState (SelectionState newState, bool insideRect)
		{
			switch (selectionState)
			{
			case SelectionState.notSelected:
				switch (newState)
				{
				case SelectionState.notSelected:
					break;

				case SelectionState.selected:
					selectionState = newState;
					if ( ! insideRect)
					if (logic != null)
						logic.LogicNodeSelected (this);
					break;
				}
				break;

			case SelectionState.selected:
				switch (newState)
				{
				case SelectionState.notSelected:
					selectionState = newState;
					break;

				case SelectionState.selected:
					break;
				}
				break;
			}
		}

		void Move (Vector2 d, Rect editLogicRect)

		{
			//float gap = editLogicRect.height * 0.05f;


			rect.x += d.x;
			/*
			if (rect.x + rect.width + gap > editLogicRect.x + editLogicRect.width)
				rect.x = editLogicRect.x + editLogicRect.width - gap - rect.width;

			if (rect.x - gap < editLogicRect.x)
				rect.x = editLogicRect.x + gap;
				*/


			rect.y += d.y;
			/*
			if (rect.y + rect.height + gap > editLogicRect.y + editLogicRect.height)
				rect.y = editLogicRect.y + editLogicRect.height - gap - rect.height;
		
			if (rect.y - gap < editLogicRect.y)
				rect.y = editLogicRect.y + gap;
				*/

			SetNormalizedPosition ();
		}

		void MoveMousePositionByArrows (ref Event e)
		{
			float arrowMoveDelta = 5f;
			if (e.keyCode == KeyCode.RightArrow)
			{
				e.mousePosition += new Vector2 (arrowMoveDelta, 0f);
			}
			else if (e.keyCode == KeyCode.LeftArrow)
			{
				e.mousePosition += new Vector2 (-arrowMoveDelta, 0f);
			}
			if (e.keyCode == KeyCode.UpArrow)
			{
				e.mousePosition += new Vector2 (0f, -arrowMoveDelta);
			}
			else if (e.keyCode == KeyCode.DownArrow)
			{
				e.mousePosition += new Vector2 (0f, arrowMoveDelta);
			}
		}

		void Reset ()
		{
			LogicNodeInit (logic, rect.position, specialNodeType, true);
		}

		void OptionsRename ()
		{
			renameCalled = true;
		}

		void AlwaysDoIt ()
		{
			alwaysDoIt = true;
			doIT = true;
		}

		void DontDoItAllTheTime ()
		{
			alwaysDoIt = false;
			doIT = false;
		}

		#endregion events

	}
}